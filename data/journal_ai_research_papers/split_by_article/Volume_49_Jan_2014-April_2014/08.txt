Journal of Artificial Intelligence Research 49 (2014) 635-668

Submitted 01/14; published 04/14

Algorithms for Argumentation Semantics: Labeling Attacks as a
Generalization of Labeling Arguments
Samer Nofal

S AMER .N OFAL @ GJU . EDU . JO

Dept. of Computer Science, German-Jordanian University
P.O. Box 35247, Amman 11180, Jordan

Katie Atkinson
Paul E. Dunne

K.M.ATKINSON @ LIVERPOOL . AC . UK
P.E.D UNNE @ LIVERPOOL . AC . UK

Dept. of Computer Science, University of Liverpool
Ashton Street, Liverpool L69 3BX, United Kingdom

Abstract
A Dung argumentation framework (AF) is a pair (A, R): A is a set of abstract arguments and
R  A  A is a binary relation, so-called the attack relation, for capturing the conflicting arguments. Labeling based algorithms for enumerating extensions (i.e. sets of acceptable arguments)
have been set out such that arguments (i.e. elements of A) are the only subject for labeling. In
this paper we present implemented algorithms for listing extensions by labeling attacks (i.e. elements of R) along with arguments. Specifically, these algorithms are concerned with enumerating
all extensions of an AF under a number of argumentation semantics: preferred, stable, complete,
semi stable, stage, ideal and grounded. Our algorithms have impact, in particular, on enumerating
extensions of AF-extended models that allow attacks on attacks. To demonstrate this impact, we
instantiate our algorithms for an example of such models: namely argumentation frameworks with
recursive attacks (AFRA), thereby we end up with unified algorithms that enumerate extensions of
any AF / AFRA.

1. Introduction
Computational argumentation, covering its theory and applications, has attracted major attention in
the AI research community, notably in the last twenty years (e.g. Bench-Capon & Dunne, 2007;
Besnard & Hunter, 2008; Rahwan & Simari, 2009; Modgil, Toni, Bex, Bratko, Chesnevar, Dvorak,
Falappa, Fan, Gaggl, Garca, Gonzalez, Gordon, Leite, Mozina, Reed, Simari, Szeider, Torroni, &
Woltran, 2013). Dungs abstract argumentation frameworks (AFs) (Dung, 1995) are a widely studied
model in which an AF is described by a pair (A, R): A is a set of abstract arguments and R  AA is a
binary relation, so-called the attack relation, to represent the conflicting arguments. A central notion
in AFs is an argumentation semantics: a set of criteria that characterise the acceptable arguments;
we define these criteria rigorously in section 2. For different reasons a number of argumentation
semantics have been proposed in the literature. Explaining these reasons in detail is out of the scope
of this paper; however, see the work of Baroni, Caminada, and Giacomin (2011a) for an excellent
introduction to argumentation semantics.
Under various argumentation semantics, one might find multiple distinct extensions (defined in
section 2). Labeling based algorithms (e.g. Dimopoulos, Magirou, & Papadimitriou, 1997; Doutre
& Mengin, 2001; Modgil & Caminada, 2009) for listing all extensions have been developed such
that arguments (i.e. elements of A) are the only target to be labeled. In this paper we illustrate how to
enumerate extensions under several argumentation semantics by labeling attacks (i.e. elements of R)
c
2014
AI Access Foundation. All rights reserved.

fiN OFAL , ATKINSON , & D UNNE

along with arguments, instead of labeling arguments solely. This is particularly of interest in listing
extensions of AF-extended formalisms that allow attacks on attacks (e.g. Modgil, 2009b; Gabbay,
2009; Baroni, Cerutti, Giacomin, & Guida, 2011b). As we show throughout the paper, the term
labeling based algorithms for argumentation semantics is distinguished from the common term
labeling based semantics, although both concepts involve a labeling mapping. The former term
(i.e. labeling based algorithms) refers to the course of actions by which an extension enumeration
process classifies arguments: those which might be in an extension from those which are excluded
from the respective extension. This classification is essential in order to construct all concrete
extensions of a given AF. The later term (i.e. labeling based semantics) refers to an approach to
describing (i.e. not constructing) extensions using a labeling mapping.
In section 2 we provide necessary background materials. In section 3 we review explicit algorithms for a selection of dominant argumentation semantics: preferred, stable, complete, semi
stable, stage, ideal and grounded. These algorithms list extensions by labeling arguments only.
Then in section 4 we develop, under the respective argumentation semantics, definite algorithms
for enumerating extensions of an argumentation framework with recursive attacks (AFRA): an AFextended model that allows attacks on attacks (Baroni et al., 2011b). These algorithms construct
extensions by labeling attacks together with arguments. Since an AF is a special case of AFRA (Baroni et al., 2011b), the developed algorithms for AFRA also list extensions of an AF. In section 5 we
report on experiments concerning the practical efficiency of the algorithms. Section 6 concludes the
paper with a summary and a review of related work.

2. Preliminaries
We start with the definition of Dungs argumentation frameworks (Dung, 1995).
Definition 1. (Dungs Argumentation Frameworks)
An argumentation framework (or AF) is a pair (A, R) where A is a set of arguments and R  A  A
is a binary relation.
We refer to (x, y)  R as x attacks y (or y is attacked by x). We denote by {x} respectively
the subset of A containing those arguments that attack (resp. are attacked by) the argument x,
extending this notation in the natural way to sets of arguments, so that for S  A,
{x}+

S
S+

=
=

{ y  A :  x  S s.t. y  {x} }
{ y  A :  x  S s.t. y  {x}+ }

Given a subset S  A, then
 x  A is acceptable w.r.t. S if and only if for every (y, x)  R, there is some z  S for which
(z, y)  R.
 S is conflict free if and only if for each (x, y)  S  S, (x, y) 
/ R.
 S is admissible if and only if it is conflict free and every x  S is acceptable w.r.t. S.
 S is a preferred extension if and only if it is a maximal (w.r.t. ) admissible set.
 S is a stable extension if and only if it is conflict free and S+ = A \ S.
636

fiA LGORITHMS FOR A RGUMENTATION S EMANTICS

Figure 1: An argumentation framework.
 S is a complete extension if and only if it is an admissible set such that for each x acceptable
w.r.t. S, x  S.
 S is a stage extension if and only if it is conflict free and S  S+ is maximal (w.r.t. ).
 S is a semi stable extension if and only if it is admissible and S  S+ is maximal (w.r.t. ).
 S is the ideal extension if and only if it is the maximal (w.r.t. ) admissible set that is contained in every preferred extension.
 S is the grounded extension if and only if it is the least fixed point of F(T ) = {x  A |
x is acceptable w.r.t. T }.
Preferred, complete, stable and grounded semantics are introduced in the work of Dung (1995),
whereas stage semantics, ideal semantics and semi stable semantics are presented in the papers
of Verheij (1996), Dung, Mancarella, and Toni (2007) and Caminada, Carnielli, and Dunne (2012)
respectively. To give an example, consider the framework depicted in figure 1 where nodes represent
arguments and edges correspond to attacks (i.e. elements of R). For this example {b, d} is the
preferred, grounded, stable, ideal, complete, semi stable and stage extension. Note that we do not
intend by this example to show differences between semantics.
Offering an explicit means to weaken attacks, the formalisms of Modgil (2009b), Gabbay
(2009) and Baroni et al. (2011b) extend AFs such that attacks (i.e. elements of R) are subject
to attacks themselves. We present extension enumeration algorithms for an instance of such formalisms: namely argumentation frameworks with recursive attacks (AFRA) introduced by Baroni et
al. (2011b).
Definition 2. An argumentation framework with recursive attacks (AFRA) is a pair (A, R) where A
is a set of arguments and R is a set of pairs (x, y) such that x  A and (y  A or y  R).
Let x = (y, z)  R then we say that y is the source of x, denoted as src(x) = y, and z is the target
of x, denoted as trg(x) = z.
Let x  A  R and y  R then we say that y directly de f eats x if and only if x = trg(y).
Let x, y  R then we say y indirectly de f eats x if and only if src(x) = trg(y).
Let x  A  R and y  R, we say y de f eats x if and only if y directly or indirectly defeats x.
Given a subset S  A  R, then
 S is conflict free if and only if there does not exist x, y  S s.t. x defeats y.
 An element x  A  R is acceptable w.r.t. S if and only if for each y  R : y defeats x, there is
some z  S such that z defeats y.
 S is admissible if and only if S is conflict free and for each x  S, x is acceptable w.r.t. S.
637

fiN OFAL , ATKINSON , & D UNNE

Figure 2: An argumentation framework with recursive attacks.
 S is a preferred extension if it is a maximal (w.r.t. ) admissible set.
/ S, there
 S is a stable extension if and only if it is conflict free and for each x  A  R : x 
exists y  S such that y de f eats x.
 S is a complete extension if and only if it is admissible and every element of A  R, which is
acceptable w.r.t. S, belongs to S.
 S is a stage (resp. semi stable) extension if and only if S is conflict free (resp. admissible) and
S  {x | y  S s.t. y defeats x} is maximal (w.r.t. ).
 S is the ideal extension if and only if it is the maximal (w.r.t. ) admissible set that is contained in every preferred extension.
 S is the grounded extension if and only if it is the least fixed point of F(T ) = {x  A  R |
x is acceptable w.r.t. T }.
Referring to figure 2, {b, d, h, e} is the grounded, stable, preferred, ideal, complete, stage and
semi stable extension.
We consider now the issue of expressing an AFRA as an AF. Let H = (A, R) be an AFRA,
then the corresponding AF H  = (A , R ) is defined such that A = A  R and R = {(x, y) | x, y 
A  R and x de f eats y}. For example, the corresponding AF of the AFRA depicted in figure 2 is
described by A = {b, c, d, e, f , g, h} and R = {(e, g), ( f , e), (g, e), (g, d), (h, c), (h, f ), (h, g)}.

3. Algorithms for a Selection of Argumentation Semantics
In this section we review explicit algorithms that list, under a number of argumentation semantics,
all extensions of an AF by labeling arguments solely. Particularly, in subsection 3.1 we recall the
algorithm of Nofal, Atkinson and Dunne (2014) for preferred semantics. In section 3.2 we present
a new implementation of the algorithm of Dimopoulos et al. (1997) for stable semantics. Then
we modify the algorithm of Nofal, Atkinson and Dunne (2014) to produce specific algorithms for
complete, stage, semi stable and ideal semantics in subsections 3.3, 3.4, 3.5 and 3.6 respectively.
In subsection 3.7 we present an implementation for building the grounded extension.
3.1 Enumerating Preferred Extensions of any AF
Algorithm 1 lists all preferred extensions of an AF. Algorithm 1 is taken from the work of Nofal,
Atkinson and Dunne (2014) where it has been shown that the algorithm is likely to be more efficient
than the algorithms of Doutre and Mengin (2001), and Modgil and Caminada (2009). We recall
638

fiA LGORITHMS FOR A RGUMENTATION S EMANTICS

algorithm 1 because other implemented algorithms of the present paper can be seen as an extension
of this algorithm. The algorithm is a backtracking procedure that traverses an abstract binary search
tree. A core notion of the algorithm is related to the use of five labels: IN, OUT, MUST OUT,
BLANK and UNDEC. Informally, the IN label identifies arguments that might be in a preferred
extension. The OUT label identifies an argument that is attacked by an IN argument. The BLANK
label is for any unprocessed argument whose final label is not decided yet. The MUST OUT label
identifies arguments that attack IN arguments. The UNDEC label designates arguments which might
not be included in a preferred extension because they might not be defended by any IN argument.
To enumerate all preferred extensions algorithm 1 starts with BLANK as the default label for all
arguments. This initial state represents the root node of the search tree. Then the algorithm forks to
a left (resp. right) child (i.e. state) by picking an argument, that is BLANK, to be labeled IN (resp.
UNDEC). Every time an argument, say x, is labeled IN some of the neighbour arguments labels
might change such that for every y  {x}+ the label of y becomes OUT and for every z  {x} \{x}+
the label of z becomes MUST OUT. This process, i.e. forking to new children, continues until for
every x  A the label of x is not BLANK. At this point, the algorithm captures a preferred extension
if and only if for every x  A the label of x belongs to {IN,OUT,UNDEC} and {x | the label of x is
IN} is not a subset of a previously found preferred extension (if such exists). Then the algorithm
backtracks to try to find all preferred extensions. It is important in these kinds of algorithms to
exploit properties whereby we might bypass expanding a child of the search tree, thus considerable
time might be saved. Algorithm 1 uses two pruning properties:
1. Algorithm 1 (lines 12-17) skips labeling an argument y IN (i.e. skips expanding a left child)
if and only if there is z  {y} such that the label of z is not OUT while there is no w  {z}
with the BLANK label. In other words, such z can not be labeled OUT later while for each
w  {z} the label of w is OUT, MUST OUT or UNDEC. Thus, it is more efficient to skip
trying to include any argument that is attacked by such z in a preferred extension.
2. Algorithm 1 (lines 19-22) skips labeling an argument y UNDEC (i.e. skips expanding a right
child) if and only if for every z  {y} the current label of z is OUT or MUST OUT. This
is because if an admissible set, say S, is constructed while such y is UNDEC then S  {y} is
admissible also. Recall that preferred extensions are the maximal admissible sets, hence no
need to label such y UNDEC.
Another fundamental issue to take into account is the selection of BLANK arguments that are
to be labeled IN. The point behind adopting a selection strategy is to try to achieve a preferred extension more efficiently. This is critical when the problem is about constructing only one extension.
Therefore, algorithm 1 (line 8) applies the following selection options:
1. Algorithm 1 tries to select first a BLANK argument, say y, that is not attacked at all or is
attacked by OUT/MUST OUT arguments only. The justification of this selection is related to
the second pruning property used by the algorithm. Note that the earlier we pick such y to be
labeled IN, the bigger part of the search tree to be avoided. Recall that such y will not lead to
expanding a right child according to the second pruning property.
2. Otherwise the algorithm picks up a BLANK argument, say y, such that |{z : z  {y}+ and
the label of z is not OUT}| is maximal. The intuition is that maximising the number of
OUT arguments will minimise the number of BLANK/MUST OUT arguments. Thus, the
639

fiN OFAL , ATKINSON , & D UNNE

Figure 3: Enumerating preferred extensions of an AF using algorithm 1.
new generated state (i.e. child), due to selecting such y, is much closer to the state where
a preferred extension is captured. Recall that a preferred extension is achieved if and only if
for each x  A the label of x is IN, OUT or UNDEC.
Algorithm 1, like all algorithms in this paper, is self-contained and self-explanatory. Figure 3,
however, illustrates algorithm 1 running on an AF.
3.2 Enumerating Stable Extensions of any AF
Algorithm 2 lists all stable extensions. Algorithm 2 can be seen as a new implementation of the
algorithm of Dimopoulos et al. (1997). Algorithm 2 differs from algorithm 1 in two ways:
640

fiA LGORITHMS FOR A RGUMENTATION S EMANTICS

Algorithm 1: Enumerating all preferred extensions of an AF (A, R).
1
2
3
4
5

6
7
8

9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26

Lab : A  {IN, OUT, MUST OUT,UNDEC, BLANK}; Lab  0;
/
foreach x  A do Lab  Lab  {(x, BLANK)};
E pre f erred  2A ; E pre f erred  0;
/
call find-preferred-extensions(Lab);
report E pre f erred is the set of all preferred extensions;
procedure find-preferred-extensions(Lab) begin
while y  A : Lab(y) = BLANK do
select y with Lab(y) = BLANK and z  {y} Lab(z)  {OUT, MUST OUT },
otherwise select y with Lab(y) = BLANK s.t. z  A : Lab(z) = BLANK, |{x : x 
{y}+  Lab(x) = OUT }|  |{x : x  {z}+  Lab(x) = OUT }|;
Lab  Lab;
Lab (y)  IN;
foreach z  {y}+ do Lab (z)  OUT ;
foreach z  {y} do
if Lab (z)  {UNDEC, BLANK} then
Lab (z)  MUST OUT ;
if  w  {z} : Lab (w) = BLANK then
Lab(y)  UNDEC;
goto line 7;
call find-preferred-extensions(Lab );
if z  {y} : Lab(z)  {BLANK,UNDEC} then
Lab(y)  UNDEC;
else
Lab  Lab ;
if  x : Lab(x) = MUST OUT then
S  {x | Lab(x) = IN};
if  T  E pre f erred : S  T then E pre f erred  E pre f erred  {S};
end procedure

641

fiN OFAL , ATKINSON , & D UNNE

1. Algorithm 2 uses four labels: IN, OUT, BLANK and MUST OUT. The usage of these labels
is as outlined in algorithm 1 with one distinction: the role of the UNDEC label used in algorithm 1 is now overloaded to the MUST OUT label. Meaning, in algorithm 2 the MUST OUT
label is used also for labeling an argument, say x, trying to build a stable extension without x.
This is because any argument, say x, outside a candidate stable extension should be attacked
by an argument in the extension, hence x should be labeled MUST OUT (not UNDEC as it is
the case in algorithm 1.)
2. In algorithm 1, P = {w | the label of w is IN} is a preferred extension if and only if for each
x  A, the label of x is not BLANK nor MUST OUT and P is not a subset of a previously
found preferred extension. In algorithm 2 (line 24) the set {w | the label of w is IN} is a stable
extension if and only if for every x  A, the label of x is not BLANK nor MUST OUT.
Algorithm 2: Enumerating all stable extensions of an AF (A, R).
1
2
3
4
5

6
7
8

9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26

Lab : A  {IN, OUT, MUST OUT, BLANK}; Lab  0;
/
foreach x  A do Lab  Lab  {(x, BLANK)};
Estable  2A ; Estable  0;
/
call find-stable-extensions(Lab);
report Estable is the set of all stable extensions;
procedure find-stable-extensions(Lab) begin
while y  A : Lab(y) = BLANK do
select y with Lab(y) = BLANK and z  {y} Lab(z)  {OUT, MUST OUT },
otherwise select y with Lab(y) = BLANK s.t. z : Lab(z) = BLANK, |{x : x 
{y}+  Lab(x) = OUT }|  |{x : x  {z}+  Lab(x) = OUT }|;
Lab  Lab;
Lab (y)  IN;
foreach z  {y}+ do Lab (z)  OUT ;
foreach z  {y} do
if Lab (z) = BLANK then
Lab (z)  MUST OUT ;
if w  {z} Lab (w) = BLANK then
Lab(y)  MUST OUT ;
goto line 7;
call find-stable-extensions(Lab );
if z  {y} : Lab(z) = BLANK then
Lab(y)  MUST OUT ;
else
Lab  Lab ;
if x : Lab(x) = MUST OUT then
S  {x | Lab(x) = IN};
Estable  Estable  {S};
end procedure

642

fiA LGORITHMS FOR A RGUMENTATION S EMANTICS

3.3 Enumerating Complete Extensions of any AF
Algorithm 3 lists all complete extensions. Algorithm 3 is a modification of algorithm 1 that enumerates preferred extensions. In algorithm 1, P = {w | the label of w is IN} is a preferred extension
if and only if for each x  A, the label of x is not BLANK nor MUST OUT and P is not a subset of
a previously found preferred extension. In algorithm 3 (line 10) the set {w | the label of w is IN} is
a complete extension if and only if
C1. for every x  A, the label of x is not MUST OUT and
C2. there is no z with UNDEC (or BLANK) label such that for every y  {z} the label of y is
OUT.
Recall that a complete extension is an admissible set S such that for every x acceptable with respect
to S, x belongs to S. Thus, the condition C1 ensures admissibility while C2 guarantees completeness.
3.4 Enumerating Stage Extensions of any AF
Algorithm 4 lists all stage extensions. Algorithm 4 is an alteration of algorithm 1 that enumerates
preferred extensions. Algorithm 4 uses four labels: IN, OUT, UNDEC and BLANK. The usage of
these labels is as outlined in algorithm 1 with one distinction: the role of the MUST OUT label used
in algorithm 1 is now overloaded to the UNDEC label. Meaning, in algorithm 4 the UNDEC label is
used also for identifying arguments that attack an IN argument. This is because any argument attacks
an argument of a stage extension is not necessarily attacked by an argument of the extension.
Algorithm 4 constructs conflict free subsets of A. In particular, algorithm 4 (line 26) keeps a
record of the conflict free set {w | the label of w is IN} if and only if for each x  A, the label of
x is not BLANK. After constructing such conflict free subsets, algorithm 4 decides that a conflict
free subset, say S, is a stage extension if and only if S  S+ is maximal, see lines 5-9. As might
be expected, argument selection and pruning strategies used in admissibility based semantics will
not be applicable to stage semantics, which are based on conflict free sets. Therefore, as a pruning
strategy we skip labeling an argument, say y, UNDEC if and only if for each z  {y}+  {y} , the
label of z is OUT or UNDEC. This is based on the following property: if a conflict free set, say S,
will be captured while such y is UNDEC then S  {y} is also conflict free, and hence, there is no
need to label y with UNDEC since S  {y}  S; recall that algorithm 4 labels an argument UNDEC
trying to build a stage extension excluding the argument. On selecting the next BLANK argument
to be labeled IN, we consider the rule:
R1. select a BLANK argument y s.t. for each z  {y}+  {y} , the label of z is OUT or UNDEC.
R2. otherwise select a BLANK argument y such that |{x : x  {y}+  {y} and the label of x is
BLANK}| is maximal.
Note the correlation between R1 and the applied pruning strategy: the earlier we label the
argument selected by R1 with IN, the bigger the part of the search tree that will be bypassed.
Regarding the benefit of R2, recall that the aim of argument selection is to accelerate achieving a
goal state, which is a conflict free subset S such that S  S+ is maximal and there is no x  A with the
BLANK label. Indeed, R2 minimises the number of BLANK arguments by maximising the number
of OUT/UNDEC arguments.
643

fiN OFAL , ATKINSON , & D UNNE

Algorithm 3: Enumerating all complete extensions of an AF (A, R).
1
2
3
4
5

6
7
8
9
10
11
12

13
14
15
16
17
18
19
20
21
22
23
24
25
26
27

Lab : A  {IN, OUT, MUST OUT,UNDEC, BLANK}; Lab  0;
/
foreach x  A do Lab  Lab  {(x, BLANK)};
Ecomplete  2A ; Ecomplete  0;
/
call find-complete-extensions(Lab);
report Ecomplete is the set of all complete extensions;
procedure find-complete-extensions(Lab) begin
if  y  A : Lab(y) = MUST OUT then
if  x : Lab(x)  {UNDEC, BLANK}  z  {x} Lab(z) = OUT then
S  {w  A | Lab(w) = IN};
Ecomplete  Ecomplete  {S};
while y  A : Lab(y) = BLANK do
select y with Lab(y) = BLANK and z  {y} Lab(z)  {OUT, MUST OUT },
otherwise select y with Lab(y) = BLANK s.t. z  A : Lab(z) = BLANK, |{x : x 
{y}+  Lab(x) = OUT }|  |{x : x  {z}+  Lab(x) = OUT }|;
Lab  Lab;
Lab (y)  IN;
foreach z  {y}+ do Lab (z)  OUT ;
foreach z  {y} do
if Lab (z)  {UNDEC, BLANK} then
Lab (z)  MUST OUT ;
if  w  {z} : Lab (w) = BLANK then
Lab(y)  UNDEC;
goto line 11;
call find-complete-extensions(Lab );
if z  {y} : Lab(z)  {BLANK,UNDEC} then
Lab(y)  UNDEC;
else
Lab  Lab ;
end procedure

644

fiA LGORITHMS FOR A RGUMENTATION S EMANTICS

Algorithm 4: Enumerating all stage extensions of an AF (A, R).
1
2
3
4
5
6
7
8
9
10
11

12
13
14

15
16
17
18
19
20
21
22
23
24
25
26
27

Lab : A  {IN, OUT,UNDEC, BLANK}; Lab  0;
/
foreach x  A do Lab  Lab  {(x, BLANK)};
Estage  {Lab1 | Lab1 : A  {IN, OUT,UNDEC, BLANK}}; Estage  0;
/
call find-conflict-free-sets(Lab);
foreach Lab1  Estage do
foreach Lab2  Estage do
if {x : Lab1 (x)  {IN, OUT }} ( {z : Lab2 (z)  {IN, OUT }} then
Estage  Estage \ {Lab1 };
continue to next iteration from line 5;
foreach Lab1  Estage do
report {x : Lab1 (x) = IN} is a stage extension ;
procedure find-conflict-free-sets(Lab) begin
while y  A : Lab(y) = BLANK do
select y with Lab(y) = BLANK such that z  {y}+  {y} Lab(z)  {OUT,UNDEC},
otherwise select y with Lab(y) = BLANK such that z : Lab(z) = BLANK, |{x : x 
{y}+  {y}  Lab(x) = BLANK}|  |{x : x  {z}+  {z}  Lab(x) = BLANK}|;
Lab  Lab;
Lab (y)  IN;
foreach z  {y}+ do Lab (z)  OUT ;
foreach z  {y} do
if Lab (z)  {BLANK} then
Lab (z)  UNDEC;
call find-conflict-free-sets(Lab );
if z  {y}+  {y} with Lab(z) = BLANK then
Lab(y)  UNDEC;
else
Lab  Lab ;
Estage  Estage  {Lab};
end procedure

645

fiN OFAL , ATKINSON , & D UNNE

3.5 Enumerating Semi Stable Extensions of any AF
Algorithm 5 enumerates all semi stable extensions. Again, algorithm 5 is a reproduction of algorithm 1. Actually, algorithm 5 firstly builds admissible sets. Then, the algorithm decides that an
admissible set, say S, is a semi stable extension if and only if S  S+ is maximal; see lines 6-10.

Algorithm 5: Enumerating all semi stable extensions of an AF (A, R).
1
2
3
4
5
6
7
8
9
10
11
12

13
14
15

16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32

Lab : A  {IN, OUT, MUST OUT,UNDEC, BLANK}; Lab  0;
/
foreach x  A do Lab  Lab  {(x, BLANK)};
Esemistable  {Lab1 | Lab1 : A  {IN, OUT, MUST OUT,UNDEC, BLANK}};
Esemistable  0;
/
call find-admissible-sets(Lab);
foreach Lab1  Esemistable do
foreach Lab2  Esemistable do
if {x : Lab1 (x)  {IN, OUT }} ( {z : Lab2 (z)  {IN, OUT }} then
Esemistable  Esemistable \ {Lab1 };
continue to next iteration from line 6;
foreach Lab1  Esemistable do
report {x : Lab1 (x) = IN} is a semi stable extension ;
procedure find-admissible-sets(Lab) begin
while y  A : Lab(y) = BLANK do
select y with Lab(y) = BLANK and z  {y} Lab(z)  {OUT, MUST OUT },
otherwise select y with Lab(y) = BLANK s.t. z  A : Lab(z) = BLANK, |{x : x 
{y}+  Lab(x) = OUT }|  |{x : x  {z}+  Lab(x) = OUT }|;
Lab  Lab;
Lab (y)  IN;
foreach z  {y}+ do Lab (z)  OUT ;
foreach z  {y} do
if Lab (z)  {UNDEC, BLANK} then
Lab (z)  MUST OUT ;
if  w  {z} : Lab (w) = BLANK then
Lab(y)  UNDEC;
goto line 14;
call find-admissible-sets(Lab );
if z  {y} : Lab(z)  {BLANK,UNDEC} then
Lab(y)  UNDEC;
else
Lab  Lab ;
if  x  A : Lab(x) = MUST OUT then
Esemistable  Esemistable  {Lab};
end procedure

646

fiA LGORITHMS FOR A RGUMENTATION S EMANTICS

3.6 Constructing the Ideal Extension of any AF
Algorithm 6 builds the ideal extension. The algorithm is a modification of algorithm 1. Algorithm 6
(line 28) records {w | the label of w is IN} as an admissible set if and only if for each x  A, the label
of x is not BLANK nor MUST OUT. However, the algorithm also constructs (line 27) S = {x  A |
there exists an admissible set T such that x  T + }. After building a set of admissible sets and
having S constructed, algorithm 6 considers an admissible set I as the ideal extension if and only
if I  S = 0;
/ see lines 6-8. Recall that the ideal extension is the maximal (w.r.t. ) admissible
set that is contained in every preferred extension. Satisfying the condition I  S = 0/ implies that
the arguments of I are not attacked by any admissible set (see the definition of S above), which
means I is contained in every preferred extension. To ensure such I is maximal, algorithm 6 collects
admissible sets in descending order: from larger sets to smaller ones. In consequence, the algorithm
checks the collected admissible sets with the condition I  S = 0/ starting from larger admissible sets
to smaller ones.
3.7 Constructing the Grounded Extension of any AF
Algorithm 7 can be viewed as another implementation of the algorithm described by Modgil and
Caminada (2009) for building the grounded extension.

4. Labeling Attacks as a Generalization of Labeling Arguments
In this section we illustrate how to enumerate extensions, under a number of argumentation semantics, by labeling attacks together with arguments instead of labeling arguments solely. To this end,
we develop algorithms for listing extensions of an AFRA (Baroni et al., 2011b) under preferred,
stable, complete, stage, semi stable, ideal and grounded semantics in subsections 4.1, 4.2, 4.3, 4.4,
4.5, 4.6 and 4.7 respectively. All these algorithms are basically a generalization of the algorithms
presented in the previous section, hence these algorithms list extensions of any AF / AFRA.
4.1 Enumerating Preferred Extensions of any AF / AFRA
Algorithm 8 enumerates all preferred extensions of an AFRA. Algorithm 8 is a generalization of
algorithm 1. The idea is based on using five labels: IN, OUT, MUST OUT, BLANK and UNDEC.
The BLANK label is the initial label for all arguments and attacks. A BLANK attack y  R is labeled
IN to indicate that y might be in a preferred extension. An argument x is labeled OUT if and only if
there is y  R with the label IN such that trg(y) = x. An attack z  R is labeled OUT if and only if
there is y  R with the label IN such that trg(y)  {z, src(z)}. A BLANK argument x is labeled IN,
implying that x might be in a preferred extension, if and only if there is y  R with the label IN such
that src(y) = x or for each z  R : trg(z) = x the label of z is OUT. An attack y is labeled UNDEC to
try to find a preferred extension excluding y. An attack z with the label BLANK/UNDEC is labeled
MUST OUT if and only if there is y  R with the label IN such that trg(z)  {y, src(y)}. Every
time an attack is labeled IN the labels of some attacks and arguments might change accordingly, see
lines 10-20 of algorithm 8. As a selection rule, line 8 represents the strategy by which the algorithm
selects the next attack, that is BLANK, to be labeled IN. The rule and its grounds is in parallel to
the selection rule applied in algorithm 1 for enumerating preferred extensions of an AF. Likewise,
algorithm 8 applies two pruning tactics:
647

fiN OFAL , ATKINSON , & D UNNE

Algorithm 6: Constructing the ideal extension of an AF (A, R).
1
2
3
4
5
6
7
8

9
10
11

12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29

Lab : A  {IN, OUT, MUST OUT,UNDEC, BLANK}; Lab  0;
/
foreach x  A do Lab  Lab  {(x, BLANK)};
Eideal : Z  2A ; Eideal  0;
/
S  0;
/
call find-admissible-sets(Lab);
foreach i = 1 .. |Eideal | do
if Eideal (i)  S = 0/ then
report Eideal (i) is the ideal extension; exit;
procedure find-admissible-sets(Lab) begin
while y  A : Lab(y) = BLANK do
select y with Lab(y) = BLANK and z  {y} Lab(z)  {OUT, MUST OUT },
otherwise select y with Lab(y) = BLANK s.t. z  A : Lab(z) = BLANK, |{x : x 
{y}+  Lab(x) = OUT }|  |{x : x  {z}+  Lab(x) = OUT }|;
Lab  Lab;
Lab (y)  IN;
foreach z  {y}+ do Lab (z)  OUT ;
foreach z  {y} do
if Lab (z)  {UNDEC, BLANK} then
Lab (z)  MUST OUT ;
if  w  {z} : Lab (w) = BLANK then
Lab(y)  UNDEC;
goto line 10;
call find-admissible-sets(Lab );
if z  {y} : Lab(z)  {BLANK,UNDEC} then
Lab(y)  UNDEC;
else
Lab  Lab ;
if  w  A : Lab(w) = MUST OUT then
S  S  {x | Lab(x) = OUT };
Eideal  Eideal  {(|Eideal | + 1, {z | Lab(z) = IN})};
end procedure

Algorithm 7: Constructing the grounded extension of an AF (A, R).
1
2
3
4
5
6
7

Lab : A  {IN, OUT,UNDEC}; Lab  0;
/
foreach w  A do Lab  Lab  {(w,UNDEC)};
while x with Lab(x) = UNDEC : y  {x} Lab(y) = OUT do
foreach x with Lab(x) = UNDEC : y  {x} Lab(y) = OUT do
Lab(x)  IN;
foreach z  {x}+ do Lab(z)  OUT ;
report the grounded extension is {w | Lab(w) = IN};

648

fiA LGORITHMS FOR A RGUMENTATION S EMANTICS

Figure 4: How algorithm 8 works on an AFRA.
1. Algorithm 8 (lines 17- 20) skips labeling an attack y IN (i.e. skips expanding a left child) if
and only if
z : trg(z)  {y, src(y)} and the label o f z is not OUT and
  w with the label BLANK : trg(w)  {z, src(z)}.
2. Algorithm 8 (lines 22- 25) skips labeling an attack y UNDEC (i.e. skips expanding a right
child) if and only if for each z  R : trg(z)  {y, src(y)}, the label of z is OUT or MUST OUT.
To get the general idea of algorithm 8 see figure 4 that shows how the algorithm works on the
AFRA depicted in figure 2.
4.2 Enumerating Stable Extensions of any AF / AFRA
Algorithm 9 enumerates all stable extensions. Actually, algorithm 9 is a modification of algorithm 8
that lists preferred extensions. However there are two differences:
1. Algorithm 9 uses four labels: IN, OUT, BLANK and MUST OUT. The usage of these labels
is as outlined in algorithm 8 with one difference: the role of the UNDEC label used in algorithm 8 is now overloaded to the MUST OUT label. That is, in algorithm 9 the MUST OUT
label is used also for labeling an attack, say x, trying to build a stable extension without x.
This is because any attack, say x, outside a candidate stable extension should be defeated by
an attack in the extension, hence x should be labeled MUST OUT.
2. In algorithm 8 we find a preferred extension, say P, if and only if for each x  A  R, x is not
BLANK nor MUST OUT and P is not a subset of a previously found preferred extension. In
algorithm 9 we encounter a stable extension if and only if for each x  A  R, x is not BLANK
nor MUST OUT.
649

fiN OFAL , ATKINSON , & D UNNE

Algorithm 8: Enumerating all preferred extensions of an AFRA (A, R).
1
2
3
4
5

6
7
8

9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27

28
29
30
31

Lab : (A  R)  {IN, OUT, MUST OUT,UNDEC, BLANK}; Lab  0;
/
foreach x  A  R do Lab  Lab  {(x, BLANK)};
E pre f erred  2AR ; E pre f erred  0;
/
call find-preferred-extensions(Lab);
report E pre f erred is the set of all preferred extensions;
procedure find-preferred-extensions(Lab) begin
while y  R : Lab(y) = BLANK do
select y  R with Lab(y) = BLANK such that
z  R : trg(z)  {y, src(y)} Lab(z)  {OUT, MUST OUT }, otherwise select y  R with
Lab(y) = BLANK such that z  R : Lab(z) = BLANK
|{x : src(x) = trg(y)  Lab(x) = OUT }|  |{x : src(x) = trg(z)  Lab(x) = OUT }|;
Lab  Lab;
Lab (y)  IN;
Lab (src(y))  IN;
Lab (trg(y))  OUT ;
if trg(y)  A then
foreach z  R : src(z) = trg(y) do
Lab (z)  OUT ;
foreach z  R : Lab (z)  {BLANK,UNDEC}  trg(z)  {y, src(y)} do
Lab (z)  MUST OUT ;
if   w  R : Lab (w) = BLANK  trg(w)  {z, src(z)} then
Lab(y)  UNDEC;
goto line 7;
call find-preferred-extensions(Lab );
if z  R : Lab(z)  {BLANK,UNDEC}  trg(z)  {y, src(y)} then
Lab(y)  UNDEC;
else
Lab  Lab ;
if  w  R : Lab(w) = MUST OUT then
foreach x  A with Lab(x) = BLANK s.t. z  R : trg(z) = x (Lab(z) = OUT ) do
Lab(x)  IN;
S  {x  A  R | Lab(x) = IN};
if T  E pre f erred (S  T ) then
E pre f erred  E pre f erred  {S};
end procedure

650

fiA LGORITHMS FOR A RGUMENTATION S EMANTICS

Algorithm 9: Enumerating all stable extensions of an AFRA (A, R).
1
2
3
4
5

6
7
8

9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27

28
29

Lab : (A  R)  {IN, OUT, MUST OUT, BLANK}; Lab  0;
/
foreach x  A  R do Lab  Lab  {(x, BLANK)};
E stable  2AR ; E stable  0;
/
call find-stable-extensions(Lab);
report E stable is the set of all stable extensions;
procedure find-stable-extensions(Lab) begin
while y  R : Lab(y) = BLANK do
select y  R with Lab(y) = BLANK such that
z  R : trg(z)  {y, src(y)} Lab(z)  {OUT, MUST OUT }, otherwise select y  R with
Lab(y) = BLANK such that z  R : Lab(z) = BLANK
|{x : src(x) = trg(y)  Lab(x) = OUT }|  |{x : src(x) = trg(z)  Lab(x) = OUT }|;
Lab  Lab;
Lab (y)  IN;
Lab (src(y))  IN;
Lab (trg(y))  OUT ;
if trg(y)  A then
foreach z  R : src(z) = trg(y) do
Lab (z)  OUT ;
foreach z  R : Lab (z) = BLANK  trg(z)  {y, src(y)} do
Lab (z)  MUST OUT ;
if   w  R : Lab (w) = BLANK  trg(w)  {z, src(z)} then
Lab(y)  MUST OUT ;
goto line 7;
call find-stable-extensions(Lab );
if z  R : Lab(z) = BLANK  trg(z)  {y, src(y)} then
Lab(y)  MUST OUT ;
else
Lab  Lab ;
if  w  R : Lab(w) = MUST OUT then
foreach x  A with Lab(x) = BLANK s.t. z  R : trg(z) = x (Lab(z) = OUT ) do
Lab(x)  IN;
E stable  E stable  {{x  A  R | Lab(x) = IN}};
end procedure

651

fiN OFAL , ATKINSON , & D UNNE

4.3 Enumerating Complete Extensions of any AF / AFRA
Algorithm 10 enumerates all complete extensions. Again, algorithm 10 is a modification of algorithm 8 that lists preferred extensions. In algorithm 8 we achieve a preferred extension, say P, if and
only if for each x  A  R, the label of x is not BLANK nor MUST OUT and P is not a subset of a
previously found preferred extension. However, in algorithm 10 (line 7) we encounter a complete
extension if and only if
C1. there is no z  R with the MUST OUT label and
C2. there does not exist w  R such that
(a) the label of w is UNDEC or BLANK and
(b) for each y  R : trg(y)  {w, src(w)}, the label of y is OUT.
Thus, C1 ensures admissibility while C2 guarantees completeness.
4.4 Enumerating Stage Extensions of any AF / AFRA
Algorithm 11 lists all stage extensions. The algorithm is a rewrite of algorithm 8. However, algorithm 11 uses four labels: IN, OUT, BLANK and UNDEC. The usage of these labels is as outlined
in algorithm 8 with one difference: the role of the MUST OUT label used in algorithm 8 is now
overloaded to the UNDEC label. That is, in algorithm 11 the UNDEC label is used also for identifying attacks that attack an IN argument/attack. This is because any attack defeats an argument/attack
of a stage extension is not necessarily defeated by an attack of the extension.
Algorithm 11 (lines 14-29) finds a set of conflict free subsets of A  R rather than constructing
admissible subsets as done by algorithm 8. In algorithm 8 the set {w  A  R | the label of w is IN}
is reported as an admissible set if and only if for each x  A  R, the label of x is not BLANK nor
MUST OUT. In algorithm 11 the set {w  A  R | the label of w is IN} is recorded as a conflict free
set (i.e. a stage extension candidate) if and only if for each x  A  R, the label of x is not BLANK,
see lines 14 & 31. After building a set of conflict free subsets, algorithm 11 decides that a conflict
free subset S  A  R is a stage extension if and only if S  {x | y  S : y defeats x} is maximal, see
lines 6-10. As we stated earlier, argument selection and pruning strategies used in semantics that are
based on admissible sets will not be applicable to stage semantics, which are based on conflict free
sets. Therefore, as a pruning strategy (line 29 of algorithm 11) we skip labeling an attack y UNDEC
(i.e. skip expanding a right child) if and only if
z  R : trg(z)  {y, src(y)}  trg(y)  {z, src(z)},
the label o f z is OUT or UNDEC.
This is based on the property that if a conflict free set, say S, is formed while such y is UNDEC
then S  {y} is also conflict free, and hence, there is no need to label y UNDEC since S  {y}  S.
On selecting the next BLANK attack to be labeled IN, we apply the following rule (see line 15):
R1. select a BLANK attack y s.t. for each z  R : trg(z)  {y, src(y)}  trg(y)  {z, src(z)}, the
label of z is OUT or UNDEC.
R2. otherwise select a BLANK attack y such that |{x : the label of x is BLANK and (src(x) =
trg(y)  trg(x)  {y, src(y)})}| is maximal.
652

fiA LGORITHMS FOR A RGUMENTATION S EMANTICS

Algorithm 10: Enumerating all complete extensions of an AFRA (A, R).
1
2
3
4
5

6
7

8

9
10
11

12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29

Lab : (A  R)  {IN, OUT, MUST OUT,UNDEC, BLANK}; Lab  0;
/
foreach x  A  R do Lab  Lab  {(x, BLANK)};
E complete  2AR ; E complete  0;
/
call find-complete-extensions(Lab);
report E complete is the set of all complete extensions;
procedure find-complete-extensions(Lab) begin
if  v  R with Lab(v) = MUST OUT and  w  R : Lab(w)  {UNDEC, BLANK} with
y  R : trg(y)  {w, src(w)} Lab(y) = OUT then
foreach x  A with Lab(x) = BLANK s.t. z  R : trg(z) = x (Lab(z) = OUT ) do
Lab(x)  IN;
E complete  E complete  {{x  A  R | Lab(x) = IN)}};
while y  R : Lab(y) = BLANK do
select y  R with Lab(y) = BLANK such that
z  R : trg(z)  {y, src(y)} Lab(z)  {OUT, MUST OUT }, otherwise select y  R with
Lab(y) = BLANK such that z  R : Lab(z) = BLANK
|{x : src(x) = trg(y)  Lab(x) = OUT }|  |{x : src(x) = trg(z)  Lab(x) = OUT }|;
Lab  Lab;
Lab (y)  IN;
Lab (src(y))  IN;
Lab (trg(y))  OUT ;
if trg(y)  A then
foreach z  R : src(z) = trg(y) do
Lab (z)  OUT ;
foreach z  R : Lab (z)  {BLANK,UNDEC}  trg(z)  {y, src(y)} do
Lab (z)  MUST OUT ;
if   w  R : Lab (w) = BLANK  trg(w)  {z, src(z)} then
Lab(y)  UNDEC;
goto line 10;
call find-complete-extensions(Lab );
if z  R : Lab(z)  {BLANK,UNDEC}  trg(z)  {y, src(y)} then
Lab(y)  UNDEC;
else
Lab  Lab ;
end procedure

653

fiN OFAL , ATKINSON , & D UNNE

The aim of R1 is to maximise the gain of the applied pruning strategy. Meaning, the earlier
we label the selected argument by R1 with IN, the greater the saving will be in terms of the part
of the search tree pruned. Regarding R2, note that a goal state (i.e. conflict free set) is reached
if and only if for each x  A  R, the label of x is not BLANK. Thus, R2 tries to maximise the
number of OUT/UNDEC attacks/arguments, which implies minimising the number of BLANK
attacks/arguments.
4.5 Enumerating Semi Stable Extensions of any AF / AFRA
Algorithm 12 lists all semi stable extensions. Algorithm 12 is a variation of algorithm 8 such that it
basically constructs admissible sets. Algorithm 12 (line 31) records the set {w | the label of w is IN}
as an admissible set (that is a semi stable extension candidate) if and only if for each x  A  R, the
label of x is not BLANK nor MUST OUT. After constructing a set of admissible sets, algorithm 12
decides that an admissible set S is a semi stable extension if and only if S  {x | y  S : y defeats x}
is maximal, see lines 6-10.
4.6 Constructing the Ideal Extension of any AF / AFRA
Algorithm 13 builds the ideal extension. In particular, algorithm 13 finds admissible sets (lines 1028) in the same way algorithm 8 does. However, in enumerating admissible sets algorithm 13
(line 31) also builds the set
S = {x  A  R | there is y in an admissible set such that trg(y)  {x, src(x)}}
After building a set of admissible sets and having such S constructed, algorithm 13 decides
that an admissible set I is the ideal extension if and only if I  S = 0,
/ see lines 6-8. Recall that
the ideal extension is the maximal (w.r.t. ) admissible set that is contained in every preferred
extension. Satisfying the condition I  S = 0/ implies that the arguments/attacks of I are not defeated
by any admissible set (see the definition of S above), which means I is contained in every preferred
extension. To ensure such I is maximal, algorithm 13 collects admissible sets in descending order:
from larger sets to smaller ones. In consequence, the algorithm checks the collected admissible sets
with the condition I  S = 0/ starting from larger admissible sets to smaller ones.
4.7 Constructing the Grounded Extension of any AF / AFRA
Algorithm 14 builds the grounded extension. Algorithm 14 is actually a generalization of algorithm 7.

5. Practical Efficiency
All algorithms presented in this paper were implemented in C++ on a Fedora (release 13) based
machine with 4 processors (Intel core i5-750 2.67GHz) and 16GB of memory. As an evaluation criterion, we considered the average elapsed time measured in seconds; the elapsed time was obtained
by using the time command of Linux. We present experimental results for two purposes. First,
we explore the efficiency of the algorithms of section 3. For the second purpose, we confirm that
the generalized algorithms of section 4, which enumerate extensions by labeling attacks together
with arguments, perform as efficiently as the algorithms of section 3, which enumerate extensions
by labeling arguments alone.
654

fiA LGORITHMS FOR A RGUMENTATION S EMANTICS

Algorithm 11: Enumerating all stage extensions of an AFRA (A, R).
1
2
3
4
5
6
7
8
9
10
11
12

13
14
15

16
17
18
19
20
21
22
23
24
25
26
27
28
29
30

31
32

Lab : (A  R)  {IN, OUT,UNDEC, BLANK}; Lab  0;
/
foreach x  A  R do Lab  Lab  {(x, BLANK)};
E stage  {Lab1 | Lab1 : (A  R)  {IN, OUT,UNDEC, BLANK}};
E stage  0;
/
call find-conflict-free-sets(Lab);
foreach Lab1  E stage do
foreach Lab2  E stage do
if {x : Lab1 (x)  {IN, OUT }} ( {z : Lab2 (z)  {IN, OUT }} then
E stage  E stage \ {Lab1 };
continue to next iteration from line 6;
foreach Lab1  E stage do
report {x : Lab1 (x) = IN} is a stage extension ;
procedure find-conflict-free-sets(Lab) begin
while y  R : Lab(y) = BLANK do
select y  R with Lab(y) = BLANK s.t.
z  R : trg(z)  {y, src(y)}  trg(y)  {z, src(z)} (Lab(z)  {OUT,UNDEC}),
otherwise select y  R with Lab(y) = BLANK s.t.
z  R : Lab(z) = BLANK |{x : Lab(x) = BLANK  (src(x) = trg(y)  trg(x) 
{y, src(y))}}|  |{x : Lab(x) = BLANK  (src(x) = trg(z)  trg(x)  {z, src(z))}}|;
Lab  Lab;
Lab (y)  IN;
Lab (src(y))  IN;
Lab (trg(y))  OUT ;
if trg(y)  A then
foreach z  R : src(z) = trg(y) do
Lab (z)  OUT ;
foreach z  R : Lab (z) = BLANK  trg(z)  {y, src(y)} do
Lab (z)  UNDEC;
call find-conflict-free-sets(Lab );
if z  R : Lab(z) = BLANK  (trg(z)  {y, src(y)}  trg(y)  {z, src(z)}) then
Lab(y)  UNDEC;
else
Lab  Lab ;
foreach x  A with Lab(x) = BLANK s.t. z  R : trg(z) = x (Lab(z) = OUT ) do
Lab(x)  IN;
E stage  E stage  {Lab};
end procedure

655

fiN OFAL , ATKINSON , & D UNNE

Algorithm 12: Enumerating all semi stable extensions of an AFRA (A, R).
1
2
3
4
5
6
7
8
9
10
11
12

13
14
15

16
17
18
19
20
21
22
23
24
25
26
27
28
29
30

31
32

Lab : (A  R)  {IN, OUT, MUST OUT,UNDEC, BLANK}; Lab  0;
/
foreach x  A  R do Lab  Lab  {(x, BLANK)};
E semistable  {Lab1 | Lab1 : (A  R)  {IN, OUT, MUST OUT,UNDEC, BLANK}};
E semistable  0;
/
call find-admissible-sets(Lab);
foreach Lab1  E semistable do
foreach Lab2  E semistable do
if {x : Lab1 (x)  {IN, OUT }} ( {z : Lab2 (z)  {IN, OUT }} then
E semistable  E semistable \ {Lab1 };
continue to next iteration from line 6;
foreach Lab1  E semistable do
report {x : Lab1 (x) = IN} is a semi stable extension ;
procedure find-admissible-sets(Lab) begin
while y  R : Lab(y) = BLANK do
select y  R with Lab(y) = BLANK s.t.
z  R : trg(z)  {y, src(y)} Lab(z)  {OUT, MUST OUT }, otherwise select y  R with
Lab(y) = BLANK s.t. z  R : Lab(z) = BLANK |{x : src(x) = trg(y)  Lab(x) =
OUT }|  |{x : src(x) = trg(z)  Lab(x) = OUT }|;
Lab  Lab; Lab (y)  IN; Lab (src(y))  IN;
Lab (trg(y))  OUT ;
if trg(y)  A then
foreach z  R : src(z) = trg(y) do Lab (z)  OUT ;
foreach z  R : Lab(z)  {BLANK,UNDEC}  trg(z)  {y, src(y)} do
Lab (z)  MUST OUT ;
if   w  R : Lab (w) = BLANK  trg(w)  {z, src(z)} then
Lab(y)  UNDEC; goto line 14;
call find-admissible-sets(Lab );
if z  R : Lab(z)  {BLANK,UNDEC}  trg(z)  {y, src(y)} then
Lab(y)  UNDEC;
else
Lab  Lab ;
if  y  R : Lab(y) = MUST OUT then
foreach x  A with Lab(x) = BLANK s.t. z  R : trg(z) = x (Lab(z) = OUT ) do
Lab(x)  IN;
E semistable  E semistable  {Lab};
end procedure

656

fiA LGORITHMS FOR A RGUMENTATION S EMANTICS

Algorithm 13: Constructing the ideal extension of an AFRA (A, R).
1
2
3
4
5
6
7
8

9
10
11

12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30

31
32
33

Lab : (A  R)  {IN, OUT, MUST OUT,UNDEC, BLANK}; Lab  0;
/
foreach x  A  R do Lab  Lab  {(x, BLANK)};
E ideal : Z  2AR ; E ideal  0;
/
S  0;
/
call find-admissible-sets(Lab);
foreach i : 1 to |E ideal | do
/ S) then
if x  E ideal (i) (x 
report E ideal (i) is the ideal extension; exit;
procedure find-admissible-sets(Lab) begin
while y  R : Lab(y) = BLANK do
select y  R with Lab(y) = BLANK s.t.
z  R : trg(z)  {y, src(y)} Lab(z)  {OUT, MUST OUT }, otherwise select y  R with
Lab(y) = BLANK such that z  R : Lab(z) = BLANK
|{x : src(x) = trg(y)  Lab(x) = OUT }|  |{x : src(x) = trg(z)  Lab(x) = OUT }|;
Lab  Lab;
Lab (y)  IN;
Lab (src(y))  IN;
Lab (trg(y))  OUT ;
if trg(y)  A then
foreach z  R : src(z) = trg(y) do
Lab (z)  OUT ;
foreach z  R : Lab (z)  {BLANK,UNDEC}  trg(z)  {y, src(y)} do
Lab (z)  MUST OUT ;
if   w  R : Lab (w) = BLANK  trg(w)  {z, src(z)} then
Lab(y)  UNDEC;
goto line 10;
call find-admissible-sets(Lab );
if z  R : Lab(z)  {BLANK,UNDEC} and trg(z)  {y, src(y)} then
Lab(y)  UNDEC;
else
Lab  Lab ;
if  w  R : Lab(w) = MUST OUT then
foreach x  A with Lab(x) = BLANK s.t. z  R : trg(z) = x (Lab(z) = OUT ) do
Lab(x)  IN;
S  S  {x  A  R | Lab(x) = OUT };
E ideal  E ideal  {(|E ideal | + 1, {z | Lab(z) = IN})};
end procedure

657

fiN OFAL , ATKINSON , & D UNNE

Algorithm 14: Constructing the grounded extension of an AFRA (A, R).
1
2
3
4

5
6
7
8
9
10
11

12

Lab : (A  R)  {IN, OUT,UNDEC}; Lab  0;
/
foreach w  A  R do Lab  Lab  {(w,UNDEC)};
while x  R with Lab(x) = UNDEC s.t. y  R : trg(y)  {x, src(x)} (Lab(y) = OUT ) do
foreach x  R with Lab(x) = UNDEC s.t. y  R : trg(y)  {x, src(x)} (Lab(y) = OUT )
do
Lab(x)  IN;
Lab(src(x))  IN;
Lab(trg(x))  OUT ;
if trg(x)  A then
foreach z  R : trg(x) = src(z) do
Lab(z)  OUT ;
foreach x  A with Lab(x) = UNDEC s.t. z  R : trg(z) = x (Lab(z) = OUT ) do
Lab(x)  IN;
report the grounded extension is {w  A  R | Lab(w) = IN};

We compared the algorithms with dynPARTIX, which is an implemented system based on the
dynamic programming algorithm of Dvorak, Pichler, and Woltran (2012b). Given an AF, dynPARTIX basically computes a tree decomposition of the AF then the extensions are enumerated based
on the tree decomposition. The algorithm used in dynPARTIX is fixed-parameter tractable such that
its time complexity depends on the tree width of the given AF while it is linear in the size of the
AF (Dvorak et al., 2012b). Since dynPARTIX computes only extensions under preferred, stable and
complete semantics, figures 5, 6 & 7 depict respectively the efficiency of algorithms 1, 2 & 3 versus dynPARTIX. In summary, the figures show that these algorithms are likely to be more efficient
than dynPARTIX. In running the experiments that are represented by these figures, we set a time
limit of 120 seconds for every execution. Out of 1000 runs, dynPARTIX encountered 316 timeouts
in enumerating preferred extensions and 827 timeouts in enumerating complete extensions. These
timeouts are plotted within the figures as 120 seconds. This explains the steady behavior of dynPARTIX that can be noted, particularly, in figure 7. To see the performance of algorithms 1-7 in
contrast to the behavior of algorithms 8-14 we present figures 8-14 respectively. In profiling algorithms 1-7, we reported running times including the time needed to get the corresponding AF of
an AFRA. Note that such process (i.e. expressing an AFRA as an AF) runs in polynomial time: at
worst quadratic time. The figures 8-14 plot the running times for 1000 instances of AFRA randomly
generated with |A| = 5 and R = R1  R2 s.t. R1  A  A and R2  A  R1 . For these instances |R|
grows from 0 to 100 as the probability, which was used for setting attacks in the random generation, goes over {0.01,0.02,0.03,...,1}. Note that instances with |A| = 5 should not be considered
quite small. For example, a randomly generated AFRA with |A| = 5 and |R| = 49 has a corresponding AF with |A| = 54 and |R| = 190. Again, we emphasize that the aim of the experiments is to
compare the performance of algorithms 1-7 with the performance of algorithms 8-14. We do not
mean by the experiments to check the scalability of these algorithms, although an important issue
to be examined. Said that, it is not crucial in such evaluation to consider very large frameworks or
higher level of recursive attacks. Back to the results of the experiments, the only case that involved
exceeding the 120-second time limit occurred in enumerating semi stable extensions. Referring
658

fiA LGORITHMS FOR A RGUMENTATION S EMANTICS

Figure 5: Enumerating all preferred extensions of 1000 instances of AF with |A|=40, for each p 
{0.01, 0.02, 0.03, ..., 1} we tracked the average elapsed time for 10 instances generated
randomly with a probability p (i.e. the probability that x attacks y for any x, y  A).

to figure 12 we note that algorithm 5 (resp. 12) encountered 68 (resp. 66) timeouts. The bottom
line conclusion of these figures is: enumerating extensions of an AFRA by labeling attacks together
with arguments seems to be as efficient as enumerating the extensions of the corresponding AF via
labeling arguments alone.

6. Discussion and Conclusion
We started the paper by refining implemented algorithms1 for enumerating all extensions of Dungs
argumentation frameworks (AFs) under a number of argumentation semantics: preferred, stable,
complete, stage, semi stable, ideal and grounded. Algorithms for all these semantics, except stage
and grounded semantics, share a similar core structure: they all basically build admissible sets in
order to construct extensions. In the case of stage semantics, the algorithm actually constructs
conflict free sets for the purpose of listing stage extensions, and hence, the algorithm applies a
slightly different approach to expanding the search tree as we elaborated earlier. Concerning the
grounded semantics, the presented algorithm builds the grounded extension in polynomial time.
Furthermore, we explored the practical efficiency of these algorithms by profiling their performance
running on a wide spectrum of AF instances: from sparse instances to dense ones. In essence
these algorithms construct extensions by using a total function that maps arguments solely to a
set of labels reflecting different states as we illustrated in the paper. Then, we generalized these
algorithms by using a total mapping that labels attacks together with arguments. We implemented
the generalized algorithms to enumerate extensions of an AFRA, which is an AF-extended model that
1. C++ implementations can be found at http://sourceforge.net/projects/argtools/files/

659

fiN OFAL , ATKINSON , & D UNNE

Figure 6: Enumerating all stable extensions of 1000 instances of AF with |A|=60, for each p 
{0.01, 0.02, 0.03, ..., 1} we tracked the average elapsed time for 10 instances generated
randomly with a probability p.

Figure 7: Enumerating all complete extensions of 1000 instances of AF with |A|=30, for each p 
{0.01, 0.02, 0.03, ..., 1} we tracked the average elapsed time for 10 instances generated
randomly with a probability p.

660

fiA LGORITHMS FOR A RGUMENTATION S EMANTICS

Figure 8: Enumerating all preferred extensions of 1000 instances of AFRA, for each p 
{0.01, 0.02, 0.03, ..., 1} we tracked the average elapsed time for 10 instances generated
randomly with a probability p.

Figure 9: Enumerating all stable extensions of 1000 instances of AFRA, for each p 
{0.01, 0.02, 0.03, ..., 1} we tracked the average elapsed time for 10 instances generated
randomly with a probability p.

661

fiN OFAL , ATKINSON , & D UNNE

Figure 10: Enumerating all complete extensions of 1000 instances of AFRA, for each p 
{0.01, 0.02, 0.03, ..., 1} we tracked the average elapsed time for 10 instances generated
randomly with a probability p.

Figure 11: Listing all stage extensions of 1000 instances of AFRA, for each p 
{0.01, 0.02, 0.03, ..., 1} we tracked the average elapsed time for 10 instances generated randomly with a probability p.

662

fiA LGORITHMS FOR A RGUMENTATION S EMANTICS

Figure 12: Listing all semi stable extensions of 1000 instances of AFRA, for each p 
{0.01, 0.02, 0.03, ..., 1} we tracked the average elapsed time for 10 instances generated
randomly with a probability p.

Figure 13: Constructing the ideal extension of 1000 instances of AFRA, for each p 
{0.01, 0.02, 0.03, ..., 1} we tracked the average elapsed time for 10 instances generated
randomly with a probability p.

663

fiN OFAL , ATKINSON , & D UNNE

Figure 14: Constructing the grounded extension of 1000 instances of AFRA, for each p 
{0.01, 0.02, 0.03, ..., 1} we tracked the average elapsed time for 10 instances generated
randomly with a probability p.

allows attacks on attacks. In other words, we offered a unified approach to enumerating extensions
of any AF/AFRA, given the fact that an AF is a special case of AFRA (Baroni et al., 2011b). On
the other hand, we showed how labeling attacks alongside arguments can be potentially used as a
basis for enumerating extensions of related formalisms that allow attacks on attacks (e.g. Modgil,
2009b; Gabbay, 2009); nonetheless this is to be confirmed by further research. In fact, extensions
of an instance of such formalisms can be listed by working on the corresponding AF. However, we
demonstrated how to enumerate extensions of an AFRA by applying labeling directly on its native
form without compromising the running time efficiency. We omitted the soundness/completeness
proof of the presented algorithms since it follows immediately from the proof of the algorithm of
Nofal, Atkinson and Dunne (2014) for preferred semantics. The algorithms presented in this paper
do not handle frameworks with self-attacking arguments perfectly. However, the algorithms can
be easily modified such that the initial label for any self-attacking argument is UNDEC instead of
BLANK. For instance, the only change necessary to be made in algorithm 1 is to modify line 2 as
follows
foreach x  A do
if (x, x)  R then Lab  Lab  {(x,UNDEC)};
else Lab  Lab  {(x, BLANK)};
In general, the UNDEC label (instead of the BLANK label) should be the default label for any
argument/attack that can not be in any extension, like self-attacking arguments and their outgoing
attacks because simply such arguments present conflict by themselves. Recall that only BLANK
arguments/attacks are to be tried with the IN label.
For future work, we plan to study additional options for argument selection. Also, we intend to
evaluate further strategies for pruning the search space.
664

fiA LGORITHMS FOR A RGUMENTATION S EMANTICS

We discuss now related work. The existing algorithms of Doutre and Mengin (2001) and Modgil
and Caminada (2009) for listing preferred extensions can also be re-engineered towards enumerating
extensions under other argumentation semantics. For example, the papers of Caminada (2007, 2010)
presented algorithms for enumerating semi stable, respectively stage, extensions building up on the
algorithm of Modgil and Caminada (2009). However, the algorithms of the present paper are based
on the algorithm of Nofal, Atkinson and Dunne (2014) for enumerating preferred extensions, which
is likely to be more efficient than existing algorithms (Nofal et al., 2014). We give now some
examples of related work on labeling-based semantics. The theory of Caminada and Gabbay (2009)
defined argumentation semantics by using a total mapping  : A  {IN, OUT,UNDEC} such that,
broadly speaking, the IN labeled arguments correspond to an extension, say S, while the OUT
labeled arguments correspond to S+ and the UNDEC labeled arguments correspond to A \ (S  S+ ).
It is not hard to see the connection between our algorithms and the theory of Caminada and Gabbay
(2009). For example, in algorithm 1 we capture a preferred extension when all arguments are
mapped to one of those labels: IN, OUT and UNDEC. Listing other works that present labelingbased semantics, the paper of Modgil (2009a) defined labeling-based semantics for the extended
AF s of Modgil (2009b) while Villata, Boella, and van der Torre (2011) described argumentation
semantics in terms of attacks and arguments. Also, the work of Gabbay (2009) set argumentation
semantics for the AF-extended model of Barringer, Gabbay, and Woods (2005) that among other
features allow attacks on attacks. On the topic of extension computation in general, the study of
Li, Oren, and Norman (2012) examined approximation versus exact computations, whereas the
experiments of Baumann, Brewka, and Wong (2012), Liao, Lei, and Dai (2013) evaluated the effect
of splitting an AF on the computation of preferred extensions. The work of Dondio (2013) studied,
under the grounded semantics, how the acceptance status of an argument varies in all the subgraphs
of the given AF. Computational complexity of argumentation semantics are widely studied (see e.g.
Dimopoulos, Nebel, & Toni, 2000; Dunne, 2007, 2009; Ordyniak & Szeider, 2011). Another line of
research concerns encoding computational problems of AFs into other formalisms and then solving
them by using a respective solver (e.g. Besnard & Doutre, 2004; Nieves, Cortes, & Osorio, 2008;
Egly, Gaggl, & Woltran, 2010; Amgoud & Devred, 2011; Dvorak, Jarvisalo, Wallner, & Woltran,
2012a; Cerutti, Dunne, Giacomin, & Vallati, 2013; Charwat, Dvorak, Gaggl, Wallner, & Woltran,
2013), such approaches are called reduction based methods. We stress that the focus of this paper
was on algorithmic based implementations of argumentation semantics.

Acknowledgments
We thank the anonymous reviewers for the comments that improved the presentation of this work.

References
Amgoud, L., & Devred, C. (2011). Argumentation frameworks as constraint satisfaction problems.
In Benferhat, S., & Grant, J. (Eds.), SUM, Vol. 6929 of Lecture Notes in Computer Science,
pp. 110122. Springer.
Baroni, P., Caminada, M., & Giacomin, M. (2011a). An introduction to argumentation semantics.
The Knowledge Engineering Review, 26(4), 365410.
665

fiN OFAL , ATKINSON , & D UNNE

Baroni, P., Cerutti, F., Giacomin, M., & Guida, G. (2011b). Argumentation framework with recursive attacks. International Journal of Approximate Reasoning, 52(1), 1937.
Barringer, H., Gabbay, D., & Woods, J. (2005). Temporal dynamics of support and attack networks:
From argumentation to zoology. In Hutter, D., & Stephan, W. (Eds.), Mechanizing Mathematical Reasoning, Vol. 2605 of Lecture Notes in Computer Science, pp. 5998. Springer.
Baumann, R., Brewka, G., & Wong, R. (2012). Splitting argumentation frameworks: An empirical
evaluation. In Modgil, S., Oren, N., & Toni, F. (Eds.), First International Workshop on Theory
and Applications of Formal Argumentation 2011, Vol. 7132 of Lecture Notes in Computer
Science, pp. 1731. Springer.
Bench-Capon, T., & Dunne, P. (2007). Argumentation in artificial intelligence. Artificial Intelligence, 171, 619641.
Besnard, P., & Doutre, S. (2004). Checking the acceptability of a set of arguments. In Delgrande,
J., & Schaub, T. (Eds.), NMR, pp. 5964.
Besnard, P., & Hunter, A. (2008). Elements of Argumentation. MIT press.
Caminada, M. (2007). An algorithm for computing semi-stable semantics. In Mellouli, K. (Ed.),
ECSQARU, Vol. 4724 of Lecture Notes in Computer Science, pp. 222234. Springer.
Caminada, M. (2010). An algorithm for stage semantics. In Baroni, P., Cerutti, F., Giacomin, M., &
Simari, G. (Eds.), COMMA, Vol. 216 of Frontiers in Artificial Intelligence and Applications,
pp. 147158. IOS Press.
Caminada, M., Carnielli, W., & Dunne, P. (2012). Semi-stable semantics. J. Log. Comput., 22(5),
12071254.
Caminada, M., & Gabbay, D. (2009). A logical account of formal argumentation. Studia Logica,
93(2-3), 109145.
Cerutti, F., Dunne, P., Giacomin, M., & Vallati, M. (2013). A sat-based approach for computing
extensions in abstract argumentation. In TAFA, Second International Workshop on Theory
and Applications of Formal Argumentation.
Charwat, G., Dvorak, W., Gaggl, S., Wallner, J., & Woltran, S. (2013). Implementing abstract argumentation - a survey. Tech. rep. DBAI-TR-2013-82, Technische Universitat Wien, Database
and Artificial Intelligence Group.
Dimopoulos, Y., Magirou, V., & Papadimitriou, C. (1997). On kernels, defaults and even graphs.
Annals of Mathematics and Artificial Intelligence, 20, 112.
Dimopoulos, Y., Nebel, B., & Toni, F. (2000). Finding admissible and preferred arguments can
be very hard. In Cohn, A., Giunchiglia, F., & Selman, B. (Eds.), KR, pp. 5361. Morgan
Kaufmann.
Dondio, P. (2013). Computing the grounded semantics in all the subgraphs of an argumentation
framework: an empirical evaluation. In CLIMA, XIV Workshop on Computational Logic in
Multi-Agent Systems.
Doutre, S., & Mengin, J. (2001). Preferred extensions of argumentation frameworks: Query answering and computation. In Gore, R., Leitsch, A., & Nipkow, T. (Eds.), IJCAR, Vol. 2083 of
Lecture Notes in Computer Science, pp. 272288. Springer.
666

fiA LGORITHMS FOR A RGUMENTATION S EMANTICS

Dung, P. (1995). On the acceptability of arguments and its fundamental role in non monotonic
reasoning, logic programming and n-person games. Artificial Intelligence, 77(2), 321357.
Dung, P., Mancarella, P., & Toni, F. (2007). Computing ideal skeptical argumentation. Artificial
Intelligence, 171(10-15), 642674.
Dunne, P. (2007). Computational properties of argument systems satisfying graph-theoretic constraints. Artificial Intelligence, 171, 701729.
Dunne, P. (2009). The computational complexity of ideal semantics. Artificial Intelligence, 173(18),
1559  1591.
Dvorak, W., Jarvisalo, M., Wallner, J. P., & Woltran, S. (2012a). Complexity-sensitive decision
procedures for abstract argumentation. In Brewka, G., Eiter, T., & McIlraith, S. (Eds.), KR.
AAAI Press.
Dvorak, W., Pichler, R., & Woltran, S. (2012b). Towards fixed-parameter tractable algorithms for
abstract argumentation. Artificial Intelligence, 186, 137.
Egly, U., Gaggl, S., & Woltran, S. (2010). Answer-set programming encodings for argumentation
frameworks. Argument and Computation, 1(2), 147177.
Gabbay, D. (2009). Semantics for higher level attacks in extended argumentation frames part 1:
Overview. Studia Logica, 93(2-3), 357381.
Li, H., Oren, N., & Norman, T. (2012). Probabilistic argumentation frameworks. In Modgil, S.,
Oren, N., & Toni, F. (Eds.), First International Workshop on Theory and Applications of
Formal Argumentation 2011, Vol. 7132 of Lecture Notes in Computer Science, pp. 116.
Springer.
Liao, B., Lei, L., & Dai, J. (2013). Computing preferred labellings by exploiting sccs and most
sceptically rejected arguments. In TAFA, Second International Workshop on Theory and Applications of Formal Argumentation.
Modgil, S. (2009a). Labellings and games for extended argumentation frameworks. In Boutilier, C.
(Ed.), IJCAI, pp. 873878.
Modgil, S. (2009b). Reasoning about preferences in argumentation frameworks. Artificial Intelligence, 173, 901934.
Modgil, S., & Caminada, M. (2009). Proof theories and algorithms for abstract argumentation
frameworks. In Rahwan, I., & Simari, G. (Eds.), Argumentation in Artificial Intelligence, pp.
105129. Springer.
Modgil, S., Toni, F., Bex, F., Bratko, I., Chesnevar, C., Dvorak, W., Falappa, M., Fan, X., Gaggl, S.,
Garca, A., Gonzalez, M., Gordon, T., Leite, J., Mozina, M., Reed, C., Simari, G., Szeider, S.,
Torroni, P., & Woltran, S. (2013). The added value of argumentation. In Ossowski, S. (Ed.),
Agreement Technologies, Vol. 8 of Law, Governance and Technology Series, pp. 357403.
Springer Netherlands.
Nieves, J., Cortes, U., & Osorio, M. (2008). Preferred extensions as stable models. Theory and
Practice of Logic Programming, 8(4), 527543.
Nofal, S., Atkinson, K., & Dunne, P. (2014). Algorithms for decision problems in argument systems
under preferred semantics. Artif. Intell., 207, 2351.
667

fiN OFAL , ATKINSON , & D UNNE

Ordyniak, S., & Szeider, S. (2011). Augmenting tractable fragments of abstract argumentation. In
Walsh, T. (Ed.), Proceedings of the 22nd International Joint Conference on Artificial Intelligence IJCAI 2011, pp. 10331038.
Rahwan, I., & Simari, G. (2009). Argumentation in Artificial Intelligence. Springer.
Verheij, B. (1996). Two approaches to dialectical argumentation: admissible sets and argumentation
stages. In Proceedings of the Eighth Dutch Conference on AI, pp. 357368.
Villata, S., Boella, G., & van der Torre, L. (2011). Attack semantics for abstract argumentation. In
Walsh, T. (Ed.), Proceedings of the 22nd International Joint Conference on Artificial Intelligence IJCAI 2011, pp. 406413.

668

fi