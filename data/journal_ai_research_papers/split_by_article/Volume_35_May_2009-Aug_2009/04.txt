Journal of Artificial Intelligence Research 35 (2009) 813857

Submitted 03/09; published 08/09

Modularity Aspects of Disjunctive Stable Models
Tomi Janhunen
Emilia Oikarinen

Tomi.Janhunen@tkk.fi
Emilia.Oikarinen@tkk.fi

Helsinki University of Technology
Department of Information and Computer Science
P.O. Box 5400, FI-02015 TKK, Finland

Hans Tompits
Stefan Woltran

tompits@kr.tuwien.ac.at
woltran@dbai.tuwien.ac.at

Technische Universitt Wien
Institut fr Informationssysteme
Favoritenstrae 911, A-1040 Vienna, Austria

Abstract
Practically all programming languages allow the programmer to split a program into
several modules which brings along several advantages in software development. In this
paper, we are interested in the area of answer-set programming where fully declarative and
nonmonotonic languages are applied. In this context, obtaining a modular structure for
programs is by no means straightforward since the output of an entire program cannot in
general be composed from the output of its components. To better understand the effects
of disjunctive information on modularity we restrict the scope of analysis to the case of
disjunctive logic programs (DLPs) subject to stable-model semantics. We define the notion
of a DLP-function, where a well-defined input/output interface is provided, and establish
a novel module theorem which indicates the compositionality of stable-model semantics
for DLP-functions. The module theorem extends the well-known splitting-set theorem and
enables the decomposition of DLP-functions given their strongly connected components
based on positive dependencies induced by rules. In this setting, it is also possible to split
shared disjunctive rules among components using a generalized shifting technique. The
concept of modular equivalence is introduced for the mutual comparison of DLP-functions
using a generalization of a translation-based verification method.

1. Introduction
Practically all programming languages used in software development allow the programmer
to split a program into several modules which interact through well-dened input/output
interfaces. Given this, the entire program can be viewed as a composition of its component modules which are typically linked together in the respective run-time environment.
The expected benets of modular program development are manifold. First, it imposes a
good programming style to be followed by the programmer. A complex software system
is much easier to develop as a set of interacting components rather than a monolithic program. Second, a modular architecture allows for additional exibility as regards delegating
programming tasks amongst a team of programmers. In this setting, the goal of each programmer is to implement desired input/output behavior(s) in terms of concrete module(s)
which together implement the software system being developed. Third, modular program
c
2009
AI Access Foundation. All rights reserved.

fiJanhunen, Oikarinen, Tompits & Woltran

design can also be exploited in order to boost the execution of programs. Program optimization is also facilitated by structural information encompassed by module interfaces.
Answer-set programming (ASP) (Marek & Truszczyski, 1999; Niemel, 1999; Gelfond
& Leone, 2002) is a paradigm for declarative problem solving in which solutions of problems
are described in terms of rules subject to a nonmonotonic semantics based on stable models
(Gelfond & Lifschitz, 1988). In typical problem representations, a tight correspondence
between solutions and stable models is sought for, and default negation is fully exploited
in order to obtain concise encodings of relations involved in such problem descriptions.
Furthermore, recursive denitions enable, e.g., the representation of closures of relations
in a very natural way. Due to ecient implementations and emerging applications, the
paradigm has received increasing attention during the past two decades.1 In the meantime,
a number of extensionssuch as disjunctions, weight constraints, and aggregateshave been
proposed to the basic syntax of normal logic programs. In this paper, we concentrate on the
class of disjunctive logic programs (DLPs) which is appropriate for solving search problems
residing up to the second level of the polynomial-time hierarchy. The semantical account
of DLPs is based on the respective generalization of stable-model semantics (Gelfond &
Lifschitz, 1991).
In this paper, our goal is to investigate modularity in the context of DLPs and stablemodel semantics. Since stable models are dened only over complete programs, they do not
lend themselves to modular programming prima facie. Perhaps for this reason, the concept
of a module has not yet raised too much attention in the realm of answer-set programming.
Except for a few dedicated papers (Gaifman & Shapiro, 1989; Eiter, Gottlob, & Veith, 1997b;
Baral, Dzifcak, & Takahashi, 2006), modules mostly appeared as a by-product in studies
of formal properties like stratication, splitting, or, more lately, in work on equivalence
relations between programs (Lifschitz & Turner, 1994; Eiter, Gottlob, & Mannila, 1997a;
Eiter, Ianni, Lukasiewicz, Schindlauer, & Tompits, 2008). In a recent approach of Oikarinen
and Janhunen (2008a), the modular architecture put forth by Gaifman and Shapiro (1989)
is accommodated for the classes of normal and smodels programs. The main result is
a module theorem which links stable models associated with individual modules to those
of their composition. Such a result is signicant as it indicates that stable models are
compositional in very much the same sense as classical models are in propositional logic.
The only major restriction implied by the module theorem is that the denition of any set
of positively interdependent atoms must be given within the same module.
Besides the general benets of modular program development discussed above, we are
also looking for potential computational advantages of modularizing reasoning tasks in ASP.
In this context, the search for stable models is probably the most central reasoning task.
Results like the module theorem discussed above provide the basis for modularizing the
search task. Extra care, however, is required because the computation of stable models
for modules in separation is not necessarily ecient. More sophisticated methods, such as
identifying cones of influence in Boolean circuits (Junttila & Niemel, 2000), can be devised
to identify modules which are relevant for the search of stable modelsthe rest is only used
to expand a qualied stable model to one for the entire program. This strategy alleviates the
treatment of extremely large program instances and it is also amenable to query evaluation.
1. The 20th anniversary of stable-model semantics was celebrated at ICLP08 which was held in Udine,
Italy, in December 2008.

814

fiModularity Aspects of Disjunctive Stable Models

Unfortunately, contemporary disjunctive answer-set solvers, such as claspd (Drescher
et al., 2008), cmodels (Giunchiglia, Lierler, & Maratea, 2006), dlv (Leone et al., 2006), and
gnt (Janhunen, Niemel, Seipel, Simons, & You, 2006), exhibit little support for modular
reasoning although related techniques like strongly connected components are exploited internally. There are also other reasoning tasks that can be boosted with a modular approach.
For instance, the optimization of answer-set programs gives rise to the problem of verifying
whether dierent versions of programs have the same answer sets. As demonstrated by
Oikarinen and Janhunen (2009), such verication tasks may benet from modularization,
and, in particular, if approximation techniques based on modular equivalence are introduced.
Following this idea, the rst modular o-line optimizer of answer-set programs, called modopt, has recently been implemented (Janhunen, 2008b).
There are also other interesting applications of modules in sight: Gebser et al. (2008a)
propose an incremental technique for answer-set solving. The idea is to gradually extend a
program instance in terms of additional modules, e.g., when solving AI planning problems.
Moreover, theoretical results like the splitting-set theorem (Lifschitz & Turner, 1994) and the
module theorem can be directly exploited in correctness proofs. For instance, it is proved
by Oikarinen and Janhunen (2008b) that the models of a prioritized circumscription can
be captured with disjunctive stable models using a particular translation. A similar proof
strategy is adopted in Theorem 8.5 of this paper.
We anticipate that compositional semantics can also prove useful if one tries to boost the
search for stable models via parallelization, e.g., by computing stable models for modules in
parallel. However, in order to avoid excessive communication costs, extra caution is needed
when stable models computed in separation are linked together and potentially rejected.
One possibility is to identify mutually independent modules as the basis for distribution.
Besides this aspect, modularization may also lead to novel methods for the (non-parallelized)
computation of stable models, other than the traditional ones.
Structure and Preview of Results In this paper, we concentrate on the formal underpinnings of modular programming in the context of disjunctive logic programs under
stable-model semantics. We proceed as follows. Our rst goal is to generalize the theory
developed for normal programs and smodels programs (Oikarinen & Janhunen, 2008a) to
the case of disjunctive programs. To this end, we rst introduce the notion of a DLPfunction in Section 2. The term goes back to Gelfond and Gabaldon (1999) who introduced
LP-functions as (partial) denitions of new relations in terms of old, known ones. To enable such a functional view of disjunctive programs, they are endowed with a well-dened
input/output interface. The idea is to partition the signature of a program encapsulated in
this way into input atoms, output atoms, and hidden (or local ) atoms. These distinctions
provide the basis for the systematic composition of larger disjunctive logic programs out
of program modules. However, arbitrary combinations of program modules are not meaningful and, rst of all, we adopt syntactic restrictions introduced by Gaifman and Shapiro
(1989) from the context of negation/disjunction-free logic programs. The interplay of default negation and disjunctions brings along new factors which lead to a relaxation of the
restrictions in the sense that program modules are allowed to share rules. Then, having
the basic syntactic issues of DLP-functions laid out, we concentrate on their semantics in
Section 3. In this respect, we follow a strict model-theoretic approach and, in particular,
815

fiJanhunen, Oikarinen, Tompits & Woltran

address the role of input atoms when it comes to viewing DLP-functions as mathematical
functions. We proceed step by step and assign three dierent classes of models to each
DLP-function, viz. classical models, minimal models, and stable models. The last provides
an appropriate generalization of disjunctive stable models (Gelfond & Lifschitz, 1991) in the
presence of input atoms.
Our second objective is to establish the adequacy of the concept of a DLP-function in
view of a compositional semantics. This will be witnessed by the main result of the paper,
viz. the module theorem which shows how stable models of a DLP-function, , can be
alternatively obtained as unions of compatible stable models for the modules constituting
. The proof of the theorem is based on the notions of completion (Clark, 1978) and loop
formulas (Lin & Zhao, 2004; Lee & Lifschitz, 2003) which are rst lifted to the case of DLPfunctions in Section 4 as a preparatory step. The proof of the module theorem follows as the
main topic of Section 5. The result is non-trivial because the underlying semantics based on
stable models is inherently nonmonotonic. This feature was already recognized by Gaifman
and Shapiro (1989) in a much simpler setting of denite programsneither involving default
negation nor disjunctions. As observed by them, too, syntactic restrictions on program
composition are necessary in order to guarantee compositionality properties for the semantics
based on Herbrand models.2 In the current paper, we strive for analogous results but in
the case of programs permitting both default negation and disjunctions. It turns out that
strongly connected components of positive dependency graphs provide a key criterion when
it comes to conning program composition. The compositionality properties of disjunctive
programs under stable-model semantics have also arisen in the context of the so-called
splitting-set theorem (Lifschitz & Turner, 1994; Eiter et al., 1997a, 2008). In fact, the
module theorem established herein is a proper generalization of its predecessor (Oikarinen &
Janhunen, 2008a). We illustrate the potential of our modular architecture by the evaluation
of quantied Boolean formulas (QBFs), which serve as canonical representatives of the classes
of the polynomial-time hierarchy (PH). Due to basic complexity results established by Eiter
and Gottlob (1995), it is natural from our perspective to concentrate on the second level of
the PH in the case of disjunctive programs.
The third aim of this paper is to have a look at some particular applications of the module theorem in disjunctive logic programming. In Section 6, we take an opposite view to
the modular construction of DLP-functions and consider possibilities for their decomposition
even in the absence of any other structural information. It turns out that strongly connected
components can also be exploited in this respect but, in addition, the occurrences of hidden
atoms must be taken into account when splitting a DLP-function into its components. As
demonstrated in Section 7, our results open new prospects as regards unwinding disjunctions
using the principle of shifting (Gelfond, Przymusinska, Lifschitz, & Truszczyski, 1991; Dix,
Gottlob, & Marek, 1996; Eiter, Fink, Tompits, & Woltran, 2004). A proper generalization
of this principle that partially covers also programs involving head-cycles is formulated and
proved correct. Moreover, due to the modular nature of DLP-functions, it makes perfect
sense to compare them as modules. The notion of modular equivalence is introduced for this
purpose in Section 8. Interestingly, modular equivalence supports substitutions of equivalent
programs and it also lends itself for translation-based verification as put forth by Oikarinen
2. The main concern of Gaifman and Shapiro (1989) is modularity with respect to the logical consequences
of a definite program and hence the intersection of its Herbrand models.

816

fiModularity Aspects of Disjunctive Stable Models

and Janhunen (2004, 2009) in the related cases of ordinary equivalence and smodels programs. Section 9 contrasts our approach with related work. Finally, Section 10 provides a
brief summary of results and concludes this paper.

2. The Class of DLP-Functions
The topic of this section is the syntax of DLP-functions as well as syntactic restrictions
imposed on composition of DLP-functions. A disjunctive rule is an expression of the form
a1      an  b1 , . . . , bm , c1 , . . . , ck ,

(1)

where n, m, k  0, and a1 , . . . , an , b1 , . . . , bm , and c1 , . . . , ck are propositional atoms. Since
the order of atoms is considered insignicant, we write A  B, C as a shorthand for rules of
form (1), where A = {a1 , . . . , an }, B = {b1 , . . . , bm }, and C = {c1 , . . . , ck } are the respective
sets of atoms. The basic intuition behind a rule A  B, C is that if each atom in the
positive body B can be inferred and none of the atoms in the negative body C, then some
atom in the head A can be inferred. When both B and C are empty, we have a disjunctive
fact, written A . If A is empty, then we have a constraint, written   B, C.
A disjunctive logic program (DLP) is conventionally formed as a nite set of disjunctive
rules. Additionally, we want a distinguished input and output interface for each DLP. To this
end, we extend a denition originally proposed by Gaifman and Shapiro (1989) to the case
of disjunctive programs.3 It is natural that such an interface imposes certain restrictions on
the rules allowed in a module. Given a set R of disjunctive rules, we write At(R) for the
signature of R, i.e., the set of (ground) atoms eectively appearing in the rules of R.
Definition 2.1 A DLP-function, , is a quadruple hR, I, O, Hi, where I, O, and H are
pairwise distinct sets of input atoms, output atoms, and hidden atoms, respectively, and R
is a DLP such that for each rule A  B, C  R,
1. A  B  C  I  O  H, and
2. if A 6= , then A  (O  H) 6= .
A DLP-function  = hR, I, O, Hi is occasionally identied with R and, by a slight abuse
of notation, we write A  B, C   to denote A  B, C  R. By the rst condition
of Denition 2.1, the rules in a DLP-function  must obey the interface specication of ,
i.e., At(R)  I  O  H. As regards the sets of atoms I, O, and H involved in the module
interface, the atoms in I  O are considered to be visible and hence accessible to other
DLP-functions conjoined with ; either to produce input for  or to utilize the output of
. On the other hand, the hidden atoms in H are used to formalize some auxiliary concepts
of  which may not make sense in the context of other DLP-functions but may save space
substantially as demonstrated, e.g., by Janhunen and Oikarinen (2007, Example 4.5). The
second condition of Denition 2.1 is concerned with the set of atoms O  H defined by the
rules of R. The principle is that each non-empty disjunctive head must involve at least one
atom from O  H. This is just to ensure that a DLP-function  must not interfere with
3. Similar approaches within the area of ASP have previously been introduced by Gelfond and Gabaldon
(1999), Janhunen (2006), and Oikarinen and Janhunen (2008a).

817

fiJanhunen, Oikarinen, Tompits & Woltran

the denitions of its input atoms I in terms of rules A  B, C satisfying A  I. But
otherwise, the rules of  may be conditioned by input atoms.4 Given a set S of atoms, we
distinguish the set of rules that dene the atoms of S in R, i.e., the set of defining rules
Def R (S) = {A  B, C  R | A  S 6= }.

(2)

Our next objective is to specify the conditions on which the composition of DLP-functions
may take place. Roughly speaking, the idea is that larger DLP-functions can be formed in
a modular fashion using smaller DLP-functions as components. As observed already by
Gaifman and Shapiro (1989), syntactic restrictions on program composition are necessary in
order to guarantee compositionality properties for the semantics based on Herbrand models, even for the simple case of denite programs. Thus, program union as operator for
composition without further restrictions is not satisfactory with respect to compositionality.
We start by adapting the construction of Gaifman and Shapiro (1989) to the case of
disjunctive programs.
Definition 2.2 Two DLP-functions 1 = hR1 , I1 , O1 , H1 i and 2 = hR2 , I2 , O2 , H2 i respect the input/output interfaces of each other if and only if
1. (I1  O1  H1 )  H2 = ,
2. (I2  O2  H2 )  H1 = ,
3. O1  O2 = ,
4. Def R1 (O1 ) = Def R1 R2 (O1 ), and
5. Def R2 (O2 ) = Def R1 R2 (O2 ).
The rst three of the conditions above are due to Gaifman and Shapiro (1989) and
they imply that the sets O1 , H1 , O2 , and H1 are mutually pairwise distinct. Violations
with respect to the rst two conditions can be circumvented by a renaming strategy. For
instance, if an atom a  H1 appears in I2  O2  H2 , hence violating the second condition,
it is possible to replace all occurrences of a in 1 by a new atom a 6 I2  O2  H2 not
appearing in 2 . This removes the conict with respect to a and so forth.5
On the other hand, the last two conditions of Denition 2.2 concern the distribution
of rules involved in the definitions (2) of sets of atoms O1 and O2 , i.e., the sets of rules
Def R1 (O1 ) and Def R2 (O2 ), in R1 and R2 , respectively. As regards disjunctive rules, the
principle is that these sets of dening rules must remain intact when the union R1  R2
is formed which means that each module is supposed to have copies of all rules that form
the denition of its output atoms. In spite of this, two modules 1 and 2 subject to
the conditions of Denition 2.2 may eectively share disjunctive rules A  B, C with a
non-empty head A such that A  O1 6=  and A  O2 6= , as to be demonstrated next.
4. In particular, input atoms in the head A of a rule act very much like atoms in the negative body C.
5. An opposite view to program composition is considered in Section 6, where possibilities for decomposing a disjunctive program into smaller DLP-functions are studied. As a counterpart to renaming, a
revealing operator introduced in Definition 7.3 can be used for circumventing the first two conditions in
Definition 2.2.

818

fiModularity Aspects of Disjunctive Stable Models

Example 2.3 Consider the following two DLP-functions:6
{b}
a  b  c;
d  a, d
{a, c}

and

{a}
a  b  c;
e  a, e
{b, c}

More formally, we have 1 = hR1 , {a, c}, {b}, {d}i and 2 = hR2 , {b, c}, {a}, {e}i such that
R1  R2 = {a  b  c}. We show that 1 and 2 respect the input/output interfaces of
each other: First, both hidden atoms d and e occur in exactly one of the two programs and
thus the first two conditions in Definition 2.2 are satisfied. Second, we have disjoint output
atoms, viz. atom b in 1 and atom a in 2 . Finally, we have Def R1 ({b}) = Def R1 R2 ({b}) =
Def R2 ({a}) = Def R1 R2 ({a}) = {a  b  c}, which shows that also the final two conditions
in Definition 2.2 are satisfied, and as far as syntax is concerned, it makes sense to compose
a larger DLP-function which is obtained as a kind of a union of 1 and 2 ; see (4) below.
In contrast to disjunctive programs, shared rules do not arise in the context of normal
logic programs since only one head atom is allowed in each rule. The same can be stated
about smodels programs (Simons, Niemel, & Soininen, 2002) although such programs
may contain, among other rule types, choice rules of the form
{a1 , . . . , an }  B, C

(3)

with heads of cardinality greater than one. As observed by Oikarinen and Janhunen (2008a),
the heads of choice rules possessing multiple atoms can be freely split without aecting
their semantics. When splitting such rules into n dierent rules {ai }  B, C where
1  i  n, the only concern is the creation of n copies of the rule body B, C which could
reserve a quadratic space in the worst case. A new atom can be introduced to circumvent
this. But the nature of proper disjunctive rules (1), the subject of study in this paper, is
somewhat dierent. Unlike choice rules, disjunctive rules may interact through rule heads.
In Example 2.3, the denition of a depends on b and vice versa. However, given a choice rule
{a, b}  c for instance, the choices regarding a and b are independent of each other: if c is
true, both atoms can have any truth value. This is quite dierent from the interpretation of
ab  c which makes either a or b true given that c is true. To grasp the interaction of a and
b it is natural to have b as an input to the denition of a and, conversely, a as input to that of
b. As to be demonstrated in Section 7, shared rules can be rewritten so that input atoms are
removed from the rule head but as a drawback of the rewriting technique, the compactness
of the representation is partly lost. Therefore, we appreciate the extra exibility provided
by shared rules and interpret them to reect the true nature of disjunctive rules.
In general, DLP-functions are composed according to the following principle:

6. Here and henceforth we make use of a tabular format to represent DLP-functions: the output signature
is given on the top, the input signature at the bottom, and the rules are listed in between. Thus, the
declaration of the hidden signature remains implicit.

819

fiJanhunen, Oikarinen, Tompits & Woltran

O2
L

I1
H1

H2
I2

=

O1

I1  O2

O2

H2

I1

I1  I2

I2

H1

O1

O1  I2

Figure 1: Treatment of signatures by the composition operator .
Definition 2.4 (Composition) Let 1 = hR1 , I1 , O1 , H1 i and 2 = hR2 , I2 , O2 , H2 i be
two DLP-functions that respect the input/output interfaces of each other. Then, the composition of 1 and 2 is defined and determined by
1  2 = hR1  R2 , (I1 \ O2 )  (I2 \ O1 ), O1  O2 , H1  H2 i.

(4)

The treatment of atom types under Denitions 2.2 and 2.4 is summarized in Figure 1.
The two symmetric gures on the left-hand side illustrate the signatures of DLP-functions
1 = hR1 , I1 , O1 , H1 i and 2 = hR2 , I2 , O2 , H2 i subject to composition. Input signatures
and output signatures are emphasized by light gray and dark gray shadings, respectively.
The superposition of the two gures yields the diagram given on the right which represents
the resulting nine categories of atoms. Only three of them may involve shared atoms that
originate from both 1 and 2 . The interface conditions introduced above should be intuitive
to readers acquainted with the principles of object-oriented programming:
1. Although 1 and 2 must not share hidden atoms, they may share input atoms, i.e.,
I1  I2 6=  is allowed. Output atoms are treated dierently as O1  O2 =  is assumed.
2. An input atom of 1 becomes an output atom in 1  2 if it appears as an output
atom in 2 , i.e., 2 provides the input for 1 in this setting. The input atoms of 2
are treated in a symmetric fashion.
3. The hidden atoms of 1 and 2 retain their status in 1  2 .
Example 2.5 Recall Example 2.3 in which we showed that DLP-functions 1 and 2 respect
the input/output interfaces of each other. Thus, the composition of 1 and 2 is defined, and
1  2 is hR1  R2 , I, O, Hi where the set I of input atoms is ({a, c} \ {a})  ({b, c} \ {b}) =
{c}, the set O of output atoms is {a}  {b} = {a, b}, and the set H of hidden atoms is
{d}  {e} = {d, e}, i.e., using our tabular format to represent modules, we have
{b}
a  b  c;
d  a, d
{a, c}



{a}
a  b  c;
e  a, e
{b, c}

=

{a, b}
a  b  c;
d  a, d;
e  a, e
{c}

The definitions of a and b in 1  2 share the rule a  b  c. Thanks to the flexibility of
Definition 2.4, we are also able to split 1  2 into its components whenever appropriate.
820

fiModularity Aspects of Disjunctive Stable Models

Following previous approaches (Gelfond & Gabaldon, 1999; Oikarinen & Janhunen,
2008a), we dene the signature At() of a DLP-function  = hR, I, O, Hi as I  O  H.7
For notational convenience, we distinguish the visible and hidden parts of At() by setting
Atv () = I  O and Ath () = H = At() \ Atv (), respectively. Moreover, Ati () and
Ato () are used to refer to the sets of input and output atoms of , respectively. These
notations provide us a way to access the module interface when it is left implicit, e.g., to
neglect the internal structure of modules. Lastly, for any set S  At() of atoms, we denote the projections of S on Ati (), Ato (), Atv (), and Ath () by Si , So , Sv , and Sh ,
respectively.
In formal terms, a DLP-function  = hR, I, O, Hi is designed to provide a mapping
from subsets of I to a set of subsets of O  H in analogy to LP-functions formalized by
Gelfond and Gabaldon (1999). However, the exact denition of this mapping is deferred
until Section 3 where the semantics of DLP-functions will be anchored. In the sequel, the
(syntactic) class of DLP-functions is denoted by D. It is assumed, for the sake of simplicity,
that D spans over a xed (at most denumerable) signature At(D)8 so that At()  At(D)
holds for each DLP-function   D. Given DLP-functions 1 , 2 , and 3 that pairwise
respect the input/output interfaces of each other, it holds that
 1  2  D (closure),
 1   =   1 = 1 , for the empty DLP-function  = h, , , i (identity),
 1  2 = 2  1 (commutativity), and
 1  (2  3 ) = (1  2 )  3 (associativity).
The theory of modules put forth by Oikarinen and Janhunen (2008a) is based on a more
restrictive operator for program composition, viz. the join . The idea behind this operator
is to forbid positive dependencies between programs which is to be explicated next.
Technically speaking, we dene the positive dependency graph DG+ () of a DLP-function
 = hR, I, O, Hi using only positive dependenciesfollowing the denition by Ben-Eliyahu
and Dechter (1994). However, we exclude input atoms from the graph as their denitions
are external to  anyway. Thus, we let DG+ () = hO  H, 1 i where b 1 a holds for a
pair of atoms a, b  O  H if and only if there is a rule A  B, C  R such that a  A
and b  B. The reexive and transitive closure of 1 gives rise to the dependency relation
 over Ato ()  Ath (). A strongly connected component (SCC) S of the graph DG+ () is
a maximal set S  Ato ()  Ath () such that b  a for every pair a, b  S of atoms. Given
that 1  2 is dened, we say that 1 and 2 are mutually dependent i DG+ (1  2 )
has an SCC S such that S  Ato (1 ) 6=  and S  Ato (2 ) 6=  (Oikarinen & Janhunen,
2008a), i.e., the component S is shared by the DLP-functions 1 and 2 in this way. If 1
and 2 are not mutually dependent, we also call them mutually independent.
Definition 2.6 (Joins) Given two DLP-functions 1 and 2 , if the composition 1  2
is defined and 1 and 2 are mutually independent, then the join, 1  2 , of 1 and 2
is defined and it coincides with 1  2 .
7. Consequently, the length of  in symbols, denoted by kk, gives an upper bound for |At()| which is
important when one considers the computational cost of translating programs (Janhunen, 2006).
8. In practice, this set could be the set of all identifiers (names for propositions or similar objects).

821

fiJanhunen, Oikarinen, Tompits & Woltran

In case that 1  2 is dened, and thus 1 and 2 are mutually independent, exactly
one of the following conditions holds for each SCC S of DG+ (1  2 ):
S  Ato (1 )  Ath (1 ); or

(5)

S  Ato (2 )  Ath (2 ).

(6)

Example 2.7 Recall the programs 1 and 2 from Example 2.5 for which we obtain the
positive dependency graph DG+ (1  2 ) = h{a, b, d, e}, {ha, di, ha, ei}i. Hence, the SCCs of
the graph are simply singletons {a}, {b}, {d}, and {e}. Together with the observation that
Ato (1 ) and Ato (2 ) are disjoint, we derive that 1 and 2 are not mutually dependent.
Thus, the join 1  2 = 1  2 is defined since the composition 1  2 is defined on the
basis of the analysis performed in Example 2.5.
Example 2.8 As an example of two DLP-functions which have their composition defined
yet which are ineligible for a join, consider the following situation:
{b}
a  b  c;
b  a, c
{a, c}



{a}
a  b  c;
a  b, c
{b, c}

=

{a, b}
a  b  c;
a  b, c;
b  a, c
{c}

Here, the result of composition involves an SCC S = {a, b} in the respective positive dependency graph, which has a non-empty intersection with the output signatures of the programs
subject to composition. Hence, the respective join of the modules in question is not defined.

3. Model Theory and Stable-Model Semantics
Having the syntax of DLP-functions dened, we now turn to their semantics. We proceed
in three steps and introduce, correspondingly, three kinds of models, viz. classical models,
minimal models, and, nally, stable models for each DLP-function. The last provide the
intended semantics for a DLP-function whereas the rst two serve as auxiliary concepts.
As usual, an interpretation for a DLP-function  is dened as an arbitrary subset of
At(). Given a particular interpretation M  At(), an atom a  At() is true under M ,
denoted M |= a, i a  M , otherwise a is false under M , denoted M 6|= a. For a negative
literal a, we dene M |= a i M 6|= a. A set L of literals is satisfied by M , denotedWby
M |= L, i M |= l, for everyWliteral l  L. We also dene the disjunctive interpretation L
of a set L of literals: M |= L i M |= l for some literal l  L.
To begin with, we cover DLP-functions with a pure classical semantics, which treats
disjunctive rules as classical implications. It should be emphasized that classical models of
a DLP-function  are specic interpretations as dened above and hence subsets of At().
Definition 3.1 An interpretation M  At() is a (classical) model of a DLP-function
 = hR, I, O, Hi, denoted M |= , iff M |= R, i.e., for every rule A  B, C  R,
W
M |= B  C implies M |= A.
822

fiModularity Aspects of Disjunctive Stable Models

The set of all classical models of  is denoted by CM().
Classical models provide an appropriate level of abstraction to address the role of input
atoms in DLP-functions. Given a DLP-function  and an interpretation M  At(), the
projection Mi can be viewed as the actual input for  which may (or may not) produce the
respective output Mo , depending on the semantics assigned to . The treatment of input
atoms in the sequel will be based on partial evaluation: the idea is to pre-interpret input
atoms appearing in  with respect to Mi .
Definition 3.2 For a DLP-function  = hR, I, O, Hi and an actual input Mi  I for ,
the instantiation of  with respect to Mi , denoted by /Mi , is the quadruple hR , , O, Hi
where R contains a reduced rule
(A \ I)  (B \ I), (C \ I)

(7)

for each rule A  B, C  R such that Mi |= Ai  Bi  Ci .
Example 3.3 Consider the following DLP-function :
{a, b}
a  b  c;
a  c, b;
b  c, a
{c}
For the actual input {c}  Ati (), the reduct /{c} is the DLP-function
h{a  b; b  a}, , {a, b}, i.
On the other hand, with the actual input   Ati (), we obtain the reduct
/ = h{a  b}, , {a, b}, i.
The rules of form (7) are free of input atoms which indicates that the reduct /Mi is a
DLP-function without input. Atoms in Ato ()  Ath () are not aected in /Mi .
Proposition 3.4 Let  be a DLP-function and M  At() an interpretation that defines
an actual input Mi  Ati () for . For all interpretations N  At() such that Ni = Mi ,
N |=   No  Nh |= /Mi .
Proof. Consider any N  At() such that Ni = Mi .
(=) Suppose that N |= . Assume that No  Nh does not satisfy (7) for some rule
A  B, C in . It follows that Mi |= Ai  Bi  Ci , and therefore Ni |= Ai  Bi  Ci .
Thus, N 6|= A  B, C, a contradiction. It follows that No  Nh |= /Mi .
(=) Let No  Nh |=W/Mi hold. Assuming N 6|= A  B, C for a rule of  implies
N |= B  C and N 6|= A. It follows that Ni |= Ai  Bi  Ci and the corresponding
rule (7) is included in /Mi as Ni = Mi . But this rule is not satised by No  Nh since
823

fiJanhunen, Oikarinen, Tompits & Woltran

W
N 6|= A  B, C implies No  Nh |= (B \ I)  (C \ I) and No  Nh 6|= (A \ I), a
contradiction. Hence, we have that N |= .

Thus, the input reduction, as given in Denition 3.2, is fully compatible with classical
semantics and we can characterize the semantic operator CM also in terms of the equation
[
{Mi  N | N  CM(/Mi )}.
(8)
CM() =
Mi Ati ()

Recall that the models of any DLP-function  are subsets of At(). Hence, we have here
that each N  CM(/Mi ) is a subset of At(/Mi ) and thus Mi N =  for each Mi  Ati ()
since no atom from Ati () occurs in /Mi by denition.
Handling input atoms is slightly more complicated in the case of minimal models but
the primitives of parallel circumscription (Lifschitz, 1985; McCarthy, 1986) provide us with
a straightforward way to address them. The rough idea is to keep the interpretation of input
atoms fixed while minimizing (i.e., falsifying) others as far as possible.
Definition 3.5 Let  = hR, I, O, Hi be a DLP-function. A model M  At() of  is
I-minimal iff there is no model N of  such that Ni = Mi and N  M .
In the sequel, the set of I-minimal models of  = hR, I, O, Hi is denoted by MM() and
we treat input atoms by stipulating I-minimality of models. Using this idea, Proposition 3.4
lifts for minimal models given the fact that Ati (/Mi ) = .
Proposition 3.6 Let  be a DLP-function and M  At() an interpretation that defines
an actual input Mi  Ati () for . For all interpretations N  At() such that Ni = Mi ,
N  MM()  No  Nh  MM(/Mi ).
Proof. Consider any N  At() such that Ni = Mi .
(=) Let N  MM(). It follows by Proposition 3.4 that No  Nh |= /Mi . Assume
that No  Nh 
/ MM(/Mi ). Recall that Ati (/Mi ) = . Thus, there is an interpretation
S  No  Nh such that S |= /Mi . It follows by Proposition 3.4 that N  |=  for an
interpretation N  = Mi  S. But then Ni = Ni and N   N jointly contradict N  MM().
(=) Suppose that No  Nh  MM(/Mi ). So, No  Nh |= /Mi , and N |=  follows
by Proposition 3.4. Let us then assume that N 6 MM(), i.e., there is a model N  |= 
with Ni = Ni and N   N . Thus, we have (No  Nh )  (No  Nh ), and since Ni = Ni = Mi
it follows that No  Nh |= /Mi by Proposition 3.4. Then, however, No  Nh |= /Mi is in
contradiction with No  Nh  MM(/Mi ).

The set MM() of Ati ()-minimal models is sucient to determine the semantics of
a positive DLP-function , i.e., whose rules are of the form A  B. Recall that for such
rules A \ Ati () 6=  holds whenever A 6= . In order to cover arbitrary DLP-functions, we
interpret negative body literals in the way proposed by Gelfond and Lifschitz (1991).
Definition 3.7 Given a DLP-function  = hR, I, O, Hi and an interpretation M  At(),
the reduct of  with respect to M is the positive DLP-function M = hRM , I, O, Hi where
RM = {A  B | A  B, C  R and M |= C}.
824

(9)

fiModularity Aspects of Disjunctive Stable Models

Definition 3.8 An interpretation M  At() is a stable model of a DLP-function  with
an input signature Ati () iff M  MM(M ), i.e., M is an Ati ()-minimal model of M .
Hidden atoms play no special role in Denition 3.8. In contrast to this, they will aect
possibilities for program decomposition, as to be presented in Section 6, and their status
will be nally explicated when the notion of modular equivalence is introduced in Section 8.
Denition 3.8 covers also the case of an ordinary disjunctive logic program, which is simply
a DLP-function  = hR, , O, i: a model M  At() = O of  is stable i M is a
minimal model of RM . The denition of stable models gives rise to a semantic operator
At(D)
SM : D  22
for DLP-functions:
SM() = {M  At() | M  MM(M )}.

(10)

Proposition 3.6 provides us a way to dismiss Ati ()-minimality in the denition of stable
models if desirable. Given a stable model M of , the projection N = Mo  Mh is a minimal
model of (/Mi )N and hence a stable model of /Mi . In other words, we have
(/Mi )M = (/Mi )Mo Mh = M /Mi .
Thus, we can derive the following result:
Corollary 3.9 For any DLP-function , we have
SM() = {M  At() | Mo  Mh  SM(/Mi )}.
Example 3.10 Recall the DLP-function  from Example 3.3, having no hidden atoms,
given as follows:
{a, b}
a  b  c;
a  c, b;
b  c, a
{c}
 has four stable models in total: M1 = {a}, M2 = {b}, M3 = {a, c}, and M4 = {b, c},
which are the {c}-minimal models of the respective reducts of :
M1
M2
M3
M4

= h{a  b ; a  c}, {c}, {a, b}, i,
= h{a  b ; b  c}, {c}, {a, b}, i,
= h{a  c}, {c}, {a, b}, i, and
= h{b  c}, {c}, {a, b}, i.

Now, it is easy to verify that each Mj is a {c}-minimal model of the reduct Mj .
For illustrating Corollary 3.9, recall the reducts
/{c} = h{a  b; b  a}, , {a, b}, i and
/ = h{a  b}, , {a, b}, i.
Then, we have that SM(/{c}) = {{a}, {b}} and SM(/) = {{a}, {b}}.
825

fiJanhunen, Oikarinen, Tompits & Woltran

An immediate observation is that we loose the general antichain property of stable
models when input signatures are introduced. For instance, we have M1  M3 and M2  M4
in Example 3.10. However, since the interpretation of input atoms is xed by the semantics,
we perceive antichains locally, i.e., the set {N  SM() | Ni = Mi } of stable models forms an
antichain, for each input Mi  Ati (). In Example 3.10, the sets of stable models associated
with actual inputs  and {c} are {M1 , M2 } and {M3 , M4 }, respectively.

4. Characterizations using Classical Logic
It is well known how the set of stable models of an ordinary disjunctive logic program, i.e., a
DLP-function  of the form hR, , O, i, can be characterized via classical propositional logic,
using the concepts of completion (Clark, 1978) and loop formulas (Lin & Zhao, 2004; Lee &
Lifschitz, 2003). In this section, we generalize these concepts to arbitrary DLP-functions. To
this end, the main concern is the role of input atoms and how to incorporate them into these
concepts. Furthermore, we extend the tightness property of programs (Erdem & Lifschitz,
2003) to DLP-functions by introducing the notion of I-tightness in Section 4.2.
4.1 Program Completion and Loop Formulas
Given a DLP-function , a loop of  is any non-empty subset of a strongly connected
component of the positive dependency graph DG+ (). Recall that DG+ () has only the
atoms of Ato ()  Ath () as its nodes. In particular, each singleton {a} with a  Ato () 
Ath () is thus a loop.
Example 4.1 Consider DLP-functions 1 and 2 defined as follows:

1 :

{b, c}
a  c  b;
ba
{a}

2 :

{a, b}
a  c  b;
ba
{c}

Here, 1 has only singleton loops {b} and {c}. In particular, {a, b} is not a loop as it
contains the input atom a. On the other hand, for 2 we have loops {a}, {b}, and {a, b}.
In what follows,
we use,Wfor a set S of propositional
W formulas (or atoms), S to denote
V
a conjunction sS s and S as a shorthand for sS s. Moreover, if appearing within a
formula, a set S is implicitly understood as a conjunction of its elements. For a DLP-function
 and an atom a  Ato ()  Ath (), we dene the set of supporting formulas
SuppF(a, ) = {B  C  (A \ {a}) | A  B, C   and a  A}
and for a loop L  Ato ()  Ath () of , the set of externally supporting formulas
ESuppF(L, ) = {B  C  (A \ L) | A  B, C  , A  L 6= , and B  L = }.
Clarks completion procedure and (conjunctive) loop formulas can be generalized for DLPfunctions in the following way:
Definition 4.2 For a DLP-function , the completion of  is the set of formulas
826

fiModularity Aspects of Disjunctive Stable Models

W
Comp() = {B  C
W  A | A  B, C  } 
{a  SuppF(a, ) | a  Ato ()  Ath ()}

and the set of loop formulas for  is
W
LF() = {L  ESuppF(L, ) | L  Ato ()  Ath () is a loop of }.9

Observe that in the case of Ati () = , i.e., Ato ()  Ath () = At(), the completion
Comp() reduces to the denition provided by Lee and Lifschitz (2003) and the same holds
for the set LF() of loop formulas. Generally speaking, the propositional theories Comp()
and LF() characterize the set SM() of stable models in the following sense:

Theorem 4.3 For a DLP-function  and an interpretation M  At(),
M  SM() if and only if M |= Comp() and M |= LF().
Proof. We rst relate the sets SuppF(a, ) and ESuppF(L, ), as introduced above for
a DLP-function , with the respective sets of complementary rules
SuppCR(a, ) = {A \ {a}  B, C | A  B, C   and a  A} and
ESuppCR(L, ) = {A \ L  B, C | A  B, C  , A  L 6= , and B  L = }.
First, it is straightforward that, for each interpretation M  At(), we have M |= Comp()
i jointly M |=  and for each a  M  (Ato ()  Ath ()), M 6|= SuppCR(a, ). Quite
similarly, it holds that M |= LF() i, for each loop L  M  (Ato ()  Ath ()) of ,
M 6|= ESuppCR(L, ). On the other hand, by viewing SuppCR(a, ) and ESuppCR(L, )
as DLP-functions having the same signatures as , we can apply Proposition 3.4 in order
to evaluate input atoms. Thus, we obtain the following relationships for each DLP-function
, interpretation M  At(), atom a  Ato ()  Ath (), and loop L  Ato ()  Ath ()
of :
1. M |=  i Mo  Mh |= /Mi ,
2. M |= SuppCR(a, ) i Mo  Mh |= SuppCR(a, /Mi ), and
3. M |= ESuppCR(L, ) i Mo  Mh |= ESuppCR(L, /Mi ).
Finally, recall that for each interpretation M  At(), we have Ato () = Ato (/Mi ) and
Ath () = Ath (/Mi ). Inspecting the denition of Comp() and LF() again, we can
conclude for each interpretation M  At() that M |= Comp()  LF() i Mo  Mh |=
Comp(/Mi )  LF(/Mi ). In turn, we know that Mo  Mh |= Comp(/Mi )  LF(/Mi ) i
Mo  Mh is a stable model of the program /Mi by the results of Lee and Lifschitz (2003);
recall that /Mi is an ordinary disjunctive program without any input atoms. Finally, we
have SM() = {M  At() | Mo  Mh  SM(/Mi )} by Corollary 3.9. This equality shows
the claim.

Example 4.4 Let us demonstrate the functioning of program completion and loop formulas on the DLP-functions from Example 4.1, i.e., on 1 = hR, {a}, {b, c}, i and 2 =
hR, {c}, {a, b}, i, where R = {a  c  b; b  a}. The completions are
9. Although it may seem that the case of a singleton loop L = {a} is somewhat redundant, this is not so,
since some tautological rules such as a  b  a make a difference.

827

fiJanhunen, Oikarinen, Tompits & Woltran

Comp(1 ) = {b  a  c, a  b}  {b  a, c  b  a} and
Comp(2 ) = {b  a  c, a  b}  {b  a, a  b  c}.
Furthermore, the sets of loop formulas are
W
W
LF(1 ) = {b  ESuppF({b}, 1 ), c  ESuppF({c}, 1 )}
= {b  a,
W c  b  a} and
W
LF(2 ) = {b  ESuppF({b},
2 ), a  ESuppF({a}, 2 ),
W
a  b  ESuppF({a, b}, 2 )}
= {b  a, a  b  c, a  b  }.
In the last formula, the W
occurrence of  is in view of ESuppF({a, b}, 2 ) = , which
yields an empty disjunction ESuppF({a, b}, 2 ) =  as usual.
Computing the classical models of Comp(1 )  LF(1 ) = Comp(1 ) yields two such
models, M1 = {a, b} and M2 = . One can check that these are indeed the stable models of
1 by recalling that Ati (1 ) = {a}. Thus, M1 relates to an actual input M1  Ati (1 ) = {a}
whereas M2 is based on M2  Ati (1 ) = . On the other hand, the classical models of
Comp(2 )  LF(2 ) are M1 = {c} and M2 = , which again relate to the two possible
inputs over Ati (2 ) = {c}. Finally, we note that {a, b} is also a model of Comp(2 ) but
ruled out by LF(2 ).
4.2 Tight DLP-functions
We now extend the well-known concept of tightness (Erdem & Lifschitz, 2003) to DLPfunctions. This is of interest since we can exploit the fact that the positive dependency
graph DG+ () is reduced modulo input atoms. In other words, since the dependency graph
DG+ () has only the atoms of Ato ()  Ath () as its nodes, tightness for DLP-functions
can be dened with respect to the input signature.
In the beginning of Section 4, loops were dened as arbitrary non-empty subsets of
strongly connected components in DG+ (). Thus, if DG+ () is acyclic then  has only
singleton loops. However, the converse is not necessarily true, since, for a program  having
only singleton loops, DG+ () may have edges ha, ai, i.e., cycles of length one.
Definition 4.5 A DLP-function  is Ati ()-tight (or tight, for short), if the positive dependency graph DG+ () is acyclic.
Example 4.6 Recall DLP-functions 1 = hR, {a}, {b, c}, i and 2 = hR, {c}, {a, b}, i
based on R = {a  c  b; b  a} from Example 4.1. Here, 1 is {a}-tight since the potential
non-singleton loop {a, b} contains the input atom a. On the other hand, 2 is not {c}-tight.
It is worth mentioning that the ordinary variant of 1 , viz. DLP-function hR, , {a, b, c}, i,
is not -tightin particular, since R is not tight in the usual sense.
We note that the last observation, viz. that a DLP-function hR, I, O, Hi may be I-tight
although R is not a tight program, relies on the use of disjunctions in the program. In fact,
for DLP-functions hR, I, O, Hi, where R is a set of normal rules of the form a  B, C, we
have that a DLP-function  = hR, I, O, Hi is I-tight i R is tight. To verify this, note that
the second item of Denition 2.1 implies that the head atom of a normal rule a  B, C
must not appear in I, and thus no loop of  may involve atoms from I.
828

fiModularity Aspects of Disjunctive Stable Models

We now show that the notion of tightness introduced in Denition 4.5 enables us to
characterize the stable models of a DLP-function by the classical models of its completion.
Since each ordinary program can be represented as a DLP-function, we thus properly
generalize the well-known completion semantics (Clark, 1978). The following lemma is
already sucient for this result in view of Denition 4.2 and Theorem 4.3.
Lemma 4.7 For any tight DLP-function , LF()  Comp().
W
Proof. Recall that for each a  Ato ()  Ath (), a  SuppF(a, ) is contained in
Comp(). Moreover,Wsince  is tight,  has only singleton loops, and thus LF() contains
only formulas a  ESuppF({a}, ), again for each a  Ato ()  Ath (). It remains
to show that, for each atom a, SuppF(a, ) is equivalent to ESuppF({a}, ) whenever the
positive dependency graph DG+ () is acyclic. We repeat the denition of SuppF(a, ) and
give the denition for ESuppF(L, ), simplied for the case L = {a}:
SuppF(a, ) = {B  C  (A \ {a}) | A  B, C   and a  A};
ESuppF({a}, ) = {B  C  (A \ {a}) | A  B, C  , a  A, and B  {a} = }.
Now it is easy to see that for an acyclic dependency graph DG+ (), a  A implies B{a} = 
for every rule A  B, C  . Thus, we conclude that SuppF(a, ) = ESuppF({a}, )
holds for each a  Ato ()  Ath (). Hence, the claim follows.

Example 4.8 Recalling the DLP-function 1 = hR, {a}, {b, c}, i from Example 4.4 with
R = {a  c  b; b  a}, we obtain
Comp(1 ) = {b  a
W c, a  b}  {b  a, cW b  a} and
LF(1 ) = {b  ESuppF({b}, 1 ), c  ESuppF({c}, 1 )}
= {b  a, c  b  a}.
Now, 1 is tight and we observe that LF(1 )  Comp(1 ) as expected.
The observations presented so far lead us to the following result:
Theorem 4.9 For a tight DLP-function  and an interpretation M  At(),
M  SM() if and only if M |= Comp().
In particular, this result is compatible with an existing characterization of stable models
in the case of Ati () = , i.e., if Ato ()  Ath () = At(). Then, the notion of Ati ()tightness coincides with ordinary tightness, and the denition of the completion Comp()
reduces to the one provided by Lee and Lifschitz (2003).

5. Compositional Semantics
In what follows, our objective is to establish the main result of this paper, i.e., to show
that stable-model semantics, as given by Denition 3.8, is fully compositional when larger
DLP-functions  are formed as joins 1  . . .  n of DLP-functions. More precisely, the
interconnection of SM() and SM(1 ), . . . , SM(n ) is explicated in Section 5.1. In analogy
829

fiJanhunen, Oikarinen, Tompits & Woltran

to Section 3, we follow a quite rigorous approach and consider such a relationship for classical
models rst, then for minimal models, and eventually cover the case of stable models which
comprises our module theorem. Then, in Section 5.2, we use quantied Boolean formulas
from the second level of polynomial hierarchy and their modular representation in terms
of DLP-functions to illustrate the module theorem. Finally, we devote Section 5.3 to a
comparison with the splitting set theorem proven by Lifschitz and Turner (1994).
5.1 Module Theorem
To begin with, we formalize the criteria for combining interpretations as well as models.
Definition 5.1 Given two DLP-functions 1 and 2 , interpretations M1  At(1 ) and
M2  At(2 ) are mutually compatible (with respect to 1 and 2 ), or just compatible, if
M1  Atv (2 ) = M2  Atv (1 ).

(11)

According to (11), any two compatible interpretations M1 and M2 for 1 and 2 , respectively, agree about the truth values of their joint visible atoms in Atv (1 )  Atv (2 ). A
quick inspection of Figure 1 reveals the three cases that may arise when the join  = 1 2
is dened and joint output atoms for 1 and 2 are thereafter disallowed: There may exist
1. joint input atoms in Ati () = Ati (1 )  Ati (2 ), or
2. atoms in Ato (1 )  Ati (2 ) that are output atoms in 1 and input atoms in 2 , or
3. by symmetry, atoms in Ati (1 )  Ato (2 ).
Recall that according to Denition 2.6, atoms in the last two categories end up in Ato ()
when  = 1  2 is formed. Atoms in Atv (1 )  Atv (2 ) provide the basis to combine
compatible interpretations for 1 and 2 .
Definition 5.2 Let 1 and 2 be two DLP-functions such that  = 1  2 is defined.
Given any sets of interpretations A1  2At(1 ) and A2  2At(2 ) , the natural join of A1 and
A2 with respect to Atv (1 )  Atv (2 ), denoted by A1 
 A2 , is the set of interpretations
A1 
 A2 = {M1  M2 | M1  A1 , M2  A2 , and M1 and M2 are compatible}.

(12)

Our rst modularity result is formulated for DLP-functions under classical semantics as
dened in Section 3. The combination of classical models is understood as in (12).
Proposition 5.3 For all positive DLP-functions 1 and 2 such that 1  2 is defined,
CM(1  2 ) = CM(1 ) 
 CM(2 ).

(13)

Proof. Consider an interpretation M  At(1 2 ) and its projections M1 = M At(1 )
and M2 = M  At(2 ) with respect to 1 = hR1 , I1 , O1 , H1 i and 2 = hR2 , I2 , O2 , H2 i. It
follows that M1 and M2 are compatible and M = M1  M2 so that
830

fiModularity Aspects of Disjunctive Stable Models

M  CM(1  2 ) 




M |= R1  R2
M1 |= R1 and M2 |= R2
M1  CM(1 ) and M2  CM(2 )
M  CM(1 ) 
 CM(2 ).



Generalizing Proposition 5.3 for stable models of DLP-functions is much more elaborate.
We will cover the case of positive DLP-functions under minimal models rst. The proof of
Theorem 5.5 exploits program completion, loop formulas, as well as the characterization of
stable and minimal models from Section 4 as follows:
Lemma 5.4 For all DLP-functions 1 and 2 such that 1  2 is defined, the following
conditions hold:
Comp(1  2 ) = Comp(1 )  Comp(2 );
LF(1  2 ) = LF(1 )  LF(2 ).

(14)
(15)

Proof. We begin the proof by analyzing how formulas introduced by Clarks completion
and loop formulas are related with joins of DLP-functions. To this end, we will now establish
that the sets of formulas associated with 1  2 are directly obtained as unions of sets
of formulas associatedWwith 1 = hR1 , I1 , O1 , H1 i and 2 = hR2 , I2 , O2 , H2 i: First, an
implication B  C  A belongs to Comp(1  2 ) if and only if it belongs to Comp(1 ),
Comp(2 ), or both in case of a shared rule. Second, let us consider any atom a  O  H,
where O = O1  O2 and H = H1  H2 are disjoint because 1  2 is dened. For the same
reason, either a  O1 H1 or a  O2 H2 , i.e., the atom a is dened either by 1 or 2 . Thus,
we have either Def R1 (a) = Def R1 R2 (a) or Def R2 (a) = Def R1 R2 (a) by Denition 2.2, which
implies that either SuppF(a, 1 2 )W= SuppF(a, 1 ) or SuppF(a, 1 2 ) = SuppF(a, 2 ).
It follows that the implication
1  2 ) if
W a  SuppF(a, 1  2 ) is a member of Comp(
W
and only if either (i) a  SuppF(a, 1 ) belongs to Comp(1 ) or (ii) a  SuppF(a, 2 )
belongs to Comp(2 ). Thus, we may conclude (14) for the completions involved.
Third, recall that each loop L  At(1  2 ) of 1  2 is contained in some SCC S of
1  2 . It follows by (5), (6), and Denition 2.2 that either
1. L  O1  H1 is a loop of 1 and Def R1 (L) = Def R1 R2 (L), or
2. L  O2  H2 is a loop of 2 and Def R2 (L) = Def R1 R2 (L).
In the cases above, we have either ESuppF(L, 1 2 ) = ESuppF(L,W
1 ) or ESuppF(L, 1 
2 ) = ESuppF(L, 2 ). Thus, the respective loop formula L 
ESuppF(L, 1  2 )
belongs to LF(1  2 ) if and only if it is contained in LF(1 )  LF(2 ).

Theorem 5.5 For all positive DLP-functions 1 and 2 such that 1  2 is defined,
MM(1  2 ) = MM(1 ) 
 MM(2 ).

(16)

Proof. Consider any M  At(1  2 ) and the respective projections M1 = M  At(1 )
and M2 = M  At(2 ) which are compatible and, moreover, M = M1  M2 . We obtain the
following chain of equivalences:
831

fiJanhunen, Oikarinen, Tompits & Woltran

M  MM(1  2 )  M
 |= Comp(1  2 ) and M |= LF(1  2 )
M1 |= Comp(1 ) and M1 |= LF(1 )

M2 |= Comp(2 ) and M2 |= LF(2 )
 M1  MM(1 ) and M2  MM(2 )
 M  MM(1 ) 
 MM(2 ).

[Theorem 4.3]
[(14) and (15)]
[Theorem 4.3]
[Denition 5.2]


Example 5.6 Let us demonstrate the result of Theorem 5.5 in a practical setting using DLPfunctions 1 and 2 as visualized below and their composition  = hR, , {a, b, c, d, e}, i.

1 :

{a, b, c}
a  b ;
a  b;
b  a;
a  c;
c  d  e  a, b
{d, e}

2 :

{d, e}
d  c;
e  d;
d  e;
c  d  e  a, b
{a, b, c}

The join 1  2 is defined because the SCCs of the composition  are S1 = {a, b, c}
and S2 = {d, e}. The Ati (1 )-minimal models of 1 are {a, b, c}, {a, b, d}, {a, b, e}, and
{a, b, d, e}. Likewise, calculating MM(2 ), we get
MM(2 ) = {, {a}, {b}, {c, d, e}, {a, b, d, e}, {a, c, d, e}, {b, c, d, e}, {a, b, c, d, e}}.
Hence, the only minimal model of  is M = {a, b, d, e} and the compatibility condition
underlying (16) correctly excludes N = {a, b, c, d, e} 6 MM(). Note that there is no support
to c being true in 1 when d and e are true. Accordingly, c  d  e  a, b is not active.
We are now prepared to present our central result:
Theorem 5.7 (Module Theorem) For all DLP-functions 1 and 2 such that 1  2
is defined,
SM(1  2 ) = SM(1 ) 
 SM(2 ).
(17)
Proof. Again, we take an interpretation M  At(1  2 ) and the respective compatible
projections M1 = M  At(1 ) and M2 = M  At(2 ) into consideration. The proof of (17)
can be based on (16) once a number of preliminary facts has been established:
M2
1
1. The composition M
is dened.
1  2

Since 1  2 is dened, we know that 1  2 is dened. This indicates that 1 and
1
and
2 respect the input/output interfaces of each other. The construction of M
1
M2
M1
M2
2 does not aect this property which implies that 1  2 is dened.
M2
1
is dened.
2. The join M
1  2
M2
1
By the preceding item, the positive dependency graph DG+ (M
1  2 ) is dened.
M1
M2
Let us assume that 1 and 2 are mutually dependent, i.e., there is an SCC S
M2
1
of the graph above such that S  Ato (M
1 ) 6=  and S  Ato (2 ) 6= . Since
the dependency graph has potentially fewer dependencies than the respective graph

832

fiModularity Aspects of Disjunctive Stable Models

DG+ (1 2 ) for 1 and 2 , it follows that S is contained in some SCC S  of the latter.
M2

1
Since Ato (M
1 ) = Ato (1 ) and Ato (2 ) = Ato (2 ), we obtain S  Ato (1 ) 6=  and
S   Ato (2 ) 6= . Thus, 1 and 2 are mutually dependent, a contradiction.
M2
1
3. The reduct (1  2 )M coincides with M
1  2 .

A rule A  B belongs to (1  2 )M if and only if there is a rule A  B, C in 1 ,
2 , or both such that C  M = . Equivalently, there is a rule A  B, C in 1 such
that C  M1 = , or there is a rule A  B, C in 2 such that C  M2 = , i.e.,
1
2
A  B  M
or A  B  M
1
2 .
We therefore get the following chain of equivalences:
M  SM(1  2 ) 






M  MM((1  2 )M )
M2
1
M  MM(M
1  2 )
1
2
M  MM(M
 MM(M
1 )
2 )
M2
1
M1  MM(M
1 ) and M2  MM(2 )
M1  SM(1 ) and M2  SM(2 )
M  SM(1 ) 
 SM(2 ).

[Denition 3.8]
[Item 3 above]
[Theorem 5.5]
[Denition 5.2]
[Denition 3.8]
[Denition 5.2]



The moral of Theorem 5.7 and Denition 2.6 is that stable semantics supports modularization as long as positively interdependent atoms are enforced in the same module.
Example 5.8 Let 1 and 2 be DLP-functions as defined below and  = 1  2 their
join (which is clearly defined):
{b}
a  b ;
bc
{a, c}



{c}
a  c ;
bc
{a, b}

=

{b, c}
a  b ;
a  c ;
bc
{a}

It is straightforward to verify that SM(1 ) = {{b}, {a, b}, {a, c}, {b, c}} and SM(2 ) =
{{c}, {a, b}, {a, c}, {b, c}}. Since Atv (1 )  Atv (2 ) = {a, b, c}, we obtain
SM(1 ) 
 SM(2 ) = SM(1 )  SM(2 ) = {{a, b}, {a, c}, {b, c}}.
A simple cross-check confirms that SM() is indeed given by this set.
Example 5.9 Consider the DLP-functions 1 and 2 from Example 2.8. Then, SM(1 ) =
{, {a, b}, {b, c}} and SM(2 ) = {, {a, b}, {a, c}}. As shown in Example 2.8, the join of 1
and 2 is undefined. Thus, Theorem 5.7 is not applicable. Concerning the composition
1  2 , we note that SM(1  2 ) = {, {a, c}, {b, c}} =
6 {, {a, b}} = SM(1 ) 
 SM(2 ).
Theorem 5.7 can be easily extended for DLP-functions consisting of more than two
modules. In view of this, we say that a nite sequence M1 , . . . , Mn of stable models for
modules 1 , . . . , n , respectively, is compatible, i Mi and Mj are pairwise compatible, for
all 1 
S i, j  n. This property guarantees that each Mi can be recovered from the union
M = ni=1 Mi by taking the respective projection M  At(i ) = Mi .
833

fiJanhunen, Oikarinen, Tompits & Woltran

Corollary 5.10 Let 1 , . . . , n be a sequence of DLP-functions such that the join 1   
n is defined. Then,
SM(1      n ) = SM(1 ) 
  
 SM(n ).

(18)

Example 5.11 The following example simply extends Example 5.8:
{b}
a  b ;
bc
{a, c}



{c}
a  c ;
bc
{a, b}

{a}
a  b ;
ac
{b, c}



=

{a, b, c}
a  b ;
a  c ;
bc


Now we have SM(1 ) = {{b}, {a, b}, {a, c}, {b, c}}, SM(2 ) = {{c}, {a, b}, {a, c}, {b, c}},
and SM(3 ) = {{a}, {a, b}, {a, c}, {b, c}}. Thus, we learn from Corollary 5.10 that
SM(1  2  3 ) = SM(1 ) 
 SM(2 ) 
 SM(3 ) = {{a, b}, {a, c}, {b, c}}.
5.2 Modular Representation of Quantified Boolean Formulas
Our next objective is to illustrate the theory developed so far in terms of a more extensive
unsat as depicted
example. To this end, we consider the pair of DLP-functions sat
n and n
in Figure 2. Their purpose is the evaluation of quantified Boolean formulas (QBFs) of the
form
n
_
XY
(Ai  Bi  Ci  Di ),
(19)
i=1

where each Aj , Bj , Cj , and Dj is a set of Boolean variables, and the parameter n gives
the number of disjuncts in the matrix which is a Boolean formula  inSdisjunctive normal
form (DNF).10 Without loss of generality, we may assume that X = ni=1 (Ai  Bi ), Y =
S
n
i=1 (Ci  Di ), and X  Y =  hold for the sets X and Y of Boolean variables in (19).
It is important to point out that in general the evaluation of QBFs of the form (19) constitutes a p2 -complete decision problem which perfectly matches the complexity of checking
the existence of stable models for a disjunctive program. Given this completeness property,
it follows that in principle any decision problem in p2 can be turned into a QBF of the form
(19), albeit more direct representations can be obtained for particular problem domains. In
this respect, let us address three specic domains prior to detailing the generic approach.
1. The strategic companies domain is identied by Leone et al. (2006) as one of the rst
practical domains involving decision problems on the second level of the polynomialtime hierarchy and solved using ASP techniques. The simplied encoding provided by
Koch, Leone, and Pfeifer (2003) is based on two kinds of disjunctive rules:
strat(x1 )  strat(x2 )  strat(x3 )  strat(x4 )  prod(y, x1 , x2 , x3 , x4 ),

(20)

strat(x)  ctrl(x, x1 , x2 , x3 , x4 ), strat(x1 ), strat(x2 ), strat(x3 ), strat(x4 ),

(21)

10. Also, recall the shorthands S =

V

sS

s and S =

V

834

sS

s introduced right after Example 4.1.

fiModularity Aspects of Disjunctive Stable Models

Function sat
n :

Function unsat
:
n

X
For 1  i  n and x  Ai :  x, act(i);
For 1  i  n and x  Bi : x  act(i);
For 1  i  n: Ai  Bi , act(i)
{act(1), . . . , act(n)}

Ci  {u}  Di , act(i);
y  u;
u  u
{act(1), . . . , act(n)}

For 1  i  n:
For y  Y :

unsat
Figure 2: DLP-functions sat
n and n Wfor the evaluation of a quantied Boolean formula
XY  having a matrix  = ni=1 (Ai  Bi  Ci  Di ).

where predicates strat(x), prod(y, x1 , x2 , x3 , x4 ), and ctrl(x, x1 , x2 , x3 , x4 ), respectively,
denote that a company x is strategic, a product y is produced by companies x1 , . . . , x4 ,
and a company x is controlled by companies x1 , . . . , x4 . Obviously, instances of the
predicate strat arising from the rules of the forms (20) and (21) create positive dependencies in such a program . The resulting SCCs can be used to split the program into
modules 1 , . . . , n so that  = 1  . . .  n is dened. By Theorem 5.7, the status
of a specic company x can be decided using the module i which denes strat(x)
rather than the entire encoding .
2. The model-based diagnosis of digital circuitry provides another interesting application
area. Quite recently, Oikarinen and Janhunen (2008b) presented an ecient encoding
of prioritized circumscription as a disjunctive program (and thus, as a special case, of
parallel circumscription as well)enabling a concise representation of minimal diagnoses in the sense of Reiter (1987). The resulting disjunctive rules involve head-cycles
(see Section 7 for details) which typically pre-empt a polynomial-time translation into
a computationally easier normal logic program. This observation suggests completeness on the second level of the polynomial-time hierarchy although we are not aware of
an exact hardness result. The correctness proof of the encoding exploits two modules
and the module theorem.
3. Finally, let us mention that Gebser, Schaub, Thiele, Usadel, and Veber (2008b) identify
minimal inconsistent cores in large biological networks with disjunctive programs. The
decision problem in question is Dp -complete which also indicates the appropriateness
of disjunctive logic programs for the representation of this domain. Since any Dp complete decision problem can be described as an independent combination of an NPcomplete decision problem P1 and a coNP-complete decision problem P2 , we foresee a
representation in the form of a join sat  unsat , where sat has a stable model i P1
has a succinct certicate, and unsat has a unique stable model i P2 has no succinct
835

fiJanhunen, Oikarinen, Tompits & Woltran

{x1 , x2 }
x1  act(1);
 x1 , act(1);
 x2 , act(2); x2  act(2);
x1  act(3);
 x1 , act(3);
x1  act(4);
 x2 , act(4);
x2  x1 , act(4)
{act(1), act(2), act(3), act(4)}


u  y1 , y2 , act(1);
u  y2  y1 , act(2);
u  y1  y2 , act(3);
u  y1  y2  act(4);
y1  u; y2  u; u  u
{act(1), act(2), act(3), act(4)}

unsat .
Figure 3: Particular instances of sat
4 and 4

certicates. The required DLPs can be worked out via reductions into propositional
(un)satisability. In particular, the test for unsatisability can be realized in analogy
to unsat
analyzed below.
n
In the general case, we use Boolean variables and propositional atoms interchangeably
in order to describe how the validity problem of (19) is captured by DLP-functions from
unsat is based on the explanatory approach from Janhunen
Figure 2. The design of sat
n and n
et al. (2006), where (19) is equivalently viewed as a formula XY  having the matrix
 in conjunctive normal form (CNF). A clause 11 Ai  Bi  Ci  Di in  is active
whenever Ai  Bi is false and the truth of the clause becomes dependent on Ci  Di ; or
to put it dually, Ai  Bi is true and the truth of Ai  Bi  Ci  Di depends on Ci  Di .
The validity of the formula XY  is captured as follows: Given an input interpretation
Mi  {act(1), . . . , act(n)}, the upper DLP-function sat
n from Figure 2 tries to explain the
activation statuses of the clauses in  by checking that the respective theory {Ai  Bi |
act(i)  Mi }  {Ai  Bi | act(i) 6 Mi } is satisable. The lower DLP-function, unsat
, plays
n
the role of a coNP-oracle: it captures a test for the theory {Ci  Di | act(i)  Mi } being
unsatisable. The correctness of the representation provided by these DLP-functions will
be addressed soon, but it is enough to understand their syntax and intuitive meaning for
the moment. A concrete QBF instance is evaluated as follows.
unsat from Figure 2 in the case of QBF
Example 5.12 Consider DLP-functions sat
n and n

x1 x2 y1 y2 [(x1 y1 y2 )(x2 y1 y2 )(x1 y1 y2 )(x1 x2 y1 y2 )]. (22)
Thus, the parameter for this instance is n = 4, and the input signature is {act(1), . . . , act(4)}
unsat , as illustrated in Figure 3. The output signature of the former DLPfor both sat
4 and 4
function is {x1 , x2 } and all other atoms, i.e., y1 , y2 , and u, remain hidden in the latter.
The joint input signature is used to specify the active part of the matrix in (22). The DLPfunction sat
provides an explanation, i.e., an assignment to variables x1 and x2 as its
4
output, whereas unsat
is only responsible for the respective unsatisfiability check. As regards
4
the validity of the QBF given in (22), the input interpretation {act(1), act(2), act(3), act(4)}
yields a positive answer. The respective explanation, i.e., the output interpretation found by
sat
4 , is {x1 }. It is easy to check that when x1 is true and x2 is false then the remainder of
the matrix is true whatever values are assigned to y1 and y2 . Hence, the QBF (22) is valid.
11. For the purposes of this section, we interpret disjunctions A  B of sets A and B = {b | b  B} of
positive and negative literals, respectively, as disjunctions of their elements.

836

fiModularity Aspects of Disjunctive Stable Models

unsat in Figure 2, they have identical
As regards the general DLP-functions sat
n and n
sat
input signatures, only n has output atoms, and the hidden atoms of unsat
are fully
n
sat
unsat
respected. Hence, the composition n  n
is dened. Moreover, the atoms appearing
in rules that involve positive dependencies belong to disjoint sets X and Y  {u}. It is
unsat ) cannot have an SCC S such that S  X 6=  and
therefore clear that DG+ (sat
n  n
unsat is dened regardless of the QBF (19) in
S  (Y  {u}) 6= . This implies that sat
n  n
question. Let us exploit this fact in the context of specic DLP-functions of Example 5.12.

Example 5.13 There are four stable models for the DLP-function sat
4 :
{act(1), act(2), act(3), act(4), x1 }, {act(1), act(3), x1 , x2 }, {act(2)}, and {x2 },
listed in decreasing level of activation. On the other hand, the DLP-function unsat
has a
4
unique stable model {act(1), act(2), act(3), act(4), y1 , y2 , u}, i.e., the interpretation {y1 , y2 , u}
/{act(1), act(2), act(3), act(4)} where the set of rules is
is the unique stable model of unsat
4
given by
{ u  y1 , y2 ; u  y2  y1 ; u  y1  y2 ; u  y1  y2 ; y1  u; y2  u; u  u },
/Mi has no stable models for any other input interpretation Mi . Moreover, we
and unsat
4
unsat ) by combining compatible pairs
may apply the module theorem to calculate SM(sat
4  4
of models. There is only one such pair:
{act(1), act(2), act(3), act(4), x1 }  SM(sat
4 ) and
{act(1), act(2), act(3), act(4), y1 , y2 , u}  SM(unsat
).
4
Thus, {act(1), act(2), act(3), act(4), x1 , y1 , y2 , u} is the unique stable model of the join sat
4 
sat  unsat ) is non-empty, we conclude that (22) is indeed valid.
unsat
.
Since
SM(
4
4
4
It is natural to ask what can be stated about the stable models of the general DLPfunctions unsat
and sat
n
n associated with the QBF XY  given in (19). If M is a stable
sat
model of n , then the respective projection MX = X M determines M , i.e., it holds for all
1  i  n in the matrix  that act(i)  M if and only if MX |= Ai Bi . Moreover, the model
MX is minimal in the sense that there is no strictly smaller interpretation N  MX with
this property. This is an additional feature brought along the minimality of stable models.
As a consequence, the DLP-function sat
n does not capture all possible truth assignments to
variables in X but no relevant truth assignments are lost. On the other hand, any stable
indicates that the respective theory
model M of unsat
n
{Ci  Di | 1  i  n, act(i)  M }
W
is inconsistent, or alternatively, the formula 1in,act(i)M Ci  Di is valid.
Concerning the correctness of the representation given in Figure 2, due to an existing
proof by Janhunen et al. (2006), we only present the main stepsfully exploiting the benets
from our modular approach.
unsat ) is non-empty.
Theorem 5.14 A QBF XY  of the form (19) is valid iff SM(sat
n n

Proof sketch. Consider any QBF XY  of the form (19). The following are equivalent:
837

fiJanhunen, Oikarinen, Tompits & Woltran

1. The formula XY  is valid.
2. There is a minimal interpretation N  X such that, for the set I = {1  i  n |
N 6|= Ai  Bi } of indices determined by N with N |= {Ai  Bi | i  I}{Ai  Bi |
i 6 I}, the theory {Ci  Di | i  I} is unsatisable.
unsat have compatible stable models M = N  {act(i) |
3. The DLP-functions sat
1
n and n
i  I} and M2 = {act(i) | i  I}  Y  {u}, respectively.
unsat has a stable model
4. The DLP-function sat
n  n

M = M1  M2 = N  {act(i) | i  I}  Y  {u}.
In the second item, the minimality of N means that there is no N   N such that {1  i  n |
N  6|= Ai  Bi } = I. This can be assumed without loss of generality.

Theorem 5.14 and the module theorem suggest an approximation strategy for verifying
unsat ) is empty, we know
the validity of QBFs of the form (19). If either SM(sat
n ) or SM(n
unsat ) = .
directly that the formula is not valid. Otherwise, we check whether SM(sat
n  n
5.3 Splitting Sets
For the sake of comparison, we formulate the splitting-set theorem (Lifschitz & Turner,
1994) for a DLP-function  = hR, , O, i, which essentially forms an ordinary disjunctive
program. Splitting sets are sets of atoms that are closed in the following sense:
Definition 5.15 Given a DLP-function  = hR, , O, i, a set U  O of atoms is a splitting set for  if and only if, for every rule A  B, C  R,
A  U 6=  implies A  B  C  U .
By Denitions 2.1 and 5.15, the sets  and O are always splitting sets for . However,
one is mostly interested in other non-trivial splitting sets   U  O for , but such sets
need not exist. Nevertheless, any splitting set U divides the respective set of rules R in two
parts. The bottom, bU (R), of R with respect to U contains all rules A  B, C  R such
that A  B  C  U , whereas the top, tU (R), of R is R \ bU (R). The splitting of R into
bU (R) and tU (R) becomes a proper one, i.e., bU (R) 6=  and tU (R) 6= , if
1. U is non-trivial and
2. every atom a  O has at least one dening rule A  B, C  R such that a  A.
According to Lifschitz and Turner (1994), a solution to R with respect to U  O is a pair
hX, Y i where X  U , Y  O \U , X  SM(bU (R)), and Y  SM(tU (R)/X). Here, tU (R)/X
denotes the partial evaluation of tU (R) in the sense of Denition 3.2 using X  U as an
input interpretation. Using a similar idea, let us introduce DLP-functions corresponding to
bU (R) and tU (R). Given a splitting set U for , the join  = B  T , where
B = hbU (R), , U, i and T = htU (R), U, O \ U, i
is dened. Then, the following result is implied by Theorem 5.7.
838

fiModularity Aspects of Disjunctive Stable Models

Corollary 5.16 (Splitting-Set Theorem from Lifschitz & Turner, 1994) For every
DLP-function  = hR, , O, i corresponding to a set R of disjunctive rules, every splitting
set U  O for , and every interpretation M  At() = O, the following conditions are
equivalent:
1. M is a stable model of .
2. M  U  SM(B ) and M  SM(T ).
3. hM  U , M \ U i is a solution to R with respect to U .
In fact, Theorem 5.7 is strictly stronger than the splitting-set theorem. As previously
demonstrated by Oikarinen and Janhunen (2008a), splitting sets are applicable to DLPfunctions like  = h{a  b; b  a}, , {a, b}, i only in the trivial way, i.e., only U1 = 
are U2 = {a, b} are splitting sets for . In contrast, Theorem 5.7 applies to the preceding
DLP-function in more versatile ways, i.e., 1 2 is dened for 1 = h{a  b}, {b}, {a}, i
and 2 = h{b  a}, {a}, {b}, i. As a consequence of 1  2 being dened, it is possible
to determine the sets of stable models SM(1 ) = {{a}, {b}} = SM(2 ) in separation, if
appropriate, and then conclude that SM() = SM(1 ) 
 SM(2 ) = {{a}, {b}} holds as
well. Yet another generality aspect of splitting concerns the role of input atomsthey are
assumed nonexistent above. Theorem 5.7, however, enables us to treat them as well.

6. Decomposing DLP-Functions
The objectives of this section are contrary to the construction of a DLP-function as a join of
modules. The idea is to exploit the strongly connected components of DG+ (), for a DLPfunction , in order to decompose  into smaller components, e.g., when there is no a priori
information about the internal structure of . For simplicity, we will rst consider DLPfunctions  having no hidden atoms, i.e., where Ath () = . The eects of hidden atoms on
the decomposition of DLP-functions will be addressed thereafter. As dened in conjunction
with Denition 2.6, the SCCs in DG+ () are induced by the positive dependency relation
 which is reexive and transitive, i.e., a preorder by denition. In the sequel, the set of
SCCs in DG+ () is denoted by SCC+ (). The positive dependency relation  lifts for the
elements of SCC+ () as follows: S1  S2 if and only if there are atoms a1  S1 and a2  S2
such that a1  a2 . To this end, it does not matter which pair of atoms is inspected.
Lemma 6.1 For any DLP-function  and any components S1 , S2  SCC+ (), S1  S2 if
and only if a1  a2 for every a1  S1 and a2  S2 .
Proof. (=) If S1  S2 , there are b1  S1 and b2  S2 such that b1  b2 . Consider any
a1  S1 and a2  S2 . It follows that a1  b1 and b2  a2 by the denition of SCCs. Thus,
a1  a2 as  is transitive.
(=) This holds trivially as SCCs are non-empty.

Proposition 6.2 The relation  over SCC+ () is reflexive, transitive, and antisymmetric.
839

fiJanhunen, Oikarinen, Tompits & Woltran

Proof. The relation  over SCC+ () is reexive and transitive by denition. For antisymmetry, consider any S1 , S2  SCC+ () such that S1  S2 and S2  S1 . It follows by
Lemma 6.1 that, for every a1  S1 and a2  S2 , a1  a2 and a2  a1 . Thus, S1 = S2 by the
maximality of components in SCC+ ().

+
Consequently, we may conclude that hSCC (), i is a partially ordered set. Since  is
nite by denition, hSCC+ (), i has maxima and minima but these elements need not be
unique. In particular, for each S  SCC+ () there is a minimum element S1  SCC+ ()
such that S1  S and S2  S1 implies S2 = S1 , for any S2  SCC+ (). Thus, we may
apply the principle of well-founded induction using the minima of hSCC+ (), i as basis.
Given the structure hSCC+ (), i, the DLP-function  = hR, I, O, i can be decomposed in the following way: The set of rules associated with S  SCC+ () is Def R (S)
from (2), i.e., the set of defining rules for S in R. In general, the head of an arbitrary rule
A  B, C  R may coincide in the sense of (2) with several SCCs, which implies that
the rule is included in Def R (S) for several S  SCC+ (). However, such a distribution of
rules is in perfect harmony with the last two conditions of Denition 2.2. We must also
bear in mind integrity constraints   B, C which are not included in Def R (S) for any
S  SCC+ (). To access the integrity constraints of any set R of rules, we dene
IC(R) = {A  B, C  R | A = }.

(23)

We are now ready to present a decomposition of  based on SCC+ ().
Definition 6.3 Given a DLP-function  = hR, I, O, i, the decomposition induced by
SCC+ () includes a DLP-function
0 = hIC(R), At(IC(R))  (I \ At(R)), , i

(24)

and, for each S  SCC+ (), a DLP-function
S = hDef R (S), At(Def R (S)) \ S, S, i.

(25)

The purpose of the extra module 0 is to keep track of integrity constraints as well
as input atoms that are not mentioned by the rules of R. The other modules involved
in the decomposition  are induced by SCCs. Each S refers to other modules using
At(Def R (S)) \ S as its input signature and provides the dening rules (if any) for every
atom in S. Recall that an output atom having no dening rules will be falsied by default.
Proposition 6.4 For a DLP-function  = hR, I, O, i and its decomposition based on
SCC+ (), the join
F
(26)
0  ( SSCC+ () S )
is defined and equal to .

Proof. Let us consider 0 and S for any S  SCC+ (). The composition 0  S
is dened because these modules involve no hidden atoms, Ato (0 ) = , and we have
Def R1 () =  = Def R1 R2 () and Def R2 (S) = Def R (S) = Def R1 R2 (S) for the sets of rules
R1 = IC(R) and R2 = Def R (S). The join 0  S is dened as the respective composition
is and the integrity constraints in 0 do not create any dependencies in DG+ (0  S ).
840

fiModularity Aspects of Disjunctive Stable Models

Let us perform a similar analysis for S1 and S2 based on two dierent components
S1 , S2  SCC+ (). It is clear that S1  S2 is dened since these modules involve no
hidden atoms, S1  S2 = , and we have that Def R1 (S1 ) = Def R (S1 ) = Def R1 R2 (S1 ) and
Def R2 (S2 ) = Def R (S2 ) = Def R1 R2 (S2 ), for R1 = Def R (S1 ) and R2 = Def R (S2 ).
Since all pairwise joins are dened, also the overall join (26) is dened. By Denition 2.4
and the denition of SCC+ (), the outcome is equal to  because
S
1. IC(R)  SSCC+ () Def R (S) = R,
S
2. SSCC+ () S = O, and
S

3. (At(IC(R)) \ O)  ((I \ At(R)) \ O)  SSCC+ () (At(Def R (S)) \ O) = I.
Corollary 6.5 For a DLP-function  with Ath () =  and its decomposition based on
SCC+ (),
SM() = SM(0 ) 
 ( SSCC+ () SM(S )).




Example 6.6 Consider the following DLP-function :
{a, b, c, d}
a  b  c  d ;
 a, c;  b, c;
 a, d;  b, d;
a  b;
c  d;
b  a;
d  c.

So, Ati () = , Ato () = {a, b, c, d}, and Ath () = . There are two SCCs in DG+ (),
viz. S1 = {a, b} and S2 = {c, d}. The resulting decomposition of  consists of
0 = h{ a, c;  a, d;  b, c;  b, d}, {a, b, c, d}, , i,
S1 = h{a  b  c  d ; a  b; b  a}, {c, d}, {a, b}, i, and
S2 = h{a  b  c  d ; c  d; d  c}, {a, b}, {c, d}, i.
The respective sets of stable models are
SM(0 )
SM(S1 )
SM(S1 )
SM()

=
=
=
=

{{a, b}, {c, d}, {a}, {b}, {c}, {d}, },
{{a, b}, {c}, {d}, {c, d}},
{{c, d}, {a}, {b}, {a, b}}, and
{{a, b}, {c, d}}.

Next, we address the case of DLP-functions involving hidden atoms, i.e., for which
Ath () 6=  holds. Then, the components in DG+ () are subsets of Ato ()  Ath () and
we have to revise (25) accordingly. For a DLP-function  = hR, I, O, Hi and S  SCC+ (),
S = hDef R (S), At(Def R (S)) \ S, S  O, S  Hi.

(27)

Unfortunately, a decomposition based on modules of the form (27) is likely to be too negrained. For certain components S1 , S2  SCC+ () such that S1 6= S2 , the respective
841

fiJanhunen, Oikarinen, Tompits & Woltran

modules S1 and S2 conforming to (27) might not respect hidden atoms of each other. A
similar setting may arise with 0 and an individual module S based on some S  SCC+ ()
if the integrity constraints of  refer to hidden atoms of S . The problem would disappear
if all hidden atoms of  were revealed but this is hardly appropriatethere are good reasons
to hide certain atoms from a knowledge representation perspective.
A way to approach this problem is to distinguish components S1  SCC+ () and
S2  SCC+ () for which the respective modules S1 and S2 would not respect the hidden
atoms of each other, i.e., a hidden atom dened by one would be referred by the othereither
positively or negatively. Similar conicts could also arise due to integrity constraints packed
into the module 0 distinguished in Denition 6.3. At rst sight, we should amalgamate 0
with any other module whose hidden atoms occur in the integrity constraints of 0 . But,
in order to avoid fusions of this kind as far as possible, it is worth redistributing integrity
constraints referring to hidden atoms. This is clearly possible for integrity constraints referring to hidden atoms involved in a single component only. To formalize the ideas presented
so far, we distinguish a precise relation among the components of SCC+ () as follows.
Definition 6.7 Given a DLP-function , components S1 , S2  SCC+ () do not respect
the hidden atoms of each other, denoted by S1 !h S2 , if and only if S1 6= S2 and there is
1. a hidden atom h  Ath (S1 ) such that h  Ati (S2 ), or
2. a hidden atom h  Ath (S2 ) such that h  Ati (S1 ), or
3. there are hidden atoms h1  Ath (S1 ) and h2  Ath (S2 ) which both have an occurrence in some integrity constraint  B, C of .
It is clear that !h is irreexive and symmetric for the components of SCC+ () for
any DLP-function . Moreover, the transitive closure of !h , denoted by !+
h , gives rise
+
to a repartitioning of SCC (). Each maximal block S1 , . . . , Sn of components such that
Si !+
h Sj holds for every i 6= j induces a module S as determined by (27) for the union
S = S1  . . .  Sn . The key observation is that modules associated with dierent blocks
of components respect hidden atoms of each other which makes Theorem 5.7 applicable at
that level of abstraction. To summarize the treatment of DLP-functions involving hidden
atoms in their rules, we revise Denition 6.3 accordingly.
Definition 6.8 Given a DLP-function  = hR, I, O, Hi, the decomposition induced by
SCC+ () and !+
h includes a DLP-function
0 = hIC0 (R), At(IC0 (R))  (I \ At(R)), , i

(28)

where IC0 (R) = { B, C  R | (B  C)  H = } and, for each maximal block S1 , . . . , Sn
of components of SCC+ () such that Si !+
h Sj for every i 6= j, a DLP-function
S = hDef R (S)  ICS (R), At(Def R (S)  ICS (R)) \ S, S  O, S  Hi

(29)

where S = S1  . . .  Sn and ICS (R) = { B, C  R | (B  C)  (S  H) 6= }.
As regards Example 6.6, Denitions 6.3 and 6.8 yield identical decompositions for the
DLP-function in question. The eects of hiding are demonstrated by the following example:
842

fiModularity Aspects of Disjunctive Stable Models

Example 6.9 Consider a DLP-function  = hR, , O, Hi, for
R = { a, c; a  b ; b  c  d ; c  d; d  c, b}
and O  H = {a, b, c, d}, where the exact partitioning of atoms in O and H varies from case
to case as analyzed below. The SCCs in SCC+ () are S1 = {a}, S2 = {b}, and S3 = {c, d}.
1. If we take all atoms visible in , i.e., if H = , the decomposition of  yields three modules, S1 = h{a  b }, {b}, {a}, i, S2 = h{a  b ; b  c  d }, {a, c, d}, {b}, i,
and S3 = h{b  c  d ; c  d; d  c, b}, {b}, {c, d}, i, in addition to the module
0 = h{ a, c}, {a, c}, , i encompassing integrity constraints.
2. If we hide H = {a} in , we obtain S1 !h S2 by the disjunctive rule a  b . Therefore, components S1 and S2 must be placed in the same block which is also maximal
giving rise to a module S = h{ a, c; a  b ; b  c  d }, {c, d}, {b}, {a}i where
S = S1  S2 = {a, b}. The other modules are 0 =  and S3 listed above.
3. Finally, if we set H = {a, c} for , we obtain S2 !h S3 by b  c  d  and S1 !h S3
by  a, c in addition to S1 !h S2 as stated above. Since 0 = , the decomposition
of  effectively collapses to a single module S  =  where S  = S1  S2  S3 .
We note about the non-trivial modules mentioned above that
SM(S1 )
SM(S2 )
SM(S3 )
SM(0 )
SM(S )

=
=
=
=
=

{{a}, {b}},
{{b}, {a, b}, {b, c}, {a, c}, {b, d}, {a, d}, {b, c, d}, {a, c, d}},
{{b}, {c, d}},
{, {c}, {a, c}}, and
{{b}, {a, c}, {b, c}, {b, d}, {a, c, d}, {b, c, d}}.

But, regardless of the decomposition obtained, it holds for the respective joins that
SM() =
=
=
=

SM(S1 ) 
 SM(S2 ) 
 SM(S3 ) 
 SM(0 )
SM(S ) 
 SM(S3 ) 
 SM()
SM(S  ) 
 SM()
{{a, c, d}, {b}}.

In the calculations involving 
 it is important to notice that the allowed combinations
of stable models are determined in terms of joint visible atoms of the modules involved.
For instance, we have Atv (S1 )  Atv (S3 ) = {a, b}  {b, c, d} = {b} so that SM(S1 ) 

SM(S3 ) is {{a}  {c, d}, {b}  {b}} = {{a, c, d}, {b}} by Denition 5.2. Thus, interestingly,
the role of the remaining two modules S2 and 0 is merely to approve upon these two
models. Recalling the discussion from the introduction, this suggests a strategy which gives
precedence to
1. an evaluation of modules having only few stable models, and
2. a combination of stable models for modules that have only few visible atoms in common.
843

fiJanhunen, Oikarinen, Tompits & Woltran

7. Shifting Disjunctions
In this section, we continue the pursuit of applications for the module theorem established in
Section 5. We now generalize the principle of shifting disjunctive rules (Gelfond et al., 1991;
Dix et al., 1996) by applying the results of this paper. Roughly speaking, the idea behind
shifting is to translate a disjunctive rule A  B, C into several normal (non-disjunctive)
rules by shifting head atoms h  A to negative literals h in the body. For instance, a
simple disjunctive rule a  b  c  is captured by normal rules
a  b, c,

b  a, c,

and

c  a, b.

As shown by Eiter et al. (2004), such a local shifting transformation preserves ordinary
equivalence, i.e., stable models.12 The application of this technique is, however, pre-empted
in the presence of head-cycles (Ben-Eliyahu & Dechter, 1994). Such a cycle is provided by
an SCC S that intersects with the head A of some disjunctive rule A  B, C of  such
that |S  A| > 1. For instance, local shifting is no longer applicable to the rule a  b  c  in
the presence of a  b and b  a which create a strongly connected component S = {a, b}.
As a consequence, the respective DLP-functions
1 = h{a  b  c ; a  b; b  a}, , {a, b, c}, i,

(30)

2 = h{a  b, c; b  a, c; c  a, b; a  b; b  a}, , {a, b, c}, i

(31)

have dierent stable models: SM(1 ) = {{a, b}, {c}} and SM(2 ) = {{c}}. Such a discrepancy of stable models can be settled by applying the decomposition technique from
Section 6. In fact, it leads to a proper generalization of the local shifting transformation
which is formalized below for DLP-functions and their strongly connected components.
Definition 7.1 Let  = hR, I, O, Hi be a DLP-function and SCC+ () the respective set
of SCCs. The general shifting of  is the DLP-function GSH() = hIC(R)  R , I, O, Hi,
where R is the set of rules
{(A  S)  B, C, (A \ S) | A  B, C  R, S  SCC+ () and A  S 6= }.

(32)

Hence, the idea is to project the head A of the rule with respect to each component S,
and atoms in the dierence A \ S are shifted to the negative body. This can be viewed as
the contribution of a disjunctive rule A  B, C for a particular component S.
Example 7.2 For 1 from (30), we have SCC+ (1 ) = {{a, b}, {c}}, so that
GSH(1 ) = h{a  b  c; c  a, b; a  b; b  a}, , {a, b, c}, i.
Most importantly, we have SM(GSH(1 )) = {{a, b}, {c}} = SM(1 ), in contrast to the set
SM(2 ) = {{c}} of stable models for 2 from (31).
12. In addition to ordinary equivalence, also uniform equivalence (Eiter & Fink, 2003) is preserved by local
shifting but not strong equivalence (Lifschitz, Pearce, & Valverde, 2001).

844

fiModularity Aspects of Disjunctive Stable Models

We now prove the correctness of the general shifting principle from Denition 7.1. The
aim is to exploit the decomposition of  from Denition 6.3 together with the modular
reconstruction of  from Proposition 6.4 and the compositionality of stable semantics from
Corollary 6.5. To extend the coverage of Corollary 6.5, we introduce explicit operators for
revealing and hiding atoms of DLP-functions as follows:
Definition 7.3 Let  = hR, I, O, Hi be a DLP-function. Then,
1. Reveal(, A) = hR, I, O  A, H \ Ai, for a set A  H of hidden atoms, and
2. Hide(, A) = hR, I, O \ A, H  Ai, for a set A  O of output atoms.
Since the denition of stable models does not make a dierence between output atoms
and hidden atoms, the following properties are easy to verify. The role of hidden atoms
becomes important in Section 8 when DLP-functions are compared with each other.
Proposition 7.4 Let  be any DLP-function.
1. For any A  Ath (), SM() = SM(Reveal(, A)).
2. For any A  Ato (), SM() = SM(Hide(, A)).
Lemma 7.5 Let  be a DLP-function with Ath () = , S a component in SCC+ (), and
S the respective module in the decomposition of  according to Definition 6.3. Then,
SM(S ) = SM(GSH(S )).

(33)

Proof. Recall that S = hDef R (S), I, S, i, where the input signature I = At(Def R (S)) \
S. Notice that S is the only component in SCC+ (S ) and hence GSH(S ) has a set of rules
R = {(A  S)  B, C, (A \ S) | A  B, C  Def R (S)}.
Consider any interpretation M  I  S, where I and S are the input and output signatures
of S , respectively. Thus, Mi = M  I and Mo = M  S. Then, the following equivalences
hold:






A  B  (Def R (S)/Mi )Mo
A  B, C  Def R (S)/Mi such that Mo |= C
A  B  , C   Def R (S) such that A = Ao , B = Bo , C = Co ,
Mi |= Ai  Bi  Ci , and Mo |= Co
A  B  , C  , Ai  R such that A = Ao , B = Bo , C = Co ,
Mi |= Ai  Bi  Ci , and Mo |= Co
A  B, C  R /Mi such that Mo |= C
A  B  (R /Mi )Mo .

Thus, we conclude that (Def R (S)/Mi )Mo coincides with (R /Mi )Mo , and, consequently, Mo 
MM((Def R (S)/Mi )Mo ) if and only if Mo  MM((R /Mi )Mo ). Therefore, SM(S /Mi ) =
SM(GSH(S )/Mi ). Since M and, in particular, Mi were arbitrarily chosen in the beginning,
we obtain the equality of stable models stated in (33) directly by Corollary 3.9.

845

fiJanhunen, Oikarinen, Tompits & Woltran

Theorem 7.6 For any DLP-function  = hR, I, O, Hi, SM() = SM(GSH()).
Proof. Since  may have hidden atoms, Corollary 6.5 is not applicable to its decomposition based on SCC+ (). Thus, we have to start with  = Reveal(, H) = hR, I, O  H, i
rather than  itself. Since SCCs are independent of hiding, we have SCC+ ( ) = SCC+ ()
and GSH( ) = Reveal(GSH(),
H). Since Ath ( ) =  by construction, we know by
F

Proposition 6.4 that 0  ( SSCC+ () S ) =  . Applying GSH() to this equation yields
F
GSH( ) = 0  ( SSCC+ () GSH(S )).

(34)

As regards the respective sets of stable models, we obtain
SM( )

=



 (
SM( ) 


=

SM(GSH( )).

=

SM(0 ) 
(

0

SSCC+ ( )

SM(S ))

[Corollary 6.5]

SSCC+ ( )

SM(GSH(S )))

[Lemma 7.5]
[Corollary 6.5 and (34)]

It follows by Proposition 7.4 that SM(Hide( , H)) = SM( ) = SM(GSH( )) =
SM(Hide(GSH( ), H)). Since Hide( , H) =  and Hide(GSH( ), H) = GSH(), we
have established that SM() = SM(GSH()) as desired.

According to Denition 6.3, decompositions of DLP-functions create multiple copies of
disjunctive rules whose heads intersect with several SCCs. The introduction of such copies
can be circumvented by applying the general shifting technique from Denition 7.1.
Example 7.7 For the DLP-function  from Example 6.6, we obtain R1 = {ab  c, d;
a  b; b  a} and R2 = {c  d  a, b; c  d; d  c} as the sets of rules associated with 1 = hR1 , {c, d}, {a, b}, i and 2 = hR2 , {a, b}, {c, d}, i, for which 1  2 =
hR1  R2 , , {a, b, c, d}, i is defined.

These observations enable us to view disjunctive rules which are shared by the modules
associated with SCCs as syntactic sugar. However, a clever implementation can save space
using shared rules. In the worst case, unwinding a rule a1      an  B, C that coincides
with the respective SCCs S1 , . . . , Sn such that a1  S1 , . . . , an  Sn may create n copies of
the body B  C. Such a quadratic blow-up can be partly alleviated by introducing a new
atom b as a name for the body. Thus the result of shifting a1  S1 , . . . , an  Sn becomes
a1  b, a2 , . . . , an ;
..
.
ai  b, a1 , . . . , ai1 , ai+1 , . . . , an ;
..
.
an  b, a1 , . . . , an1
together with the dening rule b  B, C for b. There is an implementation of the general
shifting principle called dencode.13 If requested to do so, it calculates beforehand whether
it pays o to introduce a new atom for the body for each disjunctive rule or not.
13. Available at http://www.tcs.hut.fi/Software/asptools/ for experimenting.

846

fiModularity Aspects of Disjunctive Stable Models

8. Equivalence of DLP-Functions
The concept of visible equivalence was originally introduced in order to neglect hidden atoms
when logic programs, or other theories of interest, are compared on the basis of their models (Janhunen, 2006). Oikarinen and Janhunen (2008a) extended this idea to the level of
logic program modulesgiving rise to the notion of modular equivalence for logic programs.
In this section, we generalize the concept of modular equivalence for DLP-functions and
introduce a translation-based method for checking modular equivalence of DLP-functions
following analogous approaches of Oikarinen and Janhunen (2004, 2009).
8.1 Modular Equivalence
Module interfaces must be taken properly into account when DLP-functions are compared.
For this reason, we consider two DLP-functions 1 and 2 to be compatible if and only if
Ati (1 ) = Ati (2 ) and Ato (1 ) = Ato (2 ).
Definition 8.1 DLP-functions 1 and 2 are modularly equivalent, denoted by 1 m 2 ,
if and only if
1. 1 and 2 are compatible and
2. there is a bijection f : SM(1 )  SM(2 ) such that for all interpretations M 
SM(1 ), M  Atv (1 ) = f (M )  Atv (2 ).
The proof that m is congruent for  lifts from the case of normal programs (Oikarinen
& Janhunen, 2008a) to the disjunctive case using Theorem 5.7.
Proposition 8.2 Let 1 , 2 , and  be DLP-functions. If 1 m 2 and both 1   and
2   are defined, then 1   m 2  .
Proof. Let 1 = hR1 , I1 , O1 , H1 i and 2 = hR2 , I2 , O2 , H2 i be DLP-functions such that
1 m 2 , and  = hR, I, O, Hi a DLP-function acting as an arbitrary context for 1 and
2 such that 1   and 2   are dened. Consider any M  SM(1  ). Theorem 5.7
implies that M1 = M  At(1 )  SM(1 ) and N = M  At()  SM(). Since 1 m 2 ,
we have I1 = I2 , O1 = O2 , and there is a bijection f : SM(1 )  SM(2 ) such that
M1  (I1  O1 ) = f (M1 )  (I2  O2 )

(35)

holds for M1 . Dene M2 = f (M1 ). Since M1 and N are compatible by denition and (35)
holds, the models M2 and N are compatible as I1 = I2 and O1 = O2 . Thus, M2  N 
SM(2  ) by Theorem 5.7 and we have eectively described how M is mapped to a model
in SM(2  ) by a function g : SM(1  )  SM(2  ) dened by
g(M ) = f (M  At(1 ))  (M  At()).
Clearly, g maps the set of visible atoms in M to itself, that is,
M  (I1  I  O1  O) = g(M )  (I2  I  O2  O).
The justications for g being a bijection are as follows:
847

fiJanhunen, Oikarinen, Tompits & Woltran

 g is an injection: M 6= N implies g(M ) 6= g(N ) for all M, N  SM(1  ), since
f (M  At(1 )) 6= f (N  At(1 )) or M  At() 6= N  At().
 g is a surjection: for any N  SM(2  ), M = f 1 (N  At(2 ))  (N  At()) 
SM(1  ) and g(M ) = N , since f is a surjection.
The inverse function g 1 : SM(2  )  SM(1  ) of g can be dened by setting
= f 1 (N  At(2 ))  (N  At()). Thus, 1   m 2  .

Note that  m GSH() follows directly from Theorem 7.6. Applying Proposition 8.2 in
the context of Theorem 7.6 indicates that shifting can be localized to a particular component
1 in a larger DLP-function 1   since 1   m GSH(1 )  .

g 1 (N )

8.2 Verifying Modular Equivalence
Oikarinen and Janhunen (2004) proposed a translation-based method for the verication
of weak equivalence of disjunctive logic programs. Two logic programs are weakly equivalent i they have exactly the same set of stable models. Thus, weak equivalence can
be seen as a special case of modular equivalence for DLP-functions 1 and 2 where
Ati (1 )  Ath (1 ) = Ati (2 )  Ath (2 ) = . This motivates us to adjust the translationbased technique for the verication of modular equivalence. As observed in previous work
(Janhunen & Oikarinen, 2007; Oikarinen & Janhunen, 2008a), the verication of visible/modular equivalence involves a counting problem in general. A reduction of computational time complexity can be achieved for programs that have enough visible atoms,
referred to as the EVA property for short, (Janhunen & Oikarinen, 2007). For any DLPfunction  = hR, I, O, Hi, we dene the hidden part of  as the restricted DLP-function
h = hDef R (H), I  O, H, i which enables the evaluation of hidden atoms in H given
arbitrary truth values for all other atoms in I  O. Recalling Denition 3.2, we use an
instantiation of h with respect to an interpretation Mv  Ati (h ), i.e., h /Mv , to dene
the EVA property for the DLP-function .
Definition 8.3 A DLP-function  = hR, I, O, Hi has enough visible atoms iff h /Mv has
a unique stable model for each Mv  Atv () = Ati (h ).
The idea behind the translation-based method of Oikarinen and Janhunen (2004) is
that ordinary disjunctive programs R1 and R2 are weakly equivalent i their translations
TR(R1 , R2 ) and TR(R2 , R1 ) have no stable models. In the following, we propose a modied
version of the translation function adjusted to verication of modular equivalence. In order
to be able to verify modular equivalence, we need to take the semantics of the atoms in the
input signature into account as well as the role of hidden atoms when modular equivalence
of programs is under consideration. In the case of DLP-functions, we transform any pair 1
and 2 of compatible DLP-functions into a DLP-function EQT(1 , 2 ) that has a stable
model i there is some stable model M  SM(1 ) for which there is no stable model
N  SM(2 ) with M  Atv (1 ) = N  Atv (2 ). We form the translation as a composition
of DLP-functions in order to fully exploit the compositionality of the stable model semantics
when justifying the correctness of the method.
In what follows, we use new atoms a , a , and a not appearing in At(1 )  At(2 )
for any atom a, and we use the shorthand A = {a | a  A} for any set A of atoms, and
848

fiModularity Aspects of Disjunctive Stable Models

analogously dened shorthands A and A . Moreover, diff, unsat, unsat , and ok are new
atoms not appearing in At(1 )  At(2 ). The translation EQT(1 , 2 ), which is to be
summarized by Denition 8.4 below, consists of the following three parts:
(i) The DLP-function 1 naturally captures a stable model M  SM(1 ).
(ii) The DLP-function hidden(2 ) = hRh , I  O, H  , i provides a representation for the
hidden part of 2 = hR, I, O, Hi evaluated with respect to the visible part of M . The
input signature of hidden(2 ) consists of the visible atoms in Atv (2 ) = Atv (1 ) = I 
O. The set Rh contains a rule Ah  Bv Bh , (Av Cv Ch ) for each A  B, C  R
such that Ah 6= , i.e., A  B, C  Def R (H). The hidden parts of rules are renamed
systematically using atoms from Ath (2 ) . This is to capture the unique stable model
N for (2 )h /Mv expressed in Ath (2 ) rather than Ath (2 ). Note that the existence
and uniqueness of such an N is guaranteed by the EVA property.
(iii) Finally, the DLP-function
TR(2 ) = hRTR , I  O  H  , O  H   {unsat, unsat , diff, ok}, O  H  i
provides a minimality check. The set RTR contains
1. a rule unsat  Bv  Bh , (Av  Ah  Cv  Ch ) for each rule A  B, C  R,
2. rules a  a, a , unsat and a  a, a , unsat for each a  O, and rules
a  a , a , unsat and a  a , a , unsat for each a  H,
3. a rule unsat  Bi  Bo  Bh , (Ai  Ao  Ah  Cv  Ch ), unsat for each rule
A  B, C  R,
4. a rule diff  a, a , unsat for each a  O, and a rule diff  a , a , unsat for
each a  H, and
5. the following rules:
ok  unsat,

ok  diff, unsat, unsat ,

and   ok.

The intuition behind the translation TR(2 ) is as follows. The rules in the rst
item check whether an interpretation L  At(2 ) corresponding to the actual input
K = (L  (I  O))  {a | a  L  H}  Atv (2 )  Ath (2 ) for TR(2 ) satises the
rules in 2 . If the rules of 2 are satised, then the rules in items 24 are activated
by the literals unsat in their bodies. The rules in the second item are used to
generate a subset L of L such that L  Ati (2 ) = L  Ati (2 ). This is achieved by
introducing a new atom a for each a  Ato (2 )  Ath (2 ). The rules in the third
item check whether the representation of L in Ati (2 )  Ato (2 )  Ath (2 ) , i.e.,
K  = (L  I)  {a | a  L  (O  H)}, satises the rules in L
2 . The rules in the
fourth item check whether L is a proper subset of L. Finally, the rules in the fth
item summarize the reasons why L cannot be a stable model of 2 , i.e., either the
rules in 2 are not satised in L, or L is not a minimal model of L
2 . As the net eect
of this construction, TR(2 )/K has a stable model i L is not a stable model of 2 .
849

fiJanhunen, Oikarinen, Tompits & Woltran

Definition 8.4 Let 1 and 2 = hR, I, O, Hi be compatible DLP-functions having enough
visible atoms. Then, the translation EQT(1 , 2 ) is given by 1  hidden(2 )  TR(2 ).
The translation TR(2 ) for the minimality check essentially contains the same rules as
TR(R1 , R2 ) \ R1 , where TR(R1 , R2 ) is the translation dened by Oikarinen and Janhunen
(2004) for sets R1 and R2 of disjunctive rules. There are two further aspects, however.
First, occurrences of hidden atoms from H are additionally represented using their counterparts from H  . Second, we only need renamed versions of atoms in O  H because the
interpretation of atoms in the input signature I is kept xed. Finally, we note that for
DLP-functions 1 and 2 which correspond to ordinary disjunctive logic programs, i.e.,
for 1 = hR1 , , O, i and 2 = hR2 , , O, i, the translation EQT(1 , 2 ) coincides with
TR(R1 , R2 ).
Theorem 8.5 Let 1 and 2 be compatible DLP-functions having enough visible atoms.
Then, 1 m 2 iff both SM(EQT(1 , 2 )) =  and SM(EQT(2 , 1 )) = .
Proof sketch. Let 1 and 2 = hR, I, O, Hi be compatible DLP-functions having enough
visible atoms. By Theorem 5.7, given compatible interpretations M1  At(1 ), M2 
At(hidden(2 )), and M3  At(TR(2 )), M = M1 M2 M3 is a stable model of the translation EQT(1 , 2 ) i M1  SM(1 ), M2  SM(hidden(2 )), and M3  SM(TR(2 )). Given
any interpretation M1  At(1 ), there is a unique stable model M2  SM(hidden(2 ))
compatible with M1 , since 2 has the EVA property. Hence, hidden(2 ) does not constrain
stable models in the composition EQT(1 , 2 ). Whenever M3 is compatible with both M1
and M2 , it holds that M3 (I OH  ) = (M1 M2 )(I OH  ) and M3  SM(TR(2 )) i
the interpretation M3 (I O){a  H | a  M3 } is not a stable model of 2 as established
by Oikarinen and Janhunen (2004, Theorem 1).

When verifying modular equivalence of DLP-functions of the forms 1   and 2  ,
it is possible to further streamline the translations involved in the verication task.
Theorem 8.6 Let 1 and 2 be compatible DLP-functions having enough visible atoms,
and  a DLP-function such that 1   and 2   are defined. Then, 1   m 2  
iff both SM(EQT(1 , 2 )  ) =  and SM(EQT(2 , 1 )  ) = .
The context  can be an arbitrary DLP-function, i.e., it is not necessary for  to have the
EVA property, as long as 1   and 2   are dened. To prove Theorem 8.6, notice
that due to the structure of the translation, EQT(1 , 2 )   is dened whenever 1   is
dened, and then Theorems 5.7 and 8.5 can be applied.

9. Related Work
Eiter et al. (1997a) consider the use of disjunctive datalog programs as query programs over
relational databases. In their approach, query programs are formalized as triples h, R, Si
where  is a set of disjunctive rules and R and S are the signatures for the input and output
relations, respectively, whereas auxiliary (hidden) predicates are left implicit. Hence, in the
propositional case, the only notable dierence with respect to Denition 2.1 is that input
atoms are not allowed to occur in the heads of disjunctive rules. As regards semantics, the
850

fiModularity Aspects of Disjunctive Stable Models

program  is reduced with respect to a complete input database D specied in terms of
R, yielding the instantiation [D], and, among others, stable-model semantics is applied to
[D] in analogy to Denition 3.2. However, in contrast to our modular architecture, Eiter
et al. (1997a) take both positive and negative dependencies into account and no recursion
between modules is tolerated. The resulting hierarchy of complete components admits a
straightforward generalization of the splitting sequences (Lifschitz & Turner, 1994). The
essential dierence is that a partial order rather than a total order of modules is assumed.
In this respect, it is worth pointing out that partial orders of DLP-functions are permitted
by .
Modularity has gained more attention in the context of conventional (monotonic) logic
programming; see the work of Bugliesi, Lamma, and Mello (1994) for a survey. Two mainstream approaches are identied: The rst is called programming-in-the-large in which algebraic operators are introduced for the construction of logic programs out of modules. The
approach of our paper falls into this categorythe join  being an example of such operators.
The other, and quite dierent programming-in-the-small approach, is to extend the underlying logical language in terms of abstraction mechanisms. In the approach of Eiter et al.
(1997b), for instance, logic program modules are viewed as generalized quantifiers which are
allowed to nest but only in a hierarchical fashion. To give an idea of this approach, consider
a module that formalizes the transitive closure of a relation denoted by a predicate rel(, ):
tclo(x, y)  rel(x, y);

tclo(x, y)  tclo(x, z), rel(z, y).

Here, tclo(, ) acts as the output predicate of the module tclo[rel] whereas rel(, ) is its only
input predicate. The module can be invoked to create the transitive closure of any binary
relation substituted for rel(, ) above. Consider, for instance, the rule
loop(x)  tclo[edge](x, y), tclo[edge](y, x)
which captures nodes involved in the loops of a directed graph whose edges are supposed to
be represented with the predicate edge(, ). In our approach, the call tclo[edge] would result
in one module as part of the respective ground program with input and output signatures
In = {edge(x, y) | 1  x, y  n} and On = {tclo(x, y) | 1  x, y  n}
in the case of n vertices. However, in the architecture of Eiter et al. (1997b), the module
tclo[rel] can be invoked several times to form transitive closures of dierent relations. In our
eectively propositional approach, each invocation of tclo[rel] would map to a new module.
Although these modules could be obtained by straightforward renaming of predicates, this
aspect illustrates the power of the programming-in-the-small approach. Here, tclo[rel] acts
as a new parameterized connective which the programmer can concisely refer to as a new
relation, viz. the transitive closure of rel in this case. But, in spite of succinctness at this
point, such relations may have to be unwound in an actual implementation. This aspect is
made explicit in the modular action description (MAD) language proposed by Lifschitz and
Ren (2006): a modular action description is turned into a single-module description in a
recursive fashion. The outcome determines the meaning of the modular description via an
embedding into ASP (Lifschitz & Turner, 1999).
Faber, Greco, and Leone (2007) apply the magic-set method in the evaluation of datalog
programs with negation. Their notion of a module is based on the concept of an independent
851

fiJanhunen, Oikarinen, Tompits & Woltran

set. For a non-disjunctive logic program  = hR, , O, i, such a set S  O satises, for any
a  S, the following two conditions:
1. if there is a rule h  B, C  R such that h = a, then B  C  S, and
2. if a  B  C for some dangerous rule h  B, C  R, then {h}  B  C  S.
We skip the exact denition of dangerous rules which, roughly speaking, may interfere with
the existence of stable models. It is clear that independent sets are splitting sets in the sense
of Denition 5.15, but not vice versa in general. Hence, the module theorem provided by
Faber et al. (2007) can be viewed as a special case of the splitting-set theorem and, therefore,
observations presented in Section 5.3 apply to independent sets as well.

10. Conclusion and Discussion
In this paper, we introduced a formal framework for modular programming in the context
of disjunctive logic programs under stable-model semantics. The framework is based on the
notion of a DLP-function which puts into eect appropriate input/output interfacing for
disjunctive logic programs. Analogous module concepts have already been studied in the
cases of normal logic programs and smodels programs (Oikarinen & Janhunen, 2008a) and
even propositional theories (Janhunen, 2008a), but the special characteristics of disjunctive
rules are properly taken into account in the syntactic and semantic denitions of DLPfunctions presented herein. In this respect, we would like to draw the readers attention to
Denition 2.1 (item 2), Denition 2.2 (items 45), as well as Denition 3.2.
Undoubtedly, the main result of this paper is the module theorem, i.e., Theorem 5.7,
which is proved for DLP-functions in generalthus covering the class of disjunctive programs. The module theorem is important as it provides a compositional semantics for
disjunctive programs and it generalizes existing approaches such as those based on splitting sets (Lifschitz & Turner, 1994) and magic sets (Faber et al., 2007). Although our
approach is based on a number of design decisions, e.g., as regards the denition of module
composition, it nevertheless brings out the limits of modular programming in the context
of a nonmonotonic declarative language. The module theorem can be exploited in a number of ways in ASP based on disjunctive logic programs. As demonstrated in Section 6, it
provides the basis for decomposing disjunctive programs into their components and hence
the localization of reasoning tasks. Moreover, as established in Section 7, the technique of
shifting disjunctive rules can be generalized for disjunctive programs involving head-cycles.
Actually, the generalized form enables us to remove shared disjunctive rules altogether but
this might not be desirable due to higher space requirements. Finally, the theory of modular
equivalence is fully applicable to DLP-functions as demonstrated in Section 8.
In addition to the results discussed above, we anticipate further applications of the module theorem in the future. We strongly believe that research in this direction not only yields
results of theoretical interest but also leads to the development of practicably useful software
engineering methods for ASP. In fact, rst tools for decomposing and linking programs have
already been implemented in the context of the smodels system.14 The results of Section 6 enable the development of analogous tools to be used with disjunctive solvers such as
14. See modlist and lpcat in the ASP tools collection at http://www.tcs.hut.fi/Software/asptools/.

852

fiModularity Aspects of Disjunctive Stable Models

claspD, cmodels, dlv, and GnT. There is also an implementation of the general shifting
principle, called dencode, in the ASP tool collection. The results of Section 8 pave the way
for extending a translation-based verication tool, dlpeq (Janhunen & Oikarinen, 2004),
for the verication of modular equivalence. Such an extension is already available in the
respective tool, lpeq, for smodels programs (Oikarinen & Janhunen, 2009).15
Acknowledgments This work was partially supported by the Academy of Finland under projects #211025 (Advanced Constraint Programming Techniques for Large Structured Problems) and #122399 (Methods for Constructing and Solving Large Constraint
Models), and by the Austrian Science Foundation (FWF) under projects P18019 (Formal Methods for Comparing and Optimizing Nonmonotonic Logic Programs) and P21698
(Methods and Methodologies for Developing Answer-Set Programs). The authors would
like to thank the anonymous referees for their constructive comments as well as Martin Gebser and Torsten Schaub for their suggestion to exploit program completion and loop formulas
in the proof of the module theorem. A preliminary version of this paper appeared in the
proceedings of the 9th International Conference on Logic Programming and Nonmonotonic
Reasoning (LPNMR07), Vol. 4483 of LNCS, pp. 175187, Tempe, AZ, USA, Springer.

References
Baral, C., Dzifcak, J., & Takahashi, H. (2006). Macros, macro calls and use of ensembles in
modular answer set programming. In Etalle, S., & Truszczyski, M. (Eds.), Proceedings
of the 22nd International Conference on Logic Programming (ICLP06 ), Vol. 4079 of
LNCS, pp. 376390, Seattle, WA, USA. Springer.
Ben-Eliyahu, R., & Dechter, R. (1994). Propositional semantics for disjunctive logic programs. Annals of Mathematics and Artificial Intelligence, 12 (12), 5387.
Bugliesi, M., Lamma, E., & Mello, P. (1994). Modularity in logic programming. Journal of
Logic Programming, 19/20, 443502.
Clark, K. L. (1978). Negation as failure. In Gallaire, H., & Minker, J. (Eds.), Logic and
Data Bases, pp. 293322. Plenum Press, New York.
Dix, J., Gottlob, G., & Marek, V. W. (1996). Reducing disjunctive to non-disjunctive
semantics by shift-operations. Fundamenta Informaticae, 28 (1-2), 87100.
Drescher, C., Gebser, M., Grote, T., Kaufmann, B., Knig, A., Ostrowski, M., & Schaub,
T. (2008). Conict-driven disjunctive answer set solving. In Brewka, G., & Lang, J.
(Eds.), Proceedings of the 11th International Conference on Principles and Knowledge
Representation and Reasoning, pp. 170176, Sydney, Australia. AAAI Press.
Eiter, T., & Fink, M. (2003). Uniform equivalence of logic programs under the stable model
semantics. In Palamidessi, C. (Ed.), Proceedings of the 19th International Conference
on Logic Programming (ICLP03), Vol. 2916 of LNCS, pp. 224238, Mumbay, India.
Springer.
15. Verification tools mentioned here are available at http://www.tcs.hut.fi/Software/lpeq/.

853

fiJanhunen, Oikarinen, Tompits & Woltran

Eiter, T., Fink, M., Tompits, H., & Woltran, T. (2004). Simplifying logic programs under
uniform and strong equivalence. In Lifschitz, V., & Niemel, I. (Eds.), Proceedings of
the 7th International Conference on Logic Programming and Nonmonotonic Reasoning
(LPNMR04 ), Vol. 2923 of LNAI, pp. 8799, Fort Lauderdale, FL, USA. Springer.
Eiter, T., & Gottlob, G. (1995). On the computational cost of disjunctive logic programming:
Propositional case. Annals of Mathematics and Artificial Intelligence, 15 (3-4), 289
323.
Eiter, T., Gottlob, G., & Mannila, H. (1997a). Disjunctive datalog. ACM Transactions on
Database Systems, 22 (3), 364418.
Eiter, T., Gottlob, G., & Veith, H. (1997b). Modular logic programming and generalized
quantiers. In Dix, J., Furbach, U., & Nerode, A. (Eds.), Proceedings of the 4th
International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR97 ), Vol. 1265 of LNCS, pp. 290309, Dagstuhl, Germany. Springer.
Eiter, T., Ianni, G., Lukasiewicz, T., Schindlauer, R., & Tompits, H. (2008). Combining
answer set programming with description logics for the Semantic Web. Artificial
Intelligence, 172 (1213), 14951539.
Erdem, E., & Lifschitz, V. (2003). Tight logic programs. Theory and Practice of Logic
Programming, 3 (4-5), 499518.
Faber, W., Greco, G., & Leone, N. (2007). Magic sets and their application to data integration. Journal of Computer and System Sciences, 73, 584609.
Gaifman, H., & Shapiro, E. (1989). Fully abstract compositional semantics for logic programs. In Proceedings of the 16th Annual ACM Symposium on Principles of Programming Languages, pp. 134142, Austin, TX, USA. ACM Press.
Gebser, M., Kaminski, R., Kaufmann, B., Ostrowski, M., Schaub, T., & Thiele, S. (2008a).
Engineering an incremental ASP solver. In de la Banda, M., & Pontelli, E. (Eds.),
Proceedings of the 24th International Conference on Logic Programming (ICLP08),
Vol. 5366 of LNCS, pp. 190205, Udine, Italy. Springer.
Gebser, M., Schaub, T., Thiele, S., Usadel, B., & Veber, P. (2008b). Detecting inconsistencies in large biological networks with answer set programming. In de la Banda,
M., & Pontelli, E. (Eds.), Proceedings of the 24th International Conference on Logic
Programming (ICLP08), Vol. 5366 of LNCS, pp. 130144, Udine, Italy. Springer.
Gelfond, M., & Gabaldon, A. (1999). Building a knowledge base: An example. Annals of
Mathematics and Artificial Intelligence, 25 (3-4), 165199.
Gelfond, M., & Leone, N. (2002). Logic programming and knowledge representation  the
A-Prolog perspective. Artificial Intelligence, 138 (1-2), 338.
Gelfond, M., & Lifschitz, V. (1988). The stable model semantics for logic programming. In
Kowalski, R. A., & Bowen, K. A. (Eds.), Proceedings of the 5th International Conference on Logic Programming (ICLP88), pp. 10701080, Seattle, WA, USA. MIT
Press.
854

fiModularity Aspects of Disjunctive Stable Models

Gelfond, M., & Lifschitz, V. (1991). Classical negation in logic programs and disjunctive
databases. New Generation Computing, 9, 365385.
Gelfond, M., Przymusinska, H., Lifschitz, V., & Truszczyski, M. (1991). Disjunctive defaults. In Allen, J. F., Fikes, R., & Sandewall, E. (Eds.), Proceedings of the 2nd International Conference on Principles and Knowledge Representation and Reasoning, pp.
230237, Cambridge, MA, USA. Morgan Kaufmann.
Giunchiglia, E., Lierler, Y., & Maratea, M. (2006). Answer set programming based on
propositional satisability. Journal of Automated Reasoning, 36 (4), 345377.
Janhunen, T. (2006). Some (in)translatability results for normal logic programs and propositional theories. Journal of Applied Non-Classical Logics, 16 (12), 3586.
Janhunen, T. (2008a). Modular equivalence in general. In Ghallab, M., Spyropoulos, C.,
Fakotakis, N., & Avouris, N. (Eds.), Proceedings of the 18th European Conference on
Artificial Intelligence (ECAI08), pp. 7579, Patras, Greece. IOS Press.
Janhunen, T. (2008b). Removing redundancy from answer set programs. In de la Banda,
M., & Pontelli, E. (Eds.), Proceedings of the 24th International Conference on Logic
Programming (ICLP08), Vol. 5366 of LNCS, pp. 729733, Udine, Italy. Springer.
Janhunen, T., Niemel, I., Seipel, D., Simons, P., & You, J.-H. (2006). Unfolding partiality
and disjunctions in stable model semantics. ACM Transactions on Computational
Logic, 7 (1), 137.
Janhunen, T., & Oikarinen, E. (2004). lpeq and dlpeq  translators for automated equivalence testing of logic programs. In Lifschitz, V., & Niemel, I. (Eds.), Proceedings of
the 7th International Conference on Logic Programming and Nonmonotonic Reasoning
(LPNMR04 ), Vol. 2923 of LNAI, pp. 336340, Fort Lauderdale, FL, USA. Springer.
Janhunen, T., & Oikarinen, T. (2007). Automated verication of weak equivalence within
the smodels system. Theory and Practice of Logic Programming, 7 (6), 697744.
Junttila, T., & Niemel, I. (2000). Towards an ecient tableau method for boolean circuit
satisability checking. In Lloyd, J. W., et al. (Eds.), Proceedings of the First International Conference on Computational Logic (CL 2000), Vol. 1861 of LNCS, pp. 553567,
London, UK. Springer.
Koch, C., Leone, N., & Pfeifer, G. (2003). Enhancing disjunctive logic programming systems
by SAT checkers. Artificial Intelligence, 151 (1-2), 177212.
Lee, J., & Lifschitz, V. (2003). Loop formulas for disjunctive logic programs. In Palamidessi,
C. (Ed.), Proceedings of the 19th International Conference on Logic Programming
(ICLP03 ), Vol. 2916 of LNCS, pp. 451465, Mumbay, India. Springer.
Leone, N., Pfeifer, G., Faber, W., Eiter, T., Gottlob, G., & Scarcello, F. (2006). The DLV
system for knowledge representation and reasoning. ACM Transactions on Computational Logic, 7 (3), 499562.
855

fiJanhunen, Oikarinen, Tompits & Woltran

Lifschitz, V. (1985). Computing circumscription. In Joshi, A. K. (Ed.), Proceedings of the
9th International Joint Conference on Artificial Intelligence (IJCAI85 ), pp. 121127,
Los Angeles, CA, USA. Morgan Kaufmann.
Lifschitz, V., Pearce, D., & Valverde, A. (2001). Strongly equivalent logic programs. ACM
Transactions on Computational Logic, 2 (4), 526541.
Lifschitz, V., & Ren, W. (2006). A modular action description language. In Proceedings
of the 21st National Conference on Artificial Intelligence (AAAI06), pp. 853859,
Boston, MA, USA. AAAI Press.
Lifschitz, V., & Turner, H. (1994). Splitting a logic program. In Hentenryck, P. V. (Ed.),
Proceedings of the 11th International Conference on Logic Programming (ICLP94 ),
pp. 2337, Santa Margherita Ligure, Italy. MIT Press.
Lifschitz, V., & Turner, H. (1999). Representing transition systems by logic programs. In
Gelfond, M., Leone, N., & Pfeifer, G. (Eds.), Proceedings of the 6th International
Conference on Logic Programming and Nonmonotonic Reasoning, (LPNMR99 ), Vol.
1730 of LNAI, pp. 92106, El Paso, TX, USA. Springer.
Lin, F., & Zhao, Y. (2004). ASSAT: computing answer sets of a logic program by SAT
solvers. Artificial Intelligence, 157 (1-2), 115137.
Marek, V. W., & Truszczyski, M. (1999). Stable models and an alternative logic programming paradigm. In Apt, K. R., Marek, V. W., Truszczyski, M., & Warren,
D. S. (Eds.), The Logic Programming Paradigm: a 25-Year Perspective, pp. 375398.
Springer.
McCarthy, J. (1986). Applications of circumscription to formalizing commonsense knowledge. Artificial Intelligence, 28, 89116.
Niemel, I. (1999). Logic programs with stable model semantics as a constraint programming
paradigm. Annals of Mathematics and Artificial Intelligence, 25 (34), 241273.
Oikarinen, E., & Janhunen, T. (2004). Verifying the equivalence of logic programs in the
disjunctive case. In Lifschitz, V., & Niemel, I. (Eds.), Proceedings of the 7th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR04 ),
Vol. 2923 of LNAI, pp. 180193, Fort Lauderdale, FL, USA. Springer.
Oikarinen, E., & Janhunen, T. (2008a). Achieving compositionality of the stable model
semantics for smodels programs. Theory and Practice of Logic Programming, 8 (56),
717761.
Oikarinen, E., & Janhunen, T. (2008b). Implementing prioritized circumscription by computing disjunctive stable models. In Dochev, D., Pistore, M., & Traverso, P. (Eds.),
Artificial Intelligence: Methodology, Systems, and Applications, 13th International
Conference (AIMSA08), Vol. 5253 of LNCS, pp. 167180, Varna, Bulgaria. Springer.
Oikarinen, E., & Janhunen, T. (2009). A translation-based approach to the verication of
modular equivalence. Journal of Logic and Computation, 19 , 591613.
856

fiModularity Aspects of Disjunctive Stable Models

Reiter, R. (1987). A theory of diagnosis from rst principles. Artificial Intelligence, 32 (1),
5795.
Simons, P., Niemel, I., & Soininen, T. (2002). Extending and implementing the stable
model semantics. Artificial Intelligence, 138 (12), 181234.

857

fi