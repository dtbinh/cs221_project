Journal of Artificial Intelligence Research 35 (2009) 717-773

Submitted 12/08; published 08/09

The Complexity of Circumscription in Description Logic
Piero A. Bonatti

bonatti@na.infn.it

Section of Computer Science, Department of Physics
University of Naples Federico II, Italy

Carsten Lutz

clu@informatik.uni-bremen.de

Department of Mathematics and Computer Science
University of Bremen, Germany

Frank Wolter

wolter@liverpool.ac.uk

Department of Computer Science
University of Liverpool, UK

Abstract
As fragments of first-order logic, Description logics (DLs) do not provide nonmonotonic
features such as defeasible inheritance and default rules. Since many applications would
benefit from the availability of such features, several families of nonmonotonic DLs have
been developed that are mostly based on default logic and autoepistemic logic. In this
paper, we consider circumscription as an interesting alternative approach to nonmonotonic
DLs that, in particular, supports defeasible inheritance in a natural way. We study DLs
extended with circumscription under different language restrictions and under different
constraints on the sets of minimized, fixed, and varying predicates, and pinpoint the exact
computational complexity of reasoning for DLs ranging from ALC to ALCIO and ALCQO.
When the minimized and fixed predicates include only concept names but no role names,
then reasoning is complete for NExpNP . It becomes complete for NPNExp when the number
of minimized and fixed predicates is bounded by a constant. If roles can be minimized or
fixed, then complexity ranges from NExpNP to undecidability.

1. Introduction
Early knowledge representation (KR) formalisms such as semantic networks and frames
included a wealth of features in order to provide as much expressive power as possible
(Quillian, 1968; Minsky, 1975). In particular, such formalisms usually admitted a structured representation of classes and objects similar to modern description logics (DLs), but
also mechanisms for defeasible inheritance, default rules, and other features that are nowadays studied in the area of nonmonotonic logics (NMLs). When KR theory developed
further, the all-embracing approaches were largely given up in favour of more specialized
ones due to unfavourable computational properties and problems with the semantics. This
process has caused DLs and NMLs to develop into two independent subfields. Consequently,
modern description logics such as SHIQ lack the expressive power to represent defeasible
inheritance and other nonmonotonic features (Horrocks, Sattler, & Tobies, 2000).
Despite (or due to) this development, there has been a continuous interest in the
(re)integration of nonmonotonic features into description logics. In recent years, the advent of several new applications of DLs have increased this interest even further. We briefly
discuss two of them. First, DLs have become a popular tool for the formalization of biomedc
2009
AI Access Foundation. All rights reserved.

fiBonatti, Lutz, & Wolter

ical ontologies such as GALEN (Rector & Horrocks, 1997) and SNOMED (Cote, Rothwell,
Palotay, Beckett, & Brochu, 1993). As argued for example by Rector (2004) and Stevens
et al. (2005), it is important for such ontologies to represent exceptions of the form in
humans, the heart is usually located on the left-hand side of the body; in humans with
situs inversus, the heart is located on the right-hand side of the body. Modelling such
situations requires defeasible inheritance, i.e., properties transfer to all instances of a class
by default, but can be explicitly overridden in special cases (McCarthy, 1986; Horty, 1994;
Brewka, 1994; Baader & Hollunder, 1995b). The second application is the use of DLs as security policy languages (Uszok, Bradshaw, Johnson, Jeffers, Tate, Dalton, & Aitken, 2004;
Kagal, Finin, & Joshi, 2003; Tonti, Bradshaw, Jeffers, Montanari, Suri, & Uszok, 2003). In
formalizing access control policies, one must deal with the situation where a given request
is neither explicitly allowed nor explicitly denied. Then, a default decision has to be taken
such as in open and closed policies, where authorizations are respectively granted or denied
by default (Bonatti & Samarati, 2003). Moreover, policies are often formulated incrementally, i.e., start with general authorizations for large classes of subjects, objects, and actions,
and then progressively refine them by introducing exceptions for specific subclasses. This
approach is clearly an incarnation of defeasible inheritance.
While the above applications illustrate that integrating nonmonotonic features into DLs
is worthwhile, the actual engineering of a computationally well-behaved nonmonotonic DL
that provides sufficient expressive power turns out to be a non-trivial task. In particular,
combinations of DLs and nonmonotonic logics typically involve subtle interactions between
the two component logics and this easily leads to undecidability. It appears that there is no
one optimal way to circumnavigate these difficulties, and thus many different combinations
of DLs and nonmonotonic logics have been proposed in the literature, each with individual
strengths and limitations (we provide a survey in Section 7). However, there is a striking
gap: almost all existing approaches are based on default logic and autoepistemic logic, while
circumscription has received very little attention in connection with DLs, and the computational properties of DLs with circumscription have been almost completely unknown. This
is all the more surprising since circumscription is known to be one of the weakest forms of
nonmonotonic reasoningsee the work by Janhunen (1999) for one of the most recent surveys, and the paper by Bonatti and Eiter (1996) for an expressiveness analysis in terms of
queries. Therefore, it is a natural idea to use circumscription for defining a computationally
well-behaved, yet expressive DL with nonmonotonic features.
In this paper, we study circumscription (McCarthy, 1980) as an alternative approach
to defining nonmonotonic DLs. In particular, we define a family of DLs with circumscription that enable a natural modelling of defeasible inheritance. Our general approach is to
generalize standard DL knowledge bases to circumscribed knowledge bases (cKBs) which,
additionally to a TBox for representing terminological knowledge and an ABox for representing knowledge about individuals, are equipped with a circumscription pattern. This
pattern lists predicates (i.e., concept and role names) to be minimized in the sense that, in
all admitted models of the cKB, the extension of the listed predicates has to be minimal
w.r.t. set inclusion. Following McCarthy (1986), the minimized predicates can be used as
abnormality predicates that identify instances which are not typical for their class. Circumscription patterns can require other predicates to be fixed during minimization, or allow
them to vary freely (McCarthy, 1986). A main feature of the DLs of our family is that they
718

fiThe Complexity of Circumscription in DLs

come with a built-in mechanism for defeasible inheritance: by default, the properties of a
class (humans in the first example above) transfer to each subclass (humans with situs
inversus), but exceptions can be specified based on a priority mechanism. It is well-known
that defeasible inheritance with priority cannot be modularly encoded with pure default or
autoepistemic logic (Horty, 1994), and workarounds such as the explicit listing of exceptions
lead to serious maintainability problems. Circumscription lends itself naturally to priorities,
based on circumscription patterns that can express preferences between minimized predicates in terms of a partial ordering. As argued by Baader and Hollunder (1995b), such an
approach is well-suited to ensure a smooth interplay between defeasible inheritance and DL
subsumption, and thus we prefer it over traditional prioritized circumscription.
To achieve decidability, nonmonotonic DLs usually have to adopt suitable restrictions
on the expressive power of the DL component, on non-monotonic features, or their interaction. In the case of default logic and autoepistemic logic, a typical restriction concerns
the different treatment of individuals that are explicitly denoted by a constant, and those
that are not. This goes back to reasoning in first-order default logic (Reiter, 1980) and
autoepistemic logic (Moore, 1985), which also involve tricky technical issues related to the
denotation of individuals. To make reasoning decidable in DLs based on default logic, default rules are applied only to the individuals denoted by constants that occur explicitly
in the knowledge base (Baader & Hollunder, 1995a), but not to unnamed individuals. As
a consequence, named and unnamed individuals are not treated uniformly. In approaches
based on autoepistemic logic (Donini, Lenzerini, Nardi, Nutt, & Schaerf, 1998; Donini,
Nardi, & Rosati, 1997, 2002), an alternative solution is to restrict the domain to a fixed, denumerable set of constants. This approach overcomes the different treatment of named and
unnamed individuals since all individuals are named. The flipside is that ad-hoc encodings
are required when the domain is finite or the unique name assumption is not enforced, i.e.,
when different constants are allowed to denote the same individual. In this respect, DLs
with circumscription pose no difficulty at all, and named individuals are treated in exactly
the same way as unnamed ones without any assumptions on the domain. At the same
time, we are able to base our nonmonotonic DLs on rather expressive DL components such
as ALCIO and ALCQO without losing decidability. However, we cannot do without any
restrictions either: we only allow to fix and minimize concept names during circumscription
and require that all role names vary.
The main contribution of this paper is a detailed analysis of the computational properties
of reasoning with cKBs. We show that, in the expressive DLs ALCIO and ALCQO, instance
checking, satisfiability and subsumption are decidable for concept-circumscribed KBs in
which only concept names (and no role names) are minimized and fixed. More precisely, we
prove that these reasoning problems are NExpNP -complete, where the lower bound applies
already to concept-circumscribed KBs in ALC with empty preference relation and without
fixed concept names and (1) empty TBox or (2) empty ABox and acyclic TBox. In addition,
we show that if a constant bound is imposed on the number of minimized and fixed concept
names, then the complexity drops to NPNExp .
The situation is completely different when role names are minimized or fixed. First, the
complexity of reasoning with cKBs formulated in ALC with a single fixed role name, empty
TBox, empty preference relation, and no minimized role names turns out to be outside the
analytic hierarchy, and thus very highly undecidable. This result is shown by a reduction
719

fiBonatti, Lutz, & Wolter

Name

Syntax
r

inverse role
nominal
negation
conjunction
disjunction
at-least restriction
at-most restriction

{a}
C
C uD
C tD
(> n r C)
(6 n r C)

Semantics
(rI )` = {(d, e) | (e, d)  rI }
{aI }
I \ C I
C I  DI
C I  DI
{d  I | #{e  C I | (d, e)  rI }  n}
{d  I | #{e  C I | (d, e)  rI }  n}

Figure 1: Syntax and semantics of ALCQIO.

of satisfiability in monadic second-order logic (MSO) with binary predicates over arbitrary
(i.e., not necessarily tree-shaped) structures. The reduction does not apply to cKBs in
which role names can be minimized, but not fixed. Surprisingly, we find that in this case
reasoning with empty TBoxes becomes decidable (and again NExpNP -complete) for DLs
between ALC and ALCQO, and only for ALCI and its extensions it is undecidable. For all
these logics, however, adding acyclic TBoxes leads to undecidability. The reader can find a
table summarising the complexity results in Section 7.
It is interesting to note that our results are somewhat unusual from the perspective of
NMLs. First, the arity of predicates has an impact on decidability: fixing concept names
(unary predicates) does not impair decidability, whereas fixing a single role name (binary
predicate) leads to a strong undecidability result. Second, the number of predicates that
are minimized or fixed (bounded vs. unbounded) affects the computational complexity of
reasoning. Although (as we note in passing) a similar effect can be observed in propositional
logic with circumscription, this has, to the best of our knowledge, never been explicitly
noted.
The paper is organized as follows. In the next section we introduce syntax, semantics,
and reasoning problems for circumscribed KBs, and provide some examples. Section 3
provides some basic results such as a polynomial simulation of fixed concepts by means of
minimized concepts, a polynomial reduction of reasoning with general TBoxes to reasoning with acyclic TBoxes, and a polynomial reduction of the simultaneous satisfiability of
multiple cKBs to standard satisfiability. Then, Section 4 proves the decidability and complexity results for concept-circumscribed knowledge bases. Fixed and minimized roles are
considered in Sections 5 and 6, respectively. Section 7 discusses related work, and Section 8
concludes the paper by summarizing the main results and pointing out some interesting
directions for further research. To improve readability, many proof details are deferred to
the appendix. This paper is an extended version of the article by Bonatti, Lutz, and Wolter
(2006).

2. Description Logics and Circumscription
In DLs, concepts are inductively defined with the help of a set of constructors, starting with
a set NC of concept names, a set NR of role names, and (possibly) a set NI of individual
720

fiThe Complexity of Circumscription in DLs

names (all countably infinite). We use the term predicates to refer to elements of NC  NR .
The concepts of the expressive DL ALCQIO are formed using the constructors shown in
Figure 1.
There, the inverse role constructor is a role constructor, whereas the remaining six
constructors are concept constructors. In Figure 1 and throughout this paper, we use #S
to denote the cardinality of a set S, a and b to denote individual names, r and s to denote
roles (i.e., role names and inverses thereof), A, B to denote concept names, and C, D to
denote (possibly complex) concepts. As usual, we use > as abbreviation for an arbitrary
(but fixed) propositional tautology,  for >,  and  for the usual Boolean abbreviations,
r.C (existential restriction) for (> 1 r C), and r.C (universal restriction) for (6 0 r C).
In this paper, we will not be concerned with ALCQIO itself, but with several of its
fragments.1 The basic such fragment allows only for negation, conjunction, disjunction,
and universal and existential restrictions, and is called ALC. The availability of additional
constructors is indicated by concatenation of a corresponding letter: Q stands for number restrictions, I stands for inverse roles, and O for nominals. This explains the name
ALCQIO, and also allows us to refer to fragments such as ALCIO, ALCQO, and ALCQI.
The semantics of ALCQIO-concepts is defined in terms of an interpretation I =
I
( , I ). The domain I is a non-empty set of individuals and the interpretation function I maps each concept name A  NC to a subset AI of I , each role name r  NR to a
binary relation rI on I , and each individual name a  NI to an individual aI  I . The
extension of I to inverse roles and arbitrary concepts is inductively defined as shown in the
third column of Figure 1. An interpretation I is called a model of a concept C if C I 6= .
If I is a model of C, we also say that C is satisfied by I.
A (general) TBox is a finite set of concept implications (CIs) C v D where C and D are
.
concepts. As usual, we use C = D as an abbreviation for C v D and D v C. An ABox is
a finite set of concept assertions C(a) and role assertions r(a, b), where a, b are individual
names, r is a role name, and C is a concept. An interpretation I satisfies (i) a CI C v D
if C I  DI , (ii) an assertion C(a) if aI  C I , and (iii) an assertion r(a, b) if (aI , bI )  rI .
Then, I is a model of a TBox T if it satisfies all implications in T , and a model of an ABox
A if it satisfies all assertions in A.
An important class of TBoxes are acyclic TBoxes: call a TBox T acyclic if it is a set
.
of concept definitions A = C, where A is a concept name and the following two conditions
hold:
 no concept name occurs more than once on the left hand side of a definition in T ;
.
 the relation T , defined by setting A T B iff A = C  T and B occurs in C, is
well-founded.
1. The reason that we do not consider ALCQIO in this paper is that it does not have the finite model
property; i.e., there are satisfiable concepts that are not satisfiable in finite models. Our proofs of the
complexity upper bounds assume the finite model property and, therefore, do not work for ALCQIO. Investigating circumscription for description logics without the finite model property remains an interesting
open problem.

721

fiBonatti, Lutz, & Wolter

2.1 Circumscription, Varying Predicates, and Partial Priority Ordering
Circumscription is a logical approach suitable for modelling what normally or typically
holds, and thus admits the modeling of defeasible inheritance (McCarthy, 1986; Lifschitz,
1993). The idea is to define, in a standard first-order language, both domain knowledge and
so-called abnormality predicates that identify instances of a class that violate the normal or
typical properties of that class. To capture the intuition that abnormality is exceptional,
inference is not based on the set of all models of the resulting theory as in classical logic,
but rather restricted to those models where the extension of the abnormality predicates is
minimal with respect to set inclusion. Intuitively, this means that reasoning is based only
on models that are as normal as possible. Since such models are classical models of the
given knowledge base, all classical first-order inferences are valid in circumscription (but
additional inferences may become possible).
Since description logics are fragments of first-order logic, circumscription can be readily
applied. Using ALC syntax, we can assert that mammals normally inhabitate land, and
that whales do not live on land:
Mammal v habitat.Land t AbMammal
Whale v Mammal u habitat.Land
The upper inclusion states that any mammal not inhabitating land is an abnormal mammal,
thus satisfying the abnormality predicate AbMammal . When applying circumscription to the
above TBox, we should thus only consider models where the extension of AbMammal is minimal.
However, there is more than one way of defining such preferred models because each nonminimized predicate can be treated in two different ways during minimization: we may
either fix its extension or let it vary freely.
Intuitively, fixed predicates retain their classical semantics while varying predicates may
be affected by minimization. As a concrete example, consider once more the above TBox
and assume that all non-minimized predicates are fixed. Then we can derive the following
subsumptions:
Whale v AbMammal
()
.
AbMammal = Mammal u habitat.Land.
Here, Whale v AbMammal and AbMammal w Mammal u habitat.Land are classical consequences
of the TBox. The minimization of AbMammal adds only the inclusion AbMammal v Mammal u
habitat.Land.
To further analyze fixed predicates, suppose that we explicitly introduce a concrete
mammal that is not a whale by adding an ABox assertion
Mammal u Whale(flipper)
We might expect that we can derive habitat.Land(flipper), but actually that is not the
case. To see this, observe that there is a classical model of the knowledge base that falsifies
habitat.Land(flipper); the extension of the fixed predicates habitat and Land are not
affected by minimization, so habitat.Land(flipper) must still be false after minimization.
The same argument can be applied to the negation of habitat.Land(flipper), which is
thus also not derivable. What we have just seen is that if a sentence uses only fixed
722

fiThe Complexity of Circumscription in DLs

predicates, then it is a consequence of a circumscribed knowledge base if, and only if, it is
a classical consequence of the knowledge base.
Now assume that we let the role habitat and the concept name Land vary freely, and fix
only Mammal and Whale. In view of the concept inclusion for Mammal in our original TBox,
this setup may be interpreted as expressing that it is very unlikely for a mammal not to
live on land: we are willing to modify the extension of habitat and Land in order to avoid
abnormality. We obtain an additional consequence, namely:
.
Whale = AbMammal .
()
To see that this is indeed a consequence note that, during minimization, we can (i) make
Land non-empty and (ii) for any mammal m that is not a whale, ensure that m is not
an AbMammal by linking it via habitat to the generated instance of Land.2 Intuitively, the
equality () can be seen as reflecting the unlikeliness of being abnormal: a mammal is only
abnormal if there is a reason, and the only reason that we have captured in our knowledge
base is being a whale.
Let us now return to the assertion Mammal u Whale(flipper). By applying classical
reasoning to () and (), we derive Whale w Mammal u habitat.Land (i.e., whales are
the only mammals that do not live on land). Thus we can now derive the expected conclusion habitat.Land(flipper). In summary, by turning habitat and Land into varying
predicates, we have obtained a more natural modelling in which the habitat attribute of
mammals can be forced to its default value.
Driving our example further, we might now consider whales abnormal to such a degree
that we do not believe they exist unless there is evidence that they do. Then we should,
additionally, let Whale vary freely. The result is that () and () can still be derived, and
additionally we obtain the consequence
.
.
Whale = AbMammal = .
We can then use an ABox to add evidence that whales exist, e.g. through the assertion
Whale(mobydick). As expected, the result of this change is that
.
.
Whale = AbMammal = {mobydick}.
Evidence for the existence of another, anonymous whale could be generated by adding the
ABox assertion Male(mobydick) and the TBox statement
Whale v mother.(Whale u Male)
with mother and Male varying freely. This knowledge base classically entails that there exist
two whales, satisfying Male and Male, respectively. The former is denoted by mobydick,
while the latter is not denoted by any ABox individual (which corresponds to a first-order
constant). After minimization, Whale contains exactly those two individuals.
In general, the appropriate combination of fixed and varying predicates depends on the
application. Therefore, we adhere to standard circumscription and give users the freedom
to choose which predicates are minimized, fixed, and varying.
2. Indeed, this is the only reason to let Land vary: to ensure that it can be made non-empty during
minimization.

723

fiBonatti, Lutz, & Wolter

As another example, consider the sentences: In humans, the heart is usually located
on the left-hand side of the body; in humans with situs inversus, the heart is located on the
right-hand side of the body. They can be axiomatized as follows:
Human v has heart.has position.{Left} t AbHuman
Situs Inversus v has heart.has position.{Right}
has heart.has position.{Left} u has heart.has position.{Right} v  .
The predicate AbHuman represents abnormal humans and should be minimized. If humans
with situs inversus are to be restricted to those individuals that are explicitly declared to
have this property, then by analogy with the previous example the roles specifying heart
position and the class of exceptional individuals Situs Inversus should be allowed to vary
while Human can be fixed and retain its classical semantics. As a result and in the absence of
any further axioms, AbHuman and Situs Inversus are empty in all minimized models. The
additional axiom has friend.Situs Inversus(John) turns AbHuman and Situs Inversus
into a singleton set containing an anonymous individual (though in some models, it may be
John himself). As an example for a nonclassical consequence, consider:
Human u Situs Inversus v has heart.has position.{Left} ,
that is, all humans have the default heart position with the only exception of those that are
explicitly declared to have situs inversus.
It has been extensively argued (McCarthy, 1986; Horty, 1994; Brewka, 1994; Baader &
Hollunder, 1995b) that there is an interplay between subsumption and abnormality predicates that should be addressed in nonmonotonic DLs. Consider, for example, the following
TBox:
User
Staff
Staff
BlacklistedStaff

v
v
v
v

hasAccessTo.{ConfidentialFile} t AbUser
User
hasAccessTo.{ConfidentialFile} t AbStaff
Staff u hasAccessTo.{ConfidentialFile}

To get models that are as normal as possible, as a first attempt we could minimize the
two abnormality predicates AbUser and AbStaff in parallel. Assume that hasAccessTo is
varying, and User, Staff, and BlacklistedStaff are fixed. Then, the result of parallel
minimization is that staff members may or may not have access to confidential files, with
equal preference. In the first case, they are abnormal users, and in the second case, they
are abnormal staff. However, one may argue that the first option should be preferred: since
Staff v User (but not the other way round), the normality information for staff is more
specific than the normality information for users and should have higher priority. Such effects are well-known also from the propositional/first-order case and indeed, circumscription
has soon after its introduction been extended with priorities to address issues of specificity
(McCarthy, 1986).
In our formalism, users can specify priorities between minimized predicates. Typically,
these priorities will reflect the subsumption hierarchy (as computed w.r.t. the class of all
models). Since the subsumption hierarchy is in general a partial order, the priorities between
minimized predicates may form a partial order, too. This approach is analogous to partially
724

fiThe Complexity of Circumscription in DLs

ordering priorities on default rules, as proposed by Brewka (1994). It is more general
than standard prioritized circumscription, which assumes a total ordering (McCarthy, 1986;
Lifschitz, 1985), and a special case of nested circumscription (Lifschitz, 1995).
2.2 Circumscribed Knowledge Bases
To define DLs with circumscription, we start by introducing circumscription patterns. They
describe how individual predicates are treated during minimization.
Definition 1 (Circumscription pattern, <CP ) A circumscription pattern is a tuple CP
of the form (, M, F, V ), where  is a strict partial order over M , and M , F , and V
are mutually disjoint subsets of NC  NR , the minimized, fixed, and varying predicates,
respectively. By , we denote the reflexive closure of . Define a preference relation <CP
on interpretations by setting I <CP J iff the following conditions hold:
1. I = J and, for all a  NI , aI = aJ ,
2. for all p  F , pI = pJ ,
3. for all p  M , if pI 6 pJ then there exists q  M , q  p, such that q I  q J ,
4. there exists p  M such that pI  pJ and for all q  M such that q  p, q I = q J .
When M  F  NC (i.e., the minimized and fixed predicates are all concepts) we call
(, M, F, V ) a concept circumscription pattern.
4
We use the term concept circumscription if only concept circumscription patterns are admitted. Based on circumscription patterns, we can define circumscribed DL knowledge
bases and their models.
Definition 2 (Circumscribed KB) A circumscribed knowledge base (cKB) is an expression CircCP (T , A), where T is a TBox, A an ABox, and CP = (, M, F, V ) a circumscription pattern such that M, F, V partition the predicates used in T and A. An interpretation
I is a model of CircCP (T , A) if it is a model of T and A and there exists no model I 0 of T
and A such that I 0 <CP I.
A cKB CircCP (T , A) is called a concept-circumscribed KB if CP is a concept circumscription pattern.
4
Note that partially ordered circumscription becomes standard parallel circumscription if
the empty relation is used for .
The main reasoning tasks for (non-circumscribed) KBs are satisfiability of concepts
w.r.t. KBs, subsumption w.r.t. KBs, and instance checking w.r.t. KBs. These reasoning
tasks are fundamental for circumscribed KBs as well. We now provide precise definitions
of these tasks. Throughout this and the following section, DL denotes the set of DLs
introduced in the previous section; i.e., ALC, ALCI, ALCO, ALCQ, ALCQI, ALCIO,
ALCQO, and ALCQIO.
Definition 3 (Reasoning tasks)
725

fiBonatti, Lutz, & Wolter

 A concept C is satisfiable w.r.t. a cKB CircCP (T , A) if some model I of CircCP (T , A)
satisfies C I 6= . Let L  DL. The satisfiability problem w.r.t. cKBs in L is defined
as follows: given a concept C in L and a cKB CircCP (T , A) in L, decide whether C
is satisfiable w.r.t. CircCP (T , A).
 A concept C is subsumed by a concept D w.r.t. a cKB CircCP (T , A), in symbols
CircCP (T , A) |= C v D, if C I  DI for all models I of CircCP (T , A). Let L  DL.
The subsumption problem w.r.t. cKBs in L is defined as follows: given concepts C
and D in L and a cKB CircCP (T , A) in L, decide whether CircCP (T , A) |= C v D.
 An individual name a is an instance of a concept C w.r.t. a cKB CircCP (T , A), in
symbols CircCP (T , A) |= C(a), if aI  C I for all models I of CircCP (T , A). Let
L  DL. The instance problem w.r.t. cKBs in L is defined as follows: given a
concept C in L, an individual name a, and a cKB CircCP (T , A) in L, decide whether
CircCP (T , A) |= C(a).
4
These reasoning problems can be polynomially reduced to one another: first, C is satisfiable
w.r.t. CircCP (T , A) iff CircCP (T , A) 6|= C v , and CircCP (T , A) |= C v D iff C u D
is not satisfiable w.r.t. CircCP (T , A). And second, C is satisfiable w.r.t. CircCP (T , A) iff
CircCP (T , A) 6|= C(a), where a is an individual name not appearing in T and A; conversely,
we have CircCP (T , A) |= C(a) iff AuC is not satisfiable w.r.t. CircCP0 (T , A{A(a)}), where
A is a concept name not occurring in T and A, and CP0 is obtained from CP by adding A
to M (and leaving  as it is). In this paper, we use satisfiability w.r.t. cKBs as the basic
reasoning problem.

3. Basic Reductions
We present three basic reductions between reasoning problems for circumscribed knowledge
bases that are interesting in their own right and, additionally, will be useful for establishing
the main results of this paper later on. More precisely, we replay a well-known reduction of
fixed predicates to minimized predicates in the context of DLs, reduce reasoning w.r.t. cKBs
with general TBoxes to reasoning w.r.t. cKBs with acyclic TBoxes, and show that, under
certain conditions, simultaneous satisfiability w.r.t. a collection of cKBs is reducible to
satisfiability w.r.t. a single cKB.
3.1 Fixed and minimized concepts
In circumscription, it is folklore that fixed predicates can be simulated in terms of minimized
predicates, see e.g. de Kleer (1989). In the case of DLs, the same simulation is possible
for concept names. To see this, let C0 be a concept and CircCP (T , A) a circumscribed
KB with CP = (, M, F, V ) and F0 = {A1 , . . . , Ak } = F  NC . Define a new pattern
CP0 = (, M 0 , F \ F0 , V ) with
 M 0 = M  {A1 , . . . , Ak , A01 , . . . , A0k }, where A01 , . . . , A0k are concept names that do not
occur in C0 , M , F , V , T , and A;
.
 T 0 = T  {A0i = Ai | 1  i  k}.
726

fiThe Complexity of Circumscription in DLs

It is not difficult to see that C0 is satisfiable w.r.t. CircCP (T , A) iff it is satisfiable w.r.t.
CircCP0 (T 0 , A). Thus, we get the following result.
Lemma 4 Let L  DL. Then satisfiability w.r.t. (concept-)circumscribed KBs in L can be
polynomially reduced to satisfiability w.r.t. (concept-)circumscribed KBs in L that have no
fixed concept names.
In contrast to concept names, fixed role names cannot be reduced to minimized role names
since Boolean operators on roles are not available in standard DLs such as ALCQIO. A
proof is given in Section 6, where we show that, in some cases, reasoning with minimized
role names is decidable, whereas the corresponding reasoning task for cKBs with fixed role
names is undecidable.
The reduction above clearly relies on TBoxes. However, in this paper we will sometimes
work with circumscribed KBs in which the TBox is empty. The following lemma, proved in
the appendix, shows that for cKBs in ALC without fixed role names and with empty TBox,
one can simulate fixed concept names using minimized concept names without introducing
a TBox. The proof, which may be viewed as a much more careful version of the proof of
Lemma 4, can be adapted to yield an analogous result for the other logics in DL.
Lemma 5 In ALC, satisfiability w.r.t. (concept-)circumscribed KBs with empty TBox and
without fixed roles can be polynomially reduced to satisfiability w.r.t. (concept-)circumscribed
KBs with empty TBox and without fixed predicates.
3.2 Acyclic and General TBoxes
For many DLs, satisfiability w.r.t. (non-circumscribed) KBs with general TBoxes is harder
than satisfiability w.r.t. (non-circumscribed) KBs with acyclic TBoxes. In the case of ALC,
ALCI, ALCQ, and ALCQO, the latter problem is PSpace-complete (Baader, McGuiness,
Nardi, & Patel-Schneider, 2003; Baader, Milicic, Lutz, Sattler, & Wolter, 2005b; Y. Ding
& Wu, 2007) while the former is ExpTime-complete (Baader et al., 2003). The only
DLs considered in this paper for which satisfiability is ExpTime-hard already with acyclic
TBoxes are ALCIO and its extensions (Areces, Blackburn, & Marx, 2000). We show that,
for circumscribed KBs, there is no difference in computational complexity between acyclic
and general TBoxes.
Let C0 be a concept and CircCP (T , A) a cKB with CP = (, M, F, V ). We may assume
.
without loss of generality that T = {> = C} for some concept C. (To see this, observe that
.
axioms C v D are equivalent to > = C t D). Define
.
.
.
.
 an acyclic TBox T 0 = {A = C, B = u.A, A0 = A, B 0 = B}, where A, B, A0 , B 0 , u
are new concept and role names not occurring in T , A, M , F , V , and C0 .
 a circumscription pattern CP0 = (, M 0 , F, V 0 ), where M 0 = M  {A0 , B 0 } and V 0 =
V  {A, B, u}.
We will ad B 0 conjunctively to C0 and thus be interested in models of CircCP0 (T 0 , A) where
(B 0 )I 6= . In such models, we have AI = I (and thus C I = I ) since, otherwise, we
can turn each instance d of B 0 into an instance of B 0 by making d an instance of B and
727

fiBonatti, Lutz, & Wolter

linking it via the role u to an instance of A, thus obtaining a more preferred model w.r.t.
<CP0 . This is the basis of the proof of the following lemma, given in the appendix.
Lemma 6 C0 is satisfiable w.r.t. CircCP (T , A) iff C0 uB 0 is satisfiable w.r.t. CircCP0 (T 0 , A).
Thus, we have obtained the following result.
Proposition 7 Let L  DL. Satisfiability w.r.t. (concept-)circumscribed KBs in L can be
polynomially reduced to satisfiability w.r.t. (concept-)circumscribed KBs in L with acyclic
TBoxes and without changing the ABox.
This shows that satisfiability w.r.t. cKBs with acyclic TBoxes is of the same complexity as
satisfiability w.r.t. cKBs with general TBoxes. In many cases considered in this paper, the
same is even true for cKBs with empty TBoxes, c.f. Section 4. However, we also identify
cases where cKBs with non-empty TBoxes have higher complexity (see Theorems 24 and 28),
and thus a general reduction as the one underlying Proposition 7 cannot exist for the case
of empty TBoxes.
3.3 Simultaneous Satisfiability
In applications, it is often necessary to merge TBoxes, ABoxes, and whole knowledge bases
by taking their union. We show that, under certain conditions, reasoning w.r.t. the union
of several circumscribed KBs can be reduced to reasoning w.r.t. the component cKBs. A
concept C is simultaneously satisfiable w.r.t. cKBs CircCP1 (T1 , A1 ), . . . , CircCPk (Tk , Ak ) if
there exists an interpretation I that is a model of all the cKBs and satisfies C I 6= .
The following lemma says that simultaneous satisfiability can be polynomially reduced to
satisfiability w.r.t. a single cKB if there are no two cKBs that share a role name.
The proof idea for the case k = 2 is as follows. Given CircCP1 (T1 , A1 ) and CircCP2 (T2 , A2 ),
we first take the union of these two cKBs, replacing in CircCP2 (T2 , A2 ) each concept name
A that is also used in CircCP1 (T1 , A1 ) with a fresh concept name A0 . We then introduce an
additional concept name P (for problem) and make sure that P is satisfied by each ABox
individual whenever there is a point in the model where the interpretation of A and A0
disagrees. We then look for a model where P is not satisfied in the ABox. Intuitively, the
additional concept name P satisfies the purpose of decoupling A and A0 , which is important
e.g. in the case where A/A0 is minimized both in CircCP1 (T1 , A1 ) and CircCP2 (T2 , A2 ). Details
are given in the appendix.
Lemma 8 For all L  DL, simultaneous satisfiability w.r.t. (concept-)circumscribed KBs
CircCP1 (T1 , A1 ), . . . CircCPk (Tk , Ak ), such that CircCPi (Ti , Ai ) and CircCPj (Tj , Aj ) share no
role names for 1  i < j  k, can be reduced in polynomial time to satisfiability w.r.t. single
(concept-)circumscribed KBs.

4. The Complexity of Reasoning in Concept-Circumscribed KBs
The main contributions of this paper consist in (i) showing that, in many cases, reasoning
with circumscribed knowledge bases is decidable; and (ii) performing a detailed analysis
728

fiThe Complexity of Circumscription in DLs

of the computational complexity of these decidable cases. In this section, we show that
satisfiability w.r.t. concept-circumscribed KBs is NExpNP -complete for the DL ALC and
its extensions ALCIO and ALCQO. We also show that it is NPNExp -complete if the number
of fixed and minimized concept names is bounded by a constant. We first present proofs of
the upper bounds and then establish matching lower bounds.
4.1 Upper Bounds
We start with the general case in which there is no bound on the number of fixed and
minimized predicates.
4.1.1 The General Case
We prepare the upper bound proof by showing that if a concept is satisfiable w.r.t. a
concept-circumscribed KB, then it is satisfiable in a model of bounded size. We use |C| to
denote the length of the concept C, i.e.,
P the number of (occurrences of) symbols needed to
write C. The size |T | of a TBox T is CvDT |C| + |D|, and the size |A| of an ABox A is
the sum of the sizes of all assertions in A, where the size of each role assertion is 1 and the
size of concept assertions C(a) is |C|.
Lemma 9 Let C0 be a concept, CircCP (T , A) a concept-circumscribed KB, and n := |C0 | +
|T | + |A|. If C0 is satisfiable w.r.t. CircCP (T , A), then the following holds:
(i) If T , A and C0 are formulated in ALCIO, then C0 is satisfied in a model I of
CircCP (T , A) with #I  22n .
(ii) If T , A and C0 are formulated in ALCQO and m is the maximal parameter occurring in a number restriction in T , A, or C0 , then C0 is satisfied in a model I of
CircCP (T , A) with #I  22n  (m + 1)  n.
Proof. Let CP, T , A, and C0 be as in Lemma 9. We may assume that A =  as every
assertion C(a) can be expressed as an implication {a} v C, and every assertion r(a, b) can
be expressed as {a} v r.{b}. Denote by cl(C, T ) the smallest set of concepts that contains
all subconcepts of C, all subconcepts of concepts appearing in T , and is closed under single
negations (i.e., if D  cl(C, T ) and D does not start with , then D  cl(C, T )).
Let I be a common model of C0 and CircCP (T , A), and let d0  C0I . Define an equivalence relation  on I by setting d  d0 iff
{C  cl(C0 , T ) | d  C I } = {C  cl(C0 , T ) | d0  C I }.
We use [d] to denote the equivalence class of d  I w.r.t. the  relation. Pick from each
equivalence class [d] exactly one member and denote the resulting subset of I by 0 .
We first prove Point (i). Thus, assume that T and C0 are formulated in ALCIO. We
define a new interpretation J as follows:
J

:= 0

AJ

:= {d  0 | d  AI }

rJ

:= {(d1 , d2 )  0  0 | d01  [d1 ], d02  [d2 ] : (d01 , d02 )  rI }

aJ

:= d  0 if aI  [d].
729

fiBonatti, Lutz, & Wolter

The following claim is easily proved using induction on the structure of C.
Claim: For all C  cl(C0 , T ) and all d  I , we have d  C I iff d0  C J for the element
d0  [d] of J .
Thus, J is a model of T satisfying C0 . To show that J is a model of CircCP (T , A), it thus
remains to show that there is no model J 0 of T with J 0 <CP J . Assume to the contrary
that there is such a J 0 . We define an interpretation I 0 as follows:
I

0

AI

0

:= I
[
[d]
:=
dAJ 0

r

I0

[

:=

(d1 ,d2
0
aI

[d1 ]  [d2 ]

)rJ 0

:= aI .

It is a matter of routine to show the following:
0

0

Claim: For all concepts C  cl(C0 , T ) and all d  I , we have d  C I iff d0  C J for the
element d0  [d] from J .
0

0

It follows that I 0 is a model of T . Observe that AI fi AI iff AJ fi AJ for each concept
name A and fi  {, }. Therefore  and since CP is a concept circumscription pattern 
I 0 <CP I follows from J 0 <CP J . We have derived a contradiction and conclude that J is
a model of CircCP (T , A). Thus we are done since the size of J is bounded by 22n .
Now for Point (ii). Pick, for each d  0 and each concept (> k r C)  cl(C0 , T )
such that d  (> k r C)I , k elements from {d0 | d0  C I , (d, d0 )  rI }. Also pick, for
each concept (6 k r C)  cl(C0 , T ) such that d  ((6 k r C))I , k + 1 elements from
{d0 | d0  C I , (d, d0 )  rI }. Denote by 00 the collection of the elements picked. Take for
each d  00 \ 0 an element ds  0 such that d  ds and define an interpretation J by
J

:= 0  00

AJ

:= {d  0  00 | d  AI }

rJ

:= {(d1 , d2 )  0  (0  00 ) | (d1 , d2 )  rI }
{(d1 , d2 )  (00 \ 0 )  (0  00 ) | (ds1 , d2 )  rI }

aJ

:= d if aI  [d].

The following claim is easily proved.
Claim: For all C  cl(C0 , T ), we have the following:
(i) for all d, d0  J , if d  d0 , then d  C J iff d0  C J ;
(ii) for all d  I , we have d  C I iff d0  C J for some element d0  [d] of J .
Thus, J is a model of T satisfying C0 . To show that J is a model of CircCP (T , A), it
thus remains to show that there is no model J 0 of T with J 0 <CP J . Assume to the
contrary that there is such a J 0 . We define an interpretation I 0 . To this end, take for each
730

fiThe Complexity of Circumscription in DLs

d  I \ J the dp  0 such that d  dp . Now define I 0 as follows
I
A

0

I0

:= I
0

0

:= AJ  {d  I \ J | dp  AJ }

rI

0

:= rJ  {(d1 , d2 )  (I \ J )  I | (dp1 , d2 )  rJ }

aI

0

:= aI .

0

0

Again, it is a matter of routine to show:
0

Claim: For all concepts C  cl(C0 , T ) and all d  I , we have d  C I  J iff d  C J
0
0
and d  C I  (I \ J ) iff dp  C J for the element dp  [d] from 0 .
0

0

0

It follows that I 0 is a model for T . Observe that AI fi AI iff AJ fi AJ for each concept
name A and fi  {, }. Therefore  and since CP is a concept circumscription pattern
 I 0 <CP I follows from J 0 <CP J . We have derived a contradiction and conclude that
J is a model of CircCP (T , A). Thus we are done since the size of J is clearly bounded
by 22n  (m + 1)  n.
o
It is interesting to note that the proof of Lemma 9 does not go through if role names are
minimized or fixed. This problem cannot be overcome, as proved by the undecidability
results presented in Sections 5 and 6.
Using the bounded model property just established, we can now prove decidability
of reasoning with concept-circumscribed KBs formulated in ALCIO and ALCQO. More
precisely, Lemma 9 suggests a non-deterministic decision procedure for satisfiability w.r.t.
concept circumscription patterns: simply guess an interpretation of bounded size and then
check whether it is a model. It turns out that this procedure shows containment of satisfiability in the complexity class NExpNP , which contains those problems that can be solved
by a non-deterministic exponentially time-bounded Turing machine that has access to an
NP oracle. It is known that NExp  NExpNP  ExpSpace.
Theorem 10 In ALCIO and ALCQO, it is in NExpNP to decide whether a concept is
satisfiable w.r.t. a concept-circumscribed KB CircCP (T , A).
Proof. It is not hard to see that there exists an NP algorithm that takes as input a
cKB CircCP (T , A) and a finite interpretation I, and checks whether I is not a model of
CircCP (T , A): the algorithm first verifies in polynomial time whether I is a model of T and
A, answering yes if this is not the case. Otherwise, the algorithm guesses an interpretation
J that has the same domain as I and interprets all individual names in the same way, and
then checks whether (i) J is a model of T and A, and (ii) J <CP I. It answers yes if
both checks succeed, and no otherwise. Clearly, checking whether J <CP I can be done
in time polynomial w.r.t. the size of J and I.
This NP algorithm may now be used as an oracle in a NExp-algorithm for deciding
satisfiability of a concept C0 w.r.t. a cKB CircCP (T , A): by Lemma 9, it suffices to guess
an interpretation of size 24k with k = |C0 | + |T | + |A|,3 and then use the NP algorithm
to check whether I is a model of CircCP (T , A). This proves that concept satisfiability is in
NExpNP .
o
3. The bound 24k clearly dominates the two bounds given in Parts (i) and (ii) of Lemma 9.

731

fiBonatti, Lutz, & Wolter

By the reductions given in Section 2, Theorem 10 yields co-NExpNP upper bounds for
subsumption and the instance problem. We will show in Section 4.2 that these upper
bounds are tight.
4.1.2 Bounded Number of Minimized and Fixed Predicates
Since NExpNP is a rather large complexity class, it is a natural question whether we can
impose restrictions on concept circumscription such that reasoning becomes simpler. In the
following, we identify such a case by considering concept-circumscribed KBs in which the
number of minimized and fixed concept names is bounded by some constant. In this case, the
complexity of satisfiability w.r.t. concept-circumscribed KBs drops to NPNExp . For readers
uninitiated to oracle complexity classes, we recall that NExp  NPNExp  NExpNP , and
that NPNExp is believed to be much less powerful than NExpNP , see for example the work
by Eiter et al. (2004).
To prove the NPNExp upper bound, we first introduce counting formulas as a common
generalization of TBoxes and ABoxes.
Definition 11 (Counting Formula) A counting formula  is a Boolean combination of
concept implications, ABox assertions C(a), and cardinality assertions (C = n) where C
is a concept and n a non-negative integer. We use , ,  and  to denote the Boolean
operators of counting formulas. An interpretation I satisfies a cardinality assertion (C = n)
if #C I = n. The satisfaction relation I |=  between models I and counting formulas  is
defined in the obvious way.
4
In the following, we assume that the integers occurring in cardinality assertions are coded
in binary. The NPNExp algorithm to be devised will use an algorithm for satisfiability of
(non-circumscribed) counting formulas as an oracle. Therefore, we should first determine
the computational complexity of the latter. It follows from results by Tobies (2000) that,
in ALC, satisfiability of counting formulas is NExp-hard. A matching upper bound for
the DLs ALCIO and ALCQO is obtained from the facts that (i) there is a polynomial
translation of counting formulas formulated in these languages into C2, the two-variable
fragment of first-order logic extended with counting quantifiers (Gradel, Otto, & Rosen,
1997; Pacholski, Szwast, & Tendera, 2000), and (ii) satisfiability in C2 is in NExp even if
the numbers in counting quantifiers are coded in binary (Pratt-Hartmann, 2005).
Theorem 12 (Tobies, Pratt) In ALC, ALCIO and ALCQO, satisfiability of counting
formulas is NExp-complete even if numbers in number restrictions are coded in binary.
We now establish the improved upper bound.
Theorem 13 Let c be a constant. In ALCIO and ALCQO, it is in NPNExp to decide satisfiability w.r.t. concept-circumscribed KBs CircCP (T , A), where CP = (, M, F, V ) is such
that #M  c and #F  c.

732

fiThe Complexity of Circumscription in DLs

Proof. Assume that we want to decide satisfiability of the concept C0 w.r.t. the cKB
CircCP (T , A), where CP = (, M, F, V ) with #M  c and #F  c. By Lemma 4, we
may assume that F =  (we may have to increase the constant c appropriately). We
may assume without loss of generality that the cardinality of M is exactly c. Thus, let
M = {A0 , . . . , Ac }. By Lemma 9, C0 is satisfiable w.r.t. CircCP (T , A) iff there exists a
model of C0 and CircCP (T , A) of size 24k , with k = |C0 | + |T | + |A|. Consider, for all
S  M , the concept
CS :=
Au
A.

u

AS

u

A{A1 ,...,Ac }\S

As c is constant, the number 2c of such concepts is constant as well. Clearly, the sets CSI ,
S  M , form a partition of the domain I of any model I. Introduce, for each concept
name B and role name r in T  A, a fresh concept name B 0 and a fresh role name r0 ,
respectively. For a concept C, denote by C 0 the result of replacing in C each concept name
B and role name r with B 0 and r0 , respectively. The primed versions A0 and T 0 of A and
T are defined analogously. Denote by N the set of individual names in T  A  {C0 }.
The NExp-oracle we are going to use in our algorithm checks whether a counting formula
 is satisfiable or not. Now, the NPNExp -algorithm is as follows (we use C @ D as an
abbreviation for the counting formula (C v D)  (D v C)):
1. Guess
 a sequence (nS | S  M ) of numbers nS  24k coded in binary;
 for each individual name a  N , exactly one set Sa  M ;
 a subset E of N  N .
2. By calling the oracle, check whether the counting formula 1 is satisfiable, where 1
is the conjunction over
 T  A  {(C0 = 0)};
 (CS = nS ), for all S  M ;
 CSa (a), for each a  N ;
 {({a} v {b}) | (a, b)  E}  {({a} v {b}) | (a, b)  N  E}.
3. By calling the oracle, check whether the counting formula 2 is satisfiable, where 2
is the conjunction over
 T 0  A0 ;
 (CS = nS ), for all S  M (note that we use the unprimed versions);
 CSa (a), for each individual name a  N (we use the unprimed versions);
 {({a} v {b}) | (a, b)  E}  {({a} v {b}) | (a, b)  N  E};
 for all A  M ,
(A0 v A) 

_
BM,BA

733

(B 0 @ B);

fiBonatti, Lutz, & Wolter

 and, finally,
_

^

(A0 @ A) 

AM


.
(B = B 0 ) .

BM,BA

4. The algorithm states that C0 is satisfiable in a model of CircCP (T , A) if, and only if,
1 is satisfiable and 2 is not satisfiable.
Using the fact that c is fixed, is is not hard to verify that this is a NPNExp -algorithm. It
remains to show correctness and completeness.
Suppose that there exists a model of CircCP (T , A) satisfying C0 . Then there is such a
model I of size bounded by 24k . Let the algorithm guess
 the numbers nS = #CSI , S  M ,
 the sets Sa such that aI  CSIa ,
 the set E = {(a, b), (b, a) | aI = bI , a, b  N }.
Clearly, 1 is satisfied in I. It remains to show that 2 is unsatisfiable. But suppose there
exists a model J satisfying 2 . By the definitions of 1 and 2 , we may assume that
 I = J ;
 AI = AJ for all A  M ;
 aI = aJ for all individual names a.
Moreover, as no unprimed role names occur in 2 and the only unprimed concept names in
2 are those in M , we may assume that the interpretation of all unprimed concept and role
names in I and J coincide. Thus, J is a model of CircCP (T , A) satisfying C0 . But now
define a model J 0 with domain J by setting
0

 aJ = aJ , for all individual names a;
0

 rJ = (r0 )J , for all role names r;
0

 AJ = (A0 )J , for all concept names A.
Then, by the conjunct under Item 1 of the definition of 2 , J 0 is a model for A  T . By
Items 5 and 6 of the definition of 2 , J 0 <CP J , and we have derived a contradiction.
Conversely, suppose the algorithm says that there exists a model of CircCP (T , A) satisfying C0 . Then take a model I for 1 . By the conjunct under Item 1 of 1 , I is a model
for T  A satisfying C0 . It follows from the unsatisfiability of 2 that I is a model for
CircCP (T , A).
o

734

fiThe Complexity of Circumscription in DLs

As a corollary, we obtain co-NPNExp upper bounds for subsumption and the instance problem. A similar drop of complexity occurs in propositional logic, where satisfiability w.r.t.
circumscribed theories is complete for NPNP and it is not difficult to see that bounding the
minimized and fixed predicates allows us to find a PNP algorithm.
4.2 Lower Bounds
We prove lower complexity bounds for reasoning with concept-circumscribed KBs that
match the upper bounds given in Section 4.1.
4.2.1 The General Case
As in Section 4.1, we start with the general case in which the number of fixed and minimized
predicates is not bounded. Our aim is to establish two NExpNP -lower bounds that both
match the upper bound established in Theorem 10. The first bound is for satisfiability w.r.t.
concept-circumscribed KBs that are formulated in ALC and have an empty TBox, but a nonempty ABox. The second bound is also for satisfiability w.r.t. concept-circumscribed KBs
formulated in ALC, but assumes an acyclic TBox and empty ABox. Both reductions work
already in the case of an empty preference relation, and without any fixed predicates. Note
that considering satisfiability of a concept C w.r.t. a concept-circumscribed KB CircCP (T , A)
with both T and A empty is not very interesting: it can be seen that C is satisfiable w.r.t.
CircCP (T , A) iff C is satisfiable (without reference to any KB), where C is the concept
obtained from C by replacing all minimized concept names with .
The proof of our first result is by reduction of a succinct version of the problem coCERT3COL, which is NExpNP -complete (Eiter, Gottlob, & Mannila, 1997), to satisfiability
w.r.t. concept-circumscribed KBs with empty TBox. Let us first introduce the regular (nonsuccinct) version of co-CERT3COL:
Instance of size n: an undirected graph G on the vertices {0, 1, . . . , n  1} such that every
edge is labelled with a disjunction of two literals over the Boolean variables {Vi,j | i, j < n}.
Yes-Instance of size n: an instance G of size n such that, for some truth value assignment
t to the Boolean variables, the graph t(G) obtained from G by including only those edges
whose label evaluates to true under t is not 3-colorable.
As shown by Stewart (1991), co-CERT3COL is complete for NPNP . To obtain a problem
complete for NExpNP , Eiter et al. use the complexity upgrade technique: by encoding the
input in a succinct form using Boolean circuits, the complexity is raised by one exponential
to NExpNP (Eiter et al., 1997). More precisely, the succinct version co-CERT3COLS of
co-CERT3COL is obtained by representing the input graph G with nodes {0, . . . , 2n  1}
as 4n + 3 Boolean circuits with 2n inputs (and one output) each. The Boolean circuits are
(1)
(2)
(i)
named cE , cS , cS , and cj , with i  {1, 2, 3, 4} and j < n. For all circuits, the 2n inputs
are the bits of the binary representation of two nodes of the graph. The purpose of the
circuits is as follows:
 circuit cE outputs 1 if there is an edge between the two input nodes, and 0 otherwise;
(1)

 if there is an edge between the input nodes, circuit cS outputs 1 if the first literal
(2)
in the disjunction labelling this edge is positive, and 0 otherwise; circuit cS does the
735

fiBonatti, Lutz, & Wolter

same for the second literal; if there is no edge between the input nodes, the output is
arbitrary;
(i)

 if there is an edge between the input nodes, the circuits cj compute the labelling
Vk1 ,k2 Vk3 ,k4 of this edge between the input nodes by generating the numbers k1 , . . . , k4 :
(i)
circuit cj outputs the j-th bit of ki ; if there is no edge between the input nodes, the
output is arbitrary.
We reduce co-CERT3COLS to satisfiability w.r.t. concept-circumscribed KBs that are formulated in ALC and whose TBox and preference relation are empty. It then remains to
apply Lemma 5 to eliminate fixed concept names (we note that the construction in the
proof of the lemma leaves the preference relation untouched). Let
(1)

(2)

(i)

G = (n, cE , cS , cS , {cj }i{1,..,4},j<n )
be the (succinct representation of the) input graph with 2n nodes. We construct an ABox
AG = {C0 u Root(a0 )}, a circumscription pattern CPG , and a concept CG such that G is a
yes-instance of co-CERT3COLS iff CG is satisfiable w.r.t. CircCPG (, AG ).
The concept C0 used in AG is a conjunction whose presentation is split into two parts.
Intuitively, the purpose of the first group of conjuncts is to fix a truth assignment t for
the variables {Vi,j | i, j < n}, and to construct (an isomorphic image of) the graph t(G)
obtained from G by including only those edges whose label evaluates to true under t. Then,
the purpose of the second group is to make sure that t(G) is not 3-colorable.
When formulating C0 , we use several binary counters for counting modulo 2n (the
number of nodes in the input graph). The main counters X and Y use concept names
X0 , . . . , Xn1 and Y0 , . . . , Yn1 as their bits, respectively. Additionally, we introduce concept
(i)
(i)
names K0 , . . . , Kn1 , i  {1, 2, 3, 4}, that serve as four additional counters K (1) , . . . , K (4) .
The first group of conjuncts of C0 can be found in Figure 2, where the following abbreviations
are used:
 ri .C denotes the n-fold nesting r.    .r.C;
 r.(K (i) = X) is an abbreviation for

u

j<n

(i)
(i) 
(Xj  r.Kj ) u (Xj  r.Kj ) and

similarly for r.(K (i) = Y );
 the abbreviations Wc , c a Boolean circuit, are explained later on.
The intuition behind Figure 2 is as follows. Lines (1) to (5) build up a binary tree of depth
2n whose edges are labeled with the role name r. The 22n leaves of the tree are instances
of the concept name Leaf, and they are labeled with all possible values of the counters X
and Y . Since we will minimize Leaf via the circumscription pattern CPG , this concept name
denotes precisely the leaves of the tree. Due to the use of the counters X and Y , the leaves
are all distinct.
The leaves of the tree just established satisfy a number of purposes. To start with,
each leaf with counter values X = i and Y = j corresponds to the variable Vi,j of co3CERTCOLS and determines a truth value for this variable via truth/falsity of the concept
736

fiThe Complexity of Circumscription in DLs

ri .(r.Xi u r.Xi )
j

r .((Xi  r.Xi ) u (Xi  r.Xi ))
r
r

n+j

n+i

.(r.Yi u r.Yi )

.((Yi  r.Yi ) u (Yi  r.Yi ))

for i < n

(1)

for i < n, j < 2n

(2)

i<n

(3)

for i < j < n

(4)

2n

r .Leaf

(5)

r2n .(WcE u Wc(1) u Wc(2) )

(6)

S

S

r2n .(Wc(1) u    u Wc(4) )
j

for j < n

r2n .(var1.LeafFix u var1.(K (1) =X) u var1.(K (2) =Y ))
2n

r .(var2.LeafFix u var2.(K

(3)

(7)

j

=X) u var2.(K

(4)

(8)

=Y ))

(9)

2n

P  r .var1.Leaf

(10)

2n

P  r .var2.Leaf

(11)

r2n .(S1  (Tr1  var1.Tr))

(12)

2n

r .(S1  (Tr1  var1.Tr))
2n

r .(S2  (Tr2  var2.Tr))
2n

(13)
(14)

r .(S2  (Tr2  var1.Tr))

(15)

2n

(16)

r .(Elim  (E t (Tr1 t Tr2 )))
Figure 2: The first group of conjuncts of C0 .

name Tr. Thus, the leaves jointly describe a truth assignment t for the instance G of co3CERTCOLS . A second purpose of the leaves is to represent the potential edges of G:
additionally to representing a variable, a leaf with X = i and Y = j corresponds to the
potential edge between the nodes i and j. To explain this more properly, we must first
discuss the abbreviations Wc used in Lines (6) and (7) of Figure 2.
Each concept Wc , c a Boolean circuit with 2n inputs, is the result of converting c into a
concept that uses only the constructors , u, t such that the following condition is satisfied:
if a d  I is an instance of Wc , the output of c upon input b0 , . . . , b2n1 is b, and the truth
value of the concept names X0 , . . . , Xn1 , Y0 , . . . , Yn1 at d is described by b0 , . . . , b2n1 ,
then the truth value of some concept name Out at d is described by b. By introducing one
auxiliary concept name for every inner gate of c, the translation can be done such that the
size of Wc is linear in the size of c. The following concept names are used as output:
 WcE uses the concept name E as output;
 Wc(i) uses the concept name Si as output, for i  {1, 2};
S

(i)

 Wc(i) uses the concept name Kj

as output, for i  {1, . . . , 4} and j < n.

j

737

fiBonatti, Lutz, & Wolter

r2n .(col1.LeafFix u col2.LeafFix)
2n

r .(col1.(X = X) u col1.(Y = 0))
2n

r .(col2.(Y = X) u col2.(Y = 0))

(17)
(18)
(19)

2n

(20)

2n

P  r .col2.Leaf

(21)

r2n .((Y = 0)  (R t B t G))

(22)

r .((Y = 0)  ((R u B) u (R u G) u (B u G)))

(23)

r2n .((Elim u col1.R u col2.R)  Clash)

(24)

r2n .((Elim u col1.G u col2.G)  Clash)

(25)

r2n .((Elim u col1.B u col2.B)  Clash)

(26)

P  r .col1.Leaf

2n

Figure 3: The second group of conjuncts of C0 .
Lines (6) and (7) ensure that these concepts are propagated to all leaves. Our next aim is to
ensure that each leaf that represents a potential edge (i, j) is connected via the role var1 to
the leaf that represents the variable in the first disjunct of the label of (i, j), and analogously
for the role var2 and the variable in the second disjunct of the edge label. If we replaced
the concept name LeafFix with Leaf in Lines (8) and (9), then these lines would apparently
encode these properties. However, we have to be careful as the mentioned replacement
would interact with the minimization of Leaf. To fix this problem, we resort to a trick: we
use the concept name LeafFix instead of Leaf. In this way, we may or may not reach an
instance of Leaf. If we do not, we force the concept name P to be true at the root of the
tree in Lines (10) and (11). We will use CG to rule out models in which P is true. Finally,
we fix LeafFix via CPG to eliminate interaction with the minimization of Leaf.
The remaining Lines (12) to (16) ensure that a leaf is an instance of Elim iff the potential
edge that it represents is not present in the graph t(G) induced by the truth assignment t
described by the leaves.
The second group of conjuncts of C0 can be found in Figure 3. Here, (Y = 0) stands
for the concept (Y0 u    u Yn1 ). As already mentioned, the purpose of these conjuncts
is to ensure that the graph t(G) described by the leaves does not have a 3-coloring. The
strategy for ensuring this is as follows: we use the 2n leaves with Y = 0 to store the colors
of the nodes, i.e., the leaf with X = i and Y = 0 stores the color of node i. By Lines (22)
and (23), there is a unique coloring. Then, Lines (17) to (21) ensure that each leaf (viewed
as an edge) is connected via the role col1 to the leaf that stores the color of the first node
of the edge, and analogously for the role col2 and the second node of the edge. LeafFix and
P have the same role as before. Lines (24) to (26) guarantee that the concept name Clash
identifies problems in the coloring: a leaf is in Clash if it represents an edge that exists
in G, is not dropped in t(G), and where both endpoints have the same color. The idea
is that Clash will be minimized while R, G, and B vary. When some additional concept
names are fixed, this corresponds to a universal quantification over all possible colorings.
738

fiThe Complexity of Circumscription in DLs

Set CG = Root u P u r2n .Clash, and recall that AG = {C0 u Root(a0 )}. The following
lemma is proved in the appendix.
Lemma 14 G is a yes-instance of co-3CERTCOLS iff CG is satisfiable with respect to
CircCPG (, AG ), where CPG = (, M, F, V ) with  = , M = {Root, Leaf, Clash},
F = {LeafFix, Tr, X0 , . . . , Xn1 , Y0 , . . . , Yn1 , },
and V the set of all remaining predicates in AG .
Since the size of AG is polynomial in n, we get the following result by applying Lemma 5.
Theorem 15 In ALC, satisfiability w.r.t. concept-circumscribed KBs is NExpNP -hard even
if the TBox and the preference relation are empty and there are no fixed predicates.
It is now rather straightforward to establish the announced second NExpNP lower bound by
a reduction of satisfiability w.r.t. concept-circumscribed KBs in the special case formulated
in Theorem 15. Details are given in the appendix.
Corollary 16 In ALC, satisfiability w.r.t. concept-circumscribed KBs is NExpNP -hard
even if the TBox is acyclic, the ABox and preference relations are empty, and there are no
fixed predicates.
Corresponding lower bounds for subsumption and the instance problems follow from the
reduction given in Section 2.
4.2.2 Bounded Number of Minimized and Fixed Predicates
We now establish a matching lower bound for Theorem 13 by showing that, in ALC, satisfiability w.r.t. concept-circumscribed KBs is NPNExp -hard even if only a constant number
of predicates is allowed to be minimized and fixed. In contrast to the previous section,
we ignore the case of empty TBoxes and directly establish the lower bound for the case
of non-empty TBoxes and empty ABoxes. This allows us to demonstrate the usefulness of
Lemma 8 for separating different parts of a lower bound proof: in the main reduction from
the previous section, the two parts of the reduction shown in Figure 2 and 3 are not truly
independent, which forced us to implement the technical trick that involves the concept
names LeafFix and P . When using Lemma 8, in contrast, we achieve a true separation of
concerns. In general, though, we conjecture that the lower bound proved in this section can
also be established for the case of empty TBoxes by adapting the mentioned technical trick.
We leave this as a problem to the interested reader.
Recall that a (non-deterministic) k-tape Turing machine is described by a tuple
(Q, , q0 , , qacc , qrej ),
with Q a finite set of states,  a finite alphabet, q0  Q a starting state,
  Q  k  Q  k  {L, R}k
a transition relation, and qacc , qrej  Q the accepting and rejecting states. For our purposes,
an oracle Turing machine is a 2-tape Turing machine M that, additionally, is equipped
with
739

fiBonatti, Lutz, & Wolter

 a 1-tape Turing machine M0 (the oracle) whose alphabet is identical to that of M,
 a query state q? , and
 two answer states qyes and qno .
The second tape of M is called the oracle tape. When M enters q? , the oracle determines the
next state of M: if the content of the oracle tape is contained in the language accepted by
the oracle, the next state is qyes . Otherwise, it is qno . During this transition, the head is not
moved and no symbols are written. The state q? cannot occur as the left-most component
of a tuple in Ms transition relation.
Let M = (Q, , q0 , , qacc , qrej , M0 , q? , qyes , qno ) be an oracle Turing machine such that
the following holds:
 M solves an NPNExp -complete problem;
 the time consumption of M is bounded by a polynomial p (where oracle calls contribute with a single clock tick);
0 , q 0 ) is bounded by 2q(n) , with q a
 the time consumption of M0 = (Q0 , , q00 , 0 , qacc
rej
polynomial.

We assume without loss of generality that M and M0 never attempt to move left from the
left-most position of the tape (neither right from the right-most position). Our NPNExp hardness proof uses a reduction of the word problem of M. Thus, let w   be an input
for M of length n, and let m = p(n) and m0 = q(p(n)). We construct three TBoxes
Tw , Tw0 , and Tw00 , circumscription patterns CP, CP0 , and CP00 , and a concept Cw such that
M accepts w iff Cw is simultaneously satisfiable w.r.t. CircCP (Tw , ), CircCP0 (Tw0 , ), and
CircCP00 (Tw00 , ). Then, Lemma 8 yields a reduction to (non-simultaneous) satisfiability w.r.t.
concept-circumscribed cKBs. Intuitively, the purpose of the first TBox Tw is to impose a
basic structure on the domain, while Tw0 describes computations of M, and Tw00 describes
computations of M0 . We use general TBoxes rather than acyclic ones since, by Lemma 6,
this can be done without loss of generality.
The TBox Tw is shown in Figure 4. As in the previous reduction, we use concept
names X0 , . . . , Xm0 1 and Y0 , . . . , Ym0 1 to implement two binary counters for counting
0
modulo 2m . We also use the same abbreviations as in the previous reduction. Additionally,
r.(X++) states that the value of the counter X0 , . . . , Xm0 1 is incremented when going to
r-successors, i.e.,


Xj  (Xk  r.Xk ) u (Xk  r.Xk )
0

u
u

k=0..m 1

k=0..m0 1

u
t

j=0..k1

j=0..k1



Xj  (Xk  r.Xk ) u (Xk  r.Xk )

The purpose of Lines (27) to (30) is to ensure that, for each possible value (i, j) of the
counters X and Y , there is at least one instance of NExp that satisfies (X = i) and (Y = j).
0
0
We minimize NExp, and thus enforce that NExp has exactly 2m  2m elements. These
0
0
elements are interconnected via the roles r (for right) and u (for up) to form a 2m 2m grid. Later on, we use this grid to encode computations of the oracle machine M0 . Observe
740

fiThe Complexity of Circumscription in DLs

> v aux.NExp
m0

NExp v ((X = 2

(27)
m0

 1)  r.NExp) u ((Y = 2

 1)  u.NExp)

(28)

NExp v r.(Y =Y ) u r.(X++)

(29)

NExp v u.(X=X) u u.(Y ++)

(30)

> v
Result v

u aux.(Result u R )
u (R u R )

(31)

i

i<m

i

i<j<m

(32)

j

> v aux.NP

(33)
Figure 4: The TBox Tw .

that, since we are working with simultaneous satisfiability, the minimization of NExp does
not interact with anything that we are going to put into the TBoxes Tw0 and Tw00 .
We also minimize the concept name Result, and thus Lines (31) and (32) guarantee that
there are exactly m instances of Result, identified by the concept names R0 , . . . , Rm1 . If
M makes a call to the oracle in the i-th step, then the result of this call will be stored
in the (unique) instance of Result u Ri , i.e., this instance will satisfy the concept name Rej
if M0 rejected the input and falsify it otherwise. Finally, we also minimize NP, and thus
Line (33) guarantees that there is exactly one instance of NP. This instance will be used to
represent the computation of M. Summing up, the circumscription pattern for Tw is
CP := (, {NExp, Result, NP}, , V ),
with V containing all remaining predicates used in Tw .
The purpose of Tw0 is to describe computations of M. We use the following concept
names:
 For all a  , i, j < m, and k  {1, 2}, we introduce a concept name Sai,j,k . Intuitively,
Sai,j,k expresses that a is the symbol in the j-th cell of the k-th tape in the i-th step
of Ms computation. We start our numbering of tape cells and steps with 0.
 For all q  Q and i < m, Qiq is a concept name expressing that M is in state q in the
i-th step of the computation.
 For all q  Q, i, j < m, and k  {1, 2}, Hji,k is a concept name expressing that the
k-th head of M is on cell j in the i-th step of the computation.
 For all q  Q, a  , i, j < m, k  {1, 2}, and M  {L, R}, concept names Aiq , Ai,j,k
a ,
i,k
i
AM that serve as markers. More precisely, Aq means that, at time point i, M has
executed a transition that switches to state q. Similarly, Ai,j,k
describes the symbol
a
i,k
written in that transition on tape k, and AM describes the move on tape k.
The details of Tw0 are given in Figure 5. One copy of the concept inclusions in this figure
are needed for every i, j, j 0 < m and every k  {1, 2}. We assume that w = a0    an1 and
741

fiBonatti, Lutz, & Wolter

0,n,1
0,m1,1
NP v Q0q0 u H00,1 u Sa0,0,1
u    Sa0,n1,1
u SB
u    u SB
0
n1

(34)

0,0,2
0,m1,2
NP v H00,2 u SB
u    u SB

(35)

NP v

u

i,j 0 ,2

a,b,qQ\{q? }

(Sai,j,1 u Sb

NP v
NP v
NP v
NP v
NP v

uA
uA

qQ

a
Ai,k
L
i,k
AR

i
q

i,j,k
a

0 ,2
i,2 
Aiq u Ai,j,1
u Ai,j
u Ai,1
a
M u AM 0 ) (37)
b

if i < m  1

(38)

(q,a,b,q 0 ,a0 ,b0 ,M,M 0 )

 Sai+1,j,k

i+1,k
 Hj1

if i < m  1

(39)

if i < m  1 and j > 0

(40)

i+1,k
 Hj+1

if i < m  1 and j < m  1

i+1,j,k
if i < m  1 and j 6= j 0
(Sai,j,k u Hji,k
0 )  Sa

u
u

a

 Qi+1
q

a,b,a6=b

(Sai,j,k u Sbi,j,k ) u

NP v (Hji,k u Hji,k
0 )

(36)

t

(
NP v

u Qiq u Hji,1 u Hji,2
0 ) 

u

q,q 0 Q,q6=q 0

(Qiq u Qiq0 )

if j 6= j 0

(41)
(42)
(43)
(44)

NP v resi .(Result u Ri ) u resi .(Result u Ri )

(45)

NP v (Qiq? u resi .Rej)  Qi+1
qno

(46)

NP v

(Qiq?

u resi .Rej) 

Qi+1
qyes

NP v (Qiq? u Hji,k )  Hji+1,k
NP v

u

a

if i < m  1
if i < m  1

if i < m  1

i+1,j,k

(Qiq? u Sai,j,k )  Sa

(47)
(48)
(49)

Figure 5: The TBox Tw0 .
use B to denote the (shared) blank symbol of M and M0 . Lines (34) to (43) describe the
behaviour of a Turing machine in the usual way: transitions follow the transition table, the
computation starts in the initial configuration, etc. Line (45) ensures that the instance of
NP can reach the (unique) instance of Result u Ri via the role resi , for all i < m. Lines (46)
and (47) deal with transitions of M in the query state by looking up the result of the oracle
call in the corresponding instance of Result. Finally, Lines (48) and (49) ensure that the head
position and tape symbols do not change when querying the oracle. The circumscription
pattern for Tw0 is simply CP0 := (, , , V ), with V the set of all predicates used in Tw0 .
The purpose of Tw00 is to describe computations of the oracle Turing machine M0 . Note
that we have to describe more than a single computation of M0 (but at most polynomially many) since M may visit the state q? more than once. All these computations are
represented in the NExp grid, where different computations are untangled by the use of
different concept names for each computation. We use the counter X0 , . . . , Xm0 1 to count
742

fiThe Complexity of Circumscription in DLs

configurations and the counter Y0 , . . . , Ym0 1 to count the tape cells of each configuration.
Moreover, we use the following concept names:
 For all a   and i < m, a concept name Sai . If Sai is satisfied by some instance of
NExp where X0 , . . . , Xm0 1 has value j and Y0 , . . . , Ym0 1 has value k, then the i-th
computation of M0 has, in its j-th step, symbol a on the k-th cell.
 For all q  Q and i < m, a concept name Qiq . The purpose of this concept name is
two-fold: first, it represents the current state of M0 in the i-th computation. And
second, it indicates the head position in the i-th computation.
 For all a  , q  Q, M  {L, R} and all i < m, a concept name Aiq,a,M as a marker.
The meaning of the marker Aiq,a,M is that, to reach the current configuration, M0 has
switched to q, written a, and moved its head in direction M . Additionally, the marker
indicates the head position in the previous configuration.
 An additional concept name NH (for nohead) that helps us to enforce that M0 has
only a single head position.
The details of Tw00 are shown in Figure 6, where we require one copy of each line for every
i < m. The purpose of Lines (50) and (51) is to regenerate the grid structure of NExp using
the roles r0 und u0 . This is necessary since the roles r and u are used in Tw , and, to use
Lemma 8, the TBoxes cannot share any role names. Lines (52) and (53) ensure that every
instance of NExp reaches (only) the unique instance of NP via the role toNP, and (only) the
unique instance of Result u Ri via the role res0i , for all i < m. Lines (54) to (64) describe the
computation of M0 in a straightforward way. More precisely, Lines (54) to (56) set up the
initial configuration by reading the contents of Ms oracle tape from the instance of NP.
Lines (57) to (61) implement transitions, and Lines (62) to (64) enforce a unique label of
the tape, a unique state, and a unique head position. Finally, Line (65) ensures that, if the
i-th computation of M0 is rejecting, then Rej is true in the instance of Result u Ri .
Note that M0 is a non-deterministic machine and may have more than one computation.
For storing Rej in Result u Ri , we need to know that all these computations are rejecting.
To deal with this issue, Rej is minimized with all other predicates varying: if there exists
an accepting computation of M0 on the i-th input, then we can represent this computation
in NExp and make Rej false in the instance of Result u Ri . Hence, Rej holds at Result u Ri
iff there exists no accepting computation. Note that we cannot fix the concept names
X0 , . . . , Xm0 1 , Y0 , . . . , Ym0 1 while minimizing Rej since we would get an unbounded number
of fixed concept names. This means that the elements of NExp can change their position
during minimization, and with them the roles r0 and u0 . This is not harmful since Tw and
Lines (50) and (51) ensure that that the structure (NExpI , (r0 )I , (u0 )I ) is always isomorphic
to a grid, and the rest of Tw00 ensures that the elements of NExp always encode computations
of M0 . We thus use the circumscription pattern CP00 := (, {Rej}, , V 0 ), where V 0 contains
all predicates used in Tw00 except Rej.
The proof of the following lemma is left to the reader. In its formulation, the union
over all Qiqacc imposes that at least one state in the computation is accepting.
743

fiBonatti, Lutz, & Wolter

0

0

NExp v ((X = 2m  1)  r0 .NExp) u ((Y = 2m  1)  u0 .NExp)
0

0

0

0

(50)

NExp v r .(Y =Y ) u r .(X++) u u .(X=X) u u .(Y ++)

(51)

NExp v res0i .(Result u Ri ) u res0i .(Result u Ri )

(52)

NExp v toNP.NP u toNP.NP

(53)

NExp v

uu



j<m a



(X = 0) u (Y = j) u toNP.Sai,j,2  Sai

(54)

i
NExp v ((X = 0) u (Y  m))  SB

(55)

Qiq0
0

(56)

NExp v ((X = 0) u (Y = 0)) 
NExp v

uu

a

(Sai u Qiq ) 

qQ0

t

(q,a,q 0 ,a0 ,M )0

r0 .Aiq0 ,a0 ,M



(57)

NExp v Aiq,a,R  (Sai u u0 .Qiq )

(58)

Aiq,a,L  Sai
u0 .Aiq,a,L 

(59)

NExp v
NExp v

NExp v
NExp v

(60)

t Q  u (S  r .S )
u (S u S ) u u
t Q   u .NH

NH   t Q u u .NH

NExp v 
NExp v

Qiq

qQ0

i
q

a,b,a6=b
qQ0

i
a

rej

i
b

i
a

(61)
(Qiq u Qiq0 )

q,q 0 Q0 ,q6=q 0

0

i
q

qQ0

NExp v Qiq0

0

i
a

a

i
q

(62)
(63)

0

(64)

 res0i .Rej

(65)

Figure 6: The TBox Tw00 .
Lemma 17 M accepts w iff Cw := NP u

tQ

i<m

i
qacc

is simultaneously satisfiable w.r.t.

CircCP (Tw , ), CircCP0 (Tw0 , ), and CircCP00 (Tw00 , ).

It remains to apply Lemmas 6, 4, and 8 to obtain the following result.
Theorem 18 In ALC, satisfiability w.r.t. concept-circumscribed cKBs is NPNExp -hard
even if the TBox is acyclic, the ABox and preference relations are empty, there are no
fixed predicates, and the number of minimized predicates is bounded by a constant.
As already mentioned, we conjecture that the same result can be proved with empty TBoxes
(but non-empty ABoxes). Corresponding lower bounds for subsumption and the instance
problems follow from the reduction given in Section 2.
744

fiThe Complexity of Circumscription in DLs

5. Circumscription with Fixed Roles
In the preceeding sections, we have analyzed the computational complexity of reasoning
w.r.t. concept-circumscribed KBs and, in particular, established decidability. In the current
section, we extend concept-circumscribed KBs to what we call role-fixing cKBs, which differ
from the former by allowing role names to be fixed (but not minimized). Interestingly, the
result of this seemingly harmless modification is that reasoning becomes highly undecidable.
We start with defining the cKBs studied in this section.
Definition 19 A cKB CircCP (T , A) with CP = (, M, F, V ) is called role-fixing if M contains no role names.
4
To pinpoint the exact complexity of reasoning in role-fixing cKBs, we present a reduction of
the logical consequence problem in monadic second-order logic with binary relation symbols
(over unrestricted structures, not over trees) to the instance problem w.r.t. role-fixing cKBs
formulated in ALC. It follows that the latter problem is harder than any problem definable
in second-order arithmetic and thus outside the analytical hierarchy. Analogous results for
satisfiability and subsumption follow by the reductions given in Section 2. Our reduction
applies already to the case where TBox and preference relation are empty.
For a finite set R of binary relation symbols, denote by MSO(R) the set of formulas
constructed from a countably infinite set P1 , P2 , . . . of variables for sets, a countable infinite
set x1 , x2 , . . . of individual variables, and the binary relation symbols in R, using Boolean
connectives, first-order quantification, and monadic second-order quantification. It is not
hard to see that reasoning with role-fixing cKBs corresponds to reasoning in a tiny fragment of MSO(R). More specifically, consider the standard translation of ALC-concepts C to
FO-formulas (and thus MSO(R)-formulas) C ] (x) with one free individual variable x as e.g.
given by Borgida (1996) and take a cKB CircCP (T , A) with CP = (, M, F, V ),  = V = ,
M = {A}, and F = {r}. Translate (T , A) to the MSO(R)-sentence
^
^
^
=
x(C ] (x)  D] (x)) 
C ] (xa ) 
r(xa , xb ),
CvDT

C(a)A

r(a,b)A

where the xa are individual variables.
Then an ALC-concept C is satisfiable w.r.t. CircCP (T , A) if, and only if, the MSO(R)formula
  xC ] (x)  P (P  A]  [P/A] ])
is satisfiable, where P  A] stands for x (P (x)  A] (x))x (A] (x)P (x)) and [P/A] ]
denotes  with A] replaced by P . This translation is easily extended to the case where an
arbitrary number of concept names is minimized and an arbitrary number of concept and
role names is fixed and varies.
When we prove that logical consequence in MSO(R) is reducible to the instance problem w.r.t. role-fixing cKBs, we thus establish the surprising result that reasoning in such
sKBs does not only correspond to the above tiny fragment of MSO(R), but is as hard as all
of MSO(R). Our reduction is indirect: instead of directly reducing logical consequence in
MSO(R), we reduce the semantic consequence problem of modal logic and exploit Thomasons result that logical consequence in MSO(R) can be reduced to the latter problem, see
745

fiBonatti, Lutz, & Wolter

the works by Thomason (1975b, 1975a) and the survey articles by Wolter et al. (2007) and
Goldblatt (2003) for details.
We first define the semantic consequence problem of modal logic (in the framework of
description logic) and present Thomasons result, starting with some notation.
Let R be a finite set of role names. An R-frame is a structure F = (F , RF ), where F
is a non-empty domain and rF  F  F for all r  R. An interpretation I = (I , I ) is
based on an R-frame F iff F = I and rI = rF for all r  R. We say that a concept C is
valid in F and write F |= C if C I = I for every interpretation I based on F. The semantic
consequence of modal logic is now defined as follows. Let C and D be ALC concepts with
roles from R. Then D is a semantic consequence of C, in symbols C  D, if for every
R-frame F, from F |= C it follows that F |= D. Note that since validity in an R-frame F
involves quantification over all possible interpretations of the symbols not contained in R,
the relation C  D is invariant over all uniform renamings of atomic concepts in D (this
will be used later on).
For simplicity, we consider only MSO(r), monadic second-order logic with one binary
relation symbol r. It is straighforward to extend our result to arbitrary finite sets R of
relation symbols. Given a set of role names R, an ALC-concept is called an ALC R -concept
if it uses no other role names other than those in R. The following theorem follows from
the results by Thomason (1975b, 1975a).
Theorem 20 There exist an effective translation  :  7 () of MSO(r) sentences to
ALC {r} -concepts and an ALC {r} -concept C0 such that for all MSO(r) sentences  and ,
the following conditions are equivalent:
  is a logical consequence of  in MSO(r);
 C0 u ()  ().
We can thus establish the reduction of MSO(r) to the instance problem w.r.t. role-fixing
cKBs by reducing instead the semantic consequence problem. In fact, such a reduction can
be implemented in a very transparent way if we extend ALC with the universal role, whereas
the reduction to ALC itself requires a number of rather technical intermediate steps. For
this reason, we defer the ALC case to the appendix and give the proof with the universal
role.
Let u be a new role name, called the universal role. In every interpretation I, u has the
fixed interpretation as uI = I  I . Since the interpretation of u is fixed anyway, we do
not allow to use it in circumscription patterns.
Now suppose that C and D are ALC {r} -concepts. To establish the reduction, we construct a role-fixing cKB CircCP (, {C0 (a)}) and concept C1 such that C  D if, and only if, a
is an instance of C1 w.r.t. CircCP (, {C0 (a)}). As noted above, we may assume that C, D do
not share any concept names (otherwise, simply replace the concept names in D with fresh
ones). Let A be a concept name that does not occur in C and D, let CP = (, M, {r}, V ),
where  = , M consists of A and the set of concept names in C, and V consists of the
concept names in D. Set A = {(u.C t u.
B)(a)}.

u

BM

Lemma 21 The following conditions are equivalent:
746

fiThe Complexity of Circumscription in DLs

 C  D;
 a is an instance of (u.C) t D w.r.t. CircCP (, A).
Proof. To prove that Point 1 implies Point 2, assume that Point 2 does not hold. Let I
be a model of CircCP (, A) such that aI  ((u.C) u D)I . Let I be based on F. To prove
that Point 1 does not hold, we show that F |= C and F 6|= D. The latter is easy as it is
witnessed by the interpretation I. To show the former, let J be an interpretation based
on F. We show that C J = I . First note that, since I is a model of A and aI  (u.C)I ,
we have B I = I , for all B  M . We now distinguish two cases:
 B J = I , for all B  M . In this case, all B  M have the same interpretation in I
and J . Thus, since all concept names in C are in M and I and J are based on the
same frame, we obtain C J = C I = I .
 B J 6= I , for at least one B  M . Then J <CP I. Assume that C J 6= I . Then
aI  (u.C)J and J is a model of A. Thus, we have derived a contradiction to the
assumption that I is a model of CircCP (, A).
To prove that Point 2 implies Point 1, assume that Point 1 does not hold. Consider a
frame F such that F |= C, but F 6|= D. Let I be an interpretation based on F such that
aI  (D)I . We may also assume that B I = I for all B  M (since no such B occurs in
D). Then aI  ((u.C) u D)I and I is a model of A. It remains to show that there does
not exist an I 0 <CP I such that I 0 is a model of A. This is straightforward: from F |= C, we
0
0
obtain that there does not exist any I 0 such that aI  (u.C)I . Moreover, there clearly
0
0
0
does not exist an I 0 such that B I ( B I for some B  M and aI  (u.
B)I .
o

u

BM

We have thus proved that the logical consequence problem of MSO(r) is effectively reducible
to the instance problem w.r.t. role-fixing cKBs formulated in ALC extended with the universal role. In our reduction, the TBox and preference relation are empty. In the appendix,
we show how the reduction above can be modified so as to prove the same result for ALC
without the universal role.
Theorem 22 The logical consequence problem of MSO(r) is effectively reducible to the
instance problem w.r.t. role-fixing cKBs formulated in ALC. This even holds when the
TBox and preference relation are empty.

6. Circumscription with Minimized Roles
Unlike fixed concept names, fixed role names cannot be simulated using minimized role
names. This is due to the fact that Boolean operators on roles are not available in standard
DLs. Thus, Theorem 22 does not imply undecidability of reasoning in cKBs in which role
names are allowed to be minimized, but not fixed. In this section, we investigate cKBs of
this type. The formal definition is as follows.
Definition 23 A cKB CircCP (T , A) with CP = (, M, F, V ) is called role-minimizing if F
contains no role names.
4
747

fiBonatti, Lutz, & Wolter

We show that role-minimizing cKBs behave rather differently from concept-circumscribed
KBs and from role-fixing cKBs. First, it turns out that reasoning with role-minimizing
cKBs with empty TBox is NExpNP -complete for ALCQO, but undecidable for ALCI.
Thus, in contrast to the circumscribed KBs considered so far, we now observe a difference
in complexity between ALCQO and ALCI, and even between ALC and ALCI. A second
difference to the results obtained so far is that the NExpNP -lower bound, which applies
to cKBs formulated in ALC with an empty TBox, even holds for role-minimizing cKBs in
which a single role is minimized and no other predicate is fixed or minimized. This result
is of interest because it shows that complexity does not drop to NPNExp if the number of
minimized predicates is constant. Finally, we show that, with non-empty TBoxes, reasoning
with role-minimizing cKBs becomes undecidable already for ALC.
6.1 Role-minimizing cKBs With Empty TBox in ALCQO
We first prove the NExpNP -completeness result discussed above for DLs without inverse
roles. We start with the upper bound. To prove it, we first establish a bounded model
property using a selective filtration-style argument, see e.g. Blackburn et al. (2001). The
difference to the bounded model property proof given above for concept-circumscribed KBs
is that, here, we do not build a quotient model of a given model by identifying nodes using an
equivalence relation, but construct a submodel of a given model by selecting relevant nodes.
In contrast to forming quotient models, this technique works only with empty TBoxes since
a TBox can force us to select infinitely many nodes. Similarly, the selection technique does
not work for DLs with the inverse role because, as we shall see below, inverse roles can be
used to simulate TBoxes.
Recall that the role depth rd(C) of a concept C is defined as the nesting depth of the
constructors (> k r D) and (6 k r D) in C.
Theorem 24 In ALCQO, satisfiability w.r.t. role-minimizing cKBs with empty TBox is
in NExpNP .
Proof. Let CircCP (, A) be a role-minimizing cKB with CP = (, M, F, V ), and let C0 be a
concept that is satisfiable w.r.t. CircCP (, A). Let m0 be the maximal parameter occurring
in number restrictions of A or C0 . Set
n := max({rd(C0 )}  {rd(C) | C(a)  A}) and m := ((m0 + 1)  (|A| + |C0 |))n+1 ,
We show that there exists a model J of CircCP (, A) satisfying C0 such that #J  m.
Let I be a model of CircCP (, A) such that there exists a d0  C0I . For each d  I , fix a
minimal set D(d)  I such that,
 for every concept (> k r C) which occurs in A or C0 with d  (> k r C)I there exist
at least k distinct e  D(d) such that (d, e)  rI and e  C I and
 for every concept (6 k r C) which occurs in A or C0 with d 6 (6 k r C)I there exist
at least k + 1 distinct e  D(d) such that (d, e)  rI and e  C I .
Clearly, #D(d)  (m0 + 1)  (|C0 | + |A|) for each d  I . Next, define a set D0  I by
setting
D0 := {d0 }  {aI | a  NI occurs in A or C0 }.
748

fiThe Complexity of Circumscription in DLs

Define sets Di  I , 1  i  n, inductively by
[
Di+1 := (
D(d))
dDi

and set n :=

S

0in Di .

Define an interpretation I 0 with domain I as follows:

0

 aI = aI , for all individual names a;
0

 for r  M  V , (d, e)  rI if d  n \ Dn , e  D(d), and (d, e)  rI ;
0

 for A  M  V , AI = AI  n ;
0

 for A  F , AI = AI .
0

A straightforward inductive argument shows that I 0 is a model of A such that d0  C0I .
0
Note that we did not change the interpretation of the A  F . Moreover, we have pI  pI
for every p  M . Together with the fact that I 0 is a model of A and I 0 6<CP I, we even get
0
pI = pI for every p  M . It follows that I 0 is a model for CircCP (, A) because J <CP I 0
would imply J <CP I.
0
Note that rI  n  n , for every role r. Now define an interpretation J with domain
J = n by putting
0

 AJ = AI  n , for every concept name A;
0

 rJ = rI , for every role name r;
 aJ = aI , for every individual name a from A or C0 .
We still have that J is a model for A satisfying C0 . Moreover, any interpretation J 0 <CP J
satisfying A can be easily extended to an interpretation I 00 <CP I 0 satisfying A. Hence, no
such interpretation exists and J is a model for CircCP (, A). From #n  m we derive
#J  m.
The proof of the NExpNP -upper bound is now exactly the same as the proof of Theorem
10; it suffices to replace the bound 24k for the size of interpretations by the bound m.
o
We now give a lower bound matching the upper bound of Theorem 24.
Theorem 25 In ALC, satisfiability w.r.t. role-minimizing cKBs with empty TBox is NExpNP hard. This holds even if there is only one minimized role name and no fixed prediates
Proof. By Theorem 15, in ALC it is NExpNP -hard to decide whether a concept C0 is
satisfiable w.r.t. CircCP (, A), where CP = (, M, , V ) and M contains concept names only.
Clearly, it is still NExpNP -hard to decide whether there exists a common model of C0 and
CircCP (, A) of size at least #M . Thus, it is sufficient to provide a polynomial reduction
of this problem to the satisfiability problem w.r.t. cKBs in ALC with a single minimized
role and all remaining predicates varying. Suppose C0 and CircCP (, A) are given. Let
M = {A1 , . . . , Ak } and take
 two fresh role names r0 , r1 ;
749

fiBonatti, Lutz, & Wolter

 Boolean concepts C1 , . . . , Ck built using fresh concept names B1 , . . . , Bk such that
every Ci , i  k, is satisfiable and every Ci u Cj , i 6= j, is unsatisfiable. One can take,
for example, Ci = B1 u    u Bi1 u Bi u Bi+1 u    u Bk , for i  k.
Let CP0 = (, {r0 }, , V  {B1 , . . . , Bk , r1 }) and define A0 and C00 as the result of replacing,
in A and C0 , every occurrence of Ai by r0 .Ci , for i  k. Finally, set A = A0  {r1 .Ci (a) |
i  k}. We show the following:
() C0 is satisfiable w.r.t. CircCP (, A) in a model of size at least #M if, and only if, C00 is
satisfiable w.r.t. CircCP0 (, A ).
Let I be a model of CircCP (, A) and C0 of size at least #M . Define an interpretation I 0
with domain I by extending I as follows: take mutually distinct d1 , . . . , dk  I and
interpret B1 , . . . , Bk , r0 , r1 , and a in such a way that
0

 CiI = {di }, for i  k,
0

 r0I = {(d, di ) | d  AIi , i  k},
 aI = d1 ,
0

 r1I = {(d1 , d1 ), . . . , (d1 , dk )}.
It is readily checked that I 0 is a model of C00 and CircCP0 (, A ).
Conversely, let I be a model of CircCP0 (, A ) and C00 . Define an interpretation I 0 by
0
extending I with AIi = (r0 .Ci )I , for i  k. It is readily checked that I 0 is a model of C0
and CircCP (, A).
o
6.2 Role-minimizing cKBs With Nonempty TBox
In the bounded model property proof above, it is important that the selection of nodes
stops after n iterations with the set n , where n is the maximum of the role depths of the
concepts in the ABox and the concept C we want to satisfy. Such a bound for the selection
of nodes does not exist if the TBox is non-empty, and we now show that reasoning w.r.t.
role-minimizing cKBs is indeed undecidable in this case. The proof is by a reduction of the
 -tiling problem (Berger, 1966).

N N

Definition 26 A tiling problem is a quadruple triple P = (T, H, V ), where T is a finite
set of tile types and H, V  T  T are the horizontal and vertical matching conditions. A
solution to P is a mapping  :   T such that

N N

 ( (i, j),  (i + 1, j))  H for all i, j  0;
 ( (i, j),  (i, j + 1))  V for all i, j  0.
4
750

fiThe Complexity of Circumscription in DLs

Let P = (T, H, V ) be an instance of the tiling problem. We define a TBox TP as follows:
> v x.> u y.>
> v
> v

t

At u

u

At 

tT

tT

u

(66)
At0
0



(67)

t0 T,t6=t

t

(t,t0 )H


x.At0 u

u

tT

At 

t

(t,t0 )V

y.At0



> v N t (x.y.B u y.x.B)
N

v D

(68)
(69)
(70)

D w x.D t y.D

(71)

D v x.D u y.D

(72)

Let CP = (, M, , V ) be the circumscription pattern in which V = {B, D} and M consists
of the remaining concept and role names.
Lemma 27 CircCP (TP , ) 6|= D(a) iff P has a solution.
Proof. Assume that P has a solution  . Define an interpretation I as follows:
I
xI
yI
AIt
NI
BI
DI
aI

:=
:=
:=
:=
:=
:=
:=
:=

NN

{((i, j), (i + 1, j)) | i, j  0}
{((i, j), (i, j + 1)) | i, j  0}
{(i, j)  I |  (i, j) = t}
I
{(i, j)  I | i > 0 and j > 0}

(0, 0)

It is straightforward to verify that I is a model of TP . Additionally, we clearly have aI 
/ DI .
It thus remains to show that there is no model J of TP with J <CP I. Assume there is
such a J . Since all concept and role names except D and B are minimized, it follows that
1. xI = xJ and y I = y J because J is a model of (66);
2. AIt = AJ
t for all t  T because of Point 1 and J is a model of (67);
3. N I = N J because, no matter what B J is, by Point 1 we have
(x.y.B u y.x.B)J = .
Thus and because J is a model of (69), N I = N J .
Thus, I and J differ at most in the interpretation of the concept names D and B, which
are varying. This is a contradiction to J <CP I.
Conversely, assume that CircCP (TP , ) 6|= D(a), and let I be a model of CircCP (TP , ) with
aI 6 DI . By induction on i + j, we define a mapping  that assigns to each (i, j)  
an element (i, j)  I such that for all i, j  0, we have

N N

751

fiBonatti, Lutz, & Wolter

1. ((i, j), (i + 1, j))  xI ;
2. ((i, j), (i, j + 1))  y I ;
To start, set (0, 0) = aI . In the `-th step, we do the following:
 Select a d  I such that ((0, `  1), d)  y I and put (0, `) := d. Such a d exists
since I is a model of (66).
 Select a d  I such that ((`  1, 0), d)  xI and put (`, 0) := d. Again, such a d
exists since I is a model of (66).
 Now let i, j > 0 such that i + j = `. Since I is a model of (66), there are d, d0  I
such that ((i  1, j), d)  xI and ((i, j  1), d0 )  y I . We show that d = d0 , and
then set (i, j) := d.
Assume to the contrary that d 6= d0 . By (70)(72) and since aI 
/ DI , we have
I
(i  1, j  1)  N . Define a new interpretation J that is obtained from I by the
following modifications:
 (i  1, j  1) is removed from N I ;
 let d0  B J and d 6 B J ;
 let DJ = I .
Clearly, J <CP I. To obtain a contradiction against I being a model of CircCP (TP , ),
it thus remains to show that J is a model of TP . It suffices to consider (69) to (72),
the only concept inclusions referring to N , B, and D. The axioms (70) to (72) hold
because DJ = I . To show (69), let e  I . We show that e  C J for C the concept
on the right hand side of (69). Clearly, e  C J since e  C I , if e is not {x, y, x , y  }reachable from aI . We have e  N I if e is {x, y, x , y  }-reachable from aI , because
otherwise we would have aI  DI by axioms (70) to (72). Thus, e  N J  C J if
e 6= (i  1, j  1). Finally, (i  1, j  1)  C J , by definition of B J .

N N

Now define a mapping  :   T by setting  (i, j) := t if (i, j)  At . By (67), this
mapping is well-defined. By (68), it satisfies the horizontal and vertical matching conditions.
Thus, P has a solution.
o
Thus, we have shown the following result.
Theorem 28 In ALC, satisfiability w.r.t role-minimizing cKBs is undecidable.
6.3 Reasoning in Role-minimizing cKBs With Empty TBox in ALCI
We prove undecidability of reasoning in role-minimizing cKBs with empty TBox in ALCI.
The proof uses the spy-point technique (Areces, Blackburn, & Marx, 1999); namely, we
show that ABoxes can simulate TBox reasoning by employing inverse roles and a simulation
of nominals by circumscription. Using this idea the proof is rather similar to the proof of
Theorem 28.
752

fiThe Complexity of Circumscription in DLs

Let P be an instance of the tiling problem and consider the cKB CircCP (TP , ) defined
in the proof of Lemma 27. We simulate its TBox axioms C v C 0 by ABox assertions
((C  C 0 ) u r0 .(C  C 0 ))(a) and enforcing the role r0 to connect all relevant points to a.
This is achieved by forcing all relevant points in the domain to satisfy r0 .{a}. Since we
do not have nominals in the language we use a concept name A instead of {a} and ensure
that it behaves like a nominal. We now present the details.
For the sake of readability, we write concept assertions C(a) in the form a : C and we
set 1 {r}.C = C u r.C. Let A, B 0 , and N 0 be fresh concept names and r0 be a fresh role
name not occurring in TP . Then AP consists of the assertions
a : 1 {r0 }.(C  C 0 ),

(73)

for C v C 0  TP ,
a : A,

a : 1 {r0 }.

u s.r

s=x,y




a : 1 {r0 }. N 0 t (A u B 0 ) t r0 .(A u B 0 ) u
a : 1 {r0 }.(N 0  D),


0 .A,

(74)

t s.r

s=x,y


0 .(A

u B 0 )



a : r0 .D  D

(75)

(76)

Now let CP = (, M, , {D, B, B 0 }), where M consists of all concept and role names distinct
from D, B, and B 0 .
Lemma 29 CircCP (, AP ) 6|= D(a) iff P has a solution.
Proof. Assume P has a solution  . Take the interpretation I from the proof of Lemma 27
expanded by
AI = {(0, 0)},

N 0I = I ,

B 0I = ,

r0I = {(aI , d) | d  I }.

We show that I is a model of CircCP (, AP ). Clearly, I is a model of AP . Thus it remains
to show that there is no model J of AP with J <CP I. Assume there exists J <CP I which
is a model of AP . As A is minimized and by (74), AJ = {(0, 0)}. It follows from axiom
(66) encoded in (73) that ((0, 0), (1, 0))  xJ and ((0, 0), (0, 1))  y J . Now one can prove
by induction on ` > 0 using again the axiom (66) encoded in (73) and (74) that for all (i, j)
with i + j = `, ((0, 0), (i, j))  r0J and ((i, j), (i + 1, j))  xJ , ((i, j), (i, j + 1))  y J . It
follows that xJ = xI and y J = y I . Also observe that N 0J = I because, no matter how
B 0 is interpreted,

J

(A u B 0 ) t r0 .(A u B 0 ) u
s.r0 .(A u B 0 )
= .

t

s=x,y

Now one can prove similarly to the proof of Lemma 27 that J can only differ from I in the
interpretation of B, B 0 , and D, which is a contradiction.
Conversely, suppose I is a model of CircCP (, AP ) with aI 6 DI . We first show that
(aI , d)  r0I whenever d 6= aI and d is {x, y}-reachable in I from aI in a finite number of
steps. Assume that this is not the case. Then there exist d, d0  I such that
753

fiBonatti, Lutz, & Wolter

 d = aI or (aI , d)  r0I ,
 (d, d0 )  xI or (d, d0 )  y I ,
 (a, d0 ) 6 r0I .
By (74), there exists d00  I such that aI 6= d00 , (d00 , d0 )  r0I , and d00  AI . Observe that
d  N 0I by (76) and aI 6 DI . Define a new interpretation J by modifying I as follows:
 d is removed from N 0I ;
 let aI  B 0J and d00 6 B 0J ;
 let DJ = I .
Clearly J <CP I. To obtain a contradiction it is thus sufficient to show that J is a model
of AP . Clearly, all assertion in AP containing neither D, B 0 , nor N 0 are satisfied in J . For
the remaining assertions except (75), it follows from DJ = I that they are satisfied in J .
Finally, for (75), observe that N 0I  {aI }  {e | (aI , e)  r0I } because a 6 DI and assertions
(76). Thus, by definition of N 0J , we only have to consider the point d removed from N 0I .

J

s.r0 .(A u B 0 )
by definition of J .
But d  (A u B 0 ) t r0 .(A u B 0 ) u

t

s=x,y

Now one can use the assertions (73) to construct a solution  of P in the same way as
in the proof of Lemma 27.
o
We have thus proved the following result.
Theorem 30 In ALCI, satisfiability w.r.t. role-minimizing cKBs with empty TBox is undecidable.

7. Related Work
We have already pointed out in the introduction that circumscription is just one of several
possible approaches to nonmonotonic DLs and that, in order to achieve decidability, each
of these approaches has to adopt a suitable restriction on the expressive power of the DL
component, on the non-monotonic features, or on the interaction of the DL and its nonmonotonic features. In this section, we survey the existing approaches, discuss the adopted
restrictions, and relate them to DLs with circumscription whenever possible. However, we
point out that a full-fledged formal comparison of the different approaches is a serious research endeavor of its own and outside the scope of this paper. The main approaches to
nonmonotonic DLs (excluding those relying on the integration of DLs and logic programming) are summarized in Table 1, where n.a. stands for not analyzed and the specificity
column states whether a formalism is equipped with a priority mechanism based on the the
specificity (i.e., subsumption) of concepts.
We start with two early approaches based on circumscription. In the work by Brewka
(1987), a frame system is given a nonmonotonic semantics based on circumscription. The
focus is on showing the appropriateness of the proposed semantics, and the decidability and
complexity of reasoning is not analyzed. Cadoli et al. (1990), apply circumscription to a DL
754

fiThe Complexity of Circumscription in DLs

Ref
(Brewka, 1987)
(Cadoli, Donini, &
Schaerf, 1990)
(Padgham & Zhang,
1993)
(Straccia, 1993)
(Baader & Hollunder, 1995a)
(Baader & Hollunder, 1995b)
(Lambrix,
Shahmehri, & Wahlloef,
1998)
(Donini et al., 1997)

DL
frame lang.
< ALE

NM features
Circ
Circ

Complexity
n.a.
in p2

Specificity
Y
N

AL with concrete domains
ALC

inheritance
networks
prioritized
default logic
default logic

n.a.

Y

decidable

Y

decidable

N

prioritized
default logic
prioritized
default logic

decidable

Y

n.a.

Y

MKNF with
restrictions
MKNF with
restrictions
maximized
typicality

depends on DL

N

in 3-ExpTime

N

in co-NExpNP

N

ALCF
ALC
ALQO+feature
agreement
any decidable DL

(Donini et al., 2002)

ALC

(Giordano, Gliozzi,
Olivetti, & Pozzato,
2008)

ALC

Table 1: Some approaches to nonmonotonic DLs

in the same way as we do here. The authors consider only non-prioritized circumscription
and apply it to a fragment of the description logic ALE. Decidability of reasoning is shown
by a reduction to propositional reasoning under the Extended Closed World Assumption
(ECWA), which is in p2 . To the best of our knowledge, this was the first effective reasoning
method for a nonmonotonic description logic.
In another early approach by Padgham and Zhang (1993), a nonmonotonic DL is obtained by an adaptation of the inheritance networks approach (Horty, 1994) where the
underlying DL is essentially AL extended with concrete data values. The main contribution is the definition of the formalism and a discussion of applications, decidability and
complexity are not analyzed.
A recent approach that is similar in spirit to circumscription has been taken by Giordano
et al. (2008). The authors extend ALC with a modal operator T representing typicality,
and maximize T s extension to achieve nonmonotonic inferences. Decidability is proved via
a tableau algorithm that also establishes a co-NExpNP upper bound for subsumption. A
lower bound is not given.
We now turn to approaches based on default logic (Reiter, 1980). The nonmonotonic
DLs by Baader and Hollunder (1995a, 1995b), Straccia (1993), and Lambrix et al. (1998)
share a common restriction: default rules can be applied to an individual only if it has
a name, that is, if it is denoted by an individual constant that occurs explicitly in the
knowledge base. This restriction is motivated by the observation that, when defaults are also
applied to implicit (anonymous) individuals, then reasoning becomes undecidable (Baader &
755

fiBonatti, Lutz, & Wolter

Hollunder, 1995a). Since the models of DL knowledge bases usually include a large number
of anonymous individuals due to existential quantification, this restriction introduces a
strong asymmetry in the treatment of individuals.
Another line of nonmonotonic DLs (Donini et al., 1998, 1997, 2002) is based on first-order
autoepistemic logics whose interpretation domains are restricted to a fixed and denumerable
set of constants. The use of a unique domain resolves several issues related to quantification
in modal logics (such as whether the Barcan formula should hold, and whether different
worlds of the same Kripke structure should be allowed to have different domains). It also
avoids the asymmetry of the approaches based on default logic because, by definition, all
individuals have a name. The other side of the coin is that domains with finite or varying
cardinality and knowledge bases that do not satisfy the unique name assumption can only
be dealt with using rather technical encodings (such as an explicit axiomatization of the
finite domain represented by a concept name D).
In the first paper mentioned above (Donini et al., 1998), decidability results apply only to
monotonic knowledge bases4 as the autoepistemic operator can be used in a nonmonotonic
fashion only in queries. This restriction has been lifted in the subsequent publications.
They make use of the logic of minimal knowledge and negation as failure (MKNF), which
is equipped with two (auto)epistemic operators K and A (Donini et al., 1997, 2002).
In the former paper (Donini et al., 1997), the underlying monotonic fragment can be any
description logic with a decidable instance checking problem. The price payed for this
generality is that decidability results apply only to so-called simple knowledge bases, where
quantifying-in (that is, quantification across modal operators, as in R.K C) is not allowed.
Nonetheless, such KBs are expressive enough to model default rules. A different restriction is
explored by Donini et al. (2002). The underlying DL is restricted to ALC while limited forms
of quantifying-in are allowed, in so-called subjectively quantified ALCKN F knowledge bases.
Decidability results are obtained for the subclass of simple subjectively quantified knowledge
bases, whose nonmonotonic part is restricted to inclusions of the form KC v D such that
> v C is can not be inferred from the knowledge base. This restriction is incompatible
with the traditional embedding of (priority-free) circumscription into autoepistemic logic,
which is based on prerequisite-free default rules that would be equivalent to inclusions of
the form K> v C.
A recent line of research on integrating DLs and logic programming rules introduces
further nonmonotonic extensions of DLs based on negation-as-failure. Some approaches
(Eiter et al., 2004) use a loosely coupled integration of logic programs and DLs, where the
interpretations of the DL component are not restricted while the logic program variables
range only over the named DL individuals. Thus, these approaches are somewhat similar
to the classical extensions of DLs based on defaults in that nonmonotonic inferences are
limited to named individuals. A more recent approach (Motik & Rosati, 2007) is based on
MKNF and shares with the MKNF-DLs discussed above pros and cons of adopting a fixed
denumerable domain. If the complexity of reasoning in the underlying DL is C 6 NP, then
the data complexity of entailment is bounded by C C . Finally, we mention a 3-valued variant
of this approach (Knorr, Alferes, & Hitzler, 2007) based on the well-founded semantics.
4. The autoepistemic operator can be used only in restricted contexts that suffice to encode so-called
procedural rules, which are monotonic.

756

fiThe Complexity of Circumscription in DLs

ALC

Concept circ.
Minim. roles
Fixed roles

#M  n, #F  n
(unrestricted)
TBox= 
TBox6= 

ALCQO
ALCI ALCIO
NExp
NP
NExpNP even if = , and either TBox= or ABox=
NExpNP even if #M  1, #F  0
Undecidable
Undecidable
Highly undecidable, even if TBox= , = 

Table 2: Summary of complexity results for satisfiability w.r.t. cKBs
A common limitation of the nonmonotonic extensions of DLs based on MKNF is that
they provide no support for specificity and priorities. In particular, defeasible inheritance
is not mentioned in the expressiveness analysis for autoepistemic approaches (Donini et al.,
1997, 2002) and it does not appear to be a goal of any MKNF-based approach. As pointed
out in the introduction, it is well-known that, in the propositional case, nonmonotonic logics
cannot modularly encode specificity-based priorities such as those needed by inheritance
mechanisms (Horty, 1994).

8. Conclusions and Perspectives
We have shown that circumscription provides an elegant approach to defining nonmonotonic
DLs, that the resulting formalisms have an appealing expressive power and are decidable
if appropriate restrictions are adopted. The main such restriction, which leads to rather
robust decidability results, is that only concept names are minimized and fixed whereas all
role names vary. With empty TBoxes, decidability is retained if roles are allowed to be
minimized, but not when they are fixed. The decidability and complexity results obtained
in this paper are listed in more detail in Table 2. By the results of Section 3, all bounds
with TBox 6=  apply to both general and acyclic TBoxes.
We view this paper as a promising step towards establishing circumscribed DLs as a
major family of nonmonotonic DLs to be used in practical applications. To reach this goal,
some additional research topics have to be addressed, of which we mention two. First, the
algorithms presented in this paper are based on massive non-deterministic guessing and
thus do not admit an efficient implementation. Ideally, one would like to have algorithms
which are well-behaved extensions of the tableau algorithms that underly state-of-the-art
DL reasoners (Baader & Sattler, 2000). A crucial issue is whether the sophisticated optimization techniques implemented in such reasoners (tableaux caching, dependency-directed
backtracking etc.; cf. Baader et al., 2003, Chap. 9) can be adapted to circumscribed DLs.
Some first steps have been made by Grimm and Hitzler (2008). Second, it seems necessary
to develop a design methodology for modelling defeasible inheritance. The examples given
in this paper indicate that the main challenge is to find rules of thumb to determine which
predicates should be fixed, varied, and minimized. It may be appealing to hide abnormality
predicates behind explicit syntax for defeasible inclusions, and trade some generality for
simplicity and usability.
Also from a theoretical perspective, our initial investigation leave open at least some
interesting questions. For example, our current techniques are limited to circumscribed DLs
757

fiBonatti, Lutz, & Wolter

that have the finite model property. It would be desirable to overcome this limitation and
obtain decidability results for even more expressive DLs such as SHIQ or OWL. It is also
possible to follow the opposite approach and consider circumscribed versions of inexpressive
DLs such as those of the EL or DL-Lite family (Baader, Brandt, & Lutz, 2005a; Calvanese,
Giacomo, Lembo, Lenzerini, & Rosati, 2007), which are currently very popular in a large
number of applications. First steps have been made by Bonatti, Faella, and Sauro (2009),
who investigated circumscribed versions of EL and DL-lite.
Finally, it is worth mentioning that our complexity results for circumscription can be
used to prove complexity bounds for other, seemingly unrelated, reasoning problems in
description logic. For example, certain reasoning services for conservative extensions and
modularity in description logic and the satisfiability problem w.r.t. concept-circumscribed
knowledge bases are mutually reducible to each other in polynomial time (Konev, Lutz,
Walther, & Wolter, 2008). As there are not many problems that are known to be NExpNP complete, circumscription thus provides a new class of problems that can potentially be
employed to give NExpNP lower bound proofs.

Acknowledgments
The first author was partially supported by the network of excellence REWERSE, IST-2004506779. The third author was partially supported by UK EPSRC grant no. GR/S63182/01.

Appendix A. Missing Proofs in Section 3
Lemma 5. In ALC, satisfiability w.r.t. (concept-)circumscribed KBs with empty TBox and
without fixed roles can be polynomially reduced to satisfiability w.r.t. (concept-)circumscribed KBs with empty TBox and without fixed predicates.
Proof. In the proof of Lemma 4, we have used TBox axioms to state that some fresh
concept names are interpreted as the complement of fixed concept names. In general, this
cannot be done using ABox assertions only. Instead, we construct ABox assertions which
force this to be the case only for objects which are relevant for the truth of the given ABox.
Some care is required to do this using ABox assertions of polynomial size. The first part of
the proof deals with this problem. The second part is then a straighforward modification
of the proof of Lemma 4.
The first part of the proof consists of introducing some notation and proving a central
technical claim. For w = r1    rn  NR , an interpretation I, and d, e  I , we write
I
(d, e)  wI iff there are d0 , . . . , dn  I with d = d0 , e = dn , and (di , di+1 )  ri+1
for all
i < n.
Let N be a set of individual names and Paths a mapping from N to the powerset of NR .
An interpretation I is well-behaved for the mapping Paths if for every d  I , there is an
a  N and a w  Paths(a) such that (aI , d)  wI . With each ALC-concept C, we associate
a set P(C) of pairs (w, D) with w  NR and D a subconcept of C as follows:
 if C  NC , then P(C) = {(, C)};
 if C = D, then P(C) = {(, C)}  P(D);
758

fiThe Complexity of Circumscription in DLs

 if C = D1 u D2 or C = D1 t D2 , then P(C) = {(, C)}  P(D1 )  P(D2 );
 if C = r.D or C = r.D, then P(C) = {(, C)}  {(rw, E) | (w, E)  P(D)}.
For a set of ABox assertions S and an individual name a, we use P(S, a) to denote the set
S
C(a)S P(C). We write Paths(S, a) for {w | D : (w, D)  P(S, a)}. We now formulate
the announced claim.
Claim 1. Suppose CircCP (, A) 6|= C0 (a0 ), where CP does not contain fixed role names and A
and C0 (a) are formulated in ALC. Let S = A  {C0 (a0 )} and let N be the set of individual
names in S. Let I 0 be the restriction of I to those d  I such that, for some a  N
and some w  Paths(S, a), we have (aI , d)  wI . Then I 0 is a model of CircCP (, A) and
C0 (a0 ) which is well-behaved for the mapping Paths(a) = Paths(S, a), a  N .
We now prove the claim. Let I be a model of CircCP (, A) with aI0  (C0 )I . Note that
0
for all a  N , we have   Paths(S, a) and thus aI  I . Clearly, I 0 is well-behaved for
Paths. One can prove by induction on C that
0

() for all a  N , (w, C)  P(S, a), and d  I with (aI , d)  wI , we have d  C I iff
0
d  CI .
We show only the case C = r.D, and leave the other cases to the reader. Let d  C I . Then
there is an e  DI with (d, e)  rI . Since (w, C)  P(S, a), we have (wr, D)  P(S, a).
0
Since (aI , d)  wI , we have (aI , e)  (wr)I . Thus, e  I and the induction hypothesis
0
0
0
yields e  DI . By definition of I 0 and the semantics, d  C I . Now let d  C I . Then there
0
0
is an e  DI with (d, e)  rI . By definition of I 0 , (d, e)  rI . Since (w, C)  P(S, a), we
have (wr, D)  P(S, a). Since (aI , d)  wI , we have (aI , e)  (wr)I . Thus, the induction
hypothesis yields e  DI .
Thus, () is established. Using () and the facts that aI0  (C0 )I and that I is a model
0
0
of A, it is not hard to verify that aI0  (C0 )I and that I 0 is a model of A. We show that
I 0 is also a model of CircCP (, A). Assume to the contrary that there is a model J 0 of A
with J 0 <CP I 0 . Define an interpretation J as follows:
 J = I ;
 AJ = AI for all A  F ;
0

 AJ = AJ for all A  V  M ;
0

 rJ = rJ for all r  NC ;
 bJ = bI for all b  NI .
Using the assumption that CP does not contain fixed role names, it is not hard to verify
that J <CP I. To obtain a contradiction to the fact that I is a model of CircCP (, A), it
thus remains to show that J is a model of A. To this end, we prove by induction on C that
0

() for all a  N , (w, C)  P(S, a), and d  J with (aJ , d)  wJ , we have d  C J iff
0
d  CJ .
Since the induction step is as in the proof of (), we only do the induction start. Thus, let
C = A  NC . If A  V  M , we are done by definition of J . Now let A  F . Since I 0 is
759

fiBonatti, Lutz, & Wolter

0

0

0

0

a restriction of I and AJ = AI , the definition of J yields AJ  J = AJ , as required.
This finishes the proof of the claim.
To prove Lemma 5, we consider instance checking instead of satisfiability. Since we
have provided polynomial reductions from satisfiability to (non)-instance checking and vice
versa in Section 2, we nevertheless obtain the desired result. Let CircCP (, A) be a cKB
with CP = (, M, F, V ) and F = {A1 , . . . , Ak }. Take a concept assertion C0 (a0 ). Let
S = A  {C0 (a0 )} and N be the set of individual names in S. Define
 M 0 = M  {A1 , . . . , Ak , A01 , . . . , A0k }, where the A0i are fresh concept names;
 A0 = A  {w.(A0i  Ai )(a) | w  Paths(S, a), a  N , i  k};
 CP0 = (, M 0 , , V ).
Then CircCP (, A) |= C0 (a0 ) iff CircCP0 (, A0 ) |= C0 (a0 ) follows immediately from Claim 1
and the fact that Paths(S, a) = Paths(S 0 , a), for S 0 = A0  C0 (a0 ).
o
Lemma 6 C0 is satisfiable w.r.t. CircCP (T , A) iff C0 u B 0 is satisfiable w.r.t. CircCP0 (T 0 , A).
Proof. Suppose I is a model of C0 and CircCP (T , A). Expand I to an interpretation I 0 by
setting
0
0
0
0
0
AI = B 0I = I , B I = A0I = , uI = .
Clearly, I 0 is a model of C0 u B 0 and (T 0 , A). We show that I 0 is a model of CircCP0 (T 0 , A).
Assume to the contrary that there is a model J of (T 0 , A) with J <CP0 I 0 . Then A0J = ,
AJ = I , B J = , and B 0 J = I . Since u is varying and J <CP0 I 0 , it is thus easy to
show that J <CP I. This contradicts the fact that I is a model of CircCP (T , A).
Conversely, suppose I is a model of C0 u B 0 and CircCP0 (T 0 , A). We show that I is also
a model of C0 and CircCP (T , A). First observe that AI = I . For suppose that this is not
the case. Define a new interpretation J in the same way as I except that uJ = I  I ,
B J = I , and B 0J = . Then J <CP0 I (since B 0I 6= ) and J is a model of (T 0 , A). Thus
we have derived a contradiction. It follows that C I = I and hence I is a model of (T , A)
and C0 . It remains to show that there is no J <CP I such that J is a model of (T , A).
Assume such a J exists. Then C J = I . Define a model J 0 by expanding J as follows:
0

0

AJ = B 0J = I ,

0

0

B J = A0J = ,

0

uJ = .

Note that A, B, A0 , B 0 , and u are interpreted by I in the same way, then J 0 <CP0 I.
Moreover, J 0 is a model of (T 0 , A). We have derived a contradiction.
o
Lemma 8 For all L  DL, simultaneous satisfiability w.r.t. (concept) circumscribed KBs
CircCP1 (T1 , A1 ), . . . CircCPk (Tk , Ak ), such that CircCPi (Ti , Ai ) and CircCPj (Tj , Aj ) share no
role names for 1  i < j  k, can be reduced to satisfiability w.r.t. single (concept)
circumscribed KBs in polynomial time.
Proof. It suffices to reduce simultaneous satisfiability without shared role names to the complement of instance checking w.r.t. single cKBs. As a generalization is straightforward, we
only give a proof for the case k = 2. Thus, let L  DL and CircCP1 (T1 , A1 ), CircCP2 (T2 , A2 )
760

fiThe Complexity of Circumscription in DLs

be cKBs formulated in L that share no role names, and C0 an L-concept. Moreover, let
A0 , . . . , An1 be the concept names shared by the two cKBs, R the role names used in at
least one of the two cKBs together with a fresh role name r0 , and CPi = (i , Mi , Fi , Vi ) for
i  {1, 2}. We obtain a new TBox T20 from T2 by replacing each concept name Ai , i < n,
with a new concept name A0i . Let A02 be obtained from A2 and CP02 = (02 , M20 , F20 , V20 ) from
CP2 in the same way. Define a TBox T  as follows, where P is a fresh concept name:
Ai u A0i v P for all i < n
Ai u A0i v P for all i < n
P
r.P

v r.P for all r  R
v P for all r  R

Now set:
T

:= T1  T20  T 

A := A1  A02  {r0 (b1 , b2 ) | b1 , b2 occur in A1  A2  T1  T2 }
 := 1  02
M

:= M1  M20

F

:= F1  F20

V

:= V1  V20  {P, r0 }

CP := (, M, F, V )
Let a0 be an individual name from A1 (clearly, we may assume that A1 6= ). It remains
to show the following:
Claim. C0 is simultaneously satisfiable w.r.t. CircCP1 (T1 , A1 ) and CircCP2 (T2 , A2 ) iff a0 is
not an instance of (P u r0 .C0 ) w.r.t. CircCP (T , A).
If. Assume that a0 is not an instance of (P u r0 .C0 ) w.r.t. CircCP (T , A). Then there
is a model I of CircSCP (T , A) with aI0  (P u r0 .C0 )I . We call I connected if the directed
graph GI = (I , rR rI  (r )I ) is connected. A connected component I 0 of I is the
0
0
restriction of I to domain I such that I is a (maximal) connected component in GI .
We may assume without loss of generality that the chosen model I is connected: if it is
not, then the use of the role r0 ensures that there is a connected component I 0 of I that
contains bI for all individual names b in A1  A2  T1  T2 . It is easy to see that I 0 is a
0
0
model of CircCP (T , A) and aI0  (P u r0 .C0 )I , thus we may simply replace I by I 0 .
We have to show that C0 is simultaneously satisfiable with respect to CircCP1 (T1 , A1 )
and CircCP2 (T1 , A2 ). Clearly, I is a model of C0 . By construction of CircCP (T , A), it is
a model of T1 , and A1 . To show that I is also a model of CircCP1 (T1 , A1 ), assume to the
contrary that this is not the case. Then there exists a model J of T1 and A1 such that
J <CP1 I. Define a model J 0 as follows:
0

 J = J ;
 all predicates used in T1 and A1 are interpreted as in J ;
 all predicates used in T20 and A02 are interpreted as in I.
761

fiBonatti, Lutz, & Wolter

(
 P

J0

:=

0

I

if ((Ai u A0i ) t (Ai u A0i ))J 6=  for some i < n



otherwise

0

0

 r0J = J  J .
It is readily checked that J 0 is a model of T and A, and that J 0 <CP I. Thus, we have
derived a contradiction to the fact that I is a model of CircCP (T , A), and it follows that I
is a model of CircCP (T1 , A1 ).
It remains to show that I is a model of CircCP (T2 , A2 ). Since I is connected, a model
of T  , and satisfies aI0 
/ P I , we have that AIi = (A0i )I for all i < n. Therefore, I is also a
model of T2 and A2 . Analogously to the case of CircCP1 (T1 , A1 ), we can now show that I is
a model of CircCP2 (T2 , A2 ).
Only if. Assume that C0 is simultaneously satisfiable w.r.t. the cKBs CircCP1 (T1 , A1 )
and CircCP2 (T2 , A2 ). Then there exists a model I of C0 that is a model of CircCP1 (T1 , A1 )
and CircCP2 (T2 , A2 ). We modify I to a new model I 0 by setting
0

 (A0i )I := AIi for all i < n;
0

 P I := ;
0

 r0I := I  I .
0

0

It is easy to see that I 0 is a model of T and A, and that aI  (P u r0 .C0 )I . To show
that a0 is not an instance of (P u r0 .C0 ) w.r.t. CircCP (T , A), it thus remains to prove
that I 0 is also model of CircCP (T , A). To do this, we first show the following:
(a) I 0 is a model of CircCP1 (T1 , A1 ). This is the case since any model J of T1 and A1
with J <CP1 I 0 satisfies J <CP1 I. Thus, the existence of such a model contradicts
the fact that I is a model of CircCP1 (T1 , A1 ).
(b) I 0 is a model of CircCP02 (T20 , A02 ). Assume to the contrary that there is a model J of T20

:= (A0i )J
and A02 with J <CP02 I 0 . Convert J into an interpretation J  by setting AJ
i


for all i < n. Then, J is a model of T2 and A2 and satisfies J <CP2 I. This is a
contradiction to the fact that I is a model of CircCP2 (T2 , A2 ).
Now, assume to the contrary of what is to be shown that there is a model J 0 of T and
A with J 0 <CP I 0 . By definition of CP, J 0 <CP I 0 implies that either J 0 <CP1 I 0 or
J 0 <CP02 I 0 hold. Since J 0 clearly satisfies T1 , A1 , T20 , and A02 , we obtain a contradiction to
(a) and (b).
o

Appendix B. Missing Proofs in Section 4
Lemma 14 G is a yes-instance of co-3CERTCOLS iff CG is satisfiable w.r.t. CircCPG (, AG ),
where CPG = (, M, F, V ) with  = , M = {Root, Leaf, Clash},
F = {LeafFix, Tr, X0 , . . . , Xn1 , Y0 , . . . , Yn1 , },
and V the set of all remaining predicates in AG .
762

fiThe Complexity of Circumscription in DLs

Proof. If. Suppose that CG is satisfiable w.r.t. CircCPG (, AG ) and let I be a model of
I 6= . We have to show that G is a yes-instance of co-CERT3COL .
CircCPG (, AG ) with CG
S
To start, we show that
I.
(I) aI0  CG
I with d 6= aI .
Assume to the contrary that this is not the case. Then there is a d  CG
0
I , we have d  RootI . Let J be the interpretation obtained from I by setting
Since d  CG
RootJ = {aI0 }. By definition of AG , we have aI0  RootI , and thus J CPG I. Moreover,
it is easily seen that J is a model of AG . We have thus established a contradiction to the
fact that I is a model of CircCPG (, AG ), which proves (I).
By Lines (1)-(4) (Fig. 2), there are elements di,w  I (the nodes of the tree) for i  2n
and w  {0, 1}i such that

 aI0 = d0, ;
 di,w  XjI iff the j + 1-st bit of w is 1, for all i  2n and j  min{i, n  1};
 di,w  YjI iff the n + j + 1-st bit of w is 1, for all i, j with n < i  2n and j  i  n;
 (di,w , di+1,w0 ), (di,w , di+1,w1 )  rI , for all i < 2n;
 d2n,w  Leaf I , for all w  {0, 1}2n .
For i, j < 2n , we use `i,j to denote the element d2n,w such that w  {0, 1}2n denotes the
binary encoding of i followed by that of j. We now show that
(II) Leaf I = {`i,j | i, j < 2n }.
Assume to the contrary that this is not the case, i.e., that there is a d  Leaf I such that
d 6= `i,j for all i, j < 2n . Let id , jd > 0 be integers such that the truth values of X0 , . . . , Xn1
at d encode id and the truth values of Y0 , . . . , Yn1 encode jd . Starting from I, we construct
an interpretation J by setting
Leaf J
rJ

:= Leaf I \ {d}
:= (rI \ (I  d))  {(e, `id ,jd ) | (e, d)  rI }

Further modify J into J 0 by setting
PJ

0

:= (r2n .var1.Leaf)J 
(r2n .var2.Leaf)J 
(r2n .col1.Leaf)J 
(r2n .col2.Leaf)J

By going through Lines (1) to (26), it is straightforward to check that J 0 is a model of AG .
Moreover, we clearly have J 0 <CPG I, and thus obtain a contradiction to the fact that I is
a model of CircCPG (, AG ). We have thus shown (II).
The following is an easy consequence of (I), the fact that P is a conjunct of CG , and
Lines (8), (9), (20), and (21):
(III) (`i,j , d)  rI implies d  Leaf I for all i, j < 2n , d  I , and r  {var1, var2, col1, col2}.
763

fiBonatti, Lutz, & Wolter

Now suppose to the contrary of what we aim to prove that G is not a yes-instance. Then,
for all truth assignments t, the subgraph t(G) is 3-colorable. In particular, this holds for
the assignment t defined by setting, for all i, j < 2n ,

t(Vij ) := 1 iff `i,j  TrI .

Let c : {0, . . . , 2n  1}  {R, G, B} be a 3-coloring of t(G) and construct an interpretation
J by starting from I and applying the following modifications:

CJ
ClashJ

= {`i,0 | i < 2n , c(i) = C} for all C  {R, G, B}
= .

Clearly, J <CPG I: the minimized predicate Clash is empty in J , but non-empty in I since
I is non-empty. To obtain a contradiction, it thus suffices to show that J is a model
CG
of AG .
Since I and J agree on all predicates but R, G, B, and Clash, all inclusions that do not
mention these concepts are satisfied in J . These are Lines (1) to (21). Lines (22) and (23)
2n J
are satisfied by construction of J and since, due to Line (5) and (II), (aJ
0 , d)  (r )
n
implies d = `i,j for some i, j < 2 . It thus remains to consider Lines (24) to (26). We first
show that
(IV) for all i, j < 2n , (i, j) is an edge of t(G) iff `i,j 
/ ElimJ .
Let i, j < 2n and let the potential edge (i, j) be labeled with Vk1 ,k2  Vk3 ,k4 (since the
(i)
(i)
circuits cS and cj deliver an output for any input, we can assume that also potential,
but non-existing edges have a label). By (II) and (III) together with Lines (8) and (9),
var1J = var1I = {`k1 ,k2 } and var2J = var2I = {`k3 ,k4 }. Thus, the definition of t together
with Lines (12) to (16) yields that (i, j) is an edge of t(G) iff `i,j 
/ ElimI . To prove (IV), it
remains to note that I and J interpret the concept name Elim in the same way.
2n J
Now, we prove that (24) to (26) are satisfied in J . Let (aJ
0 , d)  (r ) . By Line 5
J
n
and (II), d = `i,j for some i, j < 2 . Let `i,j 
/ Elim . By (IV) and since c is a 3-coloring
of t(G), we get c(i) 6= c(j). Thus, by construction of J , `i,0 
/ C J or `j,0 
/ C J for all
C  {R, G, B}. By (II) and (III) together with Lines (18) and (19), col1J = col1I = {`i,0 }
and col2J = col2I = {`j,0 }. Therefore, `i,j 
/ (col1.C u col2.C)J for all C  {R, G, B}.
J
Since this holds for any `i,j 
/ Elim , the preconditions of the implications in Lines (24) to
(26) are never satisfied. Thus, the implications are satisfied.

Only if. Suppose that G is a yes-instance and let t be a truth assignment such that
t(G) is not 3-colorable. Let c : {0, . . . , 2n  1}  {R, G, B} be a color assignment that
minimizes (w.r.t. set inclusion) the set {(i, j) | (i, j) an edge in G with c(i) = c(j)}. Define
an interpretation I as follows (here and in the following, we do not distinguish between a
number and its binary encoding as a string):
764

fiThe Complexity of Circumscription in DLs

I
RootI

= {di,w | i  2n , w  {0, 1}i }
= {d0, }

I

= {d2n,w | w  {0, 1}2n }

LeafFixI

= {d2n,w | w  {0, 1}2n }

Leaf

XjI

= {di,w | the j + 1-st bit of w is 1, i  2n, and j  min{i, n  1}};

YjI
I

= {di,w | the n + j + 1-st bit of w is 1, n < i  2n, and j  i  n};

Tr

= {d2n,ij | t(Vij ) = 1}

TrI`

= {d2n,ij | t(Vij )  cS (i, j)}

(`)

(` = 1, 2)

Elim

I

= {d2n,ij | (i, j) is not an edge of t(G)}

C

I

= {d2n,i0 | c(i) = C} (C = R, G, B)

I

= {d2n,ij | (i, j) is an edge of t(G) and c(i) = c(j)}

r

I

= {(di,w , di+1,w0 ), (di,w , di+1,w1 ) | i < 2n}

var1

I

= {(d2n,ij , d2n,kl ) | the first variable in the label of (i, j) is Vkl }

var2

I

= {(d2n,ij , d2n,kl ) | the second variable in the label of (i, j) is Vkl }

I

col1

= {(d2n,ij , d2n,i0 ) | i < 2n }

col2I

= {(d2n,ij , d2n,j0 ) | i < 2n }

Clash

PI

= 

aI0

= d0, .

For each Boolean circuit c, the corresponding output concept name Outc is interpreted
as OutIc := {d2n,ij | i, j < 2n and c(i, j) is true}.
I and
To show that CG is satisfiable w.r.t. CircCPG (, AG ), it suffices to show that aI0  CG
I is a model of CircCPG (, AG ). The former is easy: recall that CG = RootuP ur2n .Clash.
By definition of I, aI0  (Root u P )I . Since c is not a 3-coloring, aI0  (r2n .Clash)I . It
thus remains to show that I is a model of CircCPG (, AG ). Since it is easy to verify that I is
a model of AG , this boils down to showing that there is no model J of AG with J <CPG I.
Assume to the contrary that there is such a J . By Lines (1)(5) and since J is a model
of AG , we have #Leaf J  22n . Since #Leaf I = 22n and J <CPG I, we get Leaf J = Leaf I .
For similar but simpler reasons, RootJ = RootI . Thus, J <CPG I implies ClashJ ( ClashI .
By Lines (1) to (5) and since I and J are models of AG with Leaf J = Leaf I and #Leaf I =
#Leaf J = 22n , we have
I
J
2n J
(I) {d  I | (aI0 , d)  (r2n )I } = {d  J | (aJ
0 , d)  (r ) } = Leaf = Leaf

Thus, Lines (24) to (26) and the fact that J is a model of AG ensure that
S
(II) C{R,G,B} (Leaf u Elim u col1.C u col2.C)J  ClashJ .
Define a coloring c0 by setting
c0 (i) = C iff d2n,i0  C J
Suppose that
765

(C = R, G, B).

fiBonatti, Lutz, & Wolter

(III) (a) ElimI  Leaf I = ElimJ  Leaf I ,
(b) col1I  (Leaf I  Leaf I ) = col1J  (Leaf J  Leaf J ), and
(c) col2I  (Leaf I  Leaf I ) = col2J  (Leaf J  Leaf J ).
Then (II) guarantees that if (i, j) is an edge in G with c0 (i) = c0 (j), then d2n,ij  ClashJ .
Since ClashJ ( ClashI , we get that
1. if c0 (i) = c0 (j), then c(i) = c(j);
2. there are i, j with c0 (i) 6= c0 (j), but c(i) = c(j).
This contradicts our initial minimality assumption on the coloring c.
It thus remains to prove (III). We start with (a). Assume that
(d) var1I  (Leaf I  Leaf I ) = var1J  (Leaf J  Leaf J ) and
(e) var2I  (Leaf I  Leaf I ) = var2J  (Leaf J  Leaf J ).
Then, Lines (12) to (16) together with (I) and the fact that TrI = TrJ implies (a). It thus
remains to prove (b) to (e). We concentrate on (b) as the other cases are analogous. Take
(d, d0 )  col1I  (Leaf I  Leaf I ). Then d = d2n,ij and d0 = d2n,i0 j 0 for some i, j, i0 , j 0 < 2n .
By Line (18), i0 = i and j 0 = 0. By (I) and Lines (17) and (18) and since I and J
agree on the interpretation of X0 , . . . , Xn1 , Y0 , . . . , Yn1 , there is an e  LeafFixJ such
that (d2n,ij , e)  col1J , the value encoded by X0 , . . . , Xn1 at e in J is i, and the value
encoded by Y0 , . . . , Yn1 at e in J is 0. Since LeafFixI = LeafFixJ , we have LeafFixJ =
Leaf J . However, there is only a single element of Leaf J where X0 , . . . , Xn1 encodes i and
Y0 , . . . , Yn1 encodes 0 and this is d2n,i0 = d0 . The converse direction is analogous.
o
Corollary 16 In ALC, satisfiability w.r.t. concept-circumscribed KBs is NExpNP -hard
even if the TBox is acyclic, the ABox and preference relations are empty, and there are no
fixed predicates.
Proof. The ABox AG from the reduction given in Section 4.2.1 is of the form {C0 (a0 )}
and the circumscription pattern CPG has an empty preference relation. It thus suffices to
show that there is a polynomial reduction of satisfiability w.r.t. concept-circumscribed KBs
of this form to satisfiability w.r.t. concept-circumscribed KBs with an acyclic TBox, empty
ABox and preference relation, and no fixed predicates.
Let CircCP (, A) be a concept-circumscribed KB with A = {C0 (a0 )} and CP = (
, M, V, F ) with = , and let C be an ALC concept. Define T = {A v u.C0 }, where
A is a concept name that does not occur in A and C and u is a role name that does not
occur in A and C. Also define CP0 = (, M, V  {u}, F  {A}). Then C is satisfiable w.r.t.
CircCP (, A) iff A u C is satisfiable w.r.t. CircCP0 (T , ):
If. If A u C is satisfiable w.r.t. CircCP0 (T , ), then there is a model I of CircCP0 (T , )
and a d0  (A u C)I . Thus, there is an e0  C0I . Modify I to obtain a new interpretation
J by setting aJ
0 = e0 . Clearly, J is a model of A and C. To show that it is also a model of
CircCP (, A), assume to the contrary that there is a model J 0 of A with J 0 <CP J . Modify
0
0
J 0 into an interpretation I 0 by setting AI = AI and uI = I  I . It is readily checked
that I 0 is a model of T and I 0 <CP0 I, thus we have obtained a contradiction to the fact
that I is a model of CircCP0 (T , ).
766

fiThe Complexity of Circumscription in DLs

Only if. If C is satisfiable w.r.t. CircCP (, A), then there is a model I of CircCP (, A)
and a d0  C I . Let J be defined as I, except that AJ = {d0 } and uJ = I  I . Clearly,
J is a model of T and A u C. To show that J is also a model of CircCP (T , ), assume to the
0
contrary that there is a model J 0 of T with J 0 <CP0 J . Since A is fixed in CP0 , d0  AI ,
0
0
thus d0  (u.C0 )J and there is an e0  C0J . Modify J 0 into a new interpretation I 0 by
0
setting aI0 = e0 . It is readily checked that I 0 is a model of A and I 0 <CP I, thus we have
obtained a contradiction to the fact that I is a model of CircCP0 (, A). To get rid of fixed
predicates, it suffices to apply Lemma 5.
o

Appendix C. Missing Proofs in Section 5
We show that the semantic consequence problem can be reduced to instance checking
w.r.t. role-fixing cKBs in ALC. We have already proved that for ALC extended with the
universal role. In fact, the only remaining problem is to approximate concepts u.C using ALC concepts that state that the extension of C contains all points within a certain,
sufficiently large neighbourhood.
To construct such an approximation, we first introduce a local version of the notion of
frame validity of concepts. A pointed R-frame is a pair (F, d) such that d  F and F is
an R-frame. A concept C is valid in a pointed R-frame (F, d), in symbols (F, d) |= C, iff
d  C I for every interpretation I based on F. For m  and R a finite set of role names,
m R.C denotes C if m = 0, and

N

m1 R.C u

u r.

m1

rR

R.C

if m > 0. In what follows, we will use concepts of the form m R.C as approximations of
u.C. We remind the reader of some correspondence results of modal logic. Let transA =
s.A t s.s.A and contA = s.A t r.A. Then it is well known (Blackburn & van
Benthem, 2007) and easy to prove that for every {r, s}-frame F, the following holds:
 transA is valid in F if, and only if, sF is transitive;
 contA is valid in F if, and only if, rF  sF .
Say that d0  F is {r, s}-reachable from d in F if (d, d0 )  (rF  sF ) and call d  F a
root of F if every d0  F is {r, s}-reachable from d in F. If F is an {r, s}-frame with root
d, then the following conditions are equivalent:
 1 {r, s}.(transA u contA ) is valid in (F, d);
 sF is transitive and rF  sF .
These observations are used in the proof of Lemma 31 below. As before, we sometimes write
concept assertions C(a) in the form a : C. Recall that the role depth rd(C) of a concept C
is defined as the nesting depth of the constructors r.D and r.D, r  R, in C.
Lemma 31 Let C and D be ALC {r} -concepts not sharing any concept names and let A be
a fresh concept name. Let CP = (, M, {r, s}, V ) be a circumscription pattern, where M
consists of A and the concept names in C and V consists of the concept names in D. Let
a be an individual name. Then the following conditions are equivalent:
767

fiBonatti, Lutz, & Wolter

1. for all {r, s}-frames F with rF  sF and sF transitive: if F |= C, then F |= D;
2. for all pointed {r, s}-frames (F, d):
(F, d) |= 1 {r, s}.(transA u contA u C)



(F, d) |= D

3. a is an instance of 1 {r, s}.(transA u contA u C) t D w.r.t. CircCP (, A), where
A = {a : (1 {r, s}.(transA u contA u C) t 1+max {2,rd(C)} {r, s}.

u B)}.

BM

Proof. Point 1 implies Point 2. Suppose Point 2 does not hold. Let (F, d) be a pointed
{r, s}-frame such that (F, d) |= 1 {r, s}.(transA u contA u C) and (F, d) 6|= D. We may
assume that d is a root of F. From (F, d) |= 1 {r, s}.(transA u contA ) we obtain rF  sF
and sF transitive. Therefore, from (F, d) |= 1 {s}.C we obtain F |= C. It follows that F is
a frame refuting Point 1.
In what follows we use, for every I and d  I , d,I to denote the set of all e  I
which are {r, s}-reachable from d in at most 1 + max {2, rd(C)} steps.
Point 2 implies Point 3. Suppose Point 3 does not hold. Let I be a model of CircCP (, A)
such that
aI  (1 {r, s}.(transA u contA u C) u D)I .

(77)

Let I be based on F and set d := aI . We show (F, d) |= 1 {r, s}.(transA u contA u C) and
(F, d) 6|= D. The latter is easy as it is witnessed by the interpretation I. To show the former,
let J be an interpretation based on F. We show that d  (1 {r, s}.(transA u contA u C))J .
By (77) and since I is a model of CircCP (, A), aI  (1+max {2,rd(C)} {r, s}.
B)I . It

u

BM

follows immediately that
B I = d,I ,

(78)

for all B  M . We now distinguish two cases:
 B J  d,I , for all B  M . Since I and J are based on the same frame and all concept
names in contA , transA , and C are in M , the truth of 1 {r, s}.(transA u contA u C) at
d depends on the truth value of concept names from M in d,I only. From (78) we
obtain B I  d,I = B J  d,I , for all B  M . Hence, by (77), d  (1 {r, s}.(transA u
contA u C))J , as required.
 B J 6 d,I , for at least one B  M .
0

Let J 0 be the modification of J where B J = B J  d,I , for B  M . By (78), J 0 <CP
0
I. If d  (1 {r, s}.(transA u contA u C))J , then J 0 is a model of A and we have a
contradiction to the fact that I is a model of CircCP (, A). Thus, d  (1 {r, s}.(transA u
0
contA u C))J . Since, again, the truth of 1 {r, s}.(transA u contA u C) at d depends on
the truth value of B  M on d,I only, we have d  (1 {r, s}.(transA u contA u C))J ,
as required.
768

fiThe Complexity of Circumscription in DLs

Point 3 implies Point 1. Suppose Point 1 does not hold. Consider a frame F such that sF
is transitive, rF  sF , F |= C, and F 6|= D. It follows that F |= transA u contA . Let I be an
interpretation based on F such that d  (D)I . We may assume that d is a root of F. We
may also assume that B I = d,I for all B  M (since no such B occurs in D) and aI = d.
Then aI  (1 {r, s}.(transA u contA u C) u D))I and I is a model of A. It remains to show
that there does not exist an I 0 <CP I such that
0

aI  (1 {r, s}.(transA u contA u C) t 1+max {2,rd(C)} {r, s}.

u B)

I0

BM

.

This is straightforward: from (F, d) |= 1 {r, s}.C, we obtain that there does not exist any
0
0
I 0 such that d  (1 {r, s}.C)I and clearly there does not exist any B  M with B I  B I
0
such that d  (1+max {2,rd(C)} {r, s}.B)I .
o
We are in a position now to prove the reduction for ALC.
Theorem 22 The logical consequence problem of MSO(r) is effectively reducible to the
instance problem w.r.t. role-fixing cKBs formulated in ALC. This even holds when the
TBox and preference relation are empty.
Proof. By Theorem 20, the logical consequence problem of MSO(r) is effectively reducible
to the modal consequence problem for ALC {r} -concepts. Hence, it suffices to reduce the
modal consequence problem for ALC {r} -concepts. Let ALC {r} -concepts C and D be given.
We may assume that C and D have no concept names in common (if they have, then replace
every concept name B in D by a new concept name B 0 and denote the resulting concept
by D0 ; as noted above, C  D iff C  D0 .) Let CP = (, M, {s, r}, V ) where  = , M
consists of A and all concept names in C, and V consists of all concept names in D. Let
A = {a : (1 {r, s}.(transA u contA u C) t 1+max {2,rd(C)} {r, s}.

u B)}

BM

and C0 = 1 {r, s}.(transA u contA u C) t D. By the equivalence of Point 1 and Point 3
in Lemma 31, CircCP (, A) |= C0 (a) if, and only if, for all frames F with rF  sF and sF
transitive, from F |= C follows F |= D. As C and D do not contain s,
CircCP (, A) |= C0 (a)



C  D.
o

References
Areces, C., Blackburn, P., & Marx, M. (1999). A road-map on complexity for hybrid logics.
In Proceedings of the Eighth Annual Conference of the EACSL (CSL99), No. 1683 in
Lecture Notes in Computer Science, pp. 307321. Springer-Verlag.
Areces, C., Blackburn, P., & Marx, M. (2000). The computational complexity of hybrid
temporal logics. Logic Journal of the IGPL, 8 (5), 653679.
Baader, F., Brandt, S., & Lutz, C. (2005a). Pushing the EL envelope. In Kaelbling, L. P.,
& Saffiotti, A. (Eds.), Proceedings of the Nineteenth International Joint Conference
on Artificial Intelligence (IJCAI05), pp. 364369. Professional Book Center.
769

fiBonatti, Lutz, & Wolter

Baader, F., Milicic, M., Lutz, C., Sattler, U., & Wolter, F. (2005b). Integrating description logics and action formalisms for reasoning about web services. LTCSreport LTCS-05-02, Chair for Automata Theory, Institute for Theoretical Computer Science, Dresden University of Technology, Germany. See http://lat.inf.tudresden.de/research/reports.html.
Baader, F., & Hollunder, B. (1995a). Embedding defaults into terminological knowledge
representation formalisms.. Journal of Automated Reasoning, 14 (1), 149180.
Baader, F., & Hollunder, B. (1995b). Priorities on defaults with prerequisites, and their application in treating specificity in terminological default logic.. Journal of Automated
Reasoning, 15 (1), 4168.
Baader, F., McGuiness, D. L., Nardi, D., & Patel-Schneider, P. (2003). The Description
Logic Handbook: Theory, implementation and applications. Cambridge University
Press.
Baader, F., & Sattler, U. (2000). Tableau algorithms for description logics. In Dyckhoff,
R. (Ed.), Proceedings of the International Conference on Automated Reasoning with
Tableaux and Related Methods (Tableaux2000), Vol. 1847 of Lecture Notes in Artificial
Intelligence, pp. 118. Springer-Verlag.
Berger, R. (1966). The undecidability of the dominoe problem. Memoirs of the American
Mathematical Society, 66.
Blackburn, P., & van Benthem, J. (2007). Modal logic: a semantic perspective. In Handbook
of Modal Logic. Elsevier.
Blackburn, P., de Rijke, M., & Venema, Y. (2001). Modal Logic. Cambridge University
Press.
Bonatti, P., Faella, M., & Sauro, L. (2009). Defeasible inclusions in low-complexity DLs:
Preliminary notes. In Proceedings of the 21st International Joint Conference on Artificial Intelligence (IJCAI09). AAAI Press.
Bonatti, P., Lutz, C., & Wolter, F. (2006). Expressive non-monotonic description logics
based on circumscription. In Proceedings of the Tenth International Conference on
Principles of Knowledge Representation and Reasoning (KR06), pp. 400410. AAAI
Press.
Bonatti, P. A., & Eiter, T. (1996). Querying disjunctive databases through nonmonotonic
logics.. Theoretical Computer Science, 160 (1&2), 321363.
Bonatti, P. A., & Samarati, P. (2003). Logics for authorization and security. In Logics for
Emerging Applications of Databases, pp. 277323. Springer-Verlag.
Borgida, A. (1996). On the relative expressiveness of description logics and predicate logics.
Artificial Intelligence, 82 (1 - 2), 353367.
Brewka, G. (1987). The logic of inheritance in frame systems. In Proceedings of the 10th
International Joint Conference on Artificial Intelligence (IJCAI87), pp. 483488. Morgan Kaufmann.
770

fiThe Complexity of Circumscription in DLs

Brewka, G. (1994). Adding priorities and specificity to default logic.. In Proceedings of
Logics in Artificial Intelligence (JELIA94), Vol. 838 of Lecture Notes in Computer
Science, pp. 247260. Springer-Verlag.
Cadoli, M., Donini, F., & Schaerf, M. (1990). Closed world reasoning in hybrid systems.
In Proceedings of the 6th International Symposium on Methodologies for Intelligent
Systems (ISMIS90), pp. 474481. Elsevier.
Calvanese, D., Giacomo, G. D., Lembo, D., Lenzerini, M., & Rosati, R. (2007). Tractable
reasoning and efficient query answering in description logics: The DL-lite family. Journal of Automated Reasoning, 39 (3), 385429.
Cote, R., Rothwell, D., Palotay, J., Beckett, R., & Brochu, L. (1993). The systematized
nomenclature of human and veterinary medicine. Tech. rep., SNOMED International,
Northfield, IL: College of American Pathologists.
de Kleer, J., & Konolige, K. (1989). Eliminating the fixed predicates from circumscription.
Artificial Intelligence, 39 (3), 391398.
Donini, F. M., Lenzerini, M., Nardi, D., Nutt, W., & Schaerf, A. (1998). An epistemic
operator for description logics.. Artificial Intelligence, 100 (1-2), 225274.
Donini, F. M., Nardi, D., & Rosati, R. (1997). Autoepistemic description logics. In Proceedings of the Fifteenth International Joint Conference on Artificial Intelligence (IJCAI97), pp. 136141. Morgan Kaufmann.
Donini, F. M., Nardi, D., & Rosati, R. (2002). Description logics of minimal knowledge and
negation as failure. ACM Transactions on Computational Logic, 3 (2), 177225.
Eiter, T., Gottlob, G., & Mannila, H. (1997). Disjunctive Datalog. ACM Transactions on
Database Systems, 22 (3), 364418.
Eiter, T., Lukasiewicz, T., Schindlauer, R., & Tompits, H. (2004). Combining answer set
programming with description logics for the semantic web. In Proceedings of the
Ninth International Conference on the Principles of Knowledge Representation and
Reasoning (KR 2004), pp. 141151.
Giordano, L., Gliozzi, V., Olivetti, N., & Pozzato, G. L. (2008). Reasoning about typicality
in preferential description logics. In Proceedings of Logics in Artificial Intelligence
(JELIA08), Vol. 5293 of Lecture Notes in Computer Science, pp. 192205. SpringerVerlag.
Goldblatt, R. (2003). Mathematical modal logic: A view of its evolution. Journal of Applied
Logic, 1, 309392.
Gradel, E., Otto, M., & Rosen, E. (1997). Two-Variable Logic with Counting is Decidable.
In Proceedings of Twelfth IEEE Symposium on Logic in Computer Science (LICS97),
pp. 306317. IEEE Computer Society Press.
Grimm, S., & Hitzler, P. (2008). Defeasible inference with circumscriptive OWL ontologies.
In Proceedings of the Workshop on Advancing Reasoning on the Web: Scalability and
Commonsense, No. 350 in CEUR-WS (http://ceur-ws.org/).
Horrocks, I., Sattler, U., & Tobies, S. (2000). Practical reasoning for very expressive description logics. Logic Journal of the IGPL, 8 (3), 239264.
771

fiBonatti, Lutz, & Wolter

Horty, J. F. (1994). Some direct theories of nonmonotonoc inheritance. In Handbook of
Logic in Artificial Intelligence and Logic Programming-Nonmonotonic Reasoning and
Uncertain Reasoning(Volume 3), pp. 111187. Clarendon Press.
Janhunen, T. (1999). On the intertranslatability of non-monotonic logics. Annals of Mathematics in Artificial Intelligence, 27 (1-4), 79128.
Kagal, L., Finin, T., & Joshi, A. (2003). A policy language for a pervasive computing
environment. In Fourth IEEE International Workshop on Policies for Distributed
Systems and Networks (POLICY2003).
Knorr, M., Alferes, J. J., & Hitzler, P. (2007). A well-founded semantics for hybrid MKNF
knowledge bases. In Proceedings of the 2007 International Workshop on Description
Logics (DL2007), No. 250 in CEUR-WS (http://ceur-ws.org/).
Konev, B., Lutz, C., Walther, D., & Wolter, F. (2008). Semantic modularity and module extraction in description logics. In Proceedings of 18th European Conference on
Artificial Intelligence (ECAI), pp. 5559.
Lambrix, P., Shahmehri, N., & Wahlloef, N. (1998). A default extension to description
logics for use in an intelligent search engine. In : Proceedings of the Thirty-First
Annual Hawaii International Conference on System Sciences (HICSS98)-Volume 5,
p. 2835. IEEE Computer Society.
Lifschitz, V. (1985). Computing circumscription. In Proceedings of the Ninth International Joint Conference on Artificial Intelligence (IJCAI85), pp. 121127. Morgan
Kaufmann.
Lifschitz, V. (1993). Circumscription. In The Handbook of Logic in AI and Logic Programming 3, pp. 298352. Oxford University Press.
Lifschitz, V. (1995). Nested abnormality theories. Artificial Intelligence, 74 (2), 351365.
McCarthy, J. (1980). Circumscription: a form of nonmonotonic reasoning. Artificial Intelligence, 13, 2739.
McCarthy, J. (1986). Applications of circumscription in formalizing common sense knowledge. Artificial Intelligence, 28, 89116.
Minsky, M. (1975). A framework for representating knowledge. In Winston, P. H. (Ed.),
The Psychology of Computer Vision, pp. 211277. McGraw-Hill.
Moore, R. C. (1985). Semantical considerations on nonmonotonic logics. Artificial Intelligence, 25, 7594.
Motik, B., & Rosati, R. (2007). A Faithful Integration of Description Logics with Logic
Programming. In Proceedings of the Twentieth International Joint Conference on
Artificial Intelligence (IJCAI2007), pp. 477482. Morgan Kaufmann.
Pacholski, L., Szwast, W., & Tendera, L. (2000). Complexity results for first-order twovariable logic with counting. SIAM Journal on Computing, 29 (4), 10831117.
Padgham, L., & Zhang, T. (1993). A terminological logic with defaults: A definition and
an application. In Proceedings of the Thirteenth International Joint Conference on
Artificial Intelligence (IJCAI93), pp. 662668. Morgan Kaufmann.
772

fiThe Complexity of Circumscription in DLs

Pratt-Hartmann, I. (2005). Complexity of the two-variable fragment with counting quantifiers. Journal of Logic, Language, and Information, 14 (3), 369395.
Quillian, M. R. (1968). Semantic memory. In Semantic Information Processing, pp. 227270.
MIT Press.
Rector, A. (2004). Defaults, context, and knowledge: Alternatives for OWL-indexed knowledge bases. In Proceedings of the Pacific Symposium on Biocomputing (PSB04), pp.
226237. World Scientific.
Rector, A., & Horrocks, I. (1997). Experience building a large, re-usable medical ontology
using a description logic with transitivity and concept inclusions. In Proceedings of
the Workshop on Ontological Engineering, AAAI Spring Symposium. AAAI Press.
Reiter, R. (1980). A logic for default reasoning. Artificial Intelligence, 13, 81132.
Stevens, R., Aranguren, M. E., Wolstencroft, K., Sattler, U., Drummond, N., Horridge,
M., & Rector, A. (2005). Using OWL to model biological knowledge. International
Journal of Man-Machine Studies, 65 (7), 583594.
Stewart, I. A. (1991). Complete problems involving Boolean labelled structures and projection transactions. Journal of Logic and Computation, 1 (6), 861882.
Straccia, U. (1993). Default inheritance reasoning in hybrid KL-ONE-style logics.. In
Proceedings of the Thirteenth International Joint Conference on Artificial Intelligence
(IJCAI93), pp. 676681. Morgan Kaufmann.
Thomason, S. (1975a). The logical consequence relation of propositional tense logic.
Zeitschrift fur Mathematische Logik und Grundlagen der Mathematik, 21, 2940.
Thomason, S. (1975b). Reduction of second-order logic to modal logic. Zeitschrift fur
Mathematische Logik und Grundlagen der Mathematik, 21, 107114.
Tobies, S. (2000). The complexity of reasoning with cardinality restrictions and nominals in
expressive description logics. Journal of Artificial Intelligence Research, 12, 199217.
Tonti, G., Bradshaw, J. M., Jeffers, R., Montanari, R., Suri, N., & Uszok, A. (2003). Semantic web languages for policy representation and reasoning: A comparison of KAoS,
Rei, and Ponder. In Proceedings of the Second International Semantic Web Conference
(ISWC03), Vol. 2870 of Lecture Notes in Computer Science, pp. 419437. SpringerVerlag.
Uszok, A., Bradshaw, J. M., Johnson, M., Jeffers, R., Tate, A., Dalton, J., & Aitken, S.
(2004). KAoS policy management for semantic web services. IEEE Intelligent Systems,
19 (4), 3241.
Wolter, F., & Zakharyaschev, M. (2007). Modal decision problems. In Handbook of Modal
Logic. Elsevier.
Y. Ding, V. H., & Wu, J. (2007). A new mapping from ALCI to ALC. In In Proceedings of
the 2007 International Workshop on Description Logics (DL2007), No. 250 in CEURWS (http://ceur-ws.org/).

773

fi