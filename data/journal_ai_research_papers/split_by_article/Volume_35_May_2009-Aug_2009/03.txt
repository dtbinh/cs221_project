Journal of Artificial Intelligence Research 35 (2009) 557-591

Submitted 11/08; published 07/09

Optimal Value of Information in Graphical Models
Andreas Krause

KRAUSEA @ CALTECH . EDU

California Institute of Technology,
1200 E California Blvd.,
Pasadena, CA 91125 USA

Carlos Guestrin

GUESTRIN @ CS . CMU . EDU

Carnegie Mellon University,
5000 Forbes Ave.,
Pittsburgh, PA 15213 USA

Abstract
Many real-world decision making tasks require us to choose among several expensive observations. In a sensor network, for example, it is important to select the subset of sensors that is
expected to provide the strongest reduction in uncertainty. In medical decision making tasks, one
needs to select which tests to administer before deciding on the most effective treatment. It has
been general practice to use heuristic-guided procedures for selecting observations. In this paper,
we present the first efficient optimal algorithms for selecting observations for a class of probabilistic
graphical models. For example, our algorithms allow to optimally label hidden variables in Hidden
Markov Models (HMMs). We provide results for both selecting the optimal subset of observations,
and for obtaining an optimal conditional observation plan.
Furthermore we prove a surprising result: In most graphical models tasks, if one designs an
efficient algorithm for chain graphs, such as HMMs, this procedure can be generalized to polytree graphical models. We prove that the optimizing value of information is NPPP -hard even for
polytrees. It also follows from our results that just computing decision theoretic value of information objective functions, which are commonly used in practice, is a #P-complete problem even on
Naive Bayes models (a simple special case of polytrees).
In addition, we consider several extensions, such as using our algorithms for scheduling observation selection for multiple sensors. We demonstrate the effectiveness of our approach on several
real-world datasets, including a prototype sensor network deployment for energy conservation in
buildings.

1. Introduction
In probabilistic reasoning, where one can choose among several possible but expensive observations,
it is often a central issue to decide which variables to observe in order to most effectively increase
the expected utility (Howard, 1966; Howard & Matheson, 1984; Mookerjee & Mannino, 1997;
Lindley, 1956). In a medical expert system, for example, multiple tests are available, and each test
has a different cost (Turney, 1995; Heckerman, Horvitz, & Middleton, 1993). In such systems,
it is thus important to decide which tests to perform in order to become most certain about the
patients condition, at a minimum cost. Occasionally, the cost of testing can even exceed the value
of information for any possible outcome, suggesting to discontinue any further testing.
The following running example motivates our research and is empirically evaluated in Section 6.
Consider a temperature monitoring task, where wireless temperature sensors are distributed across a

c
2009
AI Access Foundation. All rights reserved.

fiK RAUSE & G UESTRIN

building. The task is to become most certain about the temperature distribution, whilst minimizing
energy expenditure, a critically constrained resource (Deshpande, Guestrin, Madden, Hellerstein, &
Hong, 2004). Such fine-grained building monitoring is required to obtain significant energy savings
(Singhvi, Krause, Guestrin, Garrett, & Matthews, 2005).
Many researchers have suggested the use of myopic (greedy) approaches to select observations (Scheffer, Decomain, & Wrobel, 2001; van der Gaag & Wessels, 1993; Dittmer & Jensen,
1997; Bayer-Zubek, 2004; Kapoor, Horvitz, & Basu, 2007). Unfortunately, in general, this heuristic does not provide any performance guarantees. In this paper, we present efficient algorithms,
which guarantee optimal nonmyopic value of information in chain graphical models. For example,
our algorithms can be used for optimal active labeling of hidden states in Hidden Markov Models (HMMs, Baum & Petrie, 1966). We address two settings: subset selection, where the optimal
subset of observations is obtained in an open-loop fashion, and conditional plans, a sequential,
closed-loop plan where the observation strategy depends on the actual value of the observed variables (c.f., Figure 1). To our knowledge, these are the first optimal and efficient algorithms for
observation selection and diagnostic planning based on value of information for this class of graphical models. For both settings, we address the filtering and the smoothing versions: Filtering is
important in online decision making, where our decisions can only utilize observations made in the
past. Smoothing arises for example in structured classification tasks, where there is no temporal
dimension in the data, and hence all observations can be taken into account. We call our approach
VO IDP as the algorithms use Dynamic Programming to optimize Value of Information. We evaluate our VO IDP algorithms empirically on three real-world datasets, and also show that they are
well-suited for interactive classification of sequential data.
Most inference problems in graphical models, such as computing marginal distributions and
finding the most probable explanation, that can be solved efficiently for chain-structured graphs,
can also be solved efficiently for polytrees. We prove that the problem of selecting the best k
observations for maximizing decision theoretic value of information is NPPP -complete even for
discrete polytree graphical models, giving a complexity theoretic classification of a core artificial
intelligence problem. NPPP -complete problems are believed to be significantly harder than NPcomplete or even #P-complete problems commonly arising in the context of graphical models. We
furthermore prove that just evaluating decision-theoretic value of information objective functions is
#P-complete even in the case of Naive Bayes models, a simple special case of polytree graphical
models that is frequently used in practice (c.f., Domingos & Pazzani, 1997).
Unfortunately, these hardness results show that, while the problem of scheduling a single sensor can be optimally solved using our algorithms, the problem of scheduling multiple, correlated
sensors is wildly intractable. Nevertheless, we show how our VO IDP algorithms for single sensor
scheduling can be used to approximately optimize a multi-sensor schedule. We demonstrate the
effectiveness of this approach on a real sensor network testbed for building management.
In summary, we provide the following contributions:
 We present the first optimal algorithms for nonmyopically computing and optimizing value
of information on chain graphical models.
 We show that optimizing decision theoretic value of information is NPPP -hard for discrete
polytree graphical models. Just computing decision theoretic value of information is #Phard even for Naive Bayes models.

558

fiO PTIMAL VALUE OF I NFORMATION IN G RAPHICAL M ODELS

no

Tmorn =high?

Tnoon =high?

yes

Teve =high?

Figure 1: Example of a conditional plan.
 We present several extensions of our algorithms, e.g., to tree graphical models with few
leaves, and to multiple correlated chains (for multi-sensor scheduling).
 We extensively evaluate our algorithms on several real-world problems, including sensor
scheduling on a real sensor testbed and active labeling in bioinformatics and Natural Language Processing.

2. Problem Statement
We will assume that the state of the world is described by a collection of random variables
XV = (X1 , . . . , Xn ), where V is an index set. For example, V could denote a set of locations, and Xi
models the temperature reading of a sensor placed at location i  V. For a subset
A = {i1 , . . . , ik }  V, we use the notation XA to refer to the random vector XA = (Xi1 , . . . , Xik ).
While some of our algorithms extend to continuous distributions, we generally assume that the variables XV are discrete. We take a Bayesian approach, and assume a prior probability distribution
P (XV ) over the outcomes of the variables. Suppose we select a subset of the variables, XA (for
A  V), and observe XA = xA . For example, A is the set of locations where we place sensors,
or a set of medical tests we decide to perform. After observing the realization of these variables
XA = xA , we can compute the posterior distribution over all variables P (XV | XA = xA ). Based
on this posterior probability we obtain a reward R(P (XV | XA = xA )). For example, this reward function could depend on the uncertainty (e.g., measured by the entropy) of the distribution
P (XV | XA = xA ). We will describe several examples in more detail below.
In general, when selecting observation, we will not know ahead of time what observations we
will make. Instead, we only have a distribution over the possible observations. Hence, we will be
interested in the expected reward, where we take the expectation over the possible observations.
When optimizing the selection of variables, we can consider different settings: In subset selection, our goal is to pick a subset A  V of the variables, maximizing
X
A = argmax
P (XA = xA )R(P (XV | XA = xA )),
(1)
A

xA

where we impose some constraints on the set A we are allowed to pick (e.g., on the number of
variables that can be selected, etc.). In the subset selection setting, we commit to the selection of
the variables before we get to see their realization.
Instead, we can also sequentially select one variable after the other, letting our choice depend
on the observations made in the past. In this setting, we would like to find a conditional plan  

559

fiK RAUSE & G UESTRIN

that maximizes
  = argmax


X

P (xV )R(P (XV | X(xV ) = x(xV ) )).

(2)

xV

Hereby,  is a conditional plan that can select a different set of variables for each possible state of
the world xV . We use the notation (xV )  V to refer to the subset of variables selected by the
conditional plan  in state XV = xV . Figure 1 presents an example of a conditional plan for the
temperature monitoring example. We will define the notion of conditional planning more formally
in Section 4.2.
This general setup of selecting observations goes back in the decision analysis literature to
the notion of value of information by Howard (1966) and in the statistical literature to the notion
of Bayesian Experimental Design by Lindley (1956). In this paper, we refer to the Problems (1)
and (2) as the problems of optimizing value of information.
In this paper, we show how the complexity of solving these value of information problems depend on the properties of the probability distribution P . We give the first algorithms for optimally
solving value of information for an interesting and challenging class of distributions including Hidden Markov Models. We also present hardness results showing that optimizing value of information
is wildly intractable (NPPP -complete) even for probability distributions for which efficient inference is possible (even for Naive Bayes models and discrete polytrees).
2.1 Optimization Criteria
In this paper, we will consider a class of local reward1 functions Ri , which are defined on the
marginal probability distributions of the variables Xi . This class has the computational advantage
that local rewards can be evaluated using probabilistic inference techniques. The total reward will
then be the sum of all local rewards.
Let A be a subset of V. Then P (Xj | XA = xA ) denotes the marginal distribution of variable Xj conditioned on observations XA = xA . For example, in our temperature monitoring
application, Xj models the temperature at location j  V. The conditional marginal distribution
P (Xj = xj | XA = xA ) then models the conditional distribution of the temperature at location j
after observing the temperature at locations A  V.
For classification purposes, it can be more appropriate to consider the max-marginals
P max (Xj = xj | XA = xA ) = max P (XV = xV , Xj = xj | XA = xA ),
xV

that is, for Xj set to value xj , the probability of the most probable assignment XV = xV to all
other random variables (including Xj for simplicity of notation) conditioned on the observations
XA = xA .
The local reward Rj is a functional on the probability distribution P or P max over Xj . That
is, Rj takes an entire distribution over the variable Xj and maps it to a reward value. Typically, the
reward functions will be chosen such that certain or peaked distributions obtain higher reward.
To simplify notation, we write
Rj (Xj | xA ) , Rj (P (Xj | XA = xA ))
1. Local reward functions are also widely used in additively independent utility models, (c.f., Keeney & Raiffa, 1976).

560

fiO PTIMAL VALUE OF I NFORMATION IN G RAPHICAL M ODELS

to denote the reward for variable Xj upon observing XA = xA , and
X
Rj (Xj | XA ) ,
P (XA = xA )Rj (Xj | xA )
xA

to refer to expected local rewards, where the expectation is taken over all assignments xA to the
observations A. Important local reward functions include:
Residual entropy. If we set
Rj (Xj | xA ) = H(Xj | xA ) =

X

P (xj | xA ) log2 P (xj | xA ),

xj

the objective in the optimization problem becomes to minimize the sum of residual entropies. Optimizing this reward function attempts to reduce the uncertainty in predicting the marginals Xi . We
choose this reward function in our running example to measure the uncertainty about the temperature distribution.
P
Joint entropy. Instead of minimizing the sum of residual entropies i H(Xi ), we can also attempt to minimize the joint entropy of the entire distribution,
X
H(XV ) = 
P (xV ) log2 P (xV ).
xV

Note, that the joint entropy depends on the full probability distribution P (XV ), rather than on the
marginals P (Xi ), and hence it is not local. Nevertheless, we can exploit the chain rule for the joint
entropy H(XB ) of a set of random variables B = {1, . . . , m} (c.f., Cover & Thomas, 1991),
H(XB ) = H(X1 ) + H(X2 | X1 ) + H(X3 | X1 , X2 ) +    + H(Xm | X1 , . . . , Xm1 ).
Hence, if we choose the local reward functions Rj (Xj | XA ) = H(Xj | X1 , . . . , Xj1 , XA ), we
can optimize a non-local reward function (the joint entropy) using only local reward functions.
Decision-theoretic value of information. The concept of local reward functions also includes
the concept of decision theoretic value of information. The notion of value of information is widely
used (c.f., Howard, 1966; Lindley, 1956; Heckerman et al., 1993), and is formalized, e.g., in the
context of influence diagrams (Howard & Matheson, 1984) and Partially Observable Markov Decision Processes (POMDPs, Smallwood & Sondik, 1973). For each variable Xj , let Aj be a finite set
of actions. Also, let Uj : Aj  dom Xj  R be a utility function mapping an action a  Aj and an
outcome x  dom Xj to a real number. The maximum expected utility principle states that actions
should be selected as to maximize the expected utility,
X
EUj (a | XA = xA ) =
P (xj | xA )Uj (a, xj ).
xj

The more certain we are about Xj , the more economically we can choose our action. This idea is
captured by the notion of value of information, where we choose our local reward function
Rj (Xj | xA ) = max EUj (a | xA ).
a

561

fiK RAUSE & G UESTRIN

Margin for structured prediction. We can also consider the margin of confidence:
Rj (Xj | xA ) = P max (xj | xA )  P max (xj | xA ),
where
xj = argmax P max (xj | xA ) and xj = argmax P max (xj | xA ),
xj 6=xj

xj

which describes the margin between the most likely outcome and the closest runner up. This reward
function is very useful for structured classification purposes, as shown in Section 6.
Weighted mean-squared error. If the variables are continuous, we might want to minimize the
mean squared error in our prediction. We can do this by choosing
Rj (Xj | xA ) = wj Var(Xj | xA ),
where
Z
Var(Xj | xA ) =


P (xj | xA ) xj 

Z

x0j P (x0j

|

xA )dx0j

2
dxj

is the conditional variance of Xj given XA = xA , and wj is a weight indicating the importance of
variable Xj .
Monitoring for critical regions (Hotspot sampling). Suppose we want to use sensors for detecting fire. More generally, we want to detect, for each j, whether Xj  Cj , where Cj  dom Xj is a
critical region for variable Xj . Then the local reward function
Rj (Xj | xA ) = P (Xj  Cj | xA )
favors observations A that maximize the probability of detecting critical regions.
Function optimization (Correlated bandits). Consider a setting where we have a collection of
random variables XV taking numerical
P values in some interval [m, m], and, after selecting some
of the variables, we get the reward i xi . This setting arises if we want to optimize an unknown
(random) function, where evaluating the function is expensive. In this setting, we are encouraged to
only evaluate the function where it is likely to obtain high values. We can maximize our expected
total reward if we choose the local reward function
Z
Rj (Xj | xA ) = xj P (xj | xA )dxj ,
i.e., the expectation of variable Xj given observations xA . This setting of optimizing a random
function can also be considered a version of the classical k-armed bandit problem with correlated
arms. More details about the relationship with bandit problems are given in Section 8.
These examples demonstrate the generality of our notion of local reward. Note that most examples apply to continuous distributions just as well as for discrete distributions.

562

fiO PTIMAL VALUE OF I NFORMATION IN G RAPHICAL M ODELS

2.2 Cost of Selecting Observations
We also want to capture the constraint that observations are expensive. This can mean that each
observation Xj has an associated positive penalty Cj that effectively decreases the reward. In our
example, we might be interested in trading off accuracy with sensing energy expenditure. Alternatively, it is also possible to define a budget B for selecting observations, where each one is associated
with an integer cost j . Here, we want to select observations whose sum cost is within the budget,
but these costs do not decrease the reward. In our running example, the sensors could be powered
by solar power, and regain a certain amount of energy per day, which allows a certain amount of
sensing. Our formulation of the optimization
both for penalties and budgets. To
P problems allows P
simplify notation we also write C(A) = jA Cj and (A) = jA j to extend C and  to sets.
Instead of fixed penalties and costs per observation, both can also depend on the state of the
world. For example, in the medical domain, applying a particular diagnostic test can bear different
risks for the health of the patient, depending on the patients illness. The algorithms we will develop
below can be adapted to accommodate such dependencies in a straight-forward manner. We will
present details only for the conditional planning algorithm in Section 4.2.

3. Decomposing Rewards
In this section, we will present the key observation that allows us to develop efficient algorithms
for nonmyopically optimizing value of information in the class of chain graphical models. The
algorithms will be presented in Section 4.
The set of random variables XV = {X1 , . . . , Xn } forms a chain graphical model (a chain), if
Xi is conditionally independent of XV\{i1,i,i+1} given Xi1 and Xi+1 . Without loss of generality
we can assume that the joint distribution is specified by the prior P (X1 ) of variable X1 and the
conditional probability distributions P (Xi+1 | Xi ). The time series model for the temperature
measured by one sensor in our example can be formulated as a chain graphical model. Note that the
transition probabilities P (Xi+1 | Xi ) are allowed to depend on the index i (i.e., the chain models
are allowed to be nonstationary). Chain graphical models have been extensively used in machine
learning and signal processing.
Consider for example a Hidden Markov Model unrolled for n time steps, i.e., V can be partitioned into the hidden variables {X1 , . . . , Xn } and the emission variables {Y1 , . . . , Yn }. In HMMs,
the Yi are always observed and the variables Xi form a chain. In many applications, some of which
are discussed in Section 6, we can observe some of the hidden variables Xi as well, e.g., by asking
an expert, in addition to observing the emission variables. In these cases, the problem of selecting
expert labels also belongs to the class of chain graphical models addressed by this paper, since the
variables Xi form a chain conditional on the observed values of the emission variables Yi . This idea
can be generalized to the class of Dynamic Bayesian Networks where the separators between time
slices have size one, and only these separators can be selected for observation. This formulation
also includes certain conditional random fields (Lafferty, McCallum, & Pereira, 2001) which form
chains, conditional on the emission variables (the features).
Chain graphical models originating from time series have additional, specific properties: In a
system for online decision making, only observations from the past and present time steps can be
taken into account, not observations which will be made in the future. This is generally referred
to as the filtering problem. In this setting, the notation P (Xi | XA ) will refer to the distribution
of Xi conditional on observations in XA prior to and including time i. For structured classification
563

fiK RAUSE & G UESTRIN

Figure 2: Illustration of the decomposing rewards idea. The reward for chain 1:7 when observing
variables X1 , X4 and X7 decomposes as the sum of chain 1:4 plus the reward for chain
4:7 plus the immediate reward for observing XP
4 minus the cost of observing X4 . Hereby
for brevity we use the notation Rew(a : b) = bj=a Rj (Xj | X1 , X4 , X7 ).

problems as discussed in Section 6, in general observations made anywhere in the chain must be
taken into account. This situation is usually referred to as the smoothing problem. We will provide
algorithms both for filtering and smoothing.
We will now describe the key insight, which allows for efficient optimization in chains. Consider
a set of observations A  V. If the j variable is observed, i.e., j  A, then the local reward
is simply R(Xj | XA ) = R(Xj | Xj ). Now consider j 
/ A, and let Aj be the subset of A
containing the closest ancestor (and for the smoothing problem also the closest descendant) of Xj
in XA . The conditional independence property of the graphical model implies that, given XAj , Xj
is independent of the rest of the observed variables, i.e., P (Xj | XA ) = P (Xj | XAj ). Thus, it
follows that R(Xj | XA ) = R(Xj | XAj ).
These observations imply that the expected reward of some set of observations decomposes
along the chain. For simplicity of notation, we add two independent dummy variables X0 and Xn+1 ,
where R0 = C0 = 0 = Rn+1 = Cn+1 = n+1 = 0. Let A = {i0 , . . . P
, im+1 } where il < il+1 ,
i0 = 0 and im+1 = n + 1. Using this notation, the total reward R(A) = j Rj (Xj | XA ) for the
smoothing case is given by:


iv+1 1
m
X
X
Riv (Xiv | Xiv )  Civ +
Rj (Xj | Xiv , Xiv+1 ) .
v=0

j=iv +1

In filtering settings, we simply replace Rj (Xj | Xiv , Xiv+1 ) by Rj (Xj | Xiv ). Figure 2 illustrates
this decomposition.

4. Efficient Algorithms for Optimizing Value of Information
In this section, we present algorithms for efficiently and nonmyopically optimizing value of information in chain graphical models.
4.1 Efficient Algorithms for Optimal Subset Selection in Chain Models
In the subset selection problem, we want to find a most informative subset of the variables to observe
in advance, i.e., before any observations are made. In our running example, we would, before
deploying the sensors, identify k time points that are expected to provide the most informative
sensor readings according to our model.

564

fiO PTIMAL VALUE OF I NFORMATION IN G RAPHICAL M ODELS

First, define the objective function L on subsets of V by
L(A) =

n
X

Rj (Xj | XA )  C(A).

(3)

j=1

The subset selection problem is to find the optimal subset
A =

argmax L(A)
AV,(A)B

maximizing the sum of expected local rewards minus the penalties, subject to the constraint that the
total cost must not exceed the budget B.
We solve this optimization problem using a dynamic programming algorithm, where the chain
is broken into sub-chains using the insight from Section 3. Consider a sub-chain from variable Xa
to Xb . We define Lsm
a:b (k) to represent the expected total reward for the sub-chain Xa , . . . , Xb , in the
lt
smoothing setting where Xa and Xb are observed, and with a budget level of k. Lfa:b
(k) represents
the expected reward in the filtering setting where only Xa is observed. More formally:
lt
(k)
Lfa:b

=

b1
X

max

A{a+1...b1}
j=a+1
(A)k

Rj (Xj | XA , Xa )  C(A),

for the filtering version, and
Lsm
a:b (k) =

b1
X

max

Rj (Xj | XA , Xa , Xb )  C(A),

A{a+1...b1}
j=a+1
(A)k

for the smoothing version. Note that in both cases, L0:n+1 (B) = maxA:(A)B L(A), as in Equation (3), i.e., by computing the values for La:b (k), we compute the maximum expected total reward
for the entire chain.
f lt
We can compute Lsm
a:b (k) and La:b (k) using dynamic programming. The base case is simply:
lt
Lfa:b
(0) =

b1
X

Rj (Xj | Xa ),

j=a+1

for filtering, and
b1
X

Lsm
a:b (0) =

Rj (Xj | Xa , Xb ),

j=a+1

for smoothing. The recursion for La:b (k) has two cases: we can choose not to spend any more of the
budget, reaching the base case, or we can break the chain into two sub-chains, selecting the optimal
observation Xj , where a < j < b. In both filtering and smoothing we have


La:b (k) = max La:b (0),
max
{Rj (Xj | Xj )  Cj + La:j (0) + Lj:b (k  j )} .
j:a<j<b,j k

565

fiK RAUSE & G UESTRIN

Input: Budget B, rewards Rj , costs j and penalties Cj
Output: Optimal selection A of observation times
begin
for 0  a < b  n + 1 do compute La:b (0);
for k = 1 to B do
for 0  a < b  n + 1 do
sel(1) := La:b (0);
for j = a + 1 to b  1 do sel(j) := Rj (Xj | Xj )  Cj + La:j (0) + Lj:b (k  j );
La:b (k) = maxj{a+1,...,b1,1} sel(j);
a:b (k) = argmaxj{a+1,...,b1,1} sel(j);
end
end
a := 0; b := n + 1; k := B; A := ;
repeat
j := a:b (k);
if j  0 then A := A  {j}; a := j; k := k  j ;
until j = 1 ;
end
Algorithm 1: VO IDP algorithm for optimal subset selection (for both filtering and smoothing).
At first, it may seem that this recursion should consider the optimal split of the budget between the
two sub-chains. However, since the subset problem is open-loop and the order of the observations
is irrelevant, we only need to consider split points where the first sub-chain receives zero budget.
A pseudo code implementation for this dynamic programming approach, which we call VO IDP
for subset selection is given in Algorithm 1. The algorithm fills the dynamic programming tables in
two loops, the inner loop ranging over all pairs (a, b), a < b, and the outer loop increasing k. Within
the inner loop, when computing the best reward for the sub-chain from a to b, it fills out a table sel,
where sel(j) is the reward that could be obtained by making an observation at j, and sel(1) is the
reward if no observation is made.
In addition to computing the optimal rewards La:b (k) that could be achieved for sub-chain a : b
and budget k, the algorithm also stores the choices a:b (k) that realize this maximum score. Here,
a:b (k) is the index of the next variable that should be selected for sub-chain a : b with budget
k, or 1 if no variable should be selected. In order to recover the optimal subset for budget k,
Algorithm 1 uses the quantities a:b to recover the optimal subset by tracing the maximal values
occurring in the dynamic programming equations. Using an induction proof, we obtain:
Theorem 1 (Subset Selection). The dynamic programming algorithm described above computes
the optimal subset with budget B in ( 61 n3 + O(n2 ))B evaluations of expected local rewards.
Note that if we do not consider different costs  for each variable, we would simply choose j =
1 for all variables and compute La:b (N ). Further note that if the variables Xi are continuous,
our algorithm is still applicable when the integrations and inferences necessary for computing the
expected rewards can be performed efficiently. This is the case, for example, in a Gaussian linear
model (i.e., the variables Xi are normally distributed) and the local reward functions are the residual
entropies or the residual variances for each variable.

566

fiO PTIMAL VALUE OF I NFORMATION IN G RAPHICAL M ODELS

4.2 Efficient Algorithms for Optimal Conditional Planning in Chain Models
In the conditional plan problem, we want to compute an optimal sequential querying policy : We
observe a variable, pay the penalty, and depending on all values observed in the past, select the next
query, proceeding as long as our budget suffices. The objective is to find the plan with the highest
expected reward, where, for each possible sequence of observations, the budget B is not exceeded.
For filtering, we can only select observations in the future, whereas in the smoothing case, the next
observation can be anywhere in the chain. In our running example, the filtering algorithm would be
most appropriate: The sensors would sequentially follow the conditional plan, deciding on the most
informative times to sense based on the previous observations. Figure 1 shows an example of such
a conditional plan.
4.2.1 F ROM S UBSET S ELECTION TO C ONDITIONAL P LANNING
Note that in contrast to the subset selection setting that we considered in Section 4.1, in conditional planning, the set of variables depends on the state of the world XV = xV . Hence, for each
such state, the conditional plan  could select a different set of variables, (xV )  V. As an example, consider Figure 1, where the set of possible observations is V = {morn, noon, eve}, and
XV = {Tmorn , Tnoon , Teve }. If the world is in state xV = (high, low, high), then the conditional
plan  presented in Figure 1 would select (xV ) = {morn, eve}, whereas, if
xV = (low, low, high), it would select (xV ) = {morn, noon}. Since the conditional plan is
a function of the (random) state of the world, it is a set-valued random variable. In order to optimize
Problem (2), we define the objective function2
J() =

X

P (xV )

xV

n
X



Rj (Xj | x(xV ) )  C((xV )) ,

j=1

i.e., the expected sum of local rewards given the observations made by plan (xV ) in state XV = xV
minus the penalties of the selected variables, where the expectation is taken with respect to the
distribution P (XV ). In addition to defining the value of a policy J(), we also define the cost ()
() = max ((xV )),
xV

as maximum cost (A) (as defined in Section 2.2) of any set A = (xV ) that could be selected by
the policy , in any state of the world XV = xV .
Based on this notation, our goal is to find a policy   such that
  = argmax J() such that ()  B,


i.e., a policy that has maximum value, and is guaranteed to never have cost exceeding our budget
B. Hereby  is the class of sequential policies (i.e., those, where the observations are chosen
sequentially, only based on observations that have been previously made).
It will be useful to introduce the following notation:
J(xA ; k) = max J( | XA = xA ) such that ()  k,


(4)

2. Recall that, in the filtering setting, R(Xj | x(xV ) ) , R(Xj | xA0 ), where A0 = {t  (xV ) s.t. t  j}, i.e., only
observations from the past are taken into account.

567

fiK RAUSE & G UESTRIN

where
J( | XA = xA ) =

X

n
X


P (xV | XA = xA )
Rj (Xj | x(xV ) )  C((xV )) .

xV

j=1

Hence, J(xA ; k) is the best possible reward that can be achieved by any sequential policy with cost
at most k, after observing XA = xA . Using this notation, our goal is to find the optimal plan with
reward J(; B).
The value function J satisfies the following recursion. The base case considers the exhausted
budget:
X
J(xA ; 0) =
Rj (Xj | xA )  C(A).
jV

For the recursion, it holds that





X
J(xA ; k) = max J(xA ; 0), max
,
P (xj | xA )J(xA , xj ; k  j )


j A
/ 

(5)

xj

i.e., the best one can do in state XA = xA with budget k is to either stop selecting variables, or
chose the best next variable and act optimally thereupon.
Note that we can easily allow the cost j depend on the state xj of variable Xj . In this case, we
would simply replace j by j (xj ), and define J(XA , r) =  whenever r < 0. Equivalently, we
can let the penalty C(A) depend on the state by replacing C(A) by C(xA ).
Relationship to finite-horizon Markov Decision Processes (MDPs). Note that the function
J(xA ; k) defined in (4) is analogous to the concept of a value function in Markov Decision Processes (c.f., Bellman, 1957): In finite-horizon MDPs, the value function V (s; k) models the maximum expected reward obtainable when starting in state s and performing k actions. For this value
function it holds that
X
V (s; k) = R(s, k) + max
P (s0 | s, a)V (s0 ; k  1),
a

s0

where P (s0 | s, a) is the probability of transiting to state s0 when performing action a in state s,
and R(s, k) is the immediate reward obtained in state s if k steps are still left. This recursion,
which is similar to Eq. (5), is exploited by the value iteration algorithm for solving MDPs. The
conditional planning problem with unit observation cost (i.e., (A) = |A|) could be modeled as a
finite-horizon MDP, where states correspond to observed evidence XA = xA , actions correspond
to observing variables (or not making any observation) and transition probabilities are given by the
probability of observing a particular instantiation of the selected variable. The immediate reward is
R(s, k) = 0 for k > 0, and R(s, 0) is the expected reward (in the value of information problem) of
observing assignment s (i.e., R(P (XV | s))  C(s)). If all observations have unit cost, then for this
MDP, it holds that V (xA ; k) = J(xA ; k). Unfortunately, in the conditional planning problem, since
the state of the MDP is uniquely determined by the observed evidence XA = xA , the state space is
exponentially large. Hence, existing algorithms for solving MDPs exactly (such as value iteration)
cannot be applied to solve large value of information problems. In Section 4.2.2, we develop an
efficient dynamic programming algorithm for conditional planning in chain graphical models that
avoids this exponential increase in complexity.
568

fiO PTIMAL VALUE OF I NFORMATION IN G RAPHICAL M ODELS

4.2.2 DYNAMIC P ROGRAMMING FOR O PTIMAL C ONDITIONAL P LANNING IN C HAINS
We propose a dynamic programming algorithm for obtaining the optimal conditional plan that is
similar to the subset algorithm presented in Section 4.1. Again, we utilize the decomposition of
rewards described in Section 3. The difference here is that the observation selection and budget
allocation now depend on the actual values of the observations. In order to compute the value
function J(xA ; k) for the entire chain, we will compute the value functions Ja:b (xA ; k) for subchains Xa , . . . , Xb .
The base case of our dynamic programming approach deals with the zero budget setting:
f lt
Ja:b
(xa ; 0)

=

b1
X

Rj (Xj | Xa = xa ),

j=a+1

for filtering, and
sm
(xa , xb ; 0) =
Ja:b

b1
X

Rj (Xj | Xa = xa , Xb = xb ),

j=a+1

for smoothing. The recursion defines Ja:b (xa ; k) (or Ja:b (xa , xb ; k) for smoothing), the expected
reward for the problem restricted to the sub-chain Xa , . . . , Xb conditioned on the values of Xa = xa
(and Xb = xb for smoothing), and with budget limited by k. To compute this quantity, we again
iterate through possible split points j, such that a < j < b. Here we observe a notable difference
between the filtering and the smoothing case. For smoothing, we now must consider all possible
splits of the budget between the two resulting sub-chains, since an observation at time j might
require us to make an additional, earlier observation:
X

n
sm
sm
P (Xj = xj | Xa = xa , Xb = xb )
Ja:b (xa ,xb ; k) = max Ja:b (xa , xb ; 0), max
a<j<b

Rj (Xj | xj )  Cj (xj ) +

max
0lkj (xj )

xj



sm
Ja:j
(xa , xj ; l)

+

sm
(xj , xb ; k
Jj:b


o
.
 l  j (xj ))

Looking back in time is not possible in the filtering case, hence the recursion simplifies to

X
n
f lt
f lt
Ja:b (xa ; k) = max Ja:b (xa ; 0),
max
P (Xj = xj | Xa = xa )
a<j<b:j (xj )k

Rj (Xj | xj )  Cj (xj ) +

xj

f lt
Ja:j
(xa ; 0)

+

f lt
Jj:b
(xj ; k

o
 j (xj ))
.

For both J f lt and J sm , the optimal reward is obtained by J0:n+1 (; B) = J(; B) = J(  ).
Algorithm 2 presents a pseudo code implementation for the smoothing version  the filtering case
is a straight-forward modification. We call Algorithm 2 the VO IDP algorithm for conditional planning. The algorithm will fill the dynamic programming tables using three loops, the inner loop
ranging over all assignments xa , xb , the middle loop ranging over all pairs (a, b) where a < b, and
the outer loop covers increasing values of k  B. Within the innermost loop, the algorithm again
computes a table sel such that sel(j) is the optimal reward achievable by selecting variable j next.
569

fiK RAUSE & G UESTRIN

This value is now an expectation over any possible observation that variable Xj can make. Note that
for every possible instantiation Xj = xj a different allocation of the remaining budget k  j (xj )
to the left and right sub-chain (a : j and j : b respectively) can be chosen. The quantity (j, xj )
tracks this optimal budget allocation.
Input: Budget B, rewards Rj , costs j and penalties Cj
Output: Optimal conditional plan (a:b , a:b )
begin
sm (x , x ; 0);
for 0  a < b  n + 1, xa  dom Xa , xb  dom Xb do compute Ja:b
a b
for k = 1 to B do
for 0  a < b  n+1, xa  dom Xa , xb  dom Xb do
sm (0);
sel(1) := Ja:b
for a < j < b do
sel(j) := 0;
for xj  dom Xj do
for 0  l  k  j (xj ) do
sm (x , x ; l) + J sm (x , x ; k  l   (x ));
bd(l) := Ja:j
j
j j
a j
b
j:b
end
sel(j) := sel(j) + P (xj | xa , xb )  [Rj (Xj | xj )  Cj (xj ) + maxl bd(j)];
(j, xj ) = argmaxl bd(j);
end
end
sm (k) = max
Ja:b
j{a+1,...,b1,1} sel(j);
a:b (xa , xb ; k) = argmaxj{a+1,...,b1,1} sel(j);
for xj  dom Xa:b (k) do a:b (xa , xb , xj ; k) = (a:b (k), xj );
end
end
end
Algorithm 2: VO IDP algorithm for computating an optimal conditional plan (for the smoothing
setting).
Input: Budget k, observations Xa = xa , Xb = xb , , 
begin
j := a:b (xa , xb ; k);
if j  0 then
Observe Xj = xj ;
l := a:b (xa , xb , xj ; k);
Recurse with k := l, Xa = xa and Xj = xj instead of Xb = xb ;
Recurse with k := k  l  j , Xj = xj instead of Xa = xa , and Xb = xb ;
end
end
Algorithm 3: Observation selection using conditional planning.
The plan itself is compactly encoded in the quantities a:b and a:b . Hereby, a:b (xa , xb ; k)
determines the next variable to query after observing Xa = xa and Xb = xb , and with remaining budget k. a:b (xa , xb , xj ; k) determines the allocation of the budget after the new observation
Xj = xj has been made. Considering the exponential number of possible sequences of observations,
570

fiO PTIMAL VALUE OF I NFORMATION IN G RAPHICAL M ODELS

it is remarkable that the optimal plan can be represented using only polynomial space. Algorithm 3
indicates how the computed plan can be executed. The procedure is recursive, requiring the parameters a := 0, xa := 1, b := n + 1, xb := 1 and k := B for the initial call. In our temperature
monitoring example, we could first collect some temperature timeseries as training data, and then
learn the chain model from this data. Offline, we would then compute the conditional plan (for the
filtering setting), and encode it in the quantities a:b and a:b . We would then deploy the computed
plan on the actual sensor node, together with an implementation of Algorithm 3. While computation of the optimal plan (Algorithm 2) is fairly computationally expensive, the execution of the plan
(Algorithm 3) is very efficient (selecting the next timestep for observation requires a single lookup
in the a:b and a:b tables) and hence well-suited for deployment on a small, embedded device.
We summarize our analysis in the following Theorem:
Theorem 2 (Conditional Planning). The algorithm for smoothing presented above computes an
optimal conditional plan in d3  B 2  ( 61 n3 + O(n2 )) evaluations of local rewards, where d is
the maximum domain size of the random variables X1 , . . . , Xn . In the filtering case, the optimal plan can be computed using d3  B  ( 61 n3 + O(n2 )) evaluations, or, if no budget is used, in
d3  ( 16 n4 + O(n3 )) evaluations.
The faster computation for the filtering / no-budget case is obtained by observing that we do not
require the third maximum computation, which distributes the budget into the sub-chains.
Also, note that contrary to the algorithm for computing optimal subsets in Section 4.1, Algorithm 2 only requires evaluations of the form R(Xj | XA = xA ), which can in general be computed
d2 times faster than the expectations R(Xj | XA ). Under this consideration, the subset selection
algorithm is in general only a factor d  B faster, even though the conditional planning algorithm has
more nested loops.
4.3 Efficient Algorithms for Trees with Few Leaves
In Sections 4.1 and 4.2 we have presented dynamic programming-based algorithms that can optimize value of information on chain graphical models. In fact, the key observations of Section 3 that
local rewards decompose along chains holds not just in chain graphical models, but also in trees.
More formally, a tree graphical model is a joint probability distribution P (XV ) over a collection
of random variables XV if P (XV ) factors as
P (XV ) =

1 Y
i,j (Xi , Xj ),
Z
(i,j)E

where i,j is a nonnegative potential function, mapping assignments to xi and xj to the nonnegative
real numbers, E  V  V is a set of edges that form an undirected tree over the index set V, and Z
is a normalization constant enforcing a valid probability distribution.
The dynamic programming algorithms presented in the previous sections can be extended to
such tree models in a straightforward manner. Instead of identifying optimal subsets and conditional
plans for sub-chains, the algorithms would then select optimal subsets and plans for sub-trees of
increasing size. Note however that the number of sub-trees can grow exponentially in the number
of leaves of the tree: A star on n leaves for example has a number of subtrees that is exponential
in n. In fact, counting the number of subtrees of an arbitrary tree with n vertices is believed to
be intractable (#P-complete, Goldberg & Jerrum, 2000). However, for trees that contain only a
571

fiK RAUSE & G UESTRIN

small (constant) number of leaves, the number of subtrees is polynomial, and the optimal subset
and conditional plans can be computed in polynomial time.

5. Theoretical Limits
Many problems that can be solved efficiently for discrete chain graphical models can also be efficiently solved for discrete polytrees3 . Examples include probabilistic inference and the most probable explanation (MPE).
In Section 4.3 however we have seen that the complexity of the dynamic programming algorithms for chains increases dramatically when extended to trees: The complexity increases exponentially in the number of leafs of the tree.
We prove that, perhaps surprisingly, for the problem of optimizing value of information, this
exponential increase in complexity cannot be avoided, under reasonable complexity theoretic assumptions. Before making this statement more formal, we briefly review the complexity classes
used in our results.
5.1 Brief Review of Relevant Computational Complexity Classes
We briefly review the complexity classes used in the following statements by presenting a complete
problem for each of the class. For more details see, e.g., the references by Papadimitriou (1995)
or Littman, Goldsmith, and Mundhenk (1998). The class NP contains decision problems which
have polynomial-time verifiable proofs. A well-known complete problem is 3SAT for which the
instances are Boolean formulas  in conjunctive normal form containing at most three literals per
clause (3CNF form). The complexity class #P contains counting problems. A complete problem
for the class #P is #3SAT which counts the number of satisfying instances to a 3CNF formula.
PP is a decision version of the class #P: A complete problem is M AJSAT , which decides
whether a given 3CNF formula  is satisfied by the majority, i.e., by more than half of all its
possible assignments. If A and B are Turing machine based complexity classes, then AB is the
complexity class derived by allowing the Turing machines deciding instances of A oracle calls to
Turing machines in B. We can intuitively think of the problems in class AB as those that can be
solved by a Turing Machine for class A, that has a special command which solves any problem in B.
PP is similar to #P in that PPP = P#P , i.e., if we allow a deterministic polynomial time Turing
machine to have access to a counting oracle, we cannot solve more complex problems than if we give
it access to a majority oracle. Combining these ideas, the class NPPP is the class of problems that
can be solved by nondeterministic polynomial time Turing machines that have access to a majority
(or a counting) oracle. A complete problem for NPPP is EM AJSAT which, given a 3CNF on
variables X1 , . . . , X2n , it decides whether there exists an assignment to X1 , . . . , Xn such that 
is satisfied for the majority of assignments to Xn+1 , . . . , X2n . NPPP has been introduced and
found to be a natural class for modeling AI planning problems in the seminal work by Littman et al.
(1998). As an example, the MAP assignment problem is NPPP -complete for general graphical
models, as shown by Park and Darwiche (2004).
The complexity classes satisfy the following set of inclusions (where the inclusions are assumed,
but not known to be strict):
P  NP  PP  PPP = P#P  NPPP .
3. Polytrees are Bayesian Networks that form trees if the edge directions are dropped.

572

fiO PTIMAL VALUE OF I NFORMATION IN G RAPHICAL M ODELS

5.2 Complexity of Computing and Optimizing Value of Information
In order to solve the optimization problems, we will most likely have to evaluate the objective
function, i.e., the expected local rewards. Our first result states that, even if we specialize to decision theoretic value of information objective functions as defined in Section 2.1, this problem is
intractable even for Naive Bayes models, a special case of discrete polytrees. Naive Bayes models
are often used in classification tasks (c.f., Domingos & Pazzani, 1997), where the class variable is
predicted from noisy observations (features), that are assumed to be conditionally independent given
the class variable. In a sense, Naive Bayes models are the next simplest (from the perspective of
inference) class of Bayesian networks after chains. Note that Naive Bayes models correspond to the
stars referred to in Section 4.3, that have a number of subtrees that is exponential in the number
of variables.
Theorem 3 (Hardness of computation for Naive Bayes models). The computation of decision
theoretic value of information functions is #P-complete even for Naive Bayes models. It is also
hard to approximate to any factor unless P = NP.
We have the immediate corollary that the subset selection problem is PP-hard for Naive Bayes
models:
Corollary 4 (Hardness of subset selection for Naive Bayes models). The problem of determining,
given a Naive Bayes model, constants c and B, cost function  and a set of decision-theoretic value
of information objective functions Ri , whether there is a subset of variables A  V such that
L(A)  c and (A)  B is PP-hard.
In fact, we can show that subset selection for arbitrary discrete polytrees (that are more general
than Naive Bayes models, but inference is still tractable) is even NPPP -complete, a complexity
class containing problems that are believed to be significantly harder than NP or #P complete
problems. This result provides a complexity theoretic classification of value of information, a core
AI problem.
Theorem 5 (Hardness of subset selection computation for polytrees). The problem of determining, given a discrete polytree, constants c and B, cost function  and a set of decision-theoretic
value of information objective functions Ri , whether there is a subset of variables A  V such that
L(A)  c and (A)  B is NPPP -complete.
For our running example, this implies that the generalized problem of optimally selecting k sensors
from a network of correlated sensors is most likely computationally intractable without resorting to
heuristics. A corollary extends the hardness of subset selection to the hardness of conditional plans.
Corollary 6 (Hardness of conditional planning computation for polytrees). Computing conditional plans is PP-hard for Naive Bayes models and NPPP -hard for discrete polytrees.
All proofs of results in this section are stated in the Appendix. They rely on reductions of complete
problems in NP, #P and NPPP involving boolean formulae to problems of computing / optimizing value of information. The reductions are inspired by the works of Littman et al. (1998) and Park
and Darwiche (2004), but require the development of novel techniques, such as new reductions of
Boolean formulae to Naive Bayes and polytree graphical models associated with appropriate reward
functions, ensuring that observation selections lead to feasible assignments to the Boolean formulae.
573

fiK RAUSE & G UESTRIN

Percent improvement

10

1

Optimal conditional plan

8

Mean margin of optimal subset
Mean margin of greedy heuristic

1
0.98

0.9

Mean F1 score

0.96

6

0.94

0.8

4
2

0.7
Optimal subset
Greedy heuristic

0
1

4

8
12
16
20
Number of observations

24

(a) Sensor scheduling

0.6

0.9

Mean accuracy of
greedy heuristic
1

2
3
4
5
Number of observations

(b) CpG island detection

Mean margin

0.92

Mean accuracy of
optimal subset

6

0.88
0.86
0

10
20
30
40
Number of observations

50

(c) Part of Speech Tagging

Figure 3: Experimental results. (a) Temperature data: Improvement over the uniform spacing
heuristic. (b) CpG island data set: Effect of increasing the number of observations on
margin and classification accuracy. (c) Part-of-Speech tagging data set: Effect of increasing the number of observations on margin and F1 score.

6. Experiments
In this section, we evaluate our algorithms on several real world data sets. A special focus is on the
comparison of the optimal methods with the greedy heuristic and other heuristic methods for selecting observations, and on how the algorithms can be used for interactive structured classification.
6.1 Temperature Time Series
The first data set consists of temperature time series collected from a sensor network deployed at
Intel Research Berkeley (Deshpande et al., 2004) as described in our running example. Data was
continuously collected for 19 days, linear interpolation was used in case of missing samples. The
temperature was measured once every 60 minutes, and it was discretized into 10 bins of 2 degrees
Kelvin. To avoid overfitting, we used pseudo counts  = 0.5 when learning the model. Using
parameter sharing, we learned four sets of transition probabilities: from 12 am - 7am, 7 am - 12 pm,
12 pm - 7 pm and 7 pm - 12 am. Combining the data from three adjacent sensors, we got 53 sample
time series.
The goal of this task was to select k out of 24 time points during the day, during which sensor
readings are most informative. The experiment was designed to compare the performance of the
optimal algorithms, the greedy heuristic, and a uniform spacing heuristic, which distributed the k
observations uniformly over the day. Figure 3(a) shows the relative improvement of the optimal algorithms and the greedy heuristic over the uniform spacing heuristic. The performance is measured
in decrease of expected entropy, with zero observations as the baseline. It can be seen that if k is less
than about the half of all possible observations, the optimal algorithms decreased the expected uncertainty by several percent over both heuristics. The improvement gained by the optimal plan over
the subset selection algorithms appears to become more drastic if a large number of observations
(over half of all possible observations) is allowed. Furthermore, for a large number of observations,
the optimal subset and the subset selected by the greedy heuristic were almost identical.

574

fiO PTIMAL VALUE OF I NFORMATION IN G RAPHICAL M ODELS

6.2 CpG-Island Detection
We then studied the bioinformatics problem of finding CpG islands in DNA sequences. CpG islands
are regions in the genome with a high concentration of the cytosine-guanine sequence. These areas
are believed to be mainly located around the promoters of genes, which are frequently expressed in
the cell. In our experiment, we considered the gene loci HS381K22, AF047825 and AL133174, for
which the GenBank annotation listed three, two and one CpG islands each. We ran our algorithm
on a 50 base window at the beginning and end of each island, using the transition and emission
probabilities from Durbin, Eddy, Krogh, and Mitchison (1999) for our Hidden Markov Model, and
we used the sum of margins as reward function.
The goal of this experiment was to locate the beginning and ending of the CpG islands more
precisely by asking experts, whether or not certain bases belong to the CpG region or not. Figure 3(b) shows the mean classification accuracy and mean margin scores for an increasing number
of observations. The results indicate that, although the expected margin scores are similar for the
optimal algorithm and the greedy heuristic, the mean classification performance of the optimal algorithm was still better than the performance of the greedy heuristic. For example, when making 6
observations, the mean classification error obtained by the optimal algorithm is 25% lower than the
error obtained by the greedy heuristic.
6.3 Part-of-Speech Tagging
In our third experiment, we investigated the structured classification task of part-of-speech (POS)
tagging (CoNLL, 2003). Problem instances are sequences of words (sentences), where each word
is part of an entity (e.g., European Union), and each entity belongs to one of five categories:
Location, Miscellaneous, Organization, Person or Other. Imagine an application, where automatic
information extraction is guided by an expert: Our algorithms compute an optimal conditional plan
for asking the expert, trying to optimize classification performance while requiring as little expert
interaction as possible.
We used a conditional random field for the structured classification task, where each node corresponds to a word, and the joint distribution is described by node potentials and edge potentials.
The sum of margins was used as reward function. Measure of classification performance was the F1
score, the geometric mean of precision and recall. The goal of this experiment was to analyze how
the addition of expert labels increases the classification performance, and how the indirect, decomposing reward function used in our algorithms corresponds to real world classification performance.
Figure 3(c) shows the increase of the mean expected margin and F1 score for an increasing number of observations, summarized over ten 50 word sequences. It can be seen that the classification
performance can be effectively enhanced by optimally incorporating expert labels. Requesting only
three out of 50 labels increased the mean F1 score from by more than five percent. The following
example illustrates this effect: In one scenario both words of an entity, the sportsman P. Simmons,
were classified incorrectly  P. as Other and Simmons as Miscellaneous. The first request of the
optimal conditional plan was to label Simmons. Upon labeling this word correctly, the word P.
was automatically labeled correctly also, resulting in an F1 score of 100 percent.

575

fiK RAUSE & G UESTRIN

7. Applying Chain Algorithms for More General Graphical Models
In Section 4 we have seen algorithms that can be used to schedule a single sensor, assuming the time
series of sensor readings (e.g., temperature) form a Markov chain. This is a very natural assumption
for sensor networks (Deshpande et al., 2004). When deploying sensor networks however, multiple
sensors need to be scheduled. If the time series for all the sensors were independent, we could use
our algorithms to schedule all the sensors independently of each other. However, in practice, the
measurements will be correlated across the different sensors  in fact, this dependence is essential
to allow generalization of measurements to locations where no sensor has been placed. In the following, we will describe an approach for using our single-sensor scheduling algorithm to coordinate
multiple sensors.
More formally, we are interested in monitoring a spatiotemporal phenomenon at a set of locations S = {1, . . . , m}, and time steps T = {1, . . . , T }. With each locationtime pair s, t, we
associate a random variable Xs,t that describes the state of the phenomenon at that location and
time. The random vector XS,T fully describes the relevant state of the world and the vector XS,t
describes the state at a particular time step t. As before, we make the Markov assumption, assuming
conditional independence of XS,t from XS,t0 given XS,t1 for all t0 < t  1.
Similarly as in the single-chain case, we consider reward functions Rs,t that are associated with
each variable Xs,t . Our goal is then to select, for each timestep, a set At  S of sensors to activate,
in order to maximize the sum of expected rewards. Letting A1:t = A1      At , the expected total
reward is then given as
X
Rs,t (Xs,t | XA1:t )
s,t

for the filtering setting (i.e., only observations in the past are taken into account for evaluating the
rewards), and
X
Rs,t (Xs,t | XA1:T )
s,t

for the smoothing setting (where all observations are taken into account). The generalization to
conditional planning is done as described in Section 2.
Note that in the case of a single sensor (` = 1), the problem of optimal sensor scheduling can
be solved using Algorithm 1. Unfortunately, the optimization problem is wildly intractable even for
the case of two sensors, ` = 2:
Corollary 7 (Hardness of sensor selection for two chains). Given a model with two dependent
chains, constants c and B, a cost function  and a set of decision theoretic value of information
functions Rs,t , it is NPPP -complete to determine whether there is a subset A1:T of variables such
that L(A1:T )  c and (A1:T )  B.
In the following, we will develop an approximate algorithm that uses our optimal single-chain algorithms and performs well in practice.
7.1 Approximate Sensor Scheduling by Lower Bound Maximization
The reason for the sudden increase in complexity in the case of multiple chains is that the decomposition of rewards along sub-chains (as described in Section 3) does not extend to the case of multiple

576

fiO PTIMAL VALUE OF I NFORMATION IN G RAPHICAL M ODELS

S(1)1

S(1)2

S(1)3

S(1)4

S(1)5

S(2)1

S(2)2

S(2)3

S(2)4

S(2)5

Figure 4: Scheduling multiple correlated sensors in dynamic processes.
sensors, since influence can flow across chains. Figure 4 visualizes this problem  there, the distri(1)
(1)
(2)
bution for sensor (2) depends on all three observations S1 and S4 from sensor (1) and S2 from
sensor (2).
We address this complexity issue using an (approximate) extension of the decomposition approach used for single chains. We will focus on the decision-theoretic value of information objective (as described in Section 2.1), but other local reward functions, such as residual entropy, can be
used as well.
Considering only recent observations. As a first approximation, we only allow a sensor to take
into account the most recent observations. Intuitively, this appears to be a reasonable approximation,
especially if the potential scheduling times in T are reasonably far apart. Formally, when evaluating
the local rewards at time t, we replace the set of observations up to time t, A1:t  T by a subset
A01:t  A1:t such that

	
A01:t = (s, t)  A1:t : t  t0 for all (s, t0 )  A1:t ,
i.e, for each sensor s, only the last observation (with largest time index t) is kept. We then
approximate Rs,t (Xs,t | A1:t ) by Rs,t (Xs,t | A01:t ). In Figure 4 for example, where A1:5 =
{(s1 , 1), (s2 , 2), (s1 , 4)}, the total expected utility at time t5 would be computed using only observations A01:5 = {(s2 , 2), (s1 , 4)}, i.e., using time t4 for sensor one, and time t2 for sensor two,
(1)
ignoring influence originating from observation S1 and flowing through the chains as indicated by
the dashed arrow. The following proposition proves that this approximation is a lower bound to the
true value of information:
Proposition 8 (Monotonicity of value of information). The decision-theoretic value of information Rs,t (A) of a set A of sensors is monotonic in A,
Rs,t (A0 )  Rs,t (A)
for all A0  A.
Proposition 8 proves that conditioning only on the most recent observations can only decrease our
objective function, hence maximizing this approximate objective implies maximizing a lower bound
on the true objective.
A coordinate ascent approach. We propose the following heuristic for maximizing the lower
bound on the expected utility. Instead of jointly optimizing over all schedules (timesteps selected
for each sensor), the algorithm will repeatedly iterate over all sensors. For all sensors s, it will
optimize the selected observations As1:T , holding the schedules for all other sensors fixed. This
577

fiK RAUSE & G UESTRIN

procedure resembles a coordinate ascent approach, where each coordinate ranges over all possible
schedules for a fixed sensor s.
When optimizing for sensor s, the algorithm finds a schedule As1:T such that


[
X
As1:T = argmax
Rs,t Xs,t | XA01:t
XA0s0 such that (As1:T )  B,
(6)
A1:T

s0 6=s

s,t

1:t

i.e., that maximizes, over all schedules A1:T , the sum of expected rewards for all time steps and
0
sensors, given the schedules As1:T for all non-selected sensors s0 .
Solving the single-chain optimization problem. In order to solve the maximization problem
(6) for the individual sensors, we use the same dynamic programming approach as introduced in
lt
Section 4. The recursive case Lfa:b
(k) for k > 0 is exactly the same. However, the base case is
computed as
b1 X


X
[
f lt
La:b (0) =
Rs,j Xs,j | Xa
XA0s0 ,
s0 6=s

j=a+1 s

1:j

i.e., it takes into account the most recent observation for all non-selected sensors s0 .
lt
(0). First of all, in
Several remarks need to be made about the computation of the base case Lfa:b
a naive implementation, the computation of the expected utility


[
Rs,j Xs,j | Xa
XA0s0
s0 6=s

1:j

requires time exponential in the number of chains. This is the case since, in order to compute the
reward Rs,t , for each chain, all possible observations XA0s
= xA0s
that could be made need to be
1:t
1:t
taken into account. This computation requires computing the expectation over the joint distribution
P (XA01:t ), which is exponential in size. This increase in complexity can be avoided using a sampling
approximation: Hoeffdings inequality can be used to derive polynomial bounds on sample complexity for approximating the value of information up to arbitrarily small additive error , similarly
as done in the approach of Krause and Guestrin (2005a)4 . In practice, a small number of samples
appears to provide reasonable performance. Secondly, inference itself becomes intractable with an
increasing number of sensors. Approximate inference algorithms such as the algorithm proposed
by Boyen and Koller (1998) provide a viable way around this problem.
Analysis. Since all sensors maximize the same global objective L(A1:T ), the coordinated ascent
approach is guaranteed to monotonically increase the global objective with every iteration (ignoring
possible errors due to sampling or approximate inference). Hence it must converge (to a local
optimum) after a finite number of steps. The procedure is formalized in Algorithm 4.
Although we cannot in general provide performance guarantees for the procedure, we are building on an algorithm that provides an optimal schedule for each sensor in isolation, which should
benefit from observations provided by the remaining sensors. Also, note that if the sensors are all
independent, Algorithm 4 will obtain the optimal solution. Even if the sensors are correlated, the
obtained solution will be at least as good as the solution obtained when scheduling all sensors independently of each other. Algorithm 4 will always converge, and always compute a lower bound on
4. An absolute error of at most  when evaluating each reward Rs,t can accumulate to a total error of at most |T ||S|
for all variables and hence to the error of the optimal schedule.

578

fiO PTIMAL VALUE OF I NFORMATION IN G RAPHICAL M ODELS

Input: Budget B
Output: Selection A1 , . . . , A` of observation times for each sensor
begin
Select Ai , 1  i  ` at random;
repeat
for i = 1 to ` do
Use Algorithm 1 to select observations Ai for sensor i, but conditioning on current
sensor scheduling Aj , j 6= i, for remaining sensors;
end
Compute improvement  in total expected utility;
until  small enough ;
end
Algorithm 4: Multi-Sensor scheduling.
the expected total utility. Considering the intractability of the general problem even for two chains
(c.f., , Corollary 7), these properties are reassuring. In our experiments, the coordinated sensor
scheduling performed very well, as discussed in Section 7.2.
7.2 Proof of Concept Study on Real Deployment
In the work by Singhvi et al. (2005), we presented an approach for optimizing light control in
buildings, with the purpose of satisfying building occupants preferences about lighting conditions,
and simultaneously minimizing energy consumption. In our approach, a wireless sensor network
is deployed that monitors the building for environmental conditions (such as the sunlight intensity
etc.). The sensors feed their measurements to a building controller that actuates the lighting system
(lamps, blinds, etc.) accordingly. At every timestep t  T , the building controller can choose
an action that affects the lighting conditions at all locations S in the building. Utility functions
Ut (a, xS,t ) are specified that map the chosen actions and the current lighting levels to a utility
value. This utility is chosen to capture both users preferences about light levels, as well as the
energy consumption of the lighting system. Details on the utility functions are described in detail
by Singhvi et al..
We evaluated our multi-sensor scheduling approach in a real building controller testbed, as
described in detail by Singhvi et al.. In our experiments, we used Algorithm 4 to schedule three
sensors, allowing each sensor to choose a subset out of ten time steps (in one-hour intervals during
daytime). We varied the number of timesteps during which each sensor is activated, and computed
the total energy consumption and total user utility (as defined by Singhvi et al.). Figure 5(a) shows
the mean user utility and energy savings achieved, for a number of observations varying from no
observations to continuous sensing (10 observations in our discretization)5 . These results imply that
using the predictive model and our active sensing strategy, even a very small number of observations
achieves results approximately as good as the results achieved by continuous sensing.
Figure 5(b) presents the mean total utility achieved using no observations, one observation or ten
observations per sensor each day. It can be seen that even a single observation per sensor increases
the total utility close to the level achieved by continuous sensing. Figure 5(c) shows the mean energy
5. Note that in Figure 5(a), energy cost and utility are plotted in different units and should not be directly compared.

579

fiK RAUSE & G UESTRIN

6

12
Energy cost

10

1 Observ./
sensor

15

10 Observ./
sensor
Energy cost

8

Total utility

User utility and energy cost

14

4
No observ.

2

8

No observ.

10

5

0

1 Observ./
sensor

Measured user utility
6

0

1

2 3
Number of observations

10

2

(a) Sensing scheduling evaluation

10

12
14
Hour of day

16

18

0

(b) Total utility

10

10 Observ./
sensor

12
14
Hour of day

16

18

(c) Energy cost

Figure 5: Active sensing results.
consumption required for the same experiment. Here, the single sensor observation strategy comes
even closer to the power savings achieved for continuous sensing.
Since the sensor network battery lifetime is in general inversely proportional to the amount of
power expended for sensing and communication, we conclude that our sensor scheduling strategy
promises to lead to drastic increases in sensor network lifetime, deployment permanence and reduced maintenance cost. In our testbed, the network lifetime could be increased by a factor of 3
without significant reduction in user utility and increase in energy cost.

8. Related Work
In this section, we review related work in a number of different areas.
8.1 Optimal Experimental Design
Optimal experimental design is a general methodology for selecting informative experiments to infer
about aspects of the state of the world (such as the parameters of a particular nonlinear function,
etc.). There is a large literature about different approaches to experimental design (c.f., Chaloner &
Verdinelli, 1995; Krause, Singh, & Guestrin, 2007).
In Bayesian experimental design, a prior distribution over possible states of the world is assumed, and experiments are chosen, e.g., to reduce the uncertainty in the posterior distribution. In
its general form, Bayesian experimental design was pioneered by Lindley (1956). The users encode
their preferences in a utility function U (P (), ? ), where the first argument, P (), is a distribution
over states of the world (i.e., the parameters) and the second argument, ? , is the true state of the
world. Observations xA are collected, and the change in expected utility under the prior P () and
posterior P ( | XA = xA ) can be used as a design criterion. In this sense, the value of observation problems considered in this paper can be considered instances of Bayesian experimental design
problems. Typically, Bayesian Experimental Design is employed for continuous distributions, often
the multivariate normal distribution. By choosing different utility functions, different notions of
optimality are defined, including A- and D- optimality can be developed (Chaloner & Verdinelli,
1995). If we have the posterior covariance matrix |A , whose
maximum

 eigenvalue is max , then
Bayesian A-, D-, and E- optimality minimizes tr |A , det |A , and max |A , respectively. In the terminology of Section 2.1, D-optimality corresponds to choosing the total entropy,
and A-optimality corresponds to the (weighted) mean-squared error criteria.

580

fiO PTIMAL VALUE OF I NFORMATION IN G RAPHICAL M ODELS

Even for multivariate normal distributions, optimal Bayesian Experimental design is NP-hard
(Ko, Lee, & Queyranne, 1995). In some applications of experimental design, the number of experiments to be selected is often large compared to the number of design choices. In these cases, one can
find a fractional design (i.e., a non-integral solution defining the proportions by which experiments
should be performed), and round the fractional solutions. In the fractional formulation, A-, D-, and
E-optimality criteria can be solved exactly using a semi-definite program (Boyd & Vandenberghe,
2004). There are however no known bounds on the integrality gap, i.e., the loss incurred by this
rounding process.
The algorithms presented in Section 4.1 can be used to optimally solve non-fractional Bayesian
Experimental Design problems for chain graphical models, even for continuous distributions, as
long as inference in these distributions is tractable (such as normal distributions). This paper hence
provides a new class of combinatorial algorithms for an interesting class of Bayesian experimental
design problems.
8.2 Value of Information in Graphical Models
Decision-theoretic value of information has been frequently used for principled information gathering (c.f., Howard, 1966; Lindley, 1956; Heckerman et al., 1993), and popularized in decision
analysis in the context of influence diagrams (Howard & Matheson, 1984). In a sense, value of
information problems are special cases of Bayesian experimental design problems, where the prior
distribution has a particular structure, typically given by a graphical model as considered in this
paper.
Several researchers (Scheffer et al., 2001; van der Gaag & Wessels, 1993; Dittmer & Jensen,
1997; Kapoor et al., 2007) suggested myopic, i.e., greedy approaches for selectively gathering
evidence in graphical models, as considered in this paper, which, unlike the algorithms presented
in this paper. While these algorithms are applicable to much more general graphical models, they
do not have theoretical guarantees. Heckerman et al. (1993) propose a method to compute the
maximum expected utility for specific sets of observations. While their work considers more general
graphical models than this paper (Naive Bayes models and certain extensions), they provide only
large sample guarantees for the evaluation of a given sequence of observations, and use a heuristic
without guarantees to select such sequences. Bilgic and Getoor (2007) present a branch and bound
approach towards exactly optimizing value of information in more complex probabilistic models.
In contrast to the algorithms described in this paper however, their approach has running time that
is worst-case exponential. Munie and Shoham (2008) present algorithms and hardness results for
optimizing a special class of value of information objective functions that are motivated by optimal
educational testing problems. Their algorithms apply to a different class of graphical models than
chains, and only apply for specific objective functions, rather than general local reward functions as
considered in this paper. Radovilsky, Shattah, and Shimony (2006) extended the previous version
of our paper (Krause & Guestrin, 2005a) to obtain approximation algorithms with guarantees in the
case of noisy observations (i.e., selecting a subset of the emission variables to observe, rather than
selecting among the hidden variables as considered in this paper).
8.3 Bandit Problems and Exploration / Exploitation
An important class of sequential value of information problems is the class of Bandit problems. In
the classical k-armed bandit problem, as formalized by Robbins (1952), a slot machine is given
581

fiK RAUSE & G UESTRIN

with k arms. A draw from arm i results in a reward with success probability pi that is fixed for each
arm, but different (and independent) across each arm. When selecting arms to pull, an important
problem is to trade off exploration (i.e., estimation of the success probabilities of the arms) and
exploitation (i.e., repeatedly pulling the best arm known so far). A celebrated result by Gittins
and Jones (1979) shows that for a fixed number of draws, an optimal strategy can be computed in
polynomial time, using a dynamic programming based algorithm. While similar in the sense that
an optimal sequential strategy can be computed in polynomial time, Gittins algorithm however has
different structure from the dynamic programming algorithms presented in this paper.
Note that using the function optimization objective function described in Section 2.1, our
approach can be used to solve a particular instance of bandit problems, where the arms are not
required to be independent, but, in contrary to the classical notion of bandit problems, can not be
chosen repeatedly.
8.4 Probabilistic Planning
Optimized information gathering has been also extensively studied in the planning community.
Bayer-Zubek (2004) for example proposed a heuristic method based on the Markov Decision Process framework. However, her approach makes approximations without theoretical guarantees.
The problem of optimizing decision theoretic value of information can be naturally formalized
as a (finite-horizon) Partially Observable Markov Decision Process (POMDP, Smallwood & Sondik,
1973). Hence, in principle, algorithms for planning in POMDPs, such as the anytime algorithm by
Pineau, Gordon, and Thrun (2006), can be employed for optimizing value of information. Unfortunately, the state space grows exponentially with the number of variables that are considered in
the selection problem. In addition, the complexity of planning in POMDPs grows exponentially in
the cardinality of the state space, hence doubly-exponentially in the number of variables for selection. This steep increase in complexity makes application of black-box POMDP solvers infeasible.
Recently, Ji, Parr, and Carin (2007) demonstrated the use of POMDP planning on a multi-sensor
scheduling problem. While presenting promising empirical results, their approach however uses
approximate POMDP planning techniques without theoretical guarantees.
In the robotics literature, Stachniss, Grisetti, and Burgard (2005), Sim and Roy (2005) and
Kollar and Roy (2008) have presented approaches to information gathering in the context of Simultaneous Localization and Mapping (SLAM). None of these approaches however provide guarantees
about the quality of the obtained solutions. Singh, Krause, Guestrin, Kaiser, and Batalin (2007)
present an approximation algorithm with theoretical guarantees for the problem of planning an informative path for environmental monitoring using Gaussian Process models. In contrast to the
algorithms presented in this paper, while dealing with more complex probabilistic models and more
complex cost functions arising from path planning, their approach requires submodular objective
functions (a property that does not hold for value of information as we show in Proposition 9).
8.5 Sensor Selection and Scheduling
In the context of wireless sensor networks, where sensor nodes have limited battery and can hence
only enable a small number of measurements, optimizing the value of information from the selected
sensors plays a key role. The problem of deciding when to selectively turn on sensors in order to
conserve power was first discussed by Slijepcevic and Potkonjak (2001) and Zhao, Shin, and Reich
(2002). Typically, it is assumed that sensors are associated with a fixed sensing region, and a spatial
582

fiO PTIMAL VALUE OF I NFORMATION IN G RAPHICAL M ODELS

domain needs to be covered by the regions associated with the selected sensors. Abrams, Goel,
and Plotkin (2004) present an efficient approximation algorithm with theoretical guarantees for this
problem. Deshpande, Khuller, Malekian, and Toossi (2008) present an approach for this problem
based on semidefinite programming (SDP), handling more general constraints and providing tighter
approximations. The approaches described above do not apply to the problem of optimizing sensor schedules for more complex utility functions such as, e.g., the increase in prediction accuracy
and other objectives considered in this paper. To address these shortcomings, Koushanfary, Taft,
and Potkonjak (2006) developed an approach for sensor scheduling that guarantees a specified prediction accuracy based on a regression model. However, their approach relies on the solution of
a Mixed Integer Program, which is intractable in general. Zhao et al. (2002) proposed heuristics
for selectively querying nodes in a sensor network in order to reduce the entropy of the prediction. Unlike the algorithms presented in this paper, their approaches do not have any performance
guarantees.
8.6 Relationship to Machine Learning
Decision Trees (Quinlan, 1986) popularized the value of information as a criterion for creating
conditional plans. Unfortunately, there are no guarantees on the performance of this greedy method.
The subset selection problem as an instance of feature selection is a central issue in machine
learning, with a vast amount of literature (see Molina, Belanche, & Nebot, 2002 for a survey).
However, we are not aware of any work providing similarly strong performance guarantees than the
algorithms considered in this paper.
The problem of choosing observations also has a strong connection to the field of active learning
(c.f., Cohn, Gharamani, & Jordan, 1996; Tong & Koller, 2001) in which the learning system designs
experiments based on its observations. While sample complexity bounds have been derived for
some active learning problems (c.f., Dasgupta, 2005; Balcan, Beygelzimer, & Langford, 2006), we
are not aware of any active learning algorithms that perform provably optimal (even for restricted
classes of problem instances).
8.7 Previous Work by the Authors
A previous version of this paper appeared in the work by Krause and Guestrin (2005b). Some of
the contents of Section 7 appeared as part of the work by Singhvi et al. (2005). The present version
is much extended, with new algorithmic and hardness results and more detailed discussions.
In light of the negative results presented in Section 5, we cannot expect to be able to optimize value of information in more complex models than chains. However, instead of attempting
to solve for the optimal solution, one might wonder whether it is possible to obtain good approximations. The authors showed (Krause & Guestrin, 2005a; Krause et al., 2007; Krause, Leskovec,
Guestrin, VanBriesen, & Faloutsos, 2008) that a large number of practical objective functions satisfy an intuitive diminishing returns property: Adding a new observation helps more if we have few
observations so far, and less if we have already made many observations. This intuition can be formalized using the combinatorial concept called submodularity. A fundamental result by Nemhauser
et al. proves that when optimizing a submodular utility function, the myopic greedy algorithm in
fact provides a near-optimal solution, that is within a constant factor of (11/e)  63% of optimal.
Unfortunately, decision theoretic value of information does not satisfy submodularity.

583

fiK RAUSE & G UESTRIN

Proposition 9 (Non-submodularity of value of information). Decision-theoretic value of information is not submodular, even in Naive Bayes models.
Intuitively, value of information can be non-submodular, if we need to make several observations in
order to convince ourselves that we need to change our action.

9. Conclusions
We have described novel efficient algorithms for optimal subset selection and conditional plan computation in chain graphical models (and trees with few leaves), including HMMs. Our empirical
evaluation indicates that these algorithms can improve upon commonly used heuristics for decreasing expected uncertainty. Our algorithms can also effectively enhance performance in interactive
structured classification tasks.
Unfortunately, the optimization problems become wildly intractable for even a slight generalization of chains. We presented surprising theoretical limits, which indicate that even the class of
decision theoretic value of information functions (as widely used, e.g., in influence diagrams and
POMDPs) cannot be efficiently computed even in Naive Bayes models. We also identified optimization of value of information as a new class of problems that are intractable (NPPP -complete)
for polytrees.
Our hardness results, along with other recent results for polytree graphical models, the NPcompleteness of maximum a posteriori assignment (Park & Darwiche, 2004) and NP-hardness
of inference in conditional linear Gaussian models (Lerner & Parr, 2001), suggest the possibility of
developing a generalized complexity characterization of problems that are hard in polytree graphical
models.
In light of these theoretical limits for computing optimal solutions, it is a natural question to ask
whether approximation algorithms with non-trivial performance guarantees can be found. Recent
results by Krause and Guestrin (2005a), Radovilsky et al. (2006) and Krause et al. (2007) show that
this is the case for interesting classes of value of information problems.

Acknowledgments
We would like to thank Ben Taskar for providing the part-of-speech tagging model, and Reuters
for making their news archive available. We would also like to thank Brigham Anderson and Andrew Moore for helpful comments and discussions. This work was partially supported by NSF
Grants No. CNS-0509383, CNS-0625518, ARO MURI W911NF0710287 and a gift from Intel.
Carlos Guestrin was partly supported by an Alfred P. Sloan Fellowship, an IBM Faculty Fellowship and an ONR Young Investigator Award N00014-08-1-0752 (2008-2011). Andreas Krause was
partially supported by a Microsoft Research Graduate Fellowship.

Appendix A
Proof of Theorem 3. Membership in #P for arbitrary discrete polytrees is straightforward since
inference in such models is in P. Let  be an instance of #3SAT , where we have to count
the number of assignments to X1 , . . . , Xn satisfying . Let C = {C1 , . . . , Cm } be the set of
clauses. Now create a Bayesian network with 2n + 1 variables, X1 , . . . , Xn , U1 , . . . , Un and Y,
where the Xi are conditionally independent given Y. Let Y be uniformly distributed over the values
584

fiO PTIMAL VALUE OF I NFORMATION IN G RAPHICAL M ODELS

Y
U1

U2

Un


X1

X2

Xn

Figure 6: Graphical model used in the proof of Theorem 3.
{n, (n  1), . . . , 1, 1, . . . , m  1, m}, and each Ui have Bernoulli prior with p = 0.5. Let the
observed variables Xi have CPTs defined the following way:

1, if Xi = u satisfies clause Cj ;
Xi | [Y = +j, Ui = u] 
0, otherwise.

0, if i = j;
Xi | [Y = j, Ui = u] 
u, otherwise.
In this model, which is presented in Figure 6, it holds that X1 = X2 =    = Xn = 1 iff U1 , . . . , Un
encode a satisfying assignment of , and Y > 0. Hence, if we observe X1 = X2 =    = Xn = 1,
we know that Y > 0 with certainty. Furthermore, if at least one Xi = 0, we know that
P (Y > 0 | X = x) < 1. Let all nodes have zero reward, except for Y, which is assigned a
reward function with the following properties (we will show below how we can model such a local
reward function using the decision-theoretic value of information):
 (n+m)2n
, if P (Y > 0 | XA = xA ) = 1;
m
R(Y | XA = xA ) =
0,
otherwise.
By the above argument, the expected reward
X
R(Y | X1 , . . . , Xn ) =
P (Y = y)P (U = u)P (x| u)R(Y | X = x)
u,y,x

=

X

P (Y > 0)P (u)

u sat 

X
(n + m)2n
=
1
m
u sat 

is exactly the number of satisfying assignments to . Note that the model defined above is not yet a
Naive Bayes model. However, it can easily be turned into one by marginalizing out U.
We will now show how we can realize a reward function with the above properties in the maximum expected utility sense. Let D = {d1 , d2 } be a set of two decisions. Define a utility function
with the property:

(n+m)2n

,
if d = d1 and y > 0;

m
(n+m)22n+1
u(y, d) =
, if d = d1 and y < 0;

 0, n
otherwise.
The reward R(Y | XA ) is then given as the decision-theoretic value of information:
X
X
R(Y | XA ) =
P (xA ) max
P (y | xA )u(y, d).
xA

d

585

y

fiK RAUSE & G UESTRIN

Figure 7: Graphical model used in proof of Theorem 5.
The utility function u is based on the following consideration. Upon observing a particular instantiation of the variables X1 , . . . , Xn we make a decision d about variable Y. Our goal is to achieve
that the number of times action d1 is chosen exactly corresponds to the number of satisfying assignments to . This is accomplished in the following way. If all Xi are 1, then we know that the Ui had
encoded a satisfying assignment, and Y > 0 with probability 1. In this case, action d1 is chosen.
Now we need to make sure that whenever at least one Xi = 0 (which indicates either that Y < 0
or U is not a satisfying assignment) decision d2 is chosen. Now, if at least one Xi = 0, then either
Y = j > 0 and clause j was not satisfied, or Y < 0. The utilities are designed such that unless
n
P (Y > 0 | XA = xA )  1  n22m , the action d2 gives the higher expected reward of 0. Hereby,
n2n
2m is a lower bound on the probability of misclassification P (Y < 0 | XA = xA ).
Note that the above construction immediately proves the hardness of approximation: Suppose
there were a polynomial time algorithm which computes an approximation R that is within any
factor  > 1 (which can depend on the problem instance) of R = R(Y | X1 , . . . , Xn ). Then R > 0
implies that R > 0, and R = 0 implies that R = 0. Hence, the approximation R can be used to
decide whether  is satisfiable or not, implying that P = NP.
Proof of Corollary 4. Let  be a 3CNF formula. We convert it into a Naive Bayes model over variables X1 , . . . , Xn and Y as in the construction of Theorem 3. The function L(V) where
V = {1, . . . , n} is the set of all variables Xi counts the number of satisfying assignments to .
Note that the function L(A) for A  V = {1, . . . , n} is monotonic, i.e., L(A)  L(V) for all
A  V, as shown in Proposition 8. Hence the majority of assignments satisfies  if and only if
L(V) > 2n1 .
Proof of Theorem 5. Membership follows from the fact that inference in polytrees is in P for discrete polytrees: A nondeterministic Turing machine with #P oracle can first guess the selection
of variables, then compute the value of information using Theorem 3 (since such computation is
#P-complete for arbitrary discrete polytrees), and compare against constant c.
To show hardness, let  be an instance of EM AJSAT , where we have to find an instantiation
of X1 , . . . , Xn such that (X1 , . . . , X2n ) is true for the majority of assignments to Xn+1 , . . . , X2n .
Let C = {C1 , . . . , Cm } be the set of 3CNF clauses. Create the Bayesian network shown in Figure 7,
with nodes Ui , each having a uniform Bernoulli prior. Add bivariate variables Yi = (seli , pari ),
0  i  2n, where seli takes values in {0, . . . , m} and pari is a parity bit. The CPTs for Yi are

586

fiO PTIMAL VALUE OF I NFORMATION IN G RAPHICAL M ODELS

defined as: sel0 uniformly varies over {1, . . . , m}, par0 = 0, and for Y1 , . . . , Y2n :

0, if j = 0, or ui satisfies Cj ;
seli | [seli1 = j, Ui = ui ] 
j, otherwise;
pari | [pari1 = bi1 , Ui ]  bi1  Ui ,
where  denotes the parity (XOR) operator. We now add variables ZiT and ZiF for 1  i  n and
let

Uniform({0, 1}), if ui = 1;
T
Zi | [Ui = ui ] 
0,
otherwise;
where Uniform denotes the uniform distribution. Similarly, let

Uniform({0, 1}), if ui = 0;
ZiF | [Ui = ui ] 
0,
otherwise.
Intuitively, ZiT = 1 guarantees us that Ui = 1, whereas ZiT = 0 leaves us uncertain about Ui . The
case of ZiF is symmetric.
We use the subset selection algorithm to choose the Zi s that encode the solution to EM AJSAT .
If ZiT is chosen, it will indicate that Xi should set to true, similarly ZiF indicates a false assignment
to Xi . The parity function is going to be used to ensure that exactly one of {ZiT , ZiF } is observed
for each i.
We first assign penalties  to all nodes except ZiT , ZiF for 1  i  n, and Uj for
n + 1  j  2n, which are assigned zero penalty. Let all nodes have zero reward, except for
Y2n , which is assigned the following reward:
 n
 4 , if P (sel2n = 0 | XA = xA ) = 1 and
[P (par2n = 1 | XA = xA ) = 1 or P (par2n = 0 | XA = xA ) = 1];
R(Y2n | XA = xA ) =

0,
otherwise.
Note that sel2n = 0 with probability 1 iff U1 , . . . , U2n encode a satisfying assignment of . Furthermore, we get positive reward only if we are both certain that sel2n = 0, i.e., the chosen observation
set must contain a proof that  is satisfied, and we are certain about par2n . The parity certainty
will only occur if we are certain about the assignment U1 , . . . , U2n . It is only possible to infer the
value of each Ui with certainty by observing one of Ui , ZiT or ZiF . Since, for i = 1, . . . , n, the cost
of observing Ui is , to receive any reward we must observe at least one of ZiT or ZiF . Assume
that we compute the optimal subset O for budget 2n, then we can only receive positive reward by
observing exactly one of ZiT or ZiF .
We interpret the selection of ZiT and ZiF as an assignment to the first n variables of EM AJSAT .
Let R = R(Y2n | O). We claim that   EM AJSAT if and only if R > 0.5. First let
  EM AJSAT , with assignment x1 , . . . , xn to the first n variables. Now add Un+1 , . . . , U2n
to O and add ZiT to O iff xi = 1 and ZiF to O iff xi = 0. This selection guarantees R > 0.5.
Now assume R > 0.5. We call an assignment to U1 , . . . , U2n consistent if for any 1  i  n,
if ZiT  O, then Ui = 1 and if ZiF  O then Ui = 0. For any consistent assignment, the chance
that the observations Zi prove the consistency is 2n . Hence R > 0.5 implies that the majority of
all provably consistent assignments satisfy  and hence   EM AJSAT . This proves that subset
selection is NPPP complete.
Note that we can realize the local reward function R in the sense of maximum expected utility
similarly as described in the Proof of Theorem 3.
587

fiK RAUSE & G UESTRIN

Proof of Corollary 6. The constructions in the proof of Theorem 4 and Theorem 5 also prove that
computing conditional plans is PP-hard and NPPP -hard respectively, since, in these instances,
any plan with positive reward must observe variables corresponding to valid instantiations (i.e., all
X1 , . . . , Xn in Corollary 4, and all Un+1 , . . . , U2n and one each of the Z1 , . . . , Zn to satisfy the
parity condition in Theorem 5). In these cases, the order of selection is irrelevant, and, hence, the
conditional plan effectively performs subset selection.
Proof of Corollary 7. The proof follows from the observation that polytree construction from the
proof of Theorem 5 can be arranged into two dependent chains. For this transformation, we revert
the arc between ZiT and Ui by applying Bayes rule. To make sure there are the same number of
nodes for each sensor in each timeslice, we triple the variables Yi , calling the copies Yi0 and Yi00 .
The conditional probability tables are given as equality constraints, Yi0 = Yi and Yi00 = Yi0 . After
this transformation, the variables associated with timesteps 3i  2 (for i  1) are given by the sets
00 , Z T }. timesteps 3i  1 are associated with the sets {U , Y }, and timesteps 3i are associated
{Yi1
i
i
i
with {ZiF , Yi0 }.
Proof of Proposition 8. This bound follows from the fact that maximization over a is convex, and
an application of Jensens inequality. Using an induction argument, we simply need to show that
L(A)  L().
!
X
X
L(A) =
P (XA = xA )
max EU (a, t, x | XA1:t = xA1:t )
xA

a

tV

!


X
tV

=

X
tV

max
a

X

P (XA = xA )EU (a, t, x | XA1:t = xA1:t )

xA

max EU (a, t, x) = L()
a

where
EU (a, t, x | XA1:t = xA1:t ) =

X

P (xt | XA1:t = xA1:t )Ut (a, xt )

xt

is the expected utility of action a at time t after observing XA1:t = xA1:t .
Proof of Proposition 9. Consider the following binary classification problem with assymetric cost.
We have one Bernoulli random variable Y (the class label) with P (Y = 1) = 0.5 and
P (Y = 1) = 0.5. We also have two noisy observations X1 , X2 , which are conditionally independent given Y. Let P (Xi = Y) = 3/4 (i.e., the observations agree with the class label with
probability 3/4, and disagree with probability 1/4. We have three actions, a1 (classifying Y as 1),
a1 (classifying Y as -1) and a0 (not assigning any label). We define our utility functon U such that
we gain utility 1 if we assign the label correctly (U (a1 , 1) = U (a1 , 1) = 1), 3 is we misassign
the label (U (a1 , 1) = U (a1 , 1) = 3), and 0 if we choose a0 , i.e., not assign any label. Now,
2
2
6
> 0.
we can verify that L() = L({X1 }) = L({X2 }) = 0, but L({X1 , X2 }) = 43  3 14 = 16
Hence, adding X2 to X1 increases the utility more than adding X2 to the empty set, contradicting
submodularity.

588

fiO PTIMAL VALUE OF I NFORMATION IN G RAPHICAL M ODELS

References
Abrams, Z., Goel, A., & Plotkin, S. (2004). Set k-cover algorithms for energy efficient monitoring
in wireless sensor networks.. In IPSN.
Balcan, N., Beygelzimer, A., & Langford, J. (2006). Agnostic active learning. In ICML.
Baum, L. E., & Petrie, T. (1966). Statistical inference for probabilistic functions of finite state
Markov chains. Ann. Math. Stat, 37, 15541563.
Bayer-Zubek, V. (2004). Learning diagnostic policies from examples by systematic search. In UAI.
Bellman, R. (1957). A Markovian decision process. Journal of Mathematics and Mechanics, 6.
Bilgic, M., & Getoor, L. (2007). Voila: Efficient feature-value acquisition for classification. In
Twenty-Second Conference on Artificial Intelligence (AAAI).
Boyd, S., & Vandenberghe, L. (2004). Convex Optimization. Cambridge UP.
Boyen, X., & Koller, D. (1998). Tractable inference for complex stochastic processes. In Uncertainty in Artificial Intelligence (UAI).
Chaloner, K., & Verdinelli, I. (1995). Bayesian experimental design: A review. Statistical Science,
10(3), 273304.
Cohn, D. A., Gharamani, Z., & Jordan, M. I. (1996). Active learning with statistical models. J AI
Research, 4, 129145.
CoNLL (2003).
Conference on computational natural language learning shared task.
http://cnts.uia.ac.be/conll2003/ner/.
Cover, T. M., & Thomas, J. A. (1991). Elements of Information Theory. Wiley Interscience.
Dasgupta, S. (2005). Coarse sample complexity bounds for active learning. In NIPS.
Deshpande, A., Guestrin, C., Madden, S., Hellerstein, J., & Hong, W. (2004). Model-driven data
acquisition in sensor networks. In VLDB.
Deshpande, A., Khuller, S., Malekian, A., & Toossi, M. (2008). Energy efficient monitoring in
sensor networks. In LATIN.
Dittmer, S., & Jensen, F. (1997). Myopic value of information in influence diagrams. In UAI, pp.
142149, San Francisco.
Domingos, P., & Pazzani, M. (1997). On the optimality of the simple Bayesian classifier under
zero-one loss. Machine Learning, 29, 103137.
Durbin, R., Eddy, S. R., Krogh, A., & Mitchison, G. (1999). Biological Sequence Analysis : Probabilistic Models of Proteins and Nucleic Acids. Cambridge University Press.
Gittins, J. C., & Jones, D. M. (1979). A dynamic allocation index for the discounted multiarmed
bandit problem. Biometrika, 66(3), 561565.
Goldberg, L. A., & Jerrum, M. (2000). Counting unlabelled subtrees of a tree is #p-complete. LMS
J Comput. Math., 3, 117124.
Heckerman, D., Horvitz, E., & Middleton, B. (1993). An approximate nonmyopic computation for
value of information. IEEE Trans. Pattern Analysis and Machine Intelligence, 15, 292298.

589

fiK RAUSE & G UESTRIN

Howard, R. A. (1966). Information value theory. In IEEE Transactions on Systems Science and
Cybernetics (SSC-2).
Howard, R. A., & Matheson, J. (1984). Readings on the Principles and Applications of Decision
Analysis II, chap. Influence Diagrams, pp. 719762. Strategic Decision Group, Menlo Park.
Reprinted 2005 in Decision Analysis 2(3) 127-143.
Ji, S., Parr, R., & Carin, L. (2007). Non-myopic multi-aspect sensing with partially observable
Markov decision processes. IEEE Transactions on Signal Processing, 55(6), 27202730.
Kapoor, A., Horvitz, E., & Basu, S. (2007). Selective supervision: Guiding supervised learning with
decision-theoretic active learning. In International Joint Conference on Artificial Intelligence
(IJCAI).
Keeney, R. L., & Raiffa, H. (1976). Decisions with Multiple Objectives: Preferences and Value
Trade-offs. Wiley.
Ko, C., Lee, J., & Queyranne, M. (1995). An exact algorithm for maximum entropy sampling.
Operations Research, 43(4), 684691.
Kollar, T., & Roy, N. (2008). Efficient optimization of information-theoretic exploration in slam. In
AAAI.
Koushanfary, F., Taft, N., & Potkonjak, M. (2006). Sleeping coordination for comprehensive sensing
using isotonic regression and domatic partitions. In Infocom.
Krause, A., & Guestrin, C. (2005a). Near-optimal nonmyopic value of information in graphical
models. In Proc. of Uncertainty in Artificial Intelligence (UAI).
Krause, A., & Guestrin, C. (2005b). Optimal nonmyopic value of information in graphical models
- efficient algorithms and theoretical limits. In Proc. of IJCAI.
Krause, A., Leskovec, J., Guestrin, C., VanBriesen, J., & Faloutsos, C. (2008). Efficient sensor
placement optimization for securing large water distribution networks. Journal of Water Resources Planning and Management, 136(6).
Krause, A., Singh, A., & Guestrin, C. (2007). Near-optimal sensor placements in Gaussian processes: Theory, efficient algorithms and empirical studies. In JMLR.
Lafferty, J., McCallum, A., & Pereira, F. (2001). Conditional random fields: Probabilistic models
for segmenting and labeling sequence data. In ICML.
Lerner, U., & Parr, R. (2001). Inference in hybrid networks: Theoretical limits and practical algorithms. In UAI.
Lindley, D. V. (1956). On a measure of the information provided by an experiment. Annals of
Mathematical Statistics, 27, 9861005.
Littman, M., Goldsmith, J., & Mundhenk, M. (1998). The computational complexity of probabilistic
planning. Journal of Artificial Intelligence Research, 9, 136.
Molina, L., Belanche, L., & Nebot, A. (2002). Feature selection algorithms: A survey and experimental evaluation. In ICDM.
Mookerjee, V. S., & Mannino, M. V. (1997). Sequential decision models for expert system optimization. IEEE Trans. Knowl. Data Eng., 9(5), 675687.

590

fiO PTIMAL VALUE OF I NFORMATION IN G RAPHICAL M ODELS

Munie, M., & Shoham, Y. (2008). Optimal testing of structured knowledge. In Twenty-Third Conference on Artificial Intelligence (AAAI).
Papadimitriou, C. H. (1995). Computational Complexity. Addison-Wesley.
Park, J. D., & Darwiche, A. (2004). Complexity results and approximation strategies for map
explanations. Journal of Aritificial Intelligence Research, 21, 101133.
Pineau, J., Gordon, G., & Thrun, S. (2006). Anytime point-based approximations for large pomdps.
JAIR, 27, 335380.
Quinlan, J. R. (1986). Induction of decision trees. Machine Learning, 1, 81106.
Radovilsky, Y., Shattah, G., & Shimony, S. E. (2006). Efficient deterministic approximation algorithms for non-myopic value of information in graphical models. In IEEE International
Conference on Systems, Man and Cybernetics (SMC), Vol. 3, pp. 25592564.
Robbins, H. (1952). Some aspects of the sequential design of experiments. Bulletin of the American
Mathematical Society, 58, 527535.
Scheffer, T., Decomain, C., & Wrobel, S. (2001). Active learning of partially hidden Markov models
for information extraction. In ECML/PKDD Workshop on Instance Selection.
Sim, R., & Roy, N. (2005). Global a-optimal robot exploration in slam. In IEEE International
Conference on Robotics and Automation (ICRA).
Singh, A., Krause, A., Guestrin, C., Kaiser, W. J., & Batalin, M. A. (2007). Efficient planning of
informative paths for multiple robots. In International Joint Conference on Artificial Intelligence (IJCAI), pp. 22042211, Hyderabad, India.
Singhvi, V., Krause, A., Guestrin, C., Garrett, J., & Matthews, H. (2005). Intelligent light control
using sensor networks. In Proc. of the 3rd ACM Conference on Embedded Networked Sensor
Systems (SenSys).
Slijepcevic, S., & Potkonjak, M. (2001). Power efficient organization of wireless sensor networks.
In ICC.
Smallwood, R., & Sondik, E. (1973). The optimal control of partially observable Markov decision
processes over a finite horizon. Operations Research, 21, 10711088.
Stachniss, C., Grisetti, G., & Burgard, W. (2005). Information gain-based exploration using raoblackwellized particle filters. In Robotics Science and Systems (RSS).
Tong, S., & Koller, D. (2001). Active learning for parameter estimation in Bayesian networks. In
NIPS.
Turney, P. D. (1995). Cost-sensitive classification: Empirical evaluation of a hybrid genetic decision
tree induction algorithm. Journal of Artificial Intelligence Research, 2, 369409.
van der Gaag, L., & Wessels, M. (1993). Selective evidence gathering for diagnostic belief networks.
AISB Quart., 86, 2334.
Zhao, F., Shin, J., & Reich, J. (2002). Information-driven dynamic sensor collaboration for tracking
applications. IEEE Signal Processing, 19(2), 6172.

591

fi