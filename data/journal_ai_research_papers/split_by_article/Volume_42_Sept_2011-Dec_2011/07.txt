Journal of Artificial Intelligence Research 42 (2011) 887916

Submitted 04/11; published 12/11

Multi-Robot Adversarial Patrolling:
Facing a Full-Knowledge Opponent
Noa Agmon

agmon@cs.utexas.edu

Department of Computer Science
University of Texas at Austin
TX, USA

Gal A Kaminka
Sarit Kraus

galk@cs.biu.ac.il
sarit@cs.biu.ac.il

Computer Science Department
Bar Ilan University
Israel

Abstract
The problem of adversarial multi-robot patrol has gained interest in recent years, mainly
due to its immediate relevance to various security applications. In this problem, robots
are required to repeatedly visit a target area in a way that maximizes their chances of
detecting an adversary trying to penetrate through the patrol path. When facing a strong
adversary that knows the patrol strategy of the robots, if the robots use a deterministic
patrol algorithm, then in many cases it is easy for the adversary to penetrate undetected
(in fact, in some of those cases the adversary can guarantee penetration). Therefore this
paper presents a non-deterministic patrol framework for the robots. Assuming that the
strong adversary will take advantage of its knowledge and try to penetrate through the
patrols weakest spot, hence an optimal algorithm is one that maximizes the chances of
detection in that point. We therefore present a polynomial-time algorithm for determining
an optimal patrol under the Markovian strategy assumption for the robots, such that the
probability of detecting the adversary in the patrols weakest spot is maximized. We build
upon this framework and describe an optimal patrol strategy for several robotic models
based on their movement abilities (directed or undirected) and sensing abilities (perfect or
imperfect), and in dierent environment models - either patrol around a perimeter (closed
polygon) or an open fence (open polyline).

1. Introduction
The problem of multi-robot patrol has gained interest in recent years (e.g., Ahmadi & Stone,
2006; Chevaleyre, 2004; Elmaliach, Agmon, & Kaminka, 2007; Paruchuri, Tambe, Ordonez,
& Kraus, 2007; Amigoni, Gatti, & Ippedico, 2008), mainly due to its immediate relevance
to various security applications. In the multi-robot patrol problem, robots are required to
repeatedly visit a target area in order to monitor it. Many researchers have focused on a
frequency-based approach, guaranteeing that some point-visit frequency criteria are met by
the patrol algorithm, for example maximizing the minimal frequency or guaranteeing uniform frequency (e.g., refer to Elmaliach et al., 2007; Chevaleyre, 2004; Almeida, Ramalho,
Santana, Tedesco, Menezes, Corruble, & Chevaleyr, 2004).
In contrast, we advocate an approach in which the robots patrol in adversarial settings,
where their goal is to patrol in a way that maximizes their chances of detecting an adversary
c
2011
AI Access Foundation. All rights reserved.

fiAgmon, Kaminka & Kraus

trying to penetrate through the patrol path. Thus the decisions of the adversary must be
taken into account. Our objective is, therefore, to develop patrol paths for the robots, such
that following these paths the robots will maximize the chance of adversarial detection. The
problem of adversarial planning and specically adversarial patrolling is a wide problem,
where generally no computational tractable results exist. This paper presents the problem
in a restrictive environment of perimeter patrol by a set of homogenous robots, providing a
computational tractable optimal result.
As opposed to frequency-driven approaches, in adversarial settings the point-visit frequency criteria becomes less relevant. Consider the following scenario. We are given a cyclic
fence of a length of 100 meters and 4 robots must patrol around the fence while moving at a
velocity of 1m/sec. Clearly, the optimal possible frequency at each point around the fence,
in terms of maximizing the minimal frequency, is 1/25, i.e., each location is visited once
every 25 seconds. This optimal frequency is achieved if the robots are placed uniformly
along the fence (facing the same direction) and move forward without turning around. Assume that it takes an adversary 20 seconds to penetrate the area through the fence. As
the robots move in a deterministic path, an adversary knowing the patrol algorithm can
guarantee penetration if it simply enters through a position that was recently visited by
a patrolling robot. On the other hand, if the robots move non-deterministically, i.e., they
turn around from time to time with some probability greater than 0, then the choice of
penetration position becomes less trivial. Moreover, if we assume that an adversary may
penetrate at any time, it motivates the use of nondeterministic patrol behavior indenitely.
We rst consider the problem of patrolling around a closed polygon, i.e., a perimeter.
We introduce a non-deterministic framework for patrol under a rst order Markovian assumption for the robots strategy, in which the robots choose their next move at random
with some probability p. This probability value p characterizes the patrol algorithm. We
model the system as a Markov chain (e.g., Stewart, 1994), and using this model we calculate in polynomial time the probability of penetration detection at each point along the
perimeter as a function of p, i.e., it depends on the choice of patrol algorithm.
Based on the functions dening the probability of penetration detection, we nd an optimal patrol algorithm for the robots in the presence of a strong adversary, i.e., an adversary
having full knowledge on the patrolling robotstheir algorithm and current placement. In
this case, the adversary uses this knowledge in order to maximize its chances of penetrating
without being detected. It is therefore assumed that the adversary will penetrate through
the weakest spot of the path, hence the goal of the robots is to maximize the probability
of penetration detection in that weakest spot. We provide a polynomial time algorithm
(polynomial in the input size, depending on the number of robots and the characteristics
of the environment) for nding an optimal patrol for the robots facing this full knowledge
adversary. We show that a non-deterministic patrol algorithm is advantageous, and guarantees some lower bound criteria on the performance of the robots, i.e., on their ability to
block the adversary.
We then use the patrol framework to consider additional environment and robotic models. Specically, we consider the case in which the robots are required to patrol along an
open polyline (fence). We show that although this case is inherently dierent from patrolling
along a perimeter, the basic framework can still be used (with some changes) in order to nd
an optimal patrol algorithm for the robots. We investigate also dierent movement models
888

fiMulti-Robot Adversarial Patrolling

of robots, namely the robots can have directionality associated with their movement (and
turning around could cost the system time), or they can be omnidirectional. In addition,
we model various types of sensing capabilities of the robots, specically, their sensing capabilities can be perfect or imperfect, local or long-range. In all these cases we show how the
basic framework can be extended to include the various models.
This paper is organized as follows. In Section 2 we discuss previous work, related to
our research. Section 3 describes the basic robot and environment model. We introduce in
Section 4 a framework for the patrolling robots, and describe a polynomial-time algorithm
for determining the probability of penetration detection at every point along the patrol
path (Section 4.2). We then show in Section 4.3 an algorithm for dening an optimal patrol
algorithm for the robots, assuming they face a full-knowledge adversary, and in Section 4.4
provides some interesting results from an implementation of the algorithms. In Section 5
we show how the basic framework can be used in order to consider various robotic sensing
and movement models and in a dierent environment (open fences). Section 6 concludes.

2. Related Work
Systems comprising multiple robots that cooperate to patrol in some designated area have
been studied in various contexts (e.g., Chevaleyre, 2004; Elmaliach, Agmon, & Kaminka,
2009). Theoretical (e.g., Chevaleyre, 2004; Elmaliach et al., 2009; Amigoni et al., 2008)
and empirical (e.g., see Sak, Wainer, & Goldenstein, 2008; Almeida et al., 2004) solutions
have been proposed in order to assure quality patrol. The denition of quality depends on
the context. Most studies concentrate on the frequency-based patrolling, which optimizes
frequency of visits throughout the designated area (e.g. refer to Elmaliach et al., 2009;
Almeida et al., 2004; Chevaleyre, 2004). Ecient patrol, in this case, is a patrol guaranteeing a high frequency of visits in all parts of the area. In contrast, adversarial patrolling
(addressed in this paper) deals with the detection of moving adversaries who are attempting
to avoid detection. Here, an ecient patrol is one that deals eciently with intruders (e.g.,
see Sak et al., 2008; Basilico, Gatti, & Amigoni, 2009b; Amigoni et al., 2008).
The rst theoretical analysis of the frequency-based multi-robot patrol problem that
concentrated on frequency optimization was presented by Chevaleyre (2004). He introduced
the notion of idleness, which is the duration each point in the patrolled area is not visited.
In his work, he analyzed two types of multi-robot patrol schemes on graphs with respect
to the idleness criteria: partitioning the area into subsections, where each section is visited
continuously by one robot; and the cyclic scheme in which a patrol path is provided along
the entire area and all robots visit all parts of the area, consecutively. He proved that
in the latter approach, the frequency of visiting points in the area is considerably higher.
Almeida et al. (2004) oered an empirical comparison between dierent approaches towards
patrolling with regards to the idleness criteria, and shows great advantage of the cycle based
approach.
Elmaliach et al. (2007, 2009) oered new frequency optimization criteria for evaluating
patrol algorithms. They provide an algorithm for multi-robot patrol in continuous areas
that is proven to have maximal minimal frequency as well as uniform frequency, i.e., each
point in the area is visited with the same highest-possible frequency. Their work is based on

889

fiAgmon, Kaminka & Kraus

creating one patrol cycle that visits all points in the area in minimal time, and the robots
simply travel equidistantly along this patrol path.
Sak et al. (2008) considered the case of multi-agent adversarial patrol in general graphs
(rather than perimeters, as in our work). They concentrated on an empirical evaluation
(using a simulation) of several non-deterministic patrol algorithms that can be roughly
divided into two: Those that divide the graph between the patrolling agents, and those that
allow all agents to visit all parts of the graph. They considered three types of adversaries:
random adversary, an adversary that always chooses to penetrate through a recently-visited
node and an adversary that uses statistical methods to predict the chances that a node will
be visited soon. They concluded that there is no patrol method that outperformed the
others in all the domains they have checked, but the optimality depends on the graph
structure. In contrast to this investigation, we provide theoretical proofs of optimality for
dierent settings.
The work of adversarial multi-robot patrol was examined also by using game-theoretic
approaches (e.g., see Basilico et al., 2009b; Basilico, Gatti, & Amigoni, 2009a; Pita, Jain,
Ordonez, Tambe, Kraus, & Magorii-Cohen, 2009; Paruchuri, Tambe et al., 2007). Note
that the work described herein can be modeled as a game theoretic problem: Given two
players, the robots and the adversary, with a possible set of actions by each side, determine
the optimal policy of the robots that will maximize their utility gained from adversarial
detection. This is a zero-sum game. Since we assume a strong (full knowledge) adversarial
model, we adopt the minmax approach, namely, minimizing the maximal utility of the
opponent (or in this case: equivalent to maximizing the minimal probability of detection
of the robots). However, in our work we do not use game theoretic tools for nding the
equilibrium strategy, but use tailored ad-hoc solution that nds the optimal policy for the
robots in polynomial time, taking into account the robots possible sensing and movement
capabilities.
The most closely related work by Amigoni et al. (2008) and Basilico et al. (2009b, 2009a)
used a game-theoretic approach using leader-follower games for determining the optimal
strategy for a single patrolling agent. They considered an environment in which a patrolling
robot can move between any two nodes in a graph, as opposed to the perimeter model we
use. Their solution is suitable for one robot in heterogenous environments, i.e., the utility
of the agent and the adversary changes along the vertices of the graph. They formulate
the problem as a mathematical programming problem (either multilinear programming or
mixed integer linear programming). Consequently, the computation of the optimal strategy
is exponential, yet using optimization tools they manage to get good approximation to the
optimal solution.
Paruchuri, Tambe et al. (2007) considered the problem of placing stationary security
checkpoints in adversarial environments. Similar to our assumptions, they assume that
their agents work in an adversarial environment in which the adversary can exploit any predictable behavior of the agents, and that the adversary has full knowledge of the patrolling
agents. They model their system using Stackelberg games, which uses policy randomization
in the agents behavior in order to maximize their rewards. The problem is formulated
as a linear program for a single agent, yielding an optimal solution for that case. Using
this single agent policy, they present a heuristic solution for multiple agents, in which the
optimal solution is intractable. Paruchuri, Pearce et al. (2007) further study this problem
890

fiMulti-Robot Adversarial Patrolling

in cases where the adversarial model is unknown to the agents, although the adversary still
has full knowledge of the patrol scheme. They again provide heuristic algorithms for optimal strategy selection by the agents. Pita et al. (2009) continued this research to consider
the case in which the adversaries make their choices based on their bounded rationality or
uncertainty, rather than make the optimal game-theoretic choice. They considered three
dierent types of uncertainty over the adversarys choices, and provided new mixed-integer
linear programs for Stackelberg games that deal with these types of uncertainties.
As opposed to all these works that are based on using game-theoretic approaches and
provide approximate or heuristic solutions to intractable optimal solutions, in our work we
focus on specic characteristics of the robots and the environment, and provide optimal
polynomial-time algorithms for nding an optimal patrol strategy for the multi-robot team
using the minmax approach.
Theoretical work based on stochastic processes that is related to our work is the cat and
mouse problem (Coppersmith, Doyle, Raghavan, & Snir, 1993), also known as the predatorprey (Haynes & Sen, 1995) or pursuit evasion problem (Vidal, Shakernia, Kim, Shim, &
Sastry, 2002). In this problem, a cat attempts to catch a mouse in a graph where both
are mobile. The cat has no knowledge about the mouses movement, therefore as far as
the cat is concerned, the mouse travels similarly to a simple random walk on the graph.
We, on the other hand, have worst case assumptions about the adversary. We consider
a robotic model, in which the movement of the cat is correlated with the movement of a
robot, with possible directionality of movement, possible cost of changing directions and
possible sensorial abilities. Moreover, in our model the robots travel around a perimeter or
a fence, rather than in a general graph. Thus in a sense, our research is concerned with
pursuit-evasion on a polyline - open or closed.
Other theoretical work by Shieh and Calvert (1992), based on computational geometry
solutions, attempts to nd optimal viewpoints for patrolling robots. They try to maximize the view of the robots in the area, show that the problem is N P-Hard, and nd
approximation algorithms for the problem.

3. Robot and Environment Model
In the following section, we provide a description of the robotic model, environment model
and the adversarial model. We describe the basic model of patrolling around a perimeter
(closed polygon). Further environments and robotic models are discussed in Section 5.
3.1 The Environment
We consider a patrol in a circular path around a closed polygon P . The path around P
is divided into N segments of a length of uniform time distance, i.e., each robot travels
through one segment per cycle while sensing it (its velocity is 1 segment / 1 time cycle).
This division into segments makes it possible to consider patrols in heterogeneous paths. In
such areas, the diculty of passing through terrains varies from one terrain to another, for
example driving in muddy tracks vs. driving on a road. In addition, riding around corners
requires a vehicle to slow down. Figure 1 demonstrates a transition from a given area to a
discrete cycle. The area, on the left, is given along with its velocity constraints. The path
is then divided into segments such that a robot travels through one segment per time cycle
891

fiAgmon, Kaminka & Kraus

while monitoring it, i.e., the length of each segment is determined by both the velocity of
the robot (corresponding to the time it takes it to travel through the specic segment) and
the sensorial capabilities of the robot. After the path is divided into segments with uniform
travel time, it is equivalent to considering a simple cycle as appears in the right of Figure
1.
Note that the distance between the robots is calculated with respect to the number of
segments between them, i.e., the distance is in travel time. For example, if we say that
the distance between R1 and R2 is 7, then there are 7 segments between them, and if R1
had remained still, then it would have taken R2 7 time cycles to reach R1 (assuming R2 is
headed towards the right direction).

equivalent
Figure 1: An example for creating discrete segments from a circular path with the property that the
robots travel through one segment per cycle. The dierent line structures along the perimeter on the left
correlate to dierent velocity constraints, which are converted (in the middle gure) to N segments in
which the robots travel during one time cycle. This gure is equivalent to the gure in the right, which
is a simple cycle divided into N uni-time segments.

3.2 Patrolling Robotic Model
We consider a system of k > 1 homogenous mobile robots R1 , . . . , Rk , that are required to
patrol around a closed polygon. The robots operate in cycles, where each cycle consists of
two stages.
1. Compute: Execute the given algorithm, resulting in a goal point, denoted by pG , to
which the robot should travel.
2. Move: Move towards point pG .
This model is synchronous, i.e. all robots execute each cycle simultaneously. We concentrate our attention to the Compute stage, i.e., how to compute the next goal point.
We assume the robots movement model is directed such that if pG is behind the robot,
it has to physically turn around. Turning around is a costly operation, and we model this
cost in time, i.e., if the robot turns around it resides in its segment for  time units. The
case in which the movement model is not directed is discussed in Section 5.1. Throughout
the paper we assume for simplicity that  = 1, unless stated otherwise.
A key result of this research (Section 4) is that optimal patrolling necessitates robots
to be placed at a uniform distance d = N/k from one another along the perimeter. Consequently, we require the robots to be coordinated in the sense that all robots move in the
same direction, and if decided to turn around they do it simultaneously. This requirement
guarantees that the uniform distance of d is maintained throughout the execution of the
892

fiMulti-Robot Adversarial Patrolling

patrol algorithm. Note that this tightly-coordinated behavior is achievable in centralized
systems, or in systems where communication exists between all team members. Other practical implementations may exist (for example uniformly seeding a pseudorandom number
generator for all the robots), but they all require coordination inside the team. Distributed
systems that cannot assume reliable communication are left for future work.
3.3 Adversarial Model
Our basic assumption is that the system consists of an adversary that tries to penetrate
once through the patrolling robots path without being detected. The adversary decides,
at any unknown time, through which segment to penetrate. Its penetration time is not
instantaneous, and lasts t time units, during which it stays at the same segment.
Denition 1. Let si be a discrete segment of a perimeter P which is patrolled by one robot
or more. Then the Probability of Penetration Detection in si , ppdi , is the probability that a
penetrator going through si during t time units will be detected by some robot going through
si during that period of time.
In other words, ppdi is the probability that a patrol path of some robot will pass through
segment si during the time that a penetration is attempted through that segment, hence it
is calculated for each segment with respect to the current location of the robots at a given
time (since the robots maintain uniform distance between them throughout the execution,
this relative location remains the same at all times). We use the general acronym ppd when
referring to the general term of probability of penetration detection (without reference to a
certain segment).
Recall that the time distance between every two consecutive robots around the perimeter
is d = N/k. Therefore we consider t values between the boundaries d+
2  t < d. The reason
for this is that if it takes the robot  time units to turn, then the robot adjacent to s0 will
have probability > 0 of arriving at every segment si , 0  i  t, while the robot adjacent
to sd has probability > 0 of arriving at segments si , d  (t   )  i leqd. Hence segment
st+1 has probability > 0 of being visited only if d  (t   )  t + 1  d+2+1  t, otherwise
there is at least one segment, st+1 , that has probability 0 of being visited during t time
units. Therefore an adversary having full knowledge on the patrol will always manage to
successfully penetrate regardless of the actions taken by the patrolling robots. Note that 
appears in this equation since it inuences the number of segments reachable by the robot
located in segment sd+1 if turning around (sd , sd1 , . . . , sd/2+ ). On the other hand, if t  d
then all segments si can have ppdi = 1 simply by using a deterministic algorithm.
We dene the patrol scheme of the robots as the
1. Number of robots, the distance between them and their current position.
2. The movement model of the robots and any characterization of their movement.
3. The robots patrol algorithm.
The patrol scheme reects the knowledge obtained by the adversary on the patrolling robots
at any given time (hence is not necessarily time dependent).

893

fiAgmon, Kaminka & Kraus

We consider a strong adversarial model in which the adversary has full knowledge of
the patrolling robots. Therefore the full knowledge adversary knows the patrol scheme,
and will take advantage of this knowledge in order to choose its penetration spot as the
weakest spot of the patrol, i.e., the segment with minimal ppd. The solution concept adopted
here (as stated in Section 2) is similar to the game-theoretic minmax strategy, yielding a
strategy that is in equilibrium (none of the playersrobots or adversaryhas any initiative
to diverge from their strategy). The adversary can learn the patrol scheme by observing the
behavior of the robots for a sucient amount of time. Note that in security applications,
such strong adversaries exist. In other applications, the adversary models the behavior of
the system in the worst case scenario from the patrolling robots point of view (similar to
the classical Byzantine fault model in distributed systems, see Lynch, 1996).
In our environment, the robots are responsible only for detecting penetrations and not
handling the penetration (which requires task-allocation methods). Therefore the case in
which the adversary issues multiple penetrations is similar to handling a single penetration,
as the robots detect, report and continue to monitor the rest of the path, according to their
algorithm.

4. A Framework for Adversarial Patrolling of Perimeters
The environment we consider is a linear environment, in which at each step the robots can
decide to either go straight or turn around. The framework we suggest is nondeterministic
in the sense that at each time step the decision it done independently, at random, with
some probability p. Formally,
{
p
Go straight
Probability of next move =
1  p Turn around
Since the dierent patrol algorithms we consider vary in the probability p of the next
step, we assert that the probability p characterizes the patrol algorithm.
Assume a robot is currently located in segment si . Therefore if the robot is facing
segment si+1 , then with a probability of p it will go straight to it and with a probability of
1  p it will turn around and face segment si1 . Similarly, if it is facing segment si1 , then
with a probability of p it will reach segment si1 and with a probability of 1  p it will face
segment si+1 .
Note that the probability of penetration detection in each segment si , 1  i  d, is
determined by probability p characterizing the patrol algorithm, therefore ppdi is a function
of p, i.e., ppdi (p). However, whenever possible we will use the abbreviation ppdi . By the
denition of ppdi , we need to nd the probability that si will be visited during t time units
by some robot. Assuming perfect detection capabilities of the robots, ppdi is determined
only by the first visit of some robot to si , since once the intruder is detected the detection
mission is successful (specically, once the segment is visited, the game is over). Note
that ppdi is calculated regardless of the actions of the adversary.
As stated previously, in order to guarantee optimality of the patrol algorithm, the robots
should be uniformly distributed along the perimeter with a distance of d = N/k between
every two consecutive robots, and that they are coordinated in the sense that if they are

894

fiMulti-Robot Adversarial Patrolling

supposed to turn around, they do so simultaneously. In the following theorem and supporting lemmas we prove optimality of these assumptions in a full-knowledge adversarial
environment.
Lemma 1 follows directly from the fact that the movement of the robots is continuous,
thus a robot Rl cannot move from segment si to segment si+j , j > 0, without visiting
segments si+1 , . . . , sj1 in between. Note that since k > 1 it follows that the number of
segments unvisited by Rl is greater than 2t (otherwise a simple deterministic algorithm
would suce to detect the adversary with probability 1). Therefore during t time units
Rl residing initially in segment s0 cannot visit segment si , i < t, arriving from the other
direction of the perimeter without visiting the segments closer to its current location (s0 )
rst (this argument holds for segments to the left and to the right of s0 ).
Lemma 1. For a given p, the function ppdli : N  [0, 1] for constant t and Rl residing in
segment s0 is a monotonic decreasing function, i.e., as the distance between a robot and a
segment increases, the probability of reaching it during t time units decreases.
Lemma 2. As the distance between two consecutive robots along a cyclic patrol path is
smaller, the ppd in each segment is higher and vice versa.
Proof. Consider a sequence S1 of segments s1 , . . . , sw between two adjacent robots, Rl and
Rr , where s1 is adjacent to the current location of Rl and sw is adjacent to the current
location of Rr . Let S2 be a similar sequence, but with w  1 segments, i.e., the distance
between Rl and Rr decreases by one segment. Assume that other robots are at a distance
greater than or equal to w  1 from Rl and Rr , and that w  1 < t. Since a robot may
inuence the ppd in segments that are up to a distance t from it (as it has a probability of
0 of arriving at any segment at a greater distance within t time units), the probability of
penetration detection, ppd, in these sequences is inuenced only by the possible visits of Rl
and Rr .
Denote the probability of penetration detection in segment si  Sj by ppdi (j), 1  i  w,
j  {1, 2}, and the probability that the penetrator will be detected by robot Rx by ppdxi (j),
x  {l, r}. Therefore, for any segment si  Sj , ppdi (j) = ppdli (j) + ppdri (j)  ppdli (j)ppdri (j)
(either Rl or Rr will detect the adversary, not both). Note that either ppdli (j), ppdri (j) or
both can be equal to 0. We need to show that ppdi (2)  ppdi (1), for all 1  i  w, and
for at least one segment sm , ppdm (2) > ppdm (1). Specically, it is sucient to show that
ppdli (2) + ppdri (2)  ppdli (2)ppdri (2)  {ppdli (1) + ppdri (1)  ppdli (2)ppdri (2)}  0, and for some
i this inequality is strict.
For every segment si , ppdli (1) = ppdli (2) (there is no change in its relative location),
hence we need to prove that ppdri (2)  ppdri (1)  ppdli (2){ppdri (2)  ppdri (1)}. Since 0 
ppdli (2)  1, in order for the inequality to hold, it is left to show that ppdri (2)  ppdri (1)  0.
From Lemma 1 we know that ppdri (j) is monotonically decreasing, therefore for each i,
ppdri (2)  ppdri (1), which completes the proof of this inequality.
It is left to show that for some i = m, ppdrm (2)ppdrm (1) > ppdlm (2){ppdrm (2)ppdrm (1)},
i.e., for some m in which ppdlm (2) = 1, ppdrm (2) > ppdrm (1). Robot Rr may inuence the
ppd on both of his sides - segments located to the left and to the right of its current
position. Denote the number of inuenced segments to its right by y (y may be equal to
0). If y > 0, then ppdrwy+1 (2) > ppdrwy (1). In other words, Rr has a probability of 0
895

fiAgmon, Kaminka & Kraus

of reaching the segment with a distance of t + 1 from it in S1 , but in S2 it is y segments
away from it, therefore Rr has a probability greater than 0 to reach it. If y = 0, then
ppdrw (2) = 1 > ppdrw (1), as Rr lies exactly in segment sw of S2 , and ppdrw (1) = 0.
Theorem 3. A team of k mobile robots engaged in a patrol mission maximizes minimal ppd
if the following conditions are satisfied. a. The time distance between every two consecutive
robots is equal b. The robots move in the same direction and speed.
Note that condition b means that all robots move together in the same direction, i.e.,
if they change direction, then all k robots change their direction simultaneously.
Proof. Following Lemma 2, it is sucient to show that the combination of conditions a
and b yield the minimal distance between two consecutive
robots along the cyclic path.
(N )
Since we have N segments and k robots, there are k possibilities of initial placement of
robots along the cycle (robots are homogenous, so this is regardless of their order). If the
robots are positioned uniformly along the cycle, then the time distance between each pair
of consecutive robots is N/k. This is the minimal value that can be reached. Therefore,
clearly, condition a guarantees this minimality.
If the robots are not coordinated, then it is possible that two consecutive robots along
the cycle, Ri and Ri+1 , will move in opposite directions. Therefore the distance between
them will increase from Nk to Nk + 2, and by Lemma 2 the ppd in the segments between
them will be smaller. If Ri and Ri+1 move towards one another, then the distance between
them will be Nk  2 and the ppd in the segments between them will become higher. On the
other hand, some pair Rj and Rj+1 exists such that the distance between them increases,
as the total sum of distances between consecutive robots remains N , hence the minimal ppd
around the cycle will become smaller.
Therefore the only way of achieving the minimal distance (maximal ppd) is by assuring
that condition a is satised, and maintaining it is achieved by satisfying condition b.
Since when facing a full-knowledge adversary, the goal of the robots is to maximize the
minimal ppd along the perimeter, the following corollary follows.
Corollary 4. In the full-knowledge adversarial model, an optimal patrol algorithm must
guarantee that the robots are positioned uniformly along the perimeter throughout the execution of the patrol.
4.1 The Penetration Detection Problem
The general denition of the problem is as follows.
Penetration detection (PD) problem: Given a circular fence (perimeter) that is divided into N segments, k robots uniformly distributed around this perimeter with a distance
of d = N/k (in time) between every two consecutive robots, assume that it takes t time
units for the adversary to penetrate, and the adversary is known to have full-knowledge
of the patrol scheme. Let p be the probability characterizing the patrol algorithm of the
robots, and let ppdi (p), 1  i  d be a description of ppdi as a function of p. Find the

896

fiMulti-Robot Adversarial Patrolling

optimal value p, popt , such that the minimal ppd throughout the perimeter is maximized.
Formally,
popt = argmax{ min ppdi (p)}
0p1

1id

To summarize the model and the Theorems presented above, an optimal algorithm for
multi-robot perimeter patrol under the Markovian strategy assumption for the robots has
the following characteristics.

 The robots are placed uniformly around the perimeter with d segments between every
two consecutive robots.
 The robots are coordinated in the sense that if they decide to turn around, then they
do it simultaneously.
 At each time step, the robots continue straight with a probability of p or turn around
with a probability of 1  p, and if they turn around they stay in the same segment for
 time units.

Note that under the above framework (i.e. the framework for homogenous robots), the
division of the perimeter into sections of d segments creates an equivalent symmetric environment in the sense that in order to calculate the optimal patrol algorithm it is sucient
to consider only one section of d segments, and not the entire perimeter of N segments.
This is due to the fact that each section is completely equivalent to the other, and remains
so throughout the execution.
We divide the goal of solving the PD problem, i.e., nding an optimal patrol algorithm
into two stages.
1. Calculating the d ppdi functions for each 1  i  d. This is determined according to
the robotic movement model (directed or undirected), environment model (perimeter/fence) and sensorial model (perfect/imperfect, local/extended).
2. Given the d ppdi functions, nd the solution to the PD problem, i.e., maximize the
ppd in the segment(s) with minimal ppd.
These two steps are independent in the sense that incorporating various dierent robotic
models will not change the process of determining the solution to the PD problem, as long
as the result of the procedure are d functions representing the ppd values in each segment.
On the other hand, if we would like to consider dierent goal functions other than
maximizing the minimal ppd (for example maximizing the expected ppd), it can be done
without any change in the rst stage, i.e., determining the ppd functions. The important
result is that this framework can be applied to both dierent environment and robotic
models (for example fence patrol), and dierent goal functions (corresponding to dierent
adversarial settings).
897

fiAgmon, Kaminka & Kraus

The rst stage for a the basic model (perimeter patrol, directed movement model of the
robots, robots with perfect local sensing) is described in Section 4.2, and the second stage
is described in Section 4.3. Extensions of the rst stage to dierent robot motion models
and sensing models are described in Section 5.
4.2 Determining the Probability of Penetration Detection
In order to nd an optimal patrol algorithm, it is necessary to rst determine the probability
of penetration detection at each segment si (ppdi ), which is a function of p (the probability
characterizing the patrol algorithm, as shown in Section 4.1). In this section we present a
polynomial time algorithm that determines this probability.
As stated previously, based on the symmetric nature of the system, we need to consider
only one section of d segments that lie between two consecutive robots, without loss of
generality, R1 and R2 . We use a Markov chain in order to model the possible states and
transition between states in the system.
In order to calculate the probability of detection in each segment along t time cycles,
we use the graphic model G illustrated in Figure 2. For each segment si in the original
path, 1  i  d, we create two states in G: One for moving in a clockwise direction (scw
i ),
and the other for moving in a counterclockwise direction (scc
).
If
R
or
R
reach
one
1
2
i
of the si segments within t time units, then the adversary is discovered, i.e., it does not
matter if the segment is visited more than once during these t time units. Therefore we
would like to calculate only the probability of the first arrival to each segment, and this is
done by dening the state sdt (corresponding to s0 and s0 ) as absorbing states, i.e., once
a robot passes through si once, its additional visits to this segment in this path will not
be considered. The edges of G are as follows. One outgoing edge from scw
to scc
i
i exists
cw
with a probability of 1  p for turning around, and one outgoing edge to si1 exists with
a probability of p for continuing straightforward. Similarly, one outgoing edge from scc
i to
cw
cc
si exists with a probability 1  p for turning around, and one outgoing edge to si+1 exists
with a probability of p for continuing straightforward.
cc

S0

S1

S2

S3

S4

S0

cc

0

1p p

cw

1p 0

S1

R2
S

S dt

cw

p

S

4

1

cw

p

S

p

cw

cc

3

p

S

2

1p

S

4

S

3

1p
cc

p

1

1p

S

cc

cc

1

1

p

cw

cc

cw

S3

S4

S4

S dt

0

0

0

0

0

0

0

0

0

0

0

0

p

1p p

0

0

0

0

0

0

0

0

p

1p 0

0

0

0

0

0

cc

0

0

0

0

0

1p p

0

0

cw

0

0

0

p

1p 0

0

0

0

cc

0

0

0

0

0

0

0

1p p

S4

cw

0

0

0

0

0

p

1p 0

0

S dt

0

0

0

0

0

0

0

0

1

S3

1p

S

2

S dt

cc

S3

cw

S2
p

cw

S2

S2

cc

S2

cw

cc

S1

S1

R1

cw

S1

S3
S4

Figure 2: Conversion of the initial segments and robot locations into a graphical model, and the
respective stochastic matrix M . Each segment corresponds to two states: one going clockwise and one
going counterclockwise. ppdi are all paths starting from scw
and ending at sdt .
i

898

fiMulti-Robot Adversarial Patrolling

In the following theorem, we prove that the probability of detecting the adversary by
some robot in segment si (i.e., the probability of arriving at a segment during t time units)
is equivalent to nding all paths of size at most t to the absorbing state starting at state
scc
i . Therefore it is possible to use the Markov chain representation for determining ppdi ,
as shown in Algorithm FindFunc.
Theorem 5. Determining the probability of penetration detection at segment si , ppdi , is
equivalent to finding all paths of length at most t that start at scw
and end in sdt in the
i
Markov chain described above.
Proof. For simplicity reasons, in this proof we distinguish between sldt and srdt , which are
the absorbing state to the left and to the right of the Markov chain (respectively), although
practically they are represented by the same state sdt .
Clearly, due to the d and t values considered, ppdi is determined only by the visits of
the two robots surrounding the section of d segments s1 , . . . , sd , denoted by Rl and Rr .
Recall that the probability of penetration detection in segment si is dened as ppdi =
ppdli + ppdri  ppdli ppdri , where ppdri (ppdli ) is the probability that the adversary, penetrating
through si , is detected by Rr (Rl ). We claim that ppdli is equivalent to computing the
r
r
l
paths starting from scw
i and ending at the absorbing state sdt (similarly ppdi by state sdt ).
r
l
Clearly, under this claim, since a path of length at most t cannot reach both sdt and sdt , it
follows that ppdli ppdri = 0, and the theorem will follow. We prove the claim for ppdli , where
ppdri follows directly.
ppdli is the probability that Rl will reach si at least once during t time units. Therefore,
we must construct all paths starting from the current location of Rl that passes through si ,
but take into account only the rst visit to the segment (everything beyond the rst visit
results anyway in probability of detection = 1). At each step Rl continues straight with
probability p or turns around with probability 1  p. This is equivalent to keeping Rl in
place, and moving the segments towards Rl with probability p and switch the segments
direction with probability 1  p. Hence, every path starting at state scw
i (without loss of
generality; computing paths starting at scc
is
equivalent,
but
requires
switching
the locations
i
of Rl and Rr in the representation) reaching srdt is equivalent to a path started by Rl and
passing through si . Since srdt is set to be an absorbing state, every path passing through it
will not be considered again, i.e., only the rst visit of Rl to si is considered, as required.
Using the Markov chain, we can dene the stochastic matrix M which describes the
state transitions of the system. Figure 2 illustrates the Markov chain and its corresponding
stochastic matrix M used for computing the ppd functions. The probability of arrival at
segment si during t time units, hence the probability penetration detection in that segment,
t
cw
is the scc
2d+1 + s2d+1 entry of the result of Vi  M , where Vi is a vector of 0s, except for a
1 on the 2i  1th location. The formal description of the algorithm is given by Algorithm
1. Note that the algorithm makes a symbolic calculation, hence the result is a set of d
functions of p. The time complexity of Algorithm FindFunc depends on the calculation time
of M t , which is generally t  (2d)3 . However, since M is sparse, methods for multiplying
such matrices eciently exist (e.g., see Gustavson, 1978), reducing the time complexity to
t(2d)2 , i.e. O(td2 ). Since t is bounded by d  1, the time complexity is O(d3 ).

899

fiAgmon, Kaminka & Kraus

Algorithm 1 Algorithm FindFunc(d, t)
1: Create matrix M of size (2d + 1)(2d + 1), initialized with 0s
2: Fill out all entries in M as follows:
3: M [2d + 1, 2d + 1] = 1
4: for i  1 to 2d do
5:
M [i, max{i + 1, 2d + 1}] = p
6:
M [i, min{1, i  2}] = 1  p
7: Compute M T = M t
8: Res = vector of size d initialized with 0s
9: for 1  loc  d do
V = vector of size 2d + 1 initialized with 0s.
10:
11:
V [2loc]  1
Res[loc] = V  M T [2d + 1]
12:
13: Return Res
4.2.1 Handling Higher Values of 
Algorithm FindFunc and Figure 2 demonstrate the case in which  = 1, i.e., if the robot
turns around (with probability 1  p) it remains in its current position for one time step.
In the general case, when the robot turns around, the cost of turningmodeled in time
can be higher. In such cases, the Markov chain is modied to represent the value of  .
ccw
Specically, for each segment si , instead of having two corresponding states (scw
i and si ),
cw
ccw
we have 2( ) states: si and si , and one set of   1 states for turning around to each
direction (from cw to ccw and vice versa). The probabilities assigned to each of the edges
ccw and
is 1  p for the rst outgoing edge from scc
i to the rst intermediate state towards si
ccw
cc
1 for each edge on that direction, and similarly on the path from si to si . See Figure
3 for an illustration. The matrix M is lled out according to the new chain, and the time
complexity of creating this matrix grows in a factor of  from (2d + 1)t to (2 d + 1)t .
However, as long as  is a constant, the total time complexity does not change.
S0

S1

S2

S3

S4

S0

R1

R2
S

p

cw

S

4

p

cw

S

3

p

cw

S

2

1p

1 1p

1 1p

1 1p

1

1

1

1

cw

1

p

S dt

1
1

1

S dt

1

1
1

S

cc

4

p

1

1p

S

1

1

1p
p

1

1
cc

3

p

1p

S

cc

2

p

1p

S

cc

1

Figure 3: Illustration of the Markov chain when  > 1, and specically, here  = 3.

900

fiMulti-Robot Adversarial Patrolling

4.3 An Optimal Adversarial Patrol Algorithm for Full-Knowledge Adversaries
In cases in which the robots face a full knowledge adversary, it is assumed that the adversary
will take advantage of this knowledge to nd the weakest spot of the patrol, i.e., the segment
with minimal probability of penetration detection. Therefore an optimal patrol algorithm
to handle such an adversary is the one that maximizes the minimal ppd throughout the
perimeter. Hence we need to nd an optimal p, popt , such that the minimal ppd throughout
the perimeter is maximized.
Also here, since our environment is symmetric, we do not need to consider the entire
patrol path, but only a section of d segments between two consecutive robots. The input in
this procedure is the set of d ppdi (p) functions that were calculated in the previous section
(Section 4.2).
After establishing d equations representing the probability of detection in each segment,
we must nd the p value that maximizes the minimal possible value in each segment, where
p is continuous in the range p  [0, 1]. Denote these equations by ppdi (p), 1  i  d. The
maximal minimal value that we are looking is the p value yielding the maximal value inside
the intersection of all integrals of ppdi (p). The intersection of all integrals is also known as
the lower envelope of the functions (Sharir & Agarwal, 1996).
Observing the problem geometrically, consider a vertical sweep line that sweeps the
section [0, 1] and intersects with all d curves. It seeks the point p in which the minimal
intersection point between the sweep line and the curves, denoted by ppd (p), is maximal.
This p is the maximin point. Since the segment [0, 1] and the functions ppd1 , . . . , ppdd are
continuous, this sweep line solution cannot be implemented. We prove in the following
lemma that this point is either an intersection point of two curves, or a local maxima of
one curve (see Figure 4). See Algorithm 2 for the formal description of Algorithm FindP.

Figure 4: An illustration of two possible maximin points (marked by a full circle). The curves represent
d ppdi (p) functions in p  [0, 1]. On the left, the maximin point is created by the intersection of two
curves. On in the right, the maximin point it is the local maxima of the lowest curve.

In the following, we prove that Algorithm FindP nds point p such that the maximin
property is satised.
Lemma 6. A point p yields a maximin value ppd (p) if the following two properties are
satisfied.
a. ppd (p)  ppdi (p) 1  i  d.

901

fiAgmon, Kaminka & Kraus

b. One of the two following conditions holds: ppd (p) is an intersection of two curves (or
more), ppdi (p) and ppdj (p) or a local maxima of curve ppdk (p).
Proof. Property a. is derived from the denition of a maximin point. Therefore we are
looking for the maximal point that satises property a. We must still show that this point,
ppd (p), is obtained by either an intersection of two or more curves or is a local maxima.
Clearly, a maximal point of an integral is found on the border of the integral (the curve
itself). The area which is in the intersections of all curves lies beneath parts of curves,
ppdi1 , . . . , ppdim , such that ppdij is the minimal curve in the section between two points

j
j j
[lj , rj ] and m
j=1 [l , r ] = [0, 1]. By nding the maximal point in each section ppdmax =
max{f (x), x  [lj , rj ]}, and choosing the maximal between them, i.e., max{ppdjmax , 1  j 
m}, we obtain ppd (p). In each section [lj , rj ] the maximal point can be either inside the
section or on the borders of the section. The former case is precisely a local maxima of
ppdij . The latter is the intersection point of two curves ppdij1 , ppdij or ppdij , ppdij+1 .
Lemma 7. A point p exists yielding a maximin value ppd (p) > 0.
Proof. In order to prove the lemma, we need to show that the intersection of all integrals
ppd1 , . . . , ppdd in the x section [0, 1], and the y section (0, 1] is not empty. It suces to
show that for every ppdi , ppdi (x) > 0, 0 < x < 1.
Each function ppdi , 1  i  d represents the ppd in a segment si between two robots.
From our requirement that t  d2 + 1 (for  = 1), it follows that in all models we consider,
for 0 < p < 1 the ppd = 0. Note that if p = 0 or p = 1, then ppd is either 0 or 1, but this
does not contradict the fact that we have a point guaranteeing ppd (p) > 0.
Algorithm FindP nds this point by scanning all possible points satisfying the conditions
given in Lemma 6, and reporting the x-value (corresponding to the p value) with a y-value
dominated by all ppdi . The input to the algorithm is a vector of functions ppdi , 1  i  d
and the value t. Computing the intersections between every pair of functions costs d2 t2 :
d2 for all pair computation, t2 for nding the root of the polynomial using, for example, the
Lindsey-Fox method presented by Sitton, Burrus, Fox, and Treitel (2003). Computing the
dominance of the resulting points with respect to all other curves is d2 t as well. Therefore
the time complexity of Algorithm FindP is the complexity of Algorithm FindFunc, O(( Nk )3 ),
with additional cost of O(t2 d2 ) = O(( Nk )4 ) (the algorithm itself), i.e., jointly O(( Nk )4 ).
Theorem 8. Algorithm FindP(F, t) finds point p yielding the maximin value of ppd.
Proof. Algorithm FindP checks all intersection points between the pair of curves, and the
points of local maxima of the curves. It then checks the dominance of these points, i.e.,
whether in the location these points have a lower value compared to all other curves, and
picks the maximal of them. Therefore, if such a point is found, by Lemma 6, this point is
precisely the maximin point. Moreover, by Lemma 7 this point exists.
4.4 Examples
We have fully implemented Algorithm FindP in order to nd the optimal maximin p for pairs
of ds and ts. We use the following examples to illustrate how the relation between t and d
is reected in the ppd values. Recall that when running a deterministic patrol algorithm in
902

fiMulti-Robot Adversarial Patrolling

Algorithm 2 Algorithm FindP(d, t)
1: F  Algorithm FindFunc(d, t).
2: Set popt  0.
3: for Fpivot  F1,...,d do
4:
Compute local maxima (pmax , Fpivot (pmax )) of Fpivot in
5:
for each Fi , 1  i  d do
6:
Compute intersection point pi of Fi and Fpivot in the
7:
if Fpivot (pi ) > Fpivot (pmax ) and Fpivot (pi )  Fk (pi )k
8:
popt  pi .
9:
if Fpivot (pmax ) > Fpivot (pi ) and Fpivot (pi )  Fk (pi )k
popt  pmax .
10:
11: Return (pmax , Fpivot (pmax )).

the range (0, 1).
range (0, 1).
then
then

all scenarios we handle, the minimal ppd is 0. We assume the robots are initially heading
to the clockwise direction.
First of all, we have seen that the minimal ppd achieved after running FindP was always
more than 0. As t/d  1, i.e., t increases, then the value of the maximin ppd increases, and
vice versa, i.e., as t/d  1/2, then the value of the maximin ppd decreases. This can be seen
clearly in Figure 5. In this case, we have xed the value of t to 8 and checked the maximin
ppd for 9  d  15. When t/d is close to 1 (d = 9, t = 8) the maximin ppd = 0.423, and
the value decreases to 0.05 when t/d is close to 1/2 (d = 15, t = 8). Similar results are seen
if we x the value of d and check for dierent values of t.

Figure 5: On the left, results of maximin ppd for xed t = 8 and dierent values of d: the possible
maximin ppd decreases as d increases. On the right, results of maximin ppd for xed d = 16 and
dierent values of t: the possible maximin ppd increases as t increases.

In Figure 6, we present the values of the ppd in all 16 segments, for all dierent possible
values of t (9  d  15). It is seen clearly, that the value of ppd usually decreases as
the distance from the left robot increases, until it reaches the segment with maximin ppd,
then the value rises again until reaching the current location of the robot to the right. The
reason lies in the fact that the segments to the left of the segment with the maximin ppd
are inuenced mostly by the robot on the left, and the segments to the right of that point
are mostly inuenced by the robot to the right. Since the ps yielding the maximin point
in this example have value of greater than 0.8 for all ts, the segment having the maximin
value is to the right of the midpoint.
903

fiAgmon, Kaminka & Kraus

Figure 6: ppd values in all 16 segments for all t values (9 to 15)

5. Accounting for Movement Constraints and Sensing Uncertainty
In this section we describe various ways in which the basic framework of multi-robot patrol
can be used to solve the problem of nding an optimal patrol algorithm in various other
settings. First, we describe the case in which the movement model of the robots is not
necessarily directed. We then discuss various sensing capabilities of the robots in perimeter
patrol: imperfect local sensing, perfect long-range sensing and imperfect long-range sensing.
Finally, we describe the case in which the robots should travel along an open polyline (fence)
rather than a perimeter.
5.1 Dierent Movement Models
A basic assumption of the robotic framework is that the robots movement model is directed
in the sense that if a robot has to go back to visit a point behind it, it has to physically
turn around. This directed movement model is suitable for various robotic types, for example dierential drive robots commonly used in robotic labs. However, in some cases the
robots movement is undirected, for example if the robot travels along train tracks.We will
demonstrate in this section how the basic framework can be used also in the latter case,
i.e., if the robot movement is undirected.
We examine the dierence in the Markov chain and the resulting ppd in three dierent
cases:
1. Bidirectional Movement model, denoted by BMP. Here, the robots movement pattern
is similar to movement on tracks or a camera going back and forth along a xed course
(omnidirectional robots). In this model, the robots have no movement directionality
in the sense that switching directionsright to left and vice versadoes not require
physically changing the direction of the robot (turning around).

904

fiMulti-Robot Adversarial Patrolling

2. Directional Costly-Turn model, denoted by DCP, the basic framework discussed to
far for   1. The robots movement is directed, and turning around is a special
operation that has an attached cost in time. Specically, we show the results here for
 = 1.
3. Directional Zero-Cost model, denoted by DNCP, which is a special case of the DCP
model with  = 0. The robots movement is directed, yet turning around does not
take extra time. This is coherently dierent from BMP, as in each step the robot does
not go either right or left, but straight or back (where each could be either to the
right or to the left, depending on the current heading of the robot).
The basic framework can be used for handling all three models simply by adapting the
Markov chain to the current model. This changes only lines 5  6 in Algorithm FindFunc. A
description of the Markov chains are described in Figure 7. In the BMP model, it moves one
step to the right (segment i + 1) with a probability of p and one step to the left (segment
i1) with a probability of 1p. This model is similar to a random walk. The corresponding
Markov chain is simple: edges exist from si to si+1 with a probability of p and from si to
si1 with a probability of 1  p (with no related direction). In both the DNCP and DCP
models, we assume directionality of movement, hence the robot continues its movement in
its current direction with a probability of p, and turns around (rewinds) with a probability
of 1  p. In DCP, if the robot turns around it will remain in segment i (as described in
Figure 2). In the DNCP model, the chain is similar to the one above, however edges will
cc
cc
cw
exist from scw
i to si+1 and from si to si1 with a probability of 1  p. See Figure 7 for an
illustration of DNCP, DCP and BMP as a Markov chain.
S0

S1

S2

S3

S4

S0

R1

R2
S

S dt

cw

p

S

4

DCP

cw

1p
p

S

cc

cc

cw

DNCP

cw

S

cc

S

4

S dt

S

S

cc

S

3

p

p

p

p

1

p

cc

1

cw

p

S

2

cw

1

p

S

S

4

1p

3

S dt

1p

cc

S

2

cc

1

1p

p
p
p

1p

S dt

1p

S

2

1p

cc

cw

p

p

3

1p
p

BMP

S

p

2

p

p

1p S 4

cw

1p

S

3

p

S dt

S
1p

S

4

p

3

S
1p

S

2

S dt

1

1p

Figure 7: Conversion of the initial segments and robot locations into a graphical model in all three
movement models.

905

fiAgmon, Kaminka & Kraus

We examined the dierence between the resulting ppd values in the three models in a
case where d = 16, t = 12 (Figure 8). It is clearly noticeable that the DCP model yields
less or equal values of ppd compared to DNCP model throughout the segments. The reason
is because when turning around, in the DCP model, the operation costs an extra cycle,
therefore the probability of arriving at a segment decreases, compared to the case in which
turning around is not costly. Another interesting phenomena is that the ppd values of the
BMP are considerably higher (and close to 1) than the values obtained by other models
for segments closer to the location of the righthand side robot. The value then decreases
dramatically around the value of t and then increases back again. Recall that here there is
no directionality of movement, therefore the probability of going right is 0.707 and going
left is 1  0.707 = 0.293, which explains this phenomena. One might have expected to have
p = 0.5 in the random walk model (BMP), however by choosing an equal probability for
going right and left, the robots will necessarily neglect the segments further away from them
(the mid segments between two consecutive robots), resulting in a lower minimal ppd.

Figure 8: Results of maximin ppd values for d = 16 and t = 12 for all three models: DNCP, DCP
and BMP. The maximin ppd values are circled.

5.2 Perimeter Patrol with Imperfect Penetration Detection
Uncertainty in the perception of the robots should be taken into consideration in practical
multi-robot problems. Therefore we consider the realistic case in which the robots have
imperfect sensorial capabilities. In other words, even if the adversary passes through the
sensorial range of the robot, it still does not necessarily detect it.
We introduce the ImpDetect model, in which a robot travels through one segment per
time cycle along the perimeter while monitoring it, and has imperfect sensing. Denote the

906

fiMulti-Robot Adversarial Patrolling

probability that an adversary penetrating through a segment si while it is monitored by
some robot R and R will actually detect it by pd  1.
Note that if pd < 1, revisiting a segment by a robot could be worthwhileit could
increase the probability of detecting the adversary. Therefore the probability of detection
in a segment si (ppdi ) is not equivalent to the probability of first arriving at si (as illustrated
in Section 4.2), but the probability of detecting the adversary during some visit y to si ,
0  y  t. Denote the probability of the yth visit of some robot to segment si by wiy .
Therefore ppdi is dened as follows.
ppdi = wi1 pd + wi1 (1  pd )  {wi2 pd + wi2 (1  pd )  {. . . {wit  pd }}}

(1)

In other words, the probability of detecting the penetration is the probability that it
will be detected in the rst visit (wi1  pd ) plus the probability that it will not be detected
then, but during later stages. This again is the probability that it will be detected during
the second visit (wi2  pd ) or at later stages, and so on.
Note that after t time units, wit = 0 for all currently unoccupied segments si , and if a
robot resides in si , then wit is precisely (1  pd )t .
One of the building blocks upon which the optimal patrol algorithms are based, is the
assumption that the probability of detection decreases or remains the same as the distance
from a robot increases, i.e., it is a monotonic decreasing function. This fact was used in
Section 4 in proving that in order to maintain an optimal ppd, the robots must be placed
uniformly around the perimeter (with a uniform time distance), and maintain this distance
by being coordinated. In order to show this here as well, we rst prove that the probability
of detection monotonically decreases with the distance from the location of the robot.
Lemma 9. Let S = {st+ , . . . , s1 , s0 , s1 , . . . , st } be a sequence of 2t segments, where robot
Ra resides in s0 at time 0. Then i  0, ppdi  ppdi+1 , and i  0, ppdi  ppdi1 .
Proof. First, assume that i > 0 (positive indexes). By Equation 1, we need to compare
1 p + w 1 (1 
between wi1 pd + wi1 (1  pd )  {wi2 pd + wi2 (1  pd )  {. . . {wit  pd }}} and wi+1
d
i+1
2 p + w 2 (1  p )  {. . . {w t
pd )  {wi+1
d
d
i+1
i+1  pd }}}. It is therefore sucient to show that
m , for all 1  m  t. We prove this by induction on m. As the base case, consider
wim  wi+1
1 . This is accurately proven in Lemma 1, based
m = 1, i.e., we need to show that wi1  wi+1
on the fact that the movement of the robots is continuous, therefore in order to get to a
segment you must visit the segments in between (the formal proof also uses the conditional
probability law).
m . Denote the
We now assume correctness for m < m, and prove that wim  wi+1
probability that a robot placed at segment si will return to si within r time units by xi (r).
In our symmetric environment, for every i 
and j, xi (r) = xj (r). Moreover, r, xi (r) 
m =
xi (r  1). Therefore wim can be described as r+ut wim1 (u)  xi (r), and similarly wi+1

m1
m1
m1
 wi+1
, and since xi (r) =
r+ut wi+1 (u)  xi+1 (r). By the induction assumption, wi
m
m
xi+1 (r), it follows that wi  wi+1 , proving the lemma for positive indexes.
The negative indexes are a reective image of the positive indexes, but with t   time
units. Since the induction was proven for all t values, the proof for the negative indexes
directly follows.

907

fiAgmon, Kaminka & Kraus

The following Theorem follows directly from Lemma 9. The idea behind this is that
since the probability of penetration detection decreases as the distance from the robots
grow, both minimal ppd and average ppd are maximized if the distance between the robots
is as small as possible. Since the patrol path is cyclic, this is achieved only if the distance
between every two consecutive robots is uniform, and remains uniform. Note that Theorem
10 below is a generalization of Theorem 3 for imperfect sensing (based on the fact that that
the general structure of the ppd function remains the same even if the robots might benet
from revisiting a segment, and by that increasing the ppd in that segment).
Theorem 10. In the full knowledge adversarial model, a patrol algorithm in the ImpDetect
model is optimal only if it satisfies two conditions: a. The robots are placed uniformly
around the perimeter. b. The robots are coordinated in the sense that if they turn around,
they do it simultaneously. By assuring these two conditions, the robots preserve a uniform
distance between themselves throughout the execution.
Algorithm for nding ppdi with imperfect sensorial detection:
Find the probability of penetration detection with pd  1 results in a dierent Markov
chain, hence a dierent stochastic matrix M . Figure 9 demonstrates the new graphical
model and the new resulting stochastic matrix M (compared to Figure 2, in which pd = 1).
cc
The dierence in the algorithm is in the division of s0 to two states, scw
0 and s0 , the
addition of the absorbing state sdt that represents the detected state and the transitions
between these states. The ppdi is therefore obtained after t + 1 steps (compared to t steps)
in the sdt s location in the result vector.
The time complexity of the algorithm remains O(d4 ).
S0

S1

S2

S3

S4

S0
cc

R1

R2

S

cw

S

4

1p

cw

S

4

p

S

3

1p
cc

p

p

cw

S

2

1p

S

cc

3

p

1

S

2

p

S

cw

0

pd

(1p)(1pd )

1p
cc

p

S

cc

1

p(1pd )

S

cc

0

pd

cc

cw

cc

cw

S4

S4

S0

S0

S dt

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

cc

0

0

0

1p p

0

0

0

0

0

0

cw

0

p

1p 0

0

0

0

0

0

0

0

cc

0

0

0

0

0

1p p

0

0

0

0

cw

0

0

0

p

1p 0

0

0

0

0

0

cc

0

0

0

0

0

0

1p

0

0

S3
S4

cw

S4

cc

p

cw

S3

p

S3
1

cc

S3

1p 0

S2

S dt

cw

S2

0

S1

cw

1p p

S2

cc

S2
p

cc

S1

cw

S1
p(1pd )

cw

S1

S0

0
p(1pd )

0

p

0

0

0

0

p

1p 0

0

0

0

0

0

0

0

0 (1p)(1p
d

0

0

0
)

pd

S0

cw

0

0

0

0

0

0

0 p(1pd ) (1p)(1p
d )0

pd

S dt

0

0

0

0

0

0

0

1

0

0

0

Figure 9: Conversion of the initial segments and robot locations into a graphical model, and the
respective stochastic matrix M for the imperfect sensing model.

908

fiMulti-Robot Adversarial Patrolling

5.3 Improving Sensing Capabilities in Perimeter Patrol
In this section we present further enhancements by considering various sensing capabilities
of the robots. Specically, we rst consider the case in which a robot can sense beyond
its currently visited segment. We then oer a solution to the case in which the robot can
sense beyond its current position, yet its sensing capabilities are not perfect, and change as
a function of the distance from its current position.
5.3.1 Extending (Perfect) Sensing Range
In this section we consider the LRange model, in which the sensorial range of a robot exceeds
the section which it currently resides in. Use L to denote the number of segments the robot
senses beyond the segment it currently occupies. If L > 0, we refer to the L segments as
shaded segments. Note that the location of the shaded segments depends on the direction
of the robot shading them, and they are always in the direction the robot is facing.
A trivial solution to dealing with such a situation is to enlarge the size of the segment,
and thus enlarge the length of the time unit used as base for the system, such that it will
force L to be 0. However, in this case we lose accuracy of the analysis of the system, as the
length of the time cycle should be as small as possible to also suit the velocity of the robots
and the value of t.
In general, the values of t that can be handled by the system are bounded by its relation
to d (the distance between every two robots along the path) - see Section 4. If L > 0, this
changes. Specically, if L = 0, then the possible values of t considered are d+
2  t  d  1.
However, if L > 0, then it is possible to handle even smaller values of t, i.e., even if the
penetration time of the adversary is short. Formally, the possible values of t are given in
the following equation.
d+
LtdL1
2
If t is smaller than d+
2  L, then an adversary with full knowledge will manage to
penetrate with a probability of 1, i.e., there is a segment (sL+1 ) which is unreachable within
t time units. On the other hand, if t is greater than d  L  1, then a simple deterministic
patrol algorithm will detect all penetrations with a probability of 1. We assume that during
the  time units the robot turns around, it can sense only its current segment.
This change in the sensing model of the robot is reected in the Markov chain, as seen in
cw
Figure 10. The change is that we add 2L arrows to the absorbing state sdt , from scw
1 , . . . , sL
cc
cc
and sd , . . . , sdL+1 . The stochastic matrix M changes accordingly, and the probability of
penetration detection in segment si becomes the result of the vector multiplication M t+1 Vi ,
where Vi is a vector of size 2d + 1 with all entries 0 except for entry corresponding to the
location of scw
i , which holds a value of 1, similar to the process described in Algorithm
FindFunc (1).
5.3.2 Extending the Sensorial Range Along With Imperfect Detection
In many cases, the actual sensorial capabilities of the robot are composed of the two characteristics described in the previous sections, i.e., the robot can sense beyond its current
segment, however the sensing ability is imperfect. Therefore in this section we introduce
909

fiAgmon, Kaminka & Kraus

L=1
cc

S0

S1

S2

S3

S4

S0

S1

cc

0

cw

cc
cw

S

cw

p

S

4

cw

1p

S

S

cw

p

S

cc

3

p

p

S

2

1p

cc

4

p

3

1

cc

1p

S

cc

1

2

p

1p

S

cc

1

S dt

cw

cc

cw

S4

S dt

1p p

0

0

0

0

0

0

0

0

0

0

0

0

0

0

1

0

0

0

1p p

0

0

0

0

0

p

1p 0

0

0

0

0

0

0

0

0

0

0

1p p

0

0

0

0

0

p

1p 0

0

0

0

cc

0

0

0

0

0

0

1

0

0

S4

cw

0

0

0

0

0

p

1p 0

0

S dt

0

0

0

0

0

0

0

0

1

S3
1

cw

S4

S2
1

cc

S3

S2

cw

cw

S3

S1

R2

cc

S2

S1

R1

cw

S1

S3
S4

S2

Figure 10: An illustration of L segments shaded by robot R. In this case R is facing right, therefore
the shaded segments are to its right. The Markov chain changes accordingly, therefore also the stochastic
matrix M .

the ImpDetLRange sensorial model, which is a combination of the LRange and the ImpDetect
models. Here the robot can sense L segments beyond its current segment, yet the pd in
each segment varies and is not necessarily 1. We therefore describe how to compute ppdi in
this case, which deals with the most realistic form of sensorial capabilities (Duarte & Hu,
2004): imperfect, long range sensing.
The information regarding the sensorial capabilities of the robots includes two parameters. The rst describes the quantity of the sensing ability, i.e., the number of segments that
exceeds the current segment in which robot resides, for which it has some sensing abilities,
denoted by L. The second parameter describes the quality of sensing in all segments the
robot can sense. This is given in the form of a vector VS = {v0 , v1 , . . . , vL }, where vi is the
probability that the robot residing in s0 will detect a penetration that occurs in segment si .
We assume that the values in VS decrease monotonically, i.e., as i increases, vi decreases or
remains the same.
The Markov chain in this model, as illustrated in Figure 11, changes in order to reect
the imperfect sensing along with the long range sensing. The absorbing state sdt exist
in addition to the states scw
0 and s0 cc. The transition probabilities are added from 2L
segments: i, j 0  i  L; d  L + 1  j  d, a transition from scw
i to s0 with probability vi
cc
and from sj to s0 with probability vdj+1 . In addition, the transition from scw
i to si cc is
cw with probability (1  p)(1  v
with probability (1  p)(1  vi ), from scc
to
s
dj+1 ), hence
j
j
cw
cw
cc
cc
the transition probability from si to si1 is p(1  vi ) and from sj to sj+1 is p(1  vdj+1 ).
The probability of penetration detection in segment si is the result of M t+1 multiplied
by Vi in location s0 of the result vector. Note that also here, similar to the solution described
in Section 5.2, since we added a new absorbing state (which takes an extra step to reach),
ppdi is the result in the product of the stochastic matrix and Vi in location s0 after t + 1
time steps (not t).

910

fiMulti-Robot Adversarial Patrolling

v0<1 v1<1
S0

S1

S2

S3

S4

S0
cc

R1

S1

R2

cc

S1
p(1v0 )

cw

S1

v1

S

p

S

4

1p

cw

S

4

p

S

3

1p
cc

p

cw

2

1p

S

cc

3

p

S

p

1

p(1v1 )

S

cw

0

(1p)(1v
1 )

(1p)(1v0 )

cc

cc

cc

2

S

cw

S

p(1v1 )

1

p(1v0 )

S

0

v0

v0

cw

cc

cw

S4

S0

S0

S dt

0

v1

) 0

0

0

0

0

0

0

0

0

0

0

0 p(1v1 ) v1

0

0

1p p

0

0

0

0

0

0

p

1p 0

0

0

0

0

0

0

0

cc

0

0

0

0

0

1p p

0

0

0

0

cw

0

0

0

p

1p 0

0

0

0

0

0

cc

0

0

0

0

0

0

0

1p

cw

0

0

0

0

0

p

1p 0

0

p(1v0 ) 0

0

0

0

0

0

0 (1p)(1v
0

S3
S4
S4

cc

v1

cc

S4

0

S0

p

cw

S3

0

S3
1

cc

S3

0

(1p)(1v
)
1
0 p(1v

(1p)(1v
0 )0

cw

S2

cw

S2

S dt

cc

S2

cc

S2
cw

0

cw

S1

0

p

0

0

0

0
)

v0

cw

S0

0

0

0

0

0

0

0 p(1v0 ) (1p)(1v
0 )0

v0

S dt

0

0

0

0

0

0

0

1

0

0

0

Figure 11: An illustration of L segments shaded by robot R, where the probability of detection is not
necessarily 1. In this case R is facing right, therefore the shaded segments are to its right. The Markov
chain and the stochastic matrix M changes accordingly.

5.4 Multi-Robot Adversarial Patrolling Along Fences
In our general work, and specically in previous sections, we assumed the robots travel
around a closed, circular, area. In this section we discuss patrolling along an open polyline,
also known as fence patrol. First, we will discuss how this patrol is dierent from perimeter
patrol. We will then describe an algorithm for determining ppdi in fence patrol assuming
the robots have perfect sensing capabilities, and nally we will provide an algorithm for
robots with imperfect sensing.
5.4.1 Patrolling Along a Closed Polyline vs. an Open Polyline
In the following, we describe why patrolling along an open polyline is more challenging than
patrolling in cyclic environments (closed polyline).
The rst reason lies in the fact that the robots are required to go back and forth along
a part (or parts) of the open polyline. As a result, the elapsed time between two visits of
a robot at each point along this line can be almost twice as long as the elapsed time in a
circular setting. In Figure 12, we are given two environments: a closed polyline (circle) (a)
and an open polyline (b). Note that open polylines b. and c. are equivalent in the sense
that each robot travels through one segment per time step, regardless of the shape of the
section. Both lines a. and b. are of the same total length l and with the same number of
robots (4). In the circular environment, if it takes an adversary more than l/4 time units to
penetrate - it will never be able to penetrate even if the robots simply continuously travel
with uniform distance between them. However, if the robots travel along an open polyline
(b), the maximal time duration between two visits of the roboteven in the best case, is
2l/4  2 (Elmaliach, Shiloni, & Kaminka, 2008). Therefore a weaker adversary that has a

911

fiAgmon, Kaminka & Kraus

penetration time which is almost twice as long as in the circular fence might still be able to
penetrate.

a.

b.

c.

Figure 12: Illustration of the dierence between patrolling along a line and patrolling along a circle, for
dierent polylines

Another reason for the added complication in analyzing the probability of penetration
detection in open polyline environments lies in the asymmetric nature of traveling in the
segments along time. In a circular environment, if the robots are coordinated and switch
directions in unison, then the placement of the robots is symmetric in each time unit. Therefore all segments in the same distance from some robot (with respect to its direction) have
the same probability of penetration detection. Hence in order to calculate an optimal way
of movement (in our case the probability p of turning around), it is sucient to consider
only one section of d segments, and the resulted p is equivalent throughout the execution.
In an open polyline environment this is not the case. The probability of penetration detection diers with respect to the current location and direction of the robot. Therefore
the algorithm that nds the ppd for each segment, needs to calculate the ppd as a function
of p for each segment si for each possible initial location of the robot inside the section.
Therefore this results in a matrix of size d  d of the ppd functions (as opposed to a vector
of d functions in the circular fence).
5.4.2 Determining ppdi in an Open Polyline (Fence)
Following the framework for multi-robot patrol along an open line proposed by Elmaliach
et al. (2008), we assume each robot is assigned to patrol back and forth along one section of d
segments. Given this framework, we would like to compute the optimal patrol algorithm for
the robots along the section. Similar to the perimeter patrol case (Section 4.2), we describe
the system as a Markov chain (see Figure 13), with its relative stochastic matrix M . Since
the robots have directionality associated with their movement, we create two states for each
segment: the rst for traveling in a segment in the clockwise direction, and the second for
traveling in the counterclockwise direction. The probability of turning around at the end of
each section is 1, otherwise the robot will continue straight with probability of p, and will
turn around with probability of 1  p.
Note that the main dierence from the perimeter patrol calculation of ppdi lies in the
number of resulting ppdi functions. In perimeter patrol, due to its symmetric nature, there is
one ppdi function for each segment between the current location of each robot, representing
the probability of a robot arriving there during t time units. Here, however, ppdi depends
on the current location of the robot, hence for each location of the robot we have d functions
of probability of penetration detection, therefore a total of d2 such functions (compared to
d in perimeter patrol).
912

fiMulti-Robot Adversarial Patrolling

Denote the probability of penetration detection in segment si given that the robot is
currently at segment sj by ppdji . In order to calculate the d ppdji function for all 1  i, j  d,
we create d dierent matrices: M1 , . . . , Md . Each matrix Mi corresponds to calculating ppdji ,
i.e., the probability of penetration detection in segment si , and from that we calculate ppdji
from every current location sj of the robot (similar to what is done in perimeter patrol).
Figure 13 demonstrates the matrix M2 with which ppd2i is calculated. The gure describes
the general case of pd  1, i.e., the robot might have imperfect sensing.
cc

S1

S2

S3

S4

S1

cc

0

cw

S1

cw

1

S

p

S

4

cw

3

p

S

cw

4

p

S

(1p)(1p
d )

1p

cc

p(1pd )

2

S

cc

3

S

cc

2

p

1

1

S

p(1pd )

S dt
1p

cc

1

1

cw

cc

cw

S dt

S4

S4

1p p

0

0

0

0

0

0

1

0

0

0

0

0

0

0

0

cc

0

0

0

)0

0

0

pd

cw

0 p(1pd )(1p)(1p
d ) 0

0

0

0

0

pd

cc

0

0

0

0

0

1p p

0

0

cw

0

0

0

p

1p 0

0

0

0

cc

0

0

0

0

0

0

0

1p

cw

0

0

0

0

0

p

1p 0

0

0

0

0

0

0

0

1

S3
S3
S4
S4

pd

cc

S3

S2

cw

cw

S3

S2

S

cc

S2

S1
pd

cw

S1

S dt

p

S2

(1p)(1p
d )p(1pd

0

p

Figure 13: Description of the system as a Markov chain, along with its stochastic matrix M for
calculating the ppd in segment s2 .

5.4.3 Optimal Algorithm for Fence Patrol
In the case of fence patrolling, the ppd value depends on the current location of the robot.
Consequently, the optimal p value characterizing the patrol of the robots is dierent for
each segment si , where 1  i  d. Therefore there could be dierent optimal p values with
respect to both location and orientation of the robot (2d values). However, it is sucient
to calculate the ppd values only d times (and not 2d times)only for one direction, as the
other direction is a reective image of the rst.
In order to nd the maximin point for the fence patrolling case, we use algorithm
MaximinFence, which nds the value p such that the minimal ppd is maximized, using
Algorithm FindP that computes this point by nding the maximal point in the integral
intersection of all curves (ppdi ). The complete description of the algorithm is shown in
Algorithm 3.
Algorithm 3 Procedure MaximinFence(d, t)
1: M  FindFencePPD(d, t)
2: for i  1 to d do
3:
OpP [i]  FindP(d, t) with additional given input M [i] as a vector of ppd functions.
4: Return OpP

913

fiAgmon, Kaminka & Kraus

6. Summary
This paper presents the problem of multi-robot patrolling in strong, full-knowledge, adversarial environments. In this problem a team of robots is required to repeatedly visit
some path, in our basic case a perimeter, and detect penetrations that are controlled by an
adversary. We assume the robots act in a strong adversarial model, in which the adversary
has full knowledge of the patrolling robots and uses this knowledge in order to penetrate
through the weakest spot of the patrol. We describe a framework for the basic case of multirobot patrol around a closed polygon, and use this framework for developing, in polynomial
time, an optimal patrol algorithm, i.e., an algorithm that strengthens the weakest spot of
the patrol. This framework is then extended in order to solve the problem also in an open
fence environment and in various movement and sensing models of the robots.
The paper makes several assumptions allowing the computation of an optimal strategy
for the patrolling robots. One such assumption is the rst order Markovian strategy of the
patrolling robots. Although proving or disproving the optimality of using rst order Markovian strategy is hard, it could be interesting to examine the case of higher order Markovian
strategies and compare their time complexity and performance to the solution discussed
here. Another direction for future work involves non-uniform environments, in which the
utility obtained from detecting penetrations on one hand or succeeding in penetration on
the other is not uniform throughout the environment. Other challenges left for future work
include handling heterogenous robots and non linear environments.

7. Acknowledgments
Preliminary results appeared in Proceedings of the IEEE International Conference on
Robotics and Automation (2008), in Proceedings of the Tenth Conference on Intelligent
Autonomous Systems (2008) and in Proceedings of IJCAI Workshop on Quantitative Risk
Analysis for Security Applications (QRASA) (2009). This research was supported in part by
ISF grant #1357/07 and #1685/07, and MOST grant #3  6797. We thank the anonymous
reviewers for constructive comments and helpful suggestions, and as always, thanks to K.
Ushi.

References
Agmon, N., Kaminka, G. A., & Kraus, S. (2008). Multi-robot fence patrol in adversarial
domains. In Proceedings of the Tenth Conference on Intelligent Autonomous Systems
(IAS-10), pp. 193201. IOS Press.
Agmon, N., Kraus, S., & Kaminka, G. A. (2008). Multi-robot perimeter patrol in adversarial settings. In Proceedings of the IEEE International Conference on Robotics and
Automation (ICRA).
Agmon, N., Kraus, S., & Kaminka, G. A. (2009). Uncertainties in adversarial patrol. In Proc.
of the IJCAI 2009 workshop on Quantitative Risk Analysis for Security Applications
(QRASA).

914

fiMulti-Robot Adversarial Patrolling

Ahmadi, M., & Stone, P. (2006). A multi-robot system for continuous area sweeping tasks.
In Proceedings of the IEEE International Conference on Robotics and Automation
(ICRA).
Almeida, A., Ramalho, G., Santana, H., Tedesco, P., Menezes, T., Corruble, V., & Chevaleyr, Y. (2004). Recent advances on multi-agent patrolling. Lecture Notes in Computer
Science, 3171, 474483.
Amigoni, F., Gatti, N., & Ippedico, A. (2008). Multiagent technology solutions for planning
in ambient intelligence. In Proceedings of Agent Intelligent Technologies (IAT-08).
Basilico, N., Gatti, N., & Amigoni, F. (2009a). Extending algorithms for mobile robot
patrolling in the presence of adversaries to more realistic settings. In Proceedings
of the IEEE/WIC/ACM International Conference on Intelligent Agent Technology
(IAT), pp. 565572.
Basilico, N., Gatti, N., & Amigoni, F. (2009b). Leader-follower strategies for robotic patrolling in environments with arbitrary topologies. In AAMAS, pp. 5764.
Chevaleyre, Y. (2004). Theoretical analysis of the multi-agent patrolling problem. In Proceedings of Agent Intelligent Technologies (IAT-04).
Coppersmith, D., Doyle, P., Raghavan, P., & Snir, M. (1993). Random walks on weighted
graphs and applications to on-line algorithms. Journal of the ACM, 40 (3).
Duarte, M. F., & Hu, Y. H. (2004). Distance-based decision fusion in a distributed wireless
sensor network. Telecommunication Systems, 26 (2-4), 339350.
Elmaliach, Y., Agmon, N., & Kaminka, G. A. (2007). Multi-robot area patrol under frequency constraints. In Proceedings of the IEEE International Conference on Robotics
and Automation (ICRA).
Elmaliach, Y., Agmon, N., & Kaminka, G. A. (2009). Multi-robot area patrol under frequency constraints. Annals of Math and Artificial Intelligence, 57 (3-4), 293320.
Elmaliach, Y., Shiloni, A., & Kaminka, G. A. (2008). A realistic model of frequencybased multi-robot fence patrolling. In Proceedings of the Seventh International Joint
Conference on Autonomous Agents and Multi-Agent Systems (AAMAS-08).
Gustavson, F. G. (1978). Two fast algorithms for sparse matrices: Multiplication and
permuted transposition. ACM Trans. Math. Softw., 4, 250269.
Haynes, T., & Sen, S. (1995). Evolving behavioral strategies predators and prey. In IJCAI95 Workshop on Adaptation and Learning in Multiagent Systems, pp. 3237.
Lynch, N. A. (1996). Distributed Algorithms. Morgan Kaufmann.
Paruchuri, P., Pearce, J. P., Tambe, M., Ordonez, F., & Kraus, S. (2007). An ecient
heuristic approach for security against multiple adversaries. In Proceedings of the
Sixth International Joint Conference on Autonomous Agents and Multi-Agent Systems
(AAMAS-08).
Paruchuri, P., Tambe, M., Ordonez, F., & Kraus, S. (2007). Security in multiagent systems
by policy randomization. In Proceedings of the Sixth International Joint Conference
on Autonomous Agents and Multi-Agent Systems (AAMAS-07).
915

fiAgmon, Kaminka & Kraus

Pita, J., Jain, M., Ordonez, F., Tambe, M., Kraus, S., & Magorii-Cohen, R. (2009). Eective solutions for real-world stackelberg games: When agents must deal with human
uncertainties. In Proceedings of the Eighth International Conference on Autonomous
Agents and Multiagent Systems (AAMAS-09).
Sak, T., Wainer, J., & Goldenstein, S. K. (2008). Probabilistic multiagent patrolling. In
Proc. of the 19th Brazilian Symposium on Artificial Intelligence (SBIA-08), pp. 124
133.
Sharir, M., & Agarwal, P. K. (1996). Davenport-Schinzel sequences and their geometric
applications. Cambridge University Press.
Shieh, J. S., & Calvert, T. W. (1992). View and route planning for patrol and exploring
robots. Advanced Robotics, 6 (4), 399430.
Sitton, G., Burrus, C., Fox, J., & Treitel, S. (2003). Factoring very-high-degree polynomials.
Signal Processing Magazine, IEEE, 20 (6), 27  42.
Stewart, W. J. (1994). Introduction to the Numerical Solution of Markov Chains. Princeton
University Press.
Vidal, R., Shakernia, O., Kim, H. J., Shim, D. H., & Sastry, S. (2002). Probabilistic pursuitevasion games - theory, implementation, and experimental evaluation. Robotics and
Automation, IEEE Transactions on, 18 (5), 662669.

916

fi