Journal of Artificial Intelligence Research 42 (2011) 661-687

Submitted 05/11; published 12/11

Finding Consensus Bayesian Network Structures
Jose M. Pena

jose.m.pena@liu.se

ADIT
Department of Computer and Information Science
Linkoping University
SE-58183 Linkoping
Sweden

Abstract
Suppose that multiple experts (or learning algorithms) provide us with alternative
Bayesian network (BN) structures over a domain, and that we are interested in combining
them into a single consensus BN structure. Specifically, we are interested in that the
consensus BN structure only represents independences all the given BN structures agree
upon and that it has as few parameters associated as possible. In this paper, we prove
that there may exist several non-equivalent consensus BN structures and that finding one
of them is NP-hard. Thus, we decide to resort to heuristics to find an approximated
consensus BN structure. In this paper, we consider the heuristic proposed by Matzkevich
and Abramson, which builds upon two algorithms, called Methods A and B, for efficiently
deriving the minimal directed independence map of a BN structure relative to a given node
ordering. Methods A and B are claimed to be correct although no proof is provided (a
proof is just sketched). In this paper, we show that Methods A and B are not correct and
propose a correction of them.

1. Introduction
Bayesian networks (BNs) are a popular graphical formalism for representing probability distributions. A BN consists of structure and parameters. The structure, a directed and acyclic
graph (DAG), induces a set of independencies that the represented probability distribution
satisfies. The parameters specify the conditional probability distribution of each node given
its parents in the structure. The BN represents the probability distribution that results
from the product of these conditional probability distributions. Typically, a single expert
(or learning algorithm) is consulted to construct a BN of the domain at hand. Therefore,
there is a risk that the so-constructed BN is not as accurate as it could be if, for instance,
the expert has a bias or overlooks certain details. One way to minimize this risk consists
in obtaining multiple BNs of the domain from multiple experts and, then, combining them
into a single consensus BN. This approach has received significant attention in the literature (Matzkevich & Abramson, 1992, 1993b; Maynard-Reid II & Chajewska, 2001; Nielsen
& Parsons, 2007; Pennock & Wellman, 1999; Richardson & Domingos, 2003; del Sagrado
& Moral, 2003). The most relevant of these references is probably the work of Pennock
and Wellman (1999), because it shows that even if the experts agree on the BN structure,
no method for combining the experts BNs produces a consensus BN that respects some
reasonable assumptions and whose structure is the agreed BN structure. Unfortunately,
this problem is often overlooked. To avoid it, we propose to combine the experts BNs
c
2011
AI Access Foundation. All rights reserved.

fiPena

in two steps. First, finding the consensus BN structure and, then, finding the consensus
parameters for the consensus BN structure. This paper focuses only on the first step (we
briefly discuss the second step in Section 8). Specifically, we assume that multiple experts
provide us with alternative DAG models of a domain, and we are interested in combining
them into a single consensus DAG. Specifically, we are interested in that the consensus
DAG only represents independences all the given DAGs agree upon and as many of them
as possible. In other words, the consensus DAG is the DAG that represents the most independences among all the minimal directed independence (MDI) maps of the intersection
of the independence models induced by the given DAGs.1 To our knowledge, whether the
consensus DAG can or cannot be found efficiently is still an open problem. See the work of
Matzkevich and Abramson (1992, 1993b) for more information. In this paper, we redefine
the consensus DAG as the DAG that has the fewest parameters associated among all the
MDI maps of the intersection of the independence models induced by the given DAGs. This
definition is in line with that of finding a DAG to represent a probability distribution p.
The desired DAG is typically defined as the MDI map of p that has the fewest parameters
associated rather than as the MDI map of p that represents the most independences. See,
for instance, the work of Chickering et al. (2004). The number of parameters associated
with a DAG is a measure of the complexity of the DAG, since it is the number of parameters
required to specify all the probability distributions that can be represented by the DAG.
In this paper, we prove that there may exist several non-equivalent consensus DAGs
and that finding one of them is NP-hard. Thus, we decide to resort to heuristics to find
an approximated consensus DAG. In this paper, we consider the following heuristic due to
Matzkevich and Abramson (1992, 1993b). See also the work of Matzkevich and Abramson
(1993a) for related information. First, let  denote any ordering of the nodes in the given
DAGs, which we denote here as G1 , . . . , Gm . Then, find the MDI map Gi of each Gi relative
to . Finally, let the approximated consensus DAG be the DAG whose arcs are exactly
the union of the arcs in G1 , . . . , Gm
 . It should be mentioned that our formulation of the
heuristic differs from that by Matzkevich and Abramson (1992, 1993b) in the following two
points. First, the heuristic was introduced under the original definition of consensus DAG.
We justify later that the heuristic also makes sense under our definition of consensus DAG.
Second,  was originally required to be consistent with one of the given DAGs. We remove
this requirement. All in all, a key step in the heuristic is finding the MDI map Gi of each
Gi . Since this task is not trivial, Matzkevich and Abramson (1993b) present two algorithms,
called Methods A and B, for efficiently deriving Gi from Gi . Methods A and B are claimed
to be correct although no proof is provided (a proof is just sketched). In this paper, we
show that Methods A and B are not correct and propose a correction of them.
As said, we are not the first to study the problem of finding the consensus DAG. In addition to the works discussed above by Matzkevich and Abramson (1992, 1993b) and Pennock
and Wellman (1999), some other works devoted to this problem are those by Maynard-Reid
II and Chajewska (2001); Nielsen and Parsons (2007); Richardson and Domingos (2003);
1. It is worth mentioning that the term consensus DAG has a different meaning in computational biology
(Jackson et al., 2005). There, the consensus DAG of a given set of DAGs G1 , . . . , Gm is defined as the
DAG that contains the most of the arcs in G1 , . . . , Gm . Therefore, the difficulty lies in keeping as many
arcs as possible without creating cycles. Note that, unlike in the present work, a DAG is not interpreted
as inducing an independence model by Jackson et al.

662

fiFinding Consensus Bayesian Network Structures

del Sagrado and Moral (2003). We elaborate below on the differences between these works
and ours. Maynard-Reid II and Chajewska (2001) propose to adapt existing score-based algorithms for learning DAGs from data to the case where the learning data is replaced by the
BNs provided by some experts. Their approach suffers the problem pointed out by Pennock
and Wellman (1999), because it consists essentially in learning a consensus DAG from a
combination of the given BNs. A somehow related approach is proposed by Richardson and
Domingos (2003). Specifically, they propose a Bayesian approach to learning DAGs from
data, where the prior probability distribution over DAGs is constructed from the DAGs
provided by some experts. Since their approach requires data and does not combine the
given DAGs into a single DAG, it addresses a problem rather different from the one in this
paper. Moreover, the construction of the prior probability distribution over DAGs ignores
the fact that some given DAGs may be different but equivalent. That is, unlike in the
present work, a DAG is not interpreted as inducing an independence model. A work that
is relatively close to ours is that by del Sagrado and Moral (2003). Specifically, they show
how to construct a MDI map of the intersection and union of the independence models
induced by the DAGs provided by some experts. However, there are three main differences
between their work and ours. First, unlike us, they do not assume that the given DAGs
are defined over the same set of nodes. Second, unlike us, they assume that there exists a
node ordering that is consistent with all the given DAGs. Third, their goal is to find a MDI
map whereas ours is to find the MDI map that has the fewest parameters associated among
all the MDI maps, i.e. the consensus DAG. Finally, Nielsen and Parsons (2007) develop a
general framework to construct the consensus DAG gradually. Their framework is general
in the sense that it is not tailored to any particular definition of consensus DAG. Instead, it
relies upon a score to be defined by the user and that each expert will use to score different
extensions to the current partial consensus DAG. The individual scores are then combined
to choose the extension to perform. Unfortunately, we do not see how this framework could
be applied to our definition of consensus DAG.
It is worth recalling that this paper deals with the combination of probability distributions expressed as BNs. Those readers interested in the combination of probability distributions expressed in non-graphical numerical forms are referred to, for instance, the work
of Genest and Zidek (1986). Note also that we are interested in the combination before any
data is observed. Those readers interested in the combination after some data has been
observed and each expert has updated her beliefs accordingly are referred to, for instance,
the work of Ng and Abramson (1994). Finally, note also that we aim at combining the given
DAGs into a DAG, the consensus DAG. Those readers interested in finding not a DAG but
graphical features (e.g. arcs or paths) all or a significant number of experts agree upon may
want to consult the works of Friedman and Koller (2003); Hartemink et al. (2002); Pena et
al. (2004), since these works deal with a similar problem.
The rest of the paper is organized as follows. We start by reviewing some preliminary
concepts in Section 2. We analyze the complexity of finding the consensus DAG in Section
3. We discuss the heuristic for finding an approximated consensus DAG in more detail in
Section 4. We introduce Methods A and B in Section 5 and show that they are not correct.
We correct them in Section 6. We analyze the complexity of the corrected Methods A and
B in Section 7 and show that they are more efficient than any other approach we can think
of to solve the same problem. We close with some discussion in Section 8.
663

fiPena

2. Preliminaries
In this section, we review some concepts used in this paper. All the DAGs, probability
distributions and independence models in this paper are defined over V, unless otherwise
stated. If A  B is in a DAG G, then we say that A and B are adjacent in G. Moreover,
we say that A is a parent of B and B a child of A in G. We denote the parents of B in G
by P aG (B). A node is called a sink node in G if it has no children in G. A route between
two nodes A and B in G is a sequence of nodes starting with A and ending with B such
that every two consecutive nodes in the sequence are adjacent in G. Note that the nodes in
a route are not necessarily distinct. The length of a route is the number of (not necessarily
distinct) arcs in the route. We treat all the nodes in G as routes of length zero. A route
between A and B is called descending from A to B if all the arcs in the route are directed
towards B. If there is a descending route from A to B, then B is called a descendant of A.
Note that A is a descendant of itself, since we allow routes of length zero. Given a subset
X  V, a node A  X is called maximal in G if A is not descendant of any node in X \ {A}
in G. Given a route  between A and B in G and a route 0 between B and C in G,   0
denotes the route between A and C in G resulting from appending 0 to .
P
Q
The number of parameters associated with a DAG G is BV [ AP aG (B) rA ](rB  1),
where rA and rB are the numbers of states of the random variables corresponding to the
node A and B. An arc A  B in G is said to be covered if P aG (A) = P aG (B) \ {A}. By
covering an arc A  B in G we mean adding to G the smallest set of arcs so that A  B
becomes covered. We say that a node C is a collider in a route in a DAG if there exist two
nodes A and B such that A  C  B is a subroute of the route. Note that A and B may
coincide. Let X, Y and Z denote three disjoint subsets of V. A route in a DAG is said to
be Z-active when (i) every collider node in the route is in Z, and (ii) every non-collider node
in the route is outside Z. When there is no route in a DAG G between a node in X and a
node in Y that is Z-active, we say that X is separated from Y given Z in G and denote it
as X  G Y|Z. We denote by X 6 G Y|Z that X  G Y|Z does not hold. This definition of
separation is equivalent to other more common definitions (Studeny, 1998, Section 5.1).
Let X, Y, Z and W denote four disjoint subsets of V. Let us abbreviate X  Y as
XY. An independence model M is a set of statements of the form X  M Y|Z, meaning
that X is independent of Y given Z. Given a subset U  V, we denote by [M ]U all the
statements in M such that X, Y, Z  U. Given two independence models M and N , we
denote by M  N that if X  M Y|Z then X  N Y|Z. We say that M is a graphoid if
it satisfies the following properties: symmetry X  M Y|Z  Y  M X|Z, decomposition
X  M YW|Z  X  M Y|Z, weak union X  M YW|Z  X  M Y|ZW, contraction
X  M Y|ZW  X  M W|Z  X  M YW|Z, and intersection X  M Y|ZW  X  M
W|ZY  X  M YW|Z. The independence model induced by a probability distribution p,
denoted as I(p), is the set of probabilistic independences in p. The independence model
induced by a DAG G, denoted as I(G), is the set of separation statements X  G Y|Z. It is
known that I(G) is a graphoid (Studeny & Bouckaert, 1998, Lemma 3.1). Moreover, I(G)
satisfies the composition property X  G Y|Z  X  G W|Z  X  G YW|Z (Chickering &
Meek, 2002, Proposition 1). Two DAGs G and H are called equivalent if I(G) = I(H).
A DAG G is a directed independence map of an independence model M if I(G)  M .
Moreover, G is a minimal directed independence (MDI) map of M if removing any arc
664

fiFinding Consensus Bayesian Network Structures

from G makes it cease to be a directed independence map of M . We say that G and an
ordering of its nodes are consistent when, for every arc A  B in G, A precedes B in
the node ordering. We say that a DAG G is a MDI map of an independence model M
relative to a node ordering  if G is a MDI map of M and G is consistent with . If M
is a graphoid, then G is unique (Pearl, 1988, Thms. 4 and 9). Specifically, for each node
A, P aG (A) is the smallest subset X of the predecessors of A in , P re (A), such that
A  M P re (A) \ X|X.

3. Finding a Consensus DAG is NP-Hard
Recall that we have defined the consensus DAG of a given set of DAGs G1 , . . . , Gm as the
i
DAG that has the fewest parameters associated among all the MDI maps of m
i=1 I(G ). A
sensible way to start the quest for the consensus DAG is by investigating whether there can
exist several non-equivalent consensus DAGs. The following theorem answers this question.
Theorem 1. There exists a set of DAGs that has two non-equivalent consensus DAGs.
Proof. Consider the following two DAGs over four random variables with the same number
of states each:
I

K



J

I





L

K



J

L

Any of the following two non-equivalent DAGs is the consensus DAG of the two DAGs
above:
I

K


&


I

K

J

L


%


J

L

A natural follow-up question to investigate is whether a consensus DAG can be found
efficiently. Unfortunately, finding a consensus DAG is NP-hard, as we prove below. Specifically, we prove that the following decision problem is NP-hard:
CONSENSUS
 INSTANCE: A set of DAGs G1 , . . . , Gm over V, and a positive integer d.
i
 QUESTION: Does there exist a DAG G over V such that I(G)  m
i=1 I(G ) and the
number of parameters associated with G is not greater than d ?

Proving that CONSENSUS is NP-hard implies that finding the consensus DAG is also
NP-hard, because if there existed an efficient algorithm for finding the consensus DAG, then
we could use it to solve CONSENSUS efficiently. Our proof makes use of the following two
665

fiPena

decision problems:
FEEDBACK ARC SET
 INSTANCE: A directed graph G = (V, A) and a positive integer k.
 QUESTION: Does there exist a subset B  A such that |B|  k and B has at least
one arc from every directed cycle in G ?
LEARN
 INSTANCE: A probability distribution p over V, and a positive integer d.
 QUESTION: Does there exist a DAG G over V such that I(G)  I(p) and the number
of parameters associated with G is not greater than d ?
FEEDBACK ARC SET is NP-complete (Garey & Johnson, 1979). FEEDBACK ARC
SET remains NP-complete for directed graphs in which the total degree of each vertex is at
most three (Gavril, 1977). This degree-bounded FEEDBACK ARC SET problem is used
by Chickering et al. (2004) to prove that LEARN is NP-hard. In their proof, Chickering
et al. (2004) use the following polynomial reduction of any instance of the degree-bounded
FEEDBACK ARC SET into an instance of LEARN:
 Let the instance of the degree-bounded FEEDBACK ARC SET consist of the directed
graph F = (VF , AF ) and the positive integer k.
 Let L denote a DAG whose nodes and arcs are determined from F as follows. For
every arc ViF  VjF in AF , create the following nodes and arcs in L:

ViF(9)



Aij (9)

Bij (2)

Cij (3)

Hij

(2)

.

&

Dij (9)

Eij (2)

Fij (2)



Gij



VjF(9)

(9)

The number in parenthesis besides each node is the number of states of the corresponding random variable. Let HL denote all the nodes Hij in L, and let VL denote
the rest of the nodes in L.
 Specify a (join) probability distribution p(HL , VL ) such that I(p(HL , VL )) = I(L).
 Let the instance of LEARN consist of the (marginal) probability distribution p(VL )
and the positive integer d, where d is computed from F and k as shown in the work
of Chickering et al. (2004, Equation 2).
We now describe how the instance of LEARN resulting from the reduction above can
be further reduced into an instance of CONSENSUS in polynomial time:
 Let C 1 denote the DAG over VL that has all and only the arcs in L whose both
endpoints are in VL .
666

fiFinding Consensus Bayesian Network Structures

 Let C 2 denote the DAG over VL that only has the arcs Bij  Cij  Fij for all i and
j.
 Let C 3 denote the DAG over VL that only has the arcs Cij  Fij  Eij for all i and
j.
 Let the instance of CONSENSUS consist of the DAGs C 1 , C 2 and C 3 , and the positive
integer d.
Theorem 2. CONSENSUS is NP-hard.
Proof. We start by proving that there is a polynomial reduction of any instance F of the
degree-bounded FEEDBACK ARC SET into an instance C of CONSENSUS. First, reduce
F into an instance L of LEARN as shown in the work of Chickering et al. (2004) and, then,
reduce L into C as shown above.
We now prove that there is a solution to F iff there is a solution to C. Chickering et
al. (2004, Thms. 8 and 9) prove that there is a solution to F iff there is a solution to L.
Therefore, it only remains to prove that there is a solution to L iff there is a solution to
C (note that the parameter d of L and the parameter d of C are the same). Let L and
p(HL , VL ) denote the DAG and the probability distribution constructed in the reduction
of F into L. Recall that I(p(HL , VL )) = I(L). Moreover:
 Let L1 denote the DAG over (HL , VL ) that has all and only the arcs in L whose both
endpoints are in VL .
 Let L2 denote the DAG over (HL , VL ) that only has the arcs Bij  Cij  Hij  Fij
for all i and j.
 Let L3 denote the DAG over (HL , VL ) that only has the arcs Cij  Hij  Fij  Eij
for all i and j.
Note that any separation statement that holds in L also holds in L1 , L2 and L3 . Then,
I(p(HL , VL )) = I(L)  3i=1 I(Li ) and, thus, I(p(VL ))  [3i=1 I(Li )]VL = 3i=1 [I(Li )]VL .
Let C 1 , C 2 and C 3 denote the DAGs constructed in the reduction of L into C. Note that
[I(Li )]VL = I(C i ) for all i. Then, I(p(VL ))  3i=1 I(C i ) and, thus, if there is a solution to
L then there is a solution to C. We now prove the opposite. The proof is essentially the
same as that in the work of Chickering et al. (2004, Thm. 9). Let us define the (Vi , Vj )
edge component of a DAG G over VL as the subgraph of G that has all and only the arcs
in G whose both endpoints are in {Vi , Aij , Bij , Cij , Dij , Eij , Fij , Gij , Vj }. Given a solution
C to C, we create another solution C 0 to C as follows:
 Initialize C 0 to C 1 .
 For every (Vi , Vj ) edge component of C, if there is no directed path in C from Vi to
Vj , then add to C 0 the arcs Eij  Cij  Fij .
 For every (Vi , Vj ) edge component of C, if there is a directed path in C from Vi to Vj ,
then add to C 0 the arcs Bij  Fij  Cij .
667

fiPena

Note that C 0 is acyclic because C is acyclic. Moreover, I(C 0 )  3i=1 I(C i ) because
I(C 0 )  I(C i ) for all i. In order to be able to conclude that C 0 is a solution to C, it only
remains to prove that the number of parameters associated with C 0 is not greater than
d. Specifically, we prove below that C 0 does not have more parameters associated than C,
which has less than d parameters associated because it is a solution to C.
As seen before, I(C 0 )  I(C 1 ). Likewise, I(C)  I(C 1 ) because C is a solution to C.
Thus, there exists a sequence S (resp. S 0 ) of covered arc reversals and arc additions that
transforms C 1 into C (resp. C 0 ) (Chickering, 2002, Thm. 4). Note that a covered arc
reversal does not modify the number of parameters associated with a DAG, whereas an arc
addition increases it (Chickering, 1995, Thm. 3). Thus, S and S 0 monotonically increase
the number of parameters associated with C 1 as they transform it. Recall that C 1 consists
of a series of edge components of the form

ViF(9)



Aij (9)

Bij (2)

Cij (3)

Dij (9)

Eij (2)

Fij (2)



Gij



VjF(9)

(9)

The number in parenthesis besides each node is the number of states of the corresponding
random variable. Let us study how the sequences S and S 0 modify each edge component
of C 1 . S 0 simply adds the arcs Bij  Fij  Cij or the arcs Eij  Cij  Fij . Note that
adding the first pair of arcs results in an increase of 10 parameters, whereas adding the
second pair of arcs results in an increase of 12 parameters. Unlike S 0 , S may reverse some
arc in the edge component. If that is the case, then S must cover the arc first, which implies
an increase of at least 16 parameters (covering Fij  Vj by adding Eij  Vj implies an
increase of exactly 16 parameters, whereas any other arc covering implies a larger increase).
Then, S implies a larger increase in the number of parameters than S 0 . On the other hand,
if S does not reverse any arc in the edge component, then S simply adds the arcs that are
in C but not in C 1 . Note that either Cij  Fij or Cij  Fij is in C, because otherwise
Cij  C Fij |Z for some Z  VL which contradicts the fact that C is a solution to C since
Cij 6 C 2 Fij |Z. If Cij  Fij is in C, then either Bij  Fij or Bij  Fij is in C because
otherwise Bij  C Fij |Z for some Z  VL such that Cij  Z, which contradicts the fact that
C is a solution to C since Bij 6 C 2 Fij |Z. As Bij  Fij would create a cycle in C, Bij  Fij
is in C. Therefore, S adds the arcs Bij  Fij  Cij and, by construction of C 0 , S 0 also
adds them. Thus, S implies an increase of at least as many parameters as S 0 . On the other
hand, if Cij  Fij is in C, then either Cij  Eij or Cij  Eij is in C because otherwise
Cij  C Eij |Z for some Z  VL such that Fij  Z, which contradicts the fact that C is a
solution to C since Cij 6 C 3 Eij |Z. As Cij  Eij would create a cycle in C, Cij  Eij is in
C. Therefore, S adds the arcs Eij  Cij  Fij and, by construction of C 0 , S 0 adds either
the arcs Eij  Cij  Fij or the arcs Bij  Fij  Cij . In any case, S implies an increase
of at least as many parameters as S 0 . Consequently, C 0 does not have more parameters
associated than C.
Finally, note that I(p(VL ))  I(C 0 ) by Chickering et al. (2004, Lemma 7). Thus, if
there is a solution to C then there is a solution to L.
668

fiFinding Consensus Bayesian Network Structures

It is worth noting that our proof above contains two restrictions. First, the number of
DAGs to consensuate is three. Second, the number of states of each random variable in
VL is not arbitrary but prescribed. The first restriction is easy to relax: Our proof can be
extended to consensuate more than three DAGs by simply letting C i be a DAG over VL
with no arcs for all i > 3. However, it is an open question whether CONSENSUS remains
NP-hard when the number of DAGs to consensuate is two and/or the number of states of
each random variable in VL is arbitrary.
The following theorem strengthens the previous one.
Theorem 3. CONSENSUS is NP-complete.
Proof. By Theorem 2, all that remains to prove is that CONSENSUS is in NP, i.e. that
we can verify in polynomial time if a given DAG G is a solution to a given instance of
CONSENSUS.
Let  denote any node ordering that is consistent with G. The causal list of G relative
to  is the set of separation statements A  G P re (A) \ P aG (A)|P aG (A) for all node A.
It is known that I(G) coincides with the closure with respect to the graphoid properties of
i
the causal list of G relative to  (Pearl, 1988, Corollary 7). Therefore, I(G)  m
i=1 I(G ) iff
i
A  Gi P re (A) \ P aG (A)|P aG (A) for all 1  i  m, because m
i=1 I(G ) is a graphoid (del
Sagrado & Moral, 2003, Corollary 1). Let n, a and ai denote, respectively, the number of
nodes in G, the number of arcs in G, and the number of arcs in Gi . Let b = max1im ai .
Checking a separation statement in Gi takes O(ai ) time (Geiger et al., 1990, p. 530). Then,
i
checking whether I(G)  m
i=1 I(G ) takes O(mnb) time. Finally, note that computing the
number of parameters associated with G takes O(a).

4. Finding an Approximated Consensus DAG
Since finding a consensus DAG of some given DAGs is NP-hard, we decide to resort to
heuristics to find an approximated consensus DAG. This does not mean that we discard
the existence of fast super-polynomial algorithms. It simply means that we do not pursue
that possibility in this paper. Specifically, in this paper we consider the following heuristic
due to Matzkevich and Abramson (1992, 1993b). See also the work of Matzkevich and
Abramson (1993a) for related information. First, let  denote any ordering of the nodes
in the given DAGs, which we denote here as G1 , . . . , Gm . Then, find the MDI map Gi of
each Gi relative to . Finally, let the approximated consensus DAG be the DAG whose
arcs are exactly the union of the arcs in G1 , . . . , Gm
 . The following theorem justifies taking
the union of the arcs. Specifically, it proves that the DAG returned by the heuristic is the
consensus DAG if this was required to be consistent with .
Theorem 4. The DAG H returned by the heuristic above is the DAG that has the fewest
i
parameters associated among all the MDI maps of m
i=1 I(G ) relative to .
i
Proof. We start by proving that H is a MDI map of m
i=1 I(G ). First, we show that
i
m
i
i
I(H)  m
i=1 I(G ). It suffices to note that I(H)  i=1 I(G ) because each G is a subm
i
m
i
i
i
graph of H, and that i=1 I(G )  i=1 I(G ) because I(G )  I(G ) for all i. Now,

669

fiPena

assume to the contrary that the DAG H 0 resulting from removing an arc A  B from H
i
i
satisfies that I(H 0 )  m
i=1 I(G ). By construction of H, A  B is in G for some i, say
i = j. Note that B  H 0 P re (B) \ P aH 0 (B)|P aH 0 (B), which implies B  Gj P re (B) \
m
m
((m
i=1 P aGi (B)) \ {A})|(i=1 P aGi (B)) \ {A} because P aH 0 (B) = (i=1 P aGi (B)) \ {A}
i
and I(H 0 )  m
i=1 I(G ). Note also that B  Gj P re (B) \ P aGj (B)|P aGj (B), which implies B  Gj P re (B) \ P aGj (B)|P aGj (B) because I(Gj )  I(Gj ). Therefore, B  Gj


P re (B) \ (P aGj (B) \ {A})|P aGj (B) \ {A} by intersection. However, this contradicts the


i
fact that Gj is the MDI map of Gj relative to . Then, H is a MDI map of m
i=1 I(G )
relative to .
i
Finally, note that m
i=1 I(G ) is a graphoid (del Sagrado & Moral, 2003, Corollary 1).
i
Consequently, H is the only MDI map of m
i=1 I(G ) relative to .

A key step in the heuristic above is, of course, choosing a good node ordering . Unfortunately, the fact that CONSENSUS is NP-hard implies that it is also NP-hard to find the
best node ordering , i.e. the node ordering that makes the heuristic to return the MDI
i
map of m
i=1 I(G ) that has the fewest parameters associated. To see it, note that if there
existed an efficient algorithm for finding the best node ordering, then Theorem 4 would
imply that we could solve CONSENSUS efficiently by running the heuristic with the best
node ordering.
In the last sentence, we have implicitly assumed that the heuristic is efficient, which
implies that we have implicitly assumed that we can efficiently find the MDI map Gi of
each Gi . The rest of this paper shows that this assumption is correct.

5. Methods A and B are not Correct
Matzkevich and Abramson (1993b) do not only propose the heuristic discussed in the previous section, but they also present two algorithms, called Methods A and B, for efficiently
deriving the MDI map G of a DAG G relative to a node ordering . The algorithms work
iteratively by covering and reversing an arc in G until the resulting DAG is consistent with
. It is obvious that such a way of working produces a directed independence map of G.
However, in order to arrive at G , the arc to cover and reverse in each iteration must be
carefully chosen. The pseudocode of Methods A and B can be seen in Figure 1. Method
A starts by calling Construct  to derive a node ordering  that is consistent with G and
as close to  as possible (line 6). By  being as close to  as possible, we mean that the
number of arcs Methods A and B will later cover and reverse is kept at a minimum, because
Methods A and B will use  to choose the arc to cover and reverse in each iteration. In
particular, Method A finds the leftmost node in  that should be interchanged with its left
neighbor (line 2) and it repeatedly interchanges this node with its left neighbor (lines 3-4
and 6-7). Each of these interchanges is preceded by covering and reversing the corresponding arc in G (line 5). Method B is essentially identical to Method A. The only differences
between them are that the word right is replaced by the word left and vice versa in
lines 2-4, and that the arcs point in opposite directions in line 5. Note that Methods A and
B do not reverse an arc more than once.
670

fiFinding Consensus Bayesian Network Structures

Construct (G, )
/* Given a DAG G and a node ordering , the algorithm returns a node ordering  that
is consistent with G and as close to  as possible */
1
2
3
/* 3
4
5
6
7
8
9
10
11

=
G0 = G
Let A denote a sink node in G0
Let A denote the rightmost node in  that is a sink node in G0 */
Add A as the leftmost node in 
Let B denote the right neighbor of A in 
If B 6=  and A 
/ P aG (B) and A is to the right of B in  then
Interchange A and B in 
Go to line 5
Remove A and all its incoming arcs from G0
If G0 6=  then go to line 3
Return 
Method A(G, )
/* Given a DAG G and a node ordering , the algorithm returns G */

1
2
3
4
5
6
7
8
9

=Construct (G, )
Let Y denote the leftmost node in  whose left neighbor in  is to its right in 
Let Z denote the left neighbor of Y in 
If Z is to the right of Y in  then
If Z  Y is in G then cover and reverse Z  Y in G
Interchange Y and Z in 
Go to line 3
If  6=  then go to line 2
Return G
Method B(G, )
/* Given a DAG G and a node ordering , the algorithm returns G */

1
2
3
4
5
6
7
8
9

=Construct (G, )
Let Y denote the leftmost node in  whose right neighbor in  is to its left in 
Let Z denote the right neighbor of Y in 
If Z is to the left of Y in  then
If Y  Z is in G then cover and reverse Y  Z in G
Interchange Y and Z in 
Go to line 3
If  6=  then go to line 2
Return G

Figure 1: Construct , and Methods A and B. Our correction of Construct  consists in (i)
replacing line 3 with the line in comments under it, and (ii) removing lines 5-8.
671

fiPena

Figure 2: A counterexample to the correctness of Methods A and B.
Methods A and B are claimed to be correct in the work of Matzkevich and Abramson
(1993b, Thm. 4 and Corollary 2) although no proof is provided (a proof is just sketched).
The following counterexample shows that Methods A and B are actually not correct. Let G
be the DAG in the left-hand side of Figure 2. Let  = (M, I, K, J, L). Then, we can make
use of the characterization introduced in Section 2 to see that G is the DAG in the center
of Figure 2. However, Methods A and B return the DAG in the right-hand side of Figure
2. To see it, we follow the execution of Methods A and B step by step. First, Methods A
and B construct  by calling Construct , which runs as follows:
1. Initially,  =  and G0 = G.
2. Select the sink node M in G0 . Then,  = (M ). Remove M and its incoming arcs from
G0 .
3. Select the sink node L in G0 . Then,  = (L, M ). No interchange in  is performed
because L  P aG (M ). Remove L and its incoming arcs from G0 .
4. Select the sink node K in G0 . Then,  = (K, L, M ). No interchange in  is performed
because K is to the left of L in . Remove K and its incoming arcs from G0 .
5. Select the sink node J in G0 . Then,  = (J, K, L, M ). No interchange in  is performed
because J  P aG (K).
6. Select the sink node I in G0 . Then,  = (I, J, K, L, M ). No interchange in  is
performed because I is to the left of J in .
When Construct  ends, Methods A and B continue as follows:
672

fiFinding Consensus Bayesian Network Structures

7. Initially,  = (I, J, K, L, M ).
8. Add the arc I  J and reverse the arc J  K in G. Interchange J and K in .
Then,  = (I, K, J, L, M ).
9. Add the arc J  M and reverse the arc L  M in G. Interchange L and M in .
Then,  = (I, K, J, M, L).
10. Add the arcs I  M and K  M , and reverse the arc J  M in G. Interchange J
and M in . Then,  = (I, K, M, J, L).
11. Reverse the arc K  M in G. Interchange K and M in . Then,  = (I, M, K, J, L).
12. Reverse the arc I  M in G. Interchange I and M in . Then,  = (M, I, K, J, L) =
.
As a matter of fact, one can see as early as in step 8 above that Methods A and B will
fail: One can see that I and M are not separated in the DAG resulting from step 8, which
implies that I and M will not be separated in the DAG returned by Methods A and B,
because covering and reversing arcs never introduces new separation statements. However,
I and M are separated in G .
Note that we constructed  by selecting first M , then L, then K, then J, and finally I.
However, we could have selected first K, then I, then M , then L, and finally J, which would
have resulted in  = (J, L, M, I, K). With this , Methods A and B return G . Therefore, it
makes a difference which sink node is selected in line 3 of Construct . However, Construct
 overlooks this detail. We propose correcting Construct  by (i) replacing line 3 by Let A
denote the rightmost node in  that is a sink node in G0 , and (ii) removing lines 5-8 since
they will never be executed. Hereinafter, we assume that any call to Construct  is a call
to the corrected version thereof. The rest of this paper is devoted to prove that Methods A
and B now do return G .

6. The Corrected Methods A and B are Correct
Before proving that Methods A and B are correct, we introduce some auxiliary lemmas.
Their proof can be found in Appendix A. Let us call percolating Y right-to-left in  to
iterating through lines 3-7 in Method A while possible. Let us modify Method A by replacing
line 2 by Let Y denote the leftmost node in  that has not been considered before and
by adding the check Z 6=  to line 4. The pseudocode of the resulting algorithm, which we
call Method A2, can be seen in Figure 3. Method A2 percolates right-to-left in  one by
one all the nodes in the order in which they appear in .
Lemma 1. Method A(G, ) and Method A2(G, ) return the same DAG.
Lemma 2. Method A2(G, ) and Method B(G, ) return the same DAG.
Let us call percolating Y left-to-right in  to iterating through lines 3-7 in Method B
while possible. Let us modify Method B by replacing line 2 by Let Y denote the rightmost
node in  that has not been considered before and by adding the check Z 6=  to line 4.
The pseudocode of the resulting algorithm, which we call Method B2, can be seen in Figure
673

fiPena

Method A2(G, )
/* Given a DAG G and a node ordering , the algorithm returns G */
1
2
3
4
5
6
7
8
9

=Construct (G, )
Let Y denote the leftmost node in  that has not been considered before
Let Z denote the left neighbor of Y in 
If Z 6=  and Z is to the right of Y in  then
If Z  Y is in G then cover and reverse Z  Y in G
Interchange Y and Z in 
Go to line 3
If  6=  then go to line 2
Return G
Method B2(G, )
/* Given a DAG G and a node ordering , the algorithm returns G */

1
2
3
4
5
6
7
8
9

=Construct (G, )
Let Y denote the rightmost node in  that has not been considered before
Let Z denote the right neighbor of Y in 
If Z 6=  and Z is to the left of Y in  then
If Y  Z is in G then cover and reverse Y  Z in G
Interchange Y and Z in 
Go to line 3
If  6=  then go to line 2
Return G

Figure 3: Methods A2 and B2.
3. Method B2 percolates left-to-right in  one by one all the nodes in the reverse order in
which they appear in .
Lemma 3. Method B(G, ) and Method B2(G, ) return the same DAG.
We are now ready to prove the main result of this paper.
Theorem 5. Let G denote the MDI map of a DAG G relative to a node ordering . Then,
Method A(G, ) and Method B(G, ) return G .
Proof. By Lemmas 1-3, it suffices to prove that Method B2(G, ) returns G . It is evident
that Method B2 transforms  into  and, thus, that it halts at some point. Therefore,
Method B2 performs a finite sequence of n modifications (arc additions and covered arc
reversals) to G. Let Gi denote the DAG resulting from the first i modifications to G, and
let G0 = G. Specifically, Method B2 constructs Gi+1 from Gi by either (i) reversing the
covered arc Y  Z, or (ii) adding the arc X  Z for some X  P aGi (Y ) \ P aGi (Z), or
(iii) adding the arc X  Y for some X  P aGi (Z) \ P aGi (Y ). Note that I(Gi+1 )  I(Gi )
for all 0  i < n and, thus, that I(Gn )  I(G0 ).
674

fiFinding Consensus Bayesian Network Structures

We start by proving that Gi is a DAG that is consistent with  for all 0  i  n. Since
this is true for G0 due to line 1, it suffices to prove that if Gi is a DAG that is consistent
with  then so is Gi+1 for all 0  i < n. We consider the following four cases.
Case 1 Method B2 constructs Gi+1 from Gi by reversing the covered arc Y  Z. Then,
Gi+1 is a DAG because reversing a covered arc does not create any cycle (Chickering,
1995, Lemma 1). Moreover, note that Y and Z are interchanged in  immediately
after the covered arc reversal. Thus, Gi+1 is consistent with .
Case 2 Method B2 constructs Gi+1 from Gi by adding the arc X  Z for some X 
P aGi (Y ) \ P aGi (Z). Note that X is to the left of Y and Y to the left of Z in ,
because Gi is consistent with . Then, X is to the left of Z in  and, thus, Gi+1 is a
DAG that is consistent with .
Case 3 Method B2 constructs Gi+1 from Gi by adding the arc X  Y for some X 
P aGi (Z) \ P aGi (Y ). Note that X is to the left of Z in  because Gi is consistent with
, and Y is the left neighbor of Z in  (recall line 3). Then, X is to the left of Y in
 and, thus, Gi+1 is a DAG that is consistent with .
Case 4 Note that  may get modified before Method B2 constructs Gi+1 from Gi . Specifically, this happens when Method B2 executes lines 5-6 but there is no arc between
Y and Z in Gi . However, the fact that Gi is consistent with  before Y and Z are
interchanged in  and the fact that Y and Z are neighbors in  (recall line 3) imply
that Gi is consistent with  after Y and Z have been interchanged.
Since Method B2 transforms  into , it follows from the result proven above that Gn
is a DAG that is consistent with . In order to prove the theorem, i.e. that Gn = G , all
that remains to prove is that I(G )  I(Gn ). To see it, note that Gn = G follows from
I(G )  I(Gn ), I(Gn )  I(G0 ), the fact that Gn is a DAG that is consistent with , and
the fact that G is the unique MDI map of G0 relative to . Recall that G is guaranteed
to be unique because I(G0 ) is a graphoid.
The rest of the proof is devoted to prove that I(G )  I(Gn ). Specifically, we prove
that if I(G )  I(Gi ) then I(G )  I(Gi+1 ) for all 0  i < n. Note that this implies
that I(G )  I(Gn ) because I(G )  I(G0 ) by definition of MDI map. First, we prove it
when Method B2 constructs Gi+1 from Gi by reversing the covered arc Y  Z. That the
arc reversed is covered implies that I(Gi+1 ) = I(Gi ) (Chickering, 1995, Lemma 1). Thus,
I(G )  I(Gi+1 ) because I(G )  I(Gi ).
Now, we prove that if I(G )  I(Gi ) then I(G )  I(Gi+1 ) for all 0  i < n when
Method B2 constructs Gi+1 from Gi by adding an arc. Specifically, we prove that if there
is an S-active route (S  V) AB
i+1 between two nodes A and B in Gi+1 , then there is an
S-active route between A and B in G . We prove this result by induction on the number of
occurrences of the added arc in AB
i+1 . We assume without loss of generality that the added
AB
arc occurs in i+1 as few or fewer times than in any other S-active route between A and B
2
in Gi+1 . We call this the minimality property of AB
i+1 . If the number of occurrences of the
2. It is not difficult to show that the number of occurrences of the added arc in AB
i+1 is then at most two
(see Case 2.1 for some intuition). However, the proof of the theorem is simpler if we ignore this fact.

675

fiPena

Figure 4: Different cases in the proof of Theorem 5. Only the relevant subgraphs of Gi+1 and
G are depicted. An undirected edge between two nodes denotes that the nodes
are adjacent. A curved edge between two nodes denotes an S-active route between
the two nodes. If the curved edge is directed, then the route is descending. A
grey node denotes a node that is in S.

AB
added arc in AB
i+1 is zero, then i+1 is an S-active route between A and B in Gi too and,
thus, there is an S-active route between A and B in G since I(G )  I(Gi ). Assume as
induction hypothesis that the result holds for up to k occurrences of the added arc in AB
i+1 .
We now prove it for k + 1 occurrences. We consider the following two cases. Each case is
illustrated in Figure 4.

Case 1 Method B2 constructs Gi+1 from Gi by adding the arc X  Z for some X 
3
AB
AX
ZB
P aGi (Y )\P aGi (Z). Note that X  Z occurs in AB
i+1 . Let i+1 = i+1 X  Zi+1 .
AX
AB
Note that X 
/ S and i+1 is S-active in Gi+1 because, otherwise, i+1 would not be
3. Note that maybe A = X and/or B = Z.

676

fiFinding Consensus Bayesian Network Structures

S-active in Gi+1 . Then, there is an S-active route AX
between A and X in G by the

ZB
induction hypothesis. Moreover, Y  S because, otherwise, AX
i+1  X  Y  Z  i+1
would be an S-active route between A and B in Gi+1 that would violate the minimality
property of AB
i+1 . Note that Y  Z is in G because (i) Y and Z are adjacent in
G since I(G )  I(Gi ), and (ii) Z is to the left of Y in  (recall line 4). Note
also that X  Y is in G . To see it, note that X and Y are adjacent in G since
I(G )  I(Gi ). Recall that Method B2 percolates left-to-right in  one by one all
the nodes in the reverse order in which they appear in . Method B2 is currently
percolating Y and, thus, the nodes to the right of Y in  are to the right of Y in 
too. If X  Y were in G then X would be to the right of Y in  and, thus, X would
be to the right of Y in . However, this would contradict the fact that X is to the
left of Y in , which follows from the fact that Gi is consistent with . Thus, X  Y
is in G . We now consider two cases.
Case 1.1 Assume that Z 
/ S. Then, ZB
i+1 is S-active in Gi+1 because, otherwise,
AB
i+1 would not be S-active in Gi+1 . Then, there is an S-active route ZB
 between
Z and B in G by the induction hypothesis. Then, AX

X

Y

Z  ZB

 is
an S-active route between A and B in G .
WB 4
Case 1.2 Assume that Z  S. Then, ZB
/ S and
i+1 = Z  W  i+1 . Note that W 
W
B
AB
i+1 is S-active in Gi+1 because, otherwise, i+1 would not be S-active in Gi+1 .
B between W and B in G by the induction
Then, there is an S-active route W


hypothesis. Note that W and Z are adjacent in G since I(G )  I(Gi ). This
and the fact proven above that Y  Z is in G imply that Y and W are adjacent
in G because, otherwise, Y 6 Gi W |U but Y  G W |U for some U  V such
that Z  U, which would contradict that I(G )  I(Gi ). In fact, Y  W is in
G . To see it, recall that the nodes to the right of Y in  are to the right of Y in
 too. If Y  W were in G then W would be to the right of Y in  and, thus,
W would be to the right of Y in  too. However, this would contradict the fact
that W is to the left of Y in , which follows from the fact that W is to the left of
Z in  because Gi is consistent with , and the fact that Y is the left neighbor of
WB
Z in  (recall line 3). Thus, Y  W is in G . Then, AX
  X  Y  W  
is an S-active route between A and B in G .

Case 2 Method B2 constructs Gi+1 from Gi by adding the arc X  Y for some X 
5
AB
AX
YB
P aGi (Z)\P aGi (Y ). Note that X  Y occurs in AB
i+1 . Let i+1 = i+1 X  Y i+1 .
AX
AB
Note that X 
/ S and i+1 is S-active in Gi+1 because, otherwise, i+1 would not be
S-active in Gi+1 . Then, there is an S-active route AX
between A and X in G by the

induction hypothesis. Note that Y  Z is in G because (i) Y and Z are adjacent in
G since I(G )  I(Gi ), and (ii) Z is to the left of Y in  (recall line 4). Note also
that X and Z are adjacent in G since I(G )  I(Gi ). This and the fact that Y  Z
is in G imply that X and Y are adjacent in G because, otherwise, X 6 Gi Y |U
but X  G Y |U for some U  V such that Z  U, which would contradict that
WB
4. Note that maybe W = B. Note also that W 6= X because, otherwise, AX
i+1  X  Y  X  i+1 would
be an S-active route between A and B in Gi+1 that would violate the minimality property of AB
i+1 .
5. Note that maybe A = X and/or B = Y .

677

fiPena

I(G )  I(Gi ). In fact, X  Y is in G . To see it, recall that Method B2 percolates
left-to-right in  one by one all the nodes in the reverse order in which they appear
in . Method B2 is currently percolating Y and, thus, the nodes to the right of Y
in  are to the right of Y in  too. If X  Y were in G then X would be to the
right of Y in  and, thus, X would be to the right of Y in  too. However, this would
contradict the fact that X is to the left of Y in , which follows from the fact that
X is to the left of Z in  because Gi is consistent with , and the fact that Y is the
left neighbor of Z in  (recall line 3). Thus, X  Y is in G . We now consider three
cases.
B = Y  X  XB . Note that XB is S-active
Case 2.1 Assume that Y  S and Yi+1
i+1
i+1
AB
in Gi+1 because, otherwise, i+1 would not be S-active in Gi+1 . Then, there
is an S-active route XB
between X and B in G by the induction hypothesis.

AX
Then,   X  Y  X  XB
is an S-active route between A and B in G .

B = Y  W  W B .6 Note that W 
Case 2.2 Assume that Y  S and Yi+1
/ S and
i+1
W
B
i+1 is S-active in Gi+1 because, otherwise, AB
would
not
be
S-active
in Gi+1 .
i+1
B between W and B in G by the induction
Then, there is an S-active route W


hypothesis. Note also that Y  W is in G . To see it, note that Y and W
are adjacent in G since I(G )  I(Gi ). Recall that the nodes to the right of
Y in  are to the right of Y in  too. If Y  W were in G then W would
be to the right of Y in  and, thus, W would be to the right of Y in  too.
However, this would contradict the fact that W is to the left of Y in , which
follows from the fact that Gi is consistent with . Thus, Y  W is in G . Then,
W B is an S-active route between A and B in G .
AX

  X  Y  W  

Case 2.3 Assume that Y 
/ S. The proof of this case is based on that of step 8 in the
work of Chickering (2002, Lemma 30). Let D denote the node that is maximal
in G from the set of descendants of Y in Gi . Note that D is guaranteed to be
unique by Chickering (2002, Lemma 29), because I(G )  I(Gi ). Note also that
D 6= Y , because Z is a descendant of Y in Gi and, as shown above, Y  Z is in
G . We now show that D is a descendant of Z in Gi . We consider three cases.
Case 2.3.1 Assume that D = Z. Then, D is a descendant of Z in Gi .
Case 2.3.2 Assume that D 6= Z and D was a descendant of Z in G0 . Recall
that Method B2 percolates left-to-right in  one by one all the nodes in the
reverse order in which they appear in . Method B2 is currently percolating
Y and, thus, it has not yet percolated Z because Z is to the left of Y in 
(recall line 4). Therefore, none of the descendants of Z in G0 (among which
is D) is to the left of Z in . This and the fact that  is consistent with Gi
imply that Z is a node that is maximal in Gi from the set of descendants of
Z in G0 . Actually, Z is the only such node by Chickering (2002, Lemma 29),
because I(Gi )  I(G0 ). Then, the descendants of Z in G0 are descendants
of Z in Gi too. Thus, D is a descendant of Z in Gi .
6. Note that maybe W = B. Note also that W 6= X, because the case where W = X is covered by Case
2.1.

678

fiFinding Consensus Bayesian Network Structures

Case 2.3.3 Assume that D 6= Z and D was not a descendant of Z in G0 . As
shown in Case 2.3.2, the descendants of Z in G0 are descendants of Z in
Gi too. Therefore, none of the descendants of Z in G0 was to the left of D
in  because, otherwise, some descendant of Z and thus of Y in Gi would
be to the left of D in , which would contradict the definition of D. This
and the fact that D was not a descendant of Z in G0 imply that D was still
in G0 when Z became a sink node of G0 in Construct  (recall Figure 1).
Therefore, Construct  added D to  after having added Z (recall lines 3-4),
because D is to the left of Z in  by definition of D.7 For the same reason,
Method B2 has not interchanged D and Z in  (recall line 4). Thus, D is
currently still to the left of Z in , which implies that D is to the left of Y
in , because Y is the left neighbor of Z in  (recall line 3). However, this
contradicts the fact that Gi is consistent with , because D is a descendant
of Y in Gi . Thus, this case never occurs.
B is
We continue with the proof of Case 2.3. Note that Y 
/ S implies that Yi+1
S-active in Gi+1 because, otherwise, AB
i+1 would not be S-active in Gi+1 . Note
also that no descendant of Z in Gi is in S because, otherwise, there would be
XY  Y B
an S-active route XY
between X and Y in Gi and, thus, AX
i
i+1  i
i+1
would be an S-active route between A and B in Gi+1 that would violate the
minimality property of AB
/ S because, as shown above,
i+1 . This implies that D 
D is a descendant of Z in Gi . It also implies that there is an S-active descending
ZD is an S-active route
route ZD
from Z to D in Gi . Then, AX
i
i+1  X  Z  i
ZD is an S-active route
between A and D in Gi+1 . Likewise, BY
i+1  Y  Z  i
BY
between B and D in Gi+1 , where i+1 denotes the route resulting from reversing
B . Therefore, there are S-active routes AD and BD between A and D and
Yi+1


between B and D in G by the induction hypothesis.
Consider the subroute of AB
i+1 that starts with the arc X  Y and continues in
the direction of this arc until it reaches a node E such that E = B or E  S.
Note that E is a descendant of Y in Gi and, thus, E is a descendant of D in G
by definition of D. Let DE
denote the descending route from D to E in G .

Assume without loss of generality that G has no descending route from D to
B or to a node in S that is shorter than DE
 . This implies that if E = B then
DE
DE is an
 is S-active in G because, as shown above, D 
/ S. Thus, AD
  
S-active route between A and B in G . On the other hand, if E  S then E 6= D
DE  ED  DB is an S-active route between
because D 
/ S. Thus, AD
  


ED
A and B in G , where  and DB
denote
the
routes resulting from reversing

BD .
DE
and




Finally, we show how the correctness of Method B2 leads to an alternative proof of the
so-called Meeks conjecture (1997). Given two DAGs G and H such that I(H)  I(G),
Meeks conjecture states that we can transform G into H by a sequence of arc additions
and covered arc reversals such that after each operation in the sequence G is a DAG and
7. Note that this statement is true thanks to our correction of Construct .

679

fiPena

Method G2H(G, H)
/* Given two DAGs G and H such that I(H)  I(G), the algorithm transforms
G into H by a sequence of arc additions and covered arc reversals such that
after each operation in the sequence G is a DAG and I(H)  I(G) */
1
2
3

Let  denote a node ordering that is consistent with H
G=Method B2(G, )
Add to G the arcs that are in H but not in G

Figure 5: Method G2H.
I(H)  I(G). The importance of Meeks conjecture lies in that it allows to develop efficient
and asymptotically correct algorithms for learning BNs from data under mild assumptions
(Chickering, 2002; Chickering & Meek, 2002; Meek, 1997; Nielsen et al., 2003). Meeks
conjecture was proven to be true in the work of Chickering (2002, Thm. 4) by developing
an algorithm that constructs a valid sequence of arc additions and covered arc reversals.
We propose an alternative algorithm to construct such a sequence. The pseudocode of our
algorithm, called Method G2H, can be seen in Figure 5. The following corollary proves that
Method G2H is correct.
Corollary 1. Given two DAGs G and H such that I(H)  I(G), Method G2H(G, H)
transforms G into H by a sequence of arc additions and covered arc reversals such that
after each operation in the sequence G is a DAG and I(H)  I(G).
Proof. Note from Method G2Hs line 1 that  denotes a node ordering that is consistent
with H. Let G denote the MDI map of G relative to . Recall that G is guaranteed to be
unique because I(G) is a graphoid. Note that I(H)  I(G) implies that G is a subgraph
of H. To see it, note that I(H)  I(G) implies that we can obtain a MDI map of G relative
to  by just removing arcs from H. However, G is the only MDI map of G relative to .
Then, it follows from the proof of Theorem 5 that Method G2Hs line 2 transforms
G into G by a sequence of arc additions and covered arc reversals, and that after each
operation in the sequence G is a DAG and I(G )  I(G). Thus, after each operation in
the sequence I(H)  I(G) because I(H)  I(G ) since, as shown above, G is a subgraph
of H. Moreover, Method G2Hs line 3 transforms G from G to H by a sequence of arc
additions. Of course, after each arc addition G is a DAG and I(H)  I(G) because G is
a subgraph of H.

7. The Corrected Methods A and B are Efficient
In this section, we show that Methods A and B are more efficient than any other solution
to the same problem we can think of. Let n and a denote, respectively, the number of
nodes and arcs in G. Moreover, let us assume hereinafter that a DAG is implemented as an
680

fiFinding Consensus Bayesian Network Structures

adjacency matrix, whereas a node ordering is implemented as an array with an entry per
node indicating the position of the node in the ordering. Since I(G) is a graphoid, the first
solution we can think of consists in applying the following characterization of G : For each
node A, P aG (A) is the smallest subset X  P re (A) such that A  G P re (A) \ X|X. This
solution implies evaluating for each node A all the O(2n ) subsets of P re (A). Evaluating a
subset implies checking a separation statement in G, which takes O(a) time (Geiger et al.,
1990, p. 530). Therefore, the overall runtime of this solution is O(an2n ).
Since I(G) satisfies the composition property in addition to the graphoid properties,
a more efficient solution consists in running the incremental association Markov boundary
(IAMB) algorithm (Pena et al., 2007, Thm. 8) for each node A to find P aG (A). The IAMB
algorithm first sets P aG (A) =  and, then, proceeds with the following two steps. The
first step consists in iterating through the following line until P aG (A) does not change:
Take any node B  P re (A) \ P aG (A) such that A 6 G B|P aG (A) and add it to P aG (A).
The second step consists in iterating through the following line until P aG (A) does not
change: Take any node B  P aG (A) that has not been considered before and such that
A  G B|P aG (A)\{B}, and remove it from P aG (A). The first step of the IAMB algorithm
can add O(n) nodes to P aG (A). Each addition implies evaluating O(n) candidates for
the addition, since P re (A) has O(n) nodes. Evaluating a candidate implies checking a
separation statement in G, which takes O(a) time (Geiger et al., 1990, p. 530). Then, the
first step of the IAMB algorithm runs in O(an2 ) time. Similarly, the second step of the
IAMB algorithm runs in O(an) time. Therefore, the IAMB algorithm runs in O(an2 ) time.
Since the IAMB algorithm has to be run once for each of the n nodes, the overall runtime
of this solution is O(an3 ).
We now analyze the efficiency of Methods A and B. To be more exact, we analyze
Methods A2 and B2 (recall Figure 3) rather than the original Methods A and B (recall
Figure 1), because the former are more efficient than the latter. Methods A2 and B2 run
in O(n3 ) time. First, note that Construct  runs in O(n3 ) time. The algorithm iterates n
times through lines 3-10 and, in each of these iterations, it iterates O(n) times through lines
5-8. Moreover, line 3 takes O(n2 ) time, line 6 takes O(1) time, and line 9 takes O(n) time.
Now, note that Methods A2 and B2 iterate n times through lines 2-8 and, in each of these
iterations, they iterate O(n) times through lines 3-7. Moreover, line 4 takes O(1) time,
and line 5 takes O(n) time because covering an arc implies updating the adjacency matrix
accordingly. Consequently, Methods A and B are more efficient than any other solution to
the same problem we can think of.
Finally, we analyze the complexity of Method G2H. Method G2H runs in O(n3 ) time:
 can be constructed in O(n3 ) time by calling Construct (H, ) where  is any node
ordering, running Method B2 takes O(n3 ) time, and adding to G the arcs that are in H
but not in G can be done in O(n2 ) time. Recall that Method G2H is an alternative to
the algorithm in the work of Chickering (2002). Unfortunately, no implementation details
are provided in the work of Chickering and, thus, a comparison with the runtime of the
algorithm there is not possible. However, we believe that our algorithm is more efficient.
681

fiPena

8. Discussion
In this paper, we have studied the problem of combining several given DAGs into a consensus
DAG that only represents independences all the given DAGs agree upon and that has as few
parameters associated as possible. Although our definition of consensus DAG is reasonable,
we would like to leave out the number of parameters associated and focus solely on the
independencies represented by the consensus DAG. In other words, we would like to define
the consensus DAG as the DAG that only represents independences all the given DAGs
agree upon and as many of them as possible. We are currently investigating whether both
definitions are equivalent. In this paper, we have proven that there may exist several nonequivalent consensus DAGs. In principle, any of them is equally good. If we were able
to conclude that one represents more independencies than the rest, then we would prefer
that one. In this paper, we have proven that finding a consensus DAG is NP-hard. This
made us resort to heuristics to find an approximated consensus DAG. This does not mean
that we discard the existence of fast super-polynomial algorithms for the general case, or
polynomial algorithms for constrained cases such as when the given DAGs have bounded
in-degree. This is a question that we are currently investigating. In this paper, we have
considered the heuristic originally proposed by Matzkevich and Abramson (1992, 1993b).
This heuristic takes as input a node ordering, and we have shown that finding the best
node ordering for the heuristic is NP-hard. We are currently investigating the application
of meta-heuristics in the space of node orderings to find a good node ordering for the
heuristic. Our preliminary experiments indicate that this approach is highly beneficial, and
that the best node ordering almost never coincides with any of the node orderings that are
consistent with some of the given DAGs.
As said in Section 1, we aim at combining the BNs provided by multiple experts (or
learning algorithms) into a single consensus BN that is more robust than the individual
BNs. In this paper, we have proposed to combine the experts BNs in two steps to avoid
the problems discussed by Pennock and Wellman (1999). First, finding a consensus BN
structure and, then, finding some consensus parameters for the consensus BN structure.
This paper has focused only on the first step. We are currently working on the second
step along the following lines. Let (G1 , 1 ), . . . , (Gm , m ) denote the BNs provided by the
experts. The first element in each pair denotes the BN structure whereas the second denotes
the BN parameters. Let p1 , . . . , pm denote the probability distributions represented by the
BNs provided by the experts. Then, we call p0 = f (p1 , . . . , pm ) the consensus probability
distribution, where f is any combination function, e.g. the weighted arithmetic or geometric
mean. Let G denote a consensus BN structure obtained from G1 , . . . , Gm as described
in this paper. We propose to obtain a consensus BN by parameterizing G such that
p (A|P aG (A)) = p0 (A|P aG (A)) for all A  V, where p is the probability distribution
represented by the consensus BN. The motivation is that such a parameterization minimizes
the Kullback-Leibler divergence between p and p0 (Koller & Friedman, 2009, Thm. 8.7).
Some hints about how to speed up the computation of this parameterization by performing
inference in the experts BNs can be found in the work of Pennock and Wellman (1999,
Properties 3 and 4, and Section 5). Alternatively, one could first sample p0 and, then,
parameterize G such that p (A|P aG (A)) = p0 (A|P aG (A)) for all A  V, where p0 is
the empirical probability distribution obtained from the sample. Again, the motivation is
682

fiFinding Consensus Bayesian Network Structures

that such a parameterization minimizes the Kullback-Leibler divergence between p and p0
(Koller & Friedman, 2009, Thm. 17.1) and, of course, p0  p0 if the sample is sufficiently
large. Note that we use p0 to parameterize G but not to construct G which, as discussed
in Section 1, allows us to avoid the problems discussed by Pennock and Wellman (1999).
Finally, note that the present work combines the DAGs G1 , . . . , Gm although there is
no guarantee that each Gi is a MDI map of I(pi ), i.e. Gi may have superfluous arcs.
Therefore, one may want to check if Gi contains superfluous arcs and remove them before
the combination takes place. In general, several MDI maps of I(pi ) may exist, and they
may differ in the number of parameters associated with them. It would be interesting to
study how the number of parameters associated with the MDI map of I(pi ) chosen affects
the number of parameters associated with the consensus DAG obtained by the method
proposed in this paper.

Acknowledgments
We thank the anonymous referees and the editor for their thorough review of this manuscript.
We thank Dr. Jens D. Nielsen and Dag Sonntag for proof-reading this manuscript. This
work is funded by the Center for Industrial Information Technology (CENIIT) and a socalled career contract at Linkoping University.

Appendix A. Proofs of Lemmas 1-3
Lemma 1. Method A(G, ) and Method A2(G, ) return the same DAG.

Proof. It is evident that Methods A and A2 transform  into  and, thus, that they halt
at some point. We now prove that they return the same DAG. We prove this result by
induction on the number of times that Method A executes line 6 before halting. It is
evident that the result holds if the number of executions is one, because Methods A and A2
share line 1. Assume as induction hypothesis that the result holds for up to k 1 executions.
We now prove it for k executions. Let Y and Z denote the nodes involved in the first of
the k executions. Since the induction hypothesis applies for the remaining k  1 executions,
the run of Method A can be summarized as

If Z  Y is in G then cover and reverse Z  Y in G
Interchange Y and Z in 
For i = 1 to n do
Percolate right-to-left in  the leftmost node in  that has not been percolated before

where n is the number of nodes in G. Now, assume that Y is percolated when i = j. Note
that the first j  1 percolations only involve nodes to the left of Y in . Thus, the run
above is equivalent to
683

fiPena

For i = 1 to j  1 do
Percolate right-to-left in  the leftmost node in  that has not been percolated before
If Z  Y is in G then cover and reverse Z  Y in G
Interchange Y and Z in 
Percolate Y right-to-left in 
Percolate Z right-to-left in 
For i = j + 2 to n do
Percolate right-to-left in  the leftmost node in  that has not been percolated before.
Now, let W denote the nodes to the left of Z in  before the first of the k executions of
line 6. Note that the fact that Y and Z are the nodes involved in the first execution implies
that the nodes in W are also to the left of Z in . Note also that, when Z is percolated
in the latter run above, the nodes to the left of Z in  are exactly W  {Y }. Since all the
nodes in W  {Y } are also to the left of Z in , the percolation of Z in the latter run above
does not perform any arc covering and reversal or node interchange. Thus, the latter run
above is equivalent to
For i = 1 to j  1 do
Percolate right-to-left in  the leftmost node in  that has not been percolated before
Percolate Z right-to-left in 
Percolate Y right-to-left in 
For i = j + 2 to n do
Percolate right-to-left in  the leftmost node in  that has not been percolated before
which is exactly the run of Method A2. Consequently, Methods A and A2 return the same
DAG.

Lemma 2. Method A2(G, ) and Method B(G, ) return the same DAG.
Proof. We can prove the lemma in much the same way as Lemma 1. We simply need to
replace Y by Z and vice versa in the proof of Lemma 1.

Lemma 3. Method B(G, ) and Method B2(G, ) return the same DAG.
Proof. It is evident that Methods B and B2 transform  into  and, thus, that they halt
at some point. We now prove that they return the same DAG. We prove this result by
induction on the number of times that Method B executes line 6 before halting. It is
evident that the result holds if the number of executions is one, because Methods B and B2
share line 1. Assume as induction hypothesis that the result holds for up to k 1 executions.
We now prove it for k executions. Let Y and Z denote the nodes involved in the first of
the k executions. Since the induction hypothesis applies for the remaining k  1 executions,
the run of Method B can be summarized as
684

fiFinding Consensus Bayesian Network Structures

If Y  Z is in G then cover and reverse Y  Z in G
Interchange Y and Z in 
For i = 1 to n do
Percolate left-to-right in  the rightmost node in  that has not been percolated before
where n is the number of nodes in G. Now, assume that Y is the j-th rightmost node in
. Note that, for all 1  i < j, the i-th rightmost node Wi in  is to the right of Y in 
when Wi is percolated in the run above. To see it, assume to the contrary that Wi is to
the left of Y in . This implies that Wi is also to the left of Z in , because Y and Z are
neighbors in . However, this is a contradiction because Wi would have been selected in
line 2 instead of Y for the first execution of line 6. Thus, the first j  1 percolations in the
run above only involve nodes to the right of Z in . Then, the run above is equivalent to
For i = 1 to j  1 do
Percolate left-to-right in  the rightmost node in  that has not been percolated before
If Y  Z is in G then cover and reverse Y  Z in G
Interchange Y and Z in 
For i = j to n do
Percolate left-to-right in  the rightmost node in  that has not been percolated before
which is exactly the run of Method B2.

References
Chickering, D. M. A Transformational Characterization of Equivalent Bayesian Network
Structures. In Proceedings of the Eleventh Conference on Uncertainty in Artificial Intelligence, 87-98, 1995.
Chickering, D. M. Optimal Structure Identification with Greedy Search. Journal of Machine
Learning Research, 3:507-554, 2002.
Chickering, D. M. & Meek, C. Finding Optimal Bayesian Networks. In Proceedings of the
Eighteenth Conference on Uncertainty in Artificial Intelligence, 94-102, 2002.
Chickering, D. M., Heckerman, D. & Meek, C. Large-Sample Learning of Bayesian Networks
is NP-Hard. Journal of Machine Learning Research, 5:1287-1330, 2004.
Friedman, N. & Koller, D. Being Bayesian About Network Structure. A Bayesian Approach
to Structure Discovery in Bayesian Networks. Machine Learning, 50:95-12, 2003.
Gavril, F. Some NP-Complete Problems on Graphs. In Proceedings of the Eleventh Conference on Information Sciences and Systems, 91-95, 1977.
Garey, M. & Johnson, D. Computers and Intractability: A Guide to the Theory of NPCompleteness. W. H. Freeman, 1979.
685

fiPena

Geiger, D., Verma, T. & Pearl, J. Identifying Independence in Bayesian Networks. Networks,
20:507-534, 1990.
Genest, C. & Zidek, J. V. Combining Probability Distributions: A Critique and an Annotated Bibliography. Statistical Science, 1:114-148, 1986.
Hartemink, A. J., Gifford, D. K., Jaakkola, T. S. & Young, R. A. Combining Location
and Expression Data for Principled Discovery of Genetic Regulatory Network Models. In
Pacific Symposium on Biocomputing 7, 437-449, 2002.
Jackson, B. N., Aluru, S. & Schnable, P. S. Consensus Genetic Maps: A Graph Theoretic Approach. In Proceedings of the 2005 IEEE Computational Systems Bioinformatics
Conference, 35-43, 2005.
Koller, D. & Friedman, N. Probabilistic Graphical Models: Principles and Techniques. MIT
Press, 2009.
Matzkevich, I. & Abramson, B. The Topological Fusion of Bayes Nets. In Proceedings of
the Eight Conference Conference on Uncertainty in Artificial Intelligence, 191-198, 1992.
Matzkevich, I. & Abramson, B. Some Complexity Considerations in the Combination of
Belief Networks. In Proceedings of the Ninth Conference Conference on Uncertainty in
Artificial Intelligence, 152-158, 1993a.
Matzkevich, I. & Abramson, B. Deriving a Minimal I-Map of a Belief Network Relative to
a Target Ordering of its Nodes. In Proceedings of the Ninth Conference Conference on
Uncertainty in Artificial Intelligence, 159-165, 1993b.
Maynard-Reid II, P. & Chajewska, U. Agregating Learned Probabilistic Beliefs. In Proceedings of the Seventeenth Conference in Uncertainty in Artificial Intelligence, 354-361,
2001.
Meek, C. Graphical Models: Selecting Causal and Statistical Models. PhD thesis, Carnegie
Mellon Unversity, 1997.
Ng, K.-C. & Abramson, B. Probabilistic Multi-Knowledge-Base Systems. Journal of Applied
Intelligence, 4:219-236, 1994.
Nielsen, J. D., Kocka, T. & Pena, J. M. On Local Optima in Learning Bayesian Networks.
In Proceedings of the Nineteenth Conference on Uncertainty in Artificial Intelligence,
435-442, 2003.
Nielsen, S. H. & Parsons, S. An Application of Formal Argumentation: Fusing Bayesian
Networks in Multi-Agent Systems. Artificial Intelligence 171:754-775, 2007.
Pearl, J. Probabilistic Reasoning in Intelligent Systems: Networks of Plausible Inference.
Morgan Kaufmann, 1988.
Pennock, D. M. & Wellman, M. P. Graphical Representations of Consensus Belief. In Proceedings of the Fifteenth Conference on Uncertainty in Artificial Intelligence, 531-540,
1999.
686

fiFinding Consensus Bayesian Network Structures

Pena, J. M., Nilsson, R., Bjorkegren, J. & Tegner, J. Towards Scalable and Data Efficient
Learning of Markov Boundaries. International Journal of Approximate Reasoning, 45:211232, 2007.
Pena, J. M., Kocka, T. & Nielsen, J. D. Featuring Multiple Local Optima to Assist the User
in the Interpretation of Induced Bayesian Network Models. In Proceedings of the Tenth
International Conference on Information Processing and Management of Uncertainty in
Knowledge-Based Systems, 1683-1690, 2004.
Richardson, M. & Domingos, P. Learning with Knowledge from Multiple Experts. In Proceedings of the Twentieth International Conference on Machine Learning, 624-631, 2003.
del Sagrado, J. & Moral, S. Qualitative Combination of Bayesian Networks. International
Journal of Intelligent Systems, 18:237-249, 2003.
Studeny, M. Bayesian Networks from the Point of View of Chain Graphs. In Proceedings of
the Fourteenth Conference Conference on Uncertainty in Artificial Intelligence, 496-503,
1998.
Studeny, M. & Bouckaert, R. R. On Chain Graph Models for Description of Conditional
Independence Structures. The Annals of Statistics, 26:1434-1495, 1998.

687

fi