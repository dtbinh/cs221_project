Journal of Artificial Intelligence Research 42 (2011) 917-943

Submitted 03/11; published 12/11

Interpolable Formulas in Equilibrium Logic and
Answer Set Programming
Dov Gabbay

dov.gabbay@kcl.ac.uk

Bar Ilan University Israel, Kings College London and
University of Luxembourg.

David Pearce

david.pearce@upm.es

AI Dept, Universidad Politecnica de Madrid, Spain.

Agustn Valverde

a valverde@ctima.uma.es

Dept of Applied Mathematics, Universidad de Malaga, Spain.

Abstract
Interpolation is an important property of classical and many non-classical logics that
has been shown to have interesting applications in computer science and AI. Here we study
the Interpolation Property for the the non-monotonic system of equilibrium logic, establishing weaker or stronger forms of interpolation depending on the precise interpretation
of the inference relation. These results also yield a form of interpolation for ground logic
programs under the answer sets semantics. For disjunctive logic programs we also study
the property of uniform interpolation that is closely related to the concept of variable forgetting. The first-order version of equilibrium logic has analogous Interpolation properties
whenever the collection of equilibrium models is (first-order) definable. Since this is the
case for so-called safe programs and theories, it applies to the usual situations that arise
in practical answer set programming.

1. Introduction
The interpolation property is an important and much discussed topic in logical systems,
both classical and non-classical (Gabbay & Maksimova, 2005). Its importance in computer
science is also becoming recognised nowadays. The interpolation property has been applied
in various areas of computer science, for example in software specification (Diaconescu,
Goguen, & Stefaneas, 1993; Bicarregui, Dimitrakos, Gabbay, & Maibaum, 2001), in the
construction of formal ontologies (Kontchakov, Wolter, & Zakharyaschev, 2008) and in
model checking and related subareas (McMillan, 2005). In the first two areas interpolation
is important as a metatheoretical property, in particular it may provide a basis for the modular composition and decomposition of theories; for instance, for Kontchakov et al. (2008)
it plays a key role in the study of the modular decomposition of ontologies. In other
cases, interpolants themselves play a role as special formulas applied in automated deduction (McMillan, 2005).
To date interpolation has received much less attention in systems of non-monotonic
reasoning and logic programming, despite their importance in AI and computer science. In
this note we study the interpolation property for the system of nonmonotonic reasoning
known as equilibrium logic (Pearce, 2006). Since this in turn can be regarded as a logical
foundation for stable model reasoning and answer set programming (ASP), our results
transfer immediately to the sphere of ASP. We shall focus here mainly on interpolation as a
c
2011
AI Access Foundation. All rights reserved.

fiGabbay, Pearce, & Valverde

metatheoretical property and our primary interest is in establishing this property for certain
cases of interest. Although in Section 8 we consider a case where an interpolant (actually
a uniform interpolant) is explicitly constructed, we are mainly concerned here with pure
existence theorems. Discussion of complexity issues as well as possible applications of the
interpolation property in ASP are left to future work. However, it seems likely that, as in the
case of studies involving formal ontologies (Konev, Walther, & Wolter, 2009), interpolation
may be a useful property for applications of ASP in knowledge representation. In a previous
paper (Pearce & Valverde, 2012), the interpolation and Beth properties of the underlying,
monotonic logic of ASP were used to characterise strong kinds of intertheory relations. To
capture weaker kinds of intertheory relations it may be important to be able to rely on
interpolation holding in the extended, non-monotonic logic. We plan to explore this avenue
in the future.
To introduce the property of interpolation, let us start with some notation and terminology. Let us assume the syntax of first-order logic with formulas denoted by lower case
Greek letters and predicates by lower case Latin letters.
Let  be a monotonic inference relation and suppose that   . An interpolant
for (, ) is a formula  such that
 & 

(1)

where  contains only predicate and constant symbols that belong to both  and . A logic L
with inference relation L is said to have the interpolation property if an interpolant exists
for every pair of formulas (, ) such that  L . As is well-known, classical logic as well
as many non-classical logics possess interpolation.
Suppose now we deal with a non-monotonic logical system with an inference relation |.
To express the idea that a formula is an interpolant it will not generally suffice simply to
replace  by | in (1). One problem is that, since | is non-monotonic, it is in general not
transitive. Instead, following the idea of Gabbay and Maksimova (2005), we can modify
condition (1) and proceed in a two-stage fashion. We make use of the fact that nonmonotonic consequence can be defined in terms of minimal models in some monotonic
logical system, say that the consequence relation | is appropriately captured by means of
minimal models in a logic L with consequence relation |=L . Now suppose that  | . Then
as an interpolant for (, ) we look for a formula  such that
 |  &  |=L 

(2)

where all predicate and constant symbols of  occur in both  and . Since | is to be
defined via a subclass of minimal L-models, we already assume that |=L  |. Moreover
we should assume too that L is a well-behaved sublogic in the sense that L-equivalent
formulas have the same |-consequences and that the L-consequences of |-consequences
are themselves |-consequences (so e.g. from (2) we can derive  | ). In non-monotonic
reasoning these last two properties are known as left and right absorption, respectively.
Given these conditions, it follows at once from (2) that any formula in the language of 
that is L-equivalent to  will also be an interpolant for (, ). Likewise if  is an interpolant
for (, ) and  |=L  then  |  and  is an interpolant for (, ).
Now, to find an interpolant for (, ) satisfying (2), or to prove that one always exists,
we can proceed as follows. We look for an L-formula  say, that precisely L-defines the
918

fiInterpolable Formulas in Equilibrium Logic and Answer Set Programming

minimal models of . Since  |  it follows that  |=L . Now, if L has the interpolation
property as defined earlier, we apply this theorem to obtain or infer the existence of an
L-interpolant  in the sense of (1) for ( , ). Hence (2) follows.
Notice that this two-stage procedure relies on three key features: (i) that we can identify
a suitable monotonic sublogic L for |, (ii) that a formulas minimal models are L-definable,
and (iii) that L has the interpolation property. These conditions are prima facie independent. As we shall see, we may have (i) and (iii) but lack (ii). The situation with respect
to equilibrium logic is as follows. In the propositional case all three conditions are met, so
we can establish the interpolation property in the general case. The situation for quantified
equilibrium logic is more complicated. In the general case, we lack condition (ii). More
precisely, we have an appropriate monotonic sublogic L and this logic has the interpolation
property, but the equilibrium models of a formula need not be first-order definable in L.
So the procedure outlined does not yield interpolants in all cases. However some recent results on a generalised concept of (first-order) stable model imply that there are interesting
classes of interpolable formulas: we shall consider in more detail one such class, that of safe
formulas. In particular, if  is a safe formula and  | , then there exists an interpolant 
such that (2) holds. Other classes of interpolable formulas are so-called tight formulas, and
formulas possessing a finite, complete set of what are called loops.
Safety, tightness and loop formulas have been studied at some length in answer set programming (ASP). The implications of these results for ASP can be summarised as follows.
In the case of (finite) ground programs the interpolation property holds. In the first-order or
non-ground case, interpolation holds for finite, safe programs without function symbols, and
hence practically for all finite programs currently admitted by answer set solvers. Moreover,
since safety is now defined for arbitrary formulas in a function-free language, the class of
safe formulas in this sense goes beyond the class of expressions normally admitted in ASP,
even if auxiliary concepts like weight constraints and aggregates are included.

2. Logical Preliminaries
We work with standard propositional and predicate languages, where the latter may in the
general case contain constant and function symbols. Propositional languages are based on
a set V of propositional variables, and formulas are built-up in the usual way using the
logical constants , , , , standing respectively for conjunction, disjunction, implication
and negation. If  is a propositional formula, we denote by V () the set of propositional
variables appearing in .
A first-order language L = hC, F, P i consists of a set of constants C, function symbols
F and predicate symbols P ; each function symbol f in F and predicate symbol p  P
has an assigned arity. Moreover, we assume a fixed countably infinite set of variables, the
symbols , , , , , , and auxiliary parentheses (, ). Atoms, terms and
formulas are constructed as usual; closed formulas, or sentences, are those where each
variable is bound by some quantifier. If  is a (first-order) formula, L() denotes the
language associated with , i.e. the set of constants, function and predicate symbols occuring
in it.
We make use of the following notation and terminology. Boldface x stands for a tuple
of variables, x = (x1 , . . . , xn ), while (x) = (x1 , . . . , xn ) is a formula whose free variables
919

fiGabbay, Pearce, & Valverde

are x1 ,. . . , xn , and x = x1 . . . xn . If ti are terms, then t = (t1 , . . . , tn ) denotes a vector
of terms. A theory  is a set of sentences. Variable-free terms, atoms, formulas, or theories
are also called ground.
As usual the symbols  and |=, possibly with subscripts, are used to denote logical
inference and consequence relations, respectively. A logic L is said to be monotonic if its
inference relation L satisfies the monotonicity property:
 L  &      L 
To distinguish non-monotonic from monotonic inference relations, we use | to symbolise
the former. In most cases a non-monotonic logic can be understood in terms of an inference
relation that extends a suitable monotonic logic. When this extension is well-behaved we
say that the monotonic logic forms a deductive base 1 (Pearce, 2006) for it. This can be
made precise as follows.
Definition 1 Let | be any nonmonotonic inference relation. We say that a logic L with
monotonic inference relation L is a deductive base for | iff (i) L  |; (ii) If 1 L 2
then 1  2 ; (iii) If  |  and  L , then  | .
Here L denotes ordinary logical equivalence in L, while  denotes non-monotonic equivalence, i.e. 1  2 means that 1 and 2 have the same non-monotonic consequences.
Furthermore, we say that a deductive base is strong if it satisfies the additional condition:
1 6L 2 

there exists  such that 1   6 2  .

In terms of nonmonotonic consequence operations, (ii) and (iii) correspond to conditions
known as left absorption and right absorption respectively (Makinson, 1994).
2.1 Interpolation
We now turn to the interpolation property.
Definition 2 A logic L with inference relation L is said to have the interpolation property
if whenever
L   
there exists a sentence  (the interpolant) such that
L    & L   
where all predicate, function and constant symbols of  are contained in both  and ,
i.e. L()  L()  L(). In the case of propositional logic, the requirement is that V () 
V ()  V ().
As explained in the introduction, for non-monotonic logics we can consider two forms
of interpolation, one weaker one stronger. The stronger form makes use of an underlying
monotonic logic.
1. It is close to the concept of fully absorbing inferential frame used by Dietrich (1994).

920

fiInterpolable Formulas in Equilibrium Logic and Answer Set Programming

Definition 3 Suppose that  | . A (|, L ) interpolant for (, ) is a formula  such that
 |  &  L 

(3)

where L is a deductive base for | and  contains only predicate, function and constant
symbols that belong to both  and . A non-monotonic logic with inference relation |
is said to have the (|, ) interpolation property if for a suitable deductive base logic L
an (|, L ) interpolant exists for every pair of formulas (, ) such that  | .
The requirement that L form a deductive base ensures that some desirable properties of
interpolation are met.
Proposition 1 Let  be a (|, L ) interpolant for (, ).
(a) For any  such that  L ,  is a (|, L ) interpolant for (, ).
(b) For any  such that  L  , and any   such that  L   ,  is a (|, L )
interpolant for ( ,   ).
The property of deductive base also guarantees that the (|, L ) relation is transitive in the
sense that if (3) holds for any , , , then also | . This last property will not necessarily
hold for the second, weaker form of interpolation that we call (|, |) interpolation.
Definition 4 Suppose that  | . A (|, |) interpolant for (, ) is a formula  such that
 |  &  | 

(4)

where  contains only predicate, function and constant symbols that belong to both  and .
In the case of propositional logic, the requirement is that V ()  V ()  V ().
Analogous to the previous case, we say that a non-monotonic logic with inference relation | has the (|, |) interpolation property if a (|, |) interpolant exists for every pair of
formulas (, ) such that  | . Notice that (|, ) is the stronger form of interpolation
because if a logic has (|, ) interpolation it must also have (|, |) interpolation, again as
a consequence of the deductive base requirement (first clause).
Evidently the properties expressed in Proposition 1 are not directly applicable to the
second form of interpolation that does not refer to any underlying base logic. Nevertheless
an important feature of the interpolation properties we shall establish below is that we can
formulate and prove analogous properties even for (|, |) interpolation.
We can also consider restricted variants of interpolation when the property holds for
certain types of formulas, in other words, when there is an interpolant for (, ) given
 |  whenever  and  belong to specific syntactic classes. In such cases we can refer to
interpolable formulas. Later on we shall consider both kinds of restrictions, where  belongs
to a specific class or alternatively when  does.
2.2 Review of the Logic of Here-and-There
Equilibrium logic is based on the nonclassical logic of here-and-there, which we denote by
HT in the propositional case. In the quantified or first-order case we denote the logic by
QHT, with subscripts/superscripts to denote specific variants.
921

fiGabbay, Pearce, & Valverde

In both propositional and quantified cases the logic is based on the axioms and rules of
intuitionistic logic and is captured by the usual Kripke semantics for intuitionistic logic (van
Dalen, 1997). However the additional axioms of HT and QHT mean that we can use very
simple kinds of Kripke structures. In the first-order case we regard these structures as
sets of atoms built over arbitrary non-empty domains D; we denote by At(D, F, P ) the set
of atomic sentences of hD, F, P i (if D = C, we obtain the set of atomic sentence of the
language L = hC, F, P i);2 and we denote by T (D, F ) the set of ground terms of hD, F, P i.
If L = hC, F, P i and L = hC  , F  , P  i, we write L  L if C  C  , F  F  and P  P  .
By an L-interpretation over a set D we mean a subset of At(D, F, P ). A classical Lstructure can be regarded as a tuple I = h(D, I), I  i where I  is an L-interpretation over D
and I : T (C  D, F )  D, called the assignment, verifies that I(d) = d for all d  D and is
recursively defined.3 If D = T (C, F ) and I = id, I is known as an Herbrand structure. On
the other hand, a here-and-there L-structure with static domains, or QHTs (L)-structure,
is a tuple I = h(D, I), I h , I t i where h(D, I), I h i and h(D, I), I t i are classical L-structures
such that I h  I t .
Thus we can think of a here-and-there structure I as similar to a first-order classical
model, but having two parts, or components, h and t that correspond to two different points
or worlds, here and there, in the sense of Kripke semantics for intuitionistic logic, where
the worlds are ordered by h  t. At each world w  {h, t} one verifies a set of atoms I w
in the expanded language for the domain D. We call the model static, since, in contrast to
say intuitionistic logic, the same domain serves each of the worlds. Since h < t, whatever is
verified at h remains true at t. The satisfaction relation for I is defined so as to reflect the
two different components, so we write I, w |=  to denote that  is true in I with respect to
the w component. Although we only need to define the satisfaction relation in L = hC, P i,
the recursive definition forces us to consider formulas from hC  D, F, P i. In particular,
if p(t1 , . . . , tn )  At(C  D, F, P ) then I, w |= p(t1 , . . . , tn ) iff p(I(t1 ), . . . , I(tn ))  I w for
every t1 , . . . , tn  T (C  D, F ). Then |= is extended recursively as follows4 :
 I, w |=    iff I, w |=  and I, w |= .
 I, w |=    iff I, w |=  or I, w |= .
 I, t |=    iff I, t 6|=  or I, t |= .
 I, h |=    iff I, t |=    and I, h 6|=  or I, h |= .
 I, w |=  iff I, t 6|= .
 I, t |= x(x) iff I, t |= (d) for all d  D.
 I, h |= x(x) iff I, t |= x(x) and I, h |= (d) for all d  D.
 I, w |= x(x) iff I, w |= (d) for some d  D.
2. We can think of the objects in D as additional constants; this approach allow us to use a simplified
notation where the objects are not distinguished from their names.
3. That is, for every a  C, I(a)  D and for every f  F with arity n, a mapping f I : Dn  D is defined;
so the recursive definition is given by I(f (t1 , . . . , tn )) = f I (I(t1 ), . . . , I(tn )).
4. The following corresponds to the usual Kripke semantics for intuitionistic logic given our assumptions
about the two worlds h and t and the single domain D,

922

fiInterpolable Formulas in Equilibrium Logic and Answer Set Programming

Truth of a sentence in a model is defined as follows: I |=  iff I, w |=  for each
w  {h, t}. A sentence  is valid if it is true in all models, denoted by |= . A sentence  is
a consequence of a set of sentences , denoted  |= , if every model of  is a model of .
The resulting logic is called Quantified Here-and-There Logic with static domains (Lifschitz, Pearce, & Valverde, 2007) denoted by QHTs . In terms of satisfiability and validity
this logic is equivalent to the logic introduced by Pearce and Valverde (2005).
A complete axiomatisation of QHTs can be obtained as follows (Lifschitz et al., 2007).
We take the axioms and rules of first-order intuitionistic logic and add the axiom of Hosoi
  (  (  ))

(5)

which determines 2-element here-and-there models in the propositional case, together with
the axiom:
x((x)  x(x)).
.
We also consider the equality predicate, =6 P , interpreted by the following condition for
every w  {h, t}
.
 I, w |= t1 = t2 iff I(t1 ) = I(t2 ).
To obtain a complete axiomatisation, we then need to add the axiom of decidible equality
.
.
xy(x = y  x =
6 y).
We denote the resulting logic by QHTs= (Lifschitz et al., 2007) and its inference relation
by . By compactness a strong form of completeness can be established such that  |= 
if and only if   .
In the context of logic programs, the following assumptions often play a role. In the case
of both classical and QHTs= models, we say that the parameter names assumption (PNA)
applies in case I|T (C,F ) is surjective, i.e. there are no unnamed individuals in D; the unique
names assumption (UNA) applies in case I|T (C,F ) is injective; in case both the PNA and
UNA apply, the standard names assumption (SNA) applies, i.e. I|T (C,F ) is a bijection.
As usual in first order logic, satisfiability and validity are independent of the signature.
If I = h(D, I), I h , I t i is an L -structure and L  L, we denote by I|L the restriction of I
to the sublanguage L:
I|L = h(D, I|L ), I h |L , I t |L i
Proposition 2 Suppose that L  L,  is a theory in L and M is an L -model of . Then
M|L is a L-model of .
Proposition 3 Suppose that L  L and   L. Then  is valid (resp. satisfiable) in
QHTs= (L) if and only if is valid (resp. satisfiable) in QHTs= (L ).
This proposition allows us to omit reference to the signature in the logic so it can be
denoted simply by QHTs= .
To simplify notation we also symbolise a QHTs= structure I = h(D, I), I h , I t i by
hU, H, T i, where U = (D, I) is the universe, and H, T respectively are the sets of atoms
I h , I t . In the case of propositional HT logic, Kripke structures can be regarded as pairs
hH, T i of set of atoms in the obvious way. A (strongly) complete axiomatisation for HT is
obtained from intuitionistic logic by adding just the Hosoi axiom (5).
923

fiGabbay, Pearce, & Valverde

2.3 Interpolation in the Logic of Here-and-There
An important and useful property of HT is the fact that it is the strongest propositional
intermediate logic (i.e. strengthening of intuitionistic logic) that is properly contained in
classical logic. Moreover it in turn properly contains all other such intermediate logics. In
addition HT is one of precisely seven superintuitionistic propositional logics possessing the
interpolation property (Maksimova, 1977; Gabbay & Maksimova, 2005).
For languages without function symbols Ono showed that interpolation holds in the
logic QHTs of quantified here-and-there with constant domains (Ono, 1983).5 In addition,
Maksimova (1997, 1998) showed that adding pure equality axioms, e.g. the decidible equality axiom, to any superintuitionistic logic preserves the interpolation property (Gabbay &
Maksimova, 2005). We conclude therefore
Proposition 4 The logic QHTs= possesses the interpolation property.
Note that by the strong completeness theorem for QHTs= we can work equivalently with 
or with |=.
Here we can make the further observation that interpolation continues to hold for languages that include function symbols. This can be established using the following property.
Proposition 5 For every formula , it is possible to build a formula , such that   ,
and the atoms of  are of one of the following types:
.
 x = a for some a  C,
.
 f (x1 , . . . xn ) = y for some f  F (where every xi and y are variables),
 p(t1 , . . . , tm ) (where every xi and y are variables).
Theorem 1 Let L be a language containing function symbols. Then QHTs= (L) has the
interpolation property.
Proof sketch: Let us assume that    ; from the previous proposition, we can assume,
without loss of generality, that the function symbols in  and  are in atoms of type
.
f (x1 , . . . xn ) = y. Now, we consider a language L obtained from L by replacing every
function symbol f by a fresh predicate symbol, Pf , such that the Arity(Pf ) = 1 + Arity(f ).
Let  and   be formulas in L build from  and  respectivelly, by replacing every atom
.
f (x1 , . . . xn ) = y by Pf (x1 , . . . xn , y). Trivially,      and, for the interpolation property
of QHTs= (L ), there exists an interpolant   :      ,       . If we replace in   the
.
predicates Pf (t1 , . . . , tn , tn+1 ) by atoms f (t1 , . . . tn ) = tn+1 we obtain the interpolant  for
the initial pair of formulas. 
5. Onos axiomatisation of QHTs uses the constant domains axiom x((x)  )  (x(x)  ), as well as
alternative axioms for propositional here-and-there, viz. p  (p  (q  q)) and (p  q)  (q  p)  (p 
q). However, the axioms given here are equivalent to Onos.

924

fiInterpolable Formulas in Equilibrium Logic and Answer Set Programming

2.4 Equilibrium Logic
Equilibrium logic is a non-monotonic logic based on certain kinds of minimal models in
QHTs= or HT. We give the definition for QHTs= ; the propositional version is easily
obtained from it.
Definition 5 Among quantified here-and-there structures we define the order E as follows:
h(D, I), I h , I t i E h(D  , J), J h , J t i

if

D = D  , I = J, I t = J t , I h  J h .

If the subset relation holds strictly, we write .
Definition 6 (Equilibrium model) Let  be a theory and I = h(D, I), I h , I t i a model
of .
1. I is said to be total if I h = I t .
2. I is said to be an equilibrium model of  (or short, we say: I is in equilibrium) if
it is minimal under E among models of , and it is total.
In other words, equilibrium models are total models for which there is no smaller non-total
model. Evidently a total QHTs= model of a theory  can be equivalently regarded as a
classical first order model of ; and in what follows we make tacit use of this equivalence.
In the propositional case, equilibrium models are defined in the same way, where now the
ordering is between propositional HT models. In the usual way a formula or theory is said
to be consistent if it has a QHTs= model and additionally we say that it is coherent if it
has an equilibrium model.
The following definition give a preliminary notion of equilibrium entailment, which
agrees with standard versions of equilibrium logic (Pearce, 2006).
Definition 7 The relation |, called equilibrium entailment, is defined as follows. Let 
be a set of formulas.
1. If  is non-empty and coherent (has equilibrium models), then  |  if every equilibrium model of  is a model of  in QHTs= (respectively HT).
2. If either  is empty or has no equilibrium models, then  |  if   .
Notice that unless we need to distinguish propositional from first-order reasoning we use
the symbols |,  and |= for either version.
A few words may help to explain the concept of equilibrium entailment. First, we
define the basic notion of entailment as truth in every intended (equilibrium) model. In
nonmonotonic reasoning this is a common approach and sometimes called a skeptical or
cautious notion of entailment or inference; its counterpart brave reasoning being defined
via truth in some intended model. Since equilibrium logic is intended to provide a logical
foundation for the answer set semantics of logic programs, the cautious variant of entailment
is the natural one to choose: the standard consequence relation associated with answer
sets is given by truth in all answer sets of a program. Note however that in ASP as a
programming paradigm each answer set may correspond to a particular solution of the
problem being modelled and is therefore of interest in its own right.
925

fiGabbay, Pearce, & Valverde

Secondly, it is useful to have a nonmonotonic consequence or entailment relation that is
non-trivially defined for all consistent theories. As we shall see below, however, not all such
theories possess equilibrium models. For such cases it is natural to use monotonic consequence as the entailment relation. In particular in the propositional case HT is a maximal
logic with the property that logically equivalent theories have the same equilibrium models.
Evidently situation 2 also handles correctly the cases that  is empty or inconsistent.
Despite these qualifications, there remains an ambiguity in the concept of equilibrium
entailment that we now need to settle. Suppose that L  L,  is a theory in L and  is a
sentence in L (i.e. L = L()). How should we understand the expression  |  ?
Evidently, if we fix a language in advance, say as the language L , then we can simply
consider the equilibrium models of  in L . But if  represents a knowledge base or a logic
program, for instance, we may also take the view that L() is the appropriate signature to
work with. In that case, the query  is as such not fully interpreted as it contains some
terms not in the theory language L().
For any language L and theory  whose language is contained in L, let EML () be
the collection of all equilibrium models of  in QHTs= (L). Now consider the following two
variants of entailment.
Definition 8 (Equilibrium entailment) Assume  is a theory in L, is non-empty and
has equilibrium models, then:
(i) Let us write |cw  if and only if M |=  for each M  EML (), where L = LL():
(ii) let us write  |ow  if and only if M |=  for each M  EML () L() , where in

general EML () L denotes the collection of all expansions of elements of EML () to
models in L  L , i.e. where the vocabulary of L \ L is interpreted arbitrarily.
(iii) If either  is empty or has no equilibrium models, then  |cw  iff  |ow  iff   .
A simple example will illustrate the difference between |cw and |ow . Let  be an
L-sentence and let q(x) be a predicate not in L. Let a be a constant in L and let L be the
language L  {q}. By the first method we have  |cw   (q(a)  q(a)). In fact we have
the stronger entailment  |cw   q(a). The reason is that when we form the equilibrium
models of  in L , q(a) will be false in each as an effect of taking minimal models. On the
other hand, if we expand equilibrium models of  in QHTs= (L) to QHTs= (L ), the new
predicate q receives an arbitrary interpretation in QHTs= (L ). Since this logic is 3-valued
we do not obtain  |ow q(a)  q(a).
For standard, monotonic logics, there is no difference between these two forms of entailment. If in Definition 8 we replace everywhere equilibrium model by simply model (in
QHTs= ), variants (i) and (ii) give the same result.
In the context of logic programming and deductive databases the more orthodox view is
that reasoning is based on a closed world assumption (CWA). Accordingly a ground atomic
query like q(a)?, where the predicate q does not belong to the language of the program or
database, would simply be assigned the value false. This is also the case with the first kind
of equilibrium entailment and we use the label |cw since this variant appears closer to a
closed world form of reasoning. On the other hand, there may be legitimate cases where we
do not want to apply the CWA and where unknown values should be assigned to an atom
that is not expressed in the theory language. Then the second form of entailment, |ow ,
926

fiInterpolable Formulas in Equilibrium Logic and Answer Set Programming

nearer to open world reasoning, may be more appropriate. For present purposes, however,
the suffices cw and ow should be thought of merely as mnemonic labels.
A thorough analysis of closed world versus open world reasoning in this context would
lead us to consider assumptions such as UNA or SNA and is outside the scope of this paper.
However, it has been observed in logic programming that the use of CWA can lead to
certain apparent anomalies. Notably this occurs with programs that are unsafe (see Section
5 below), such as the following, formulated in traditional notation for logic programs:6
q(x, y) :  not p(x, y).
p(x, x).
Given restrictions such as SNA or Herbrand models, the query
?  q(a, z).
yields no answer for z because it cannot be satisfied in models with only a single domain
element a, while the query
?  q(a, b).
is satisfiable, given the new constant b. In logic programming, where these restrictions
are usually assumed, different solutions to this problem have been proposed (Gelder, Ross,
& Schlipf, 1991; Kunen, 1987; Maher, 1988). Here we would like to point out that for
equilibrium logic generally speaking this kind of program or theory does not create any
special difficulties. Neither the query
?  q(a, z).
which is understood as zq(a, z), nor the query
?  q(a, b).
is true in all equilibrium models. In particular, in an equilibrium model whose domain is a
singleton element, even q(a, b) need not be true; evidently in the general case that UNA for
instance does not apply. On the other hand in answer set programming, where UNA is often
assumed, it is also typically assumed that programs are safe. By the safety condition the
above program is excluded because variables appearing in the head of a rule do not appear
in its positive body and this makes answer sets sensitive to the set of constants appearing
in the language or those that are used for grounding the program. In this paper, where the
application of interpolation in ASP is concerned, we restrict attention to safe programs and
theories complying with a generalised form of safety (Section 5 below).

3. Interpolation in Propositional Equilibrium Logic
In this section we deal with interpolation in propositional equilibrium logic. It is clear that
by its semantic construction propositional equilibrium logic has HT as a deductive base.
This base is actually maximal.
Proposition 6 HT is a strong and maximal deductive base for (propositional) equilibrium
entailment.
The first property is precisely the strong equivalence theorem of Lifschitz, Pearce and
Valverde (2001). Maximality follows from the fact that any logic strictly stronger than
HT would have to contain classical logic which is easily seen not to be a deductive base,
e.g. violating condition (ii) of Definition 1. We have:
6. We are grateful to an anonymous referee for raising this point and the example.

927

fiGabbay, Pearce, & Valverde

Lemma 1 Let  be a coherent HT-formula and EM () its set of equilibrium models. Then
there is formula  of HT in v() that defines EM () in the sense that M  EM () if
and only if M |=  .
Proof. Suppose that  is coherent. and let
M1 = hT1 , T1 i, M2 = hT2 , T2 i, . . . , Mn = hTn , Tn i
be an enumeration of its equilibrium models. We show how to define EM (). Suppose
each Ti , has ki elements and denote them by Ai1 , . . . , Aij , . . . , Aiki . Let Ti be the complement
of Ti ; then we can list its members as Aik1 +1 , . . . Ail . . . , Ai|v()| . Set
i =

^
j=1,...,ki

Aij  (

_

Ail ),

l=ki+1 ,...,|v()|

and  =

_

i

i=1,...,n

We claim that M |=  if and only if M = Mi for some i = 1, . . . , n, i.e. the models of 
are precisely M1 , . . . , Mn . To verify this claim, note that each Mi |= i and so Mi |=  .
Conversely, suppose that M |=  . From the semantics of HT it is clear that M |=    iff
M |=  or M |= , so in particular M |=  implies M |= i for some i = 1, . . . , n. However,
each i defines a complete theory whose models are total. It follows that if M |= i , then
M = Mi . This establishes the claim.

Although we shall now demonstrate interpolation in the (|, |) form for the relation |cw , we actually establish a stronger result. One consequence of this is that if we
are concerned with |ow entailment then the (|, ) form of interpolation actually holds.
Proposition 7 (|, |-Interpolation) Let ,  be formulas and set v = v()  v() and
v  = v() \ v() and suppose that B1 , . . . Bn is an enumeration of v  . If  |cw , there is
a formula  such that v()  v()  v(),  | , and   B1  . . .  Bn |= . Hence in
particular  |cw .
Proof. Let ,  and v, v  be as in the statement of the proposition, and suppose that |cw .
Then  holds in all equilibrium models of  in the language v. Case (i): suppose that  is
coherent and form its set of equilibrium models, EMv ().
By the equilibrium construction it is easy to see that in each model M  EMv () each
atom Bi is false, for i = 1, n. Construct the formulas i and the formula  exactly as in the
proof of Lemma 1. Now consider the formula (B1  . . .  Bn )   . Clearly this formula
defines the set of equilibrium models of  in HT(v). Consequently, (B1 . . .Bn ) |= 
and so   (B1  . . .  Bn )  . We can now apply the interpolation theorem for HT
to infer that there is a formula  such that    and   (B1  . . .  Bn )  , where
v()  v( )  v() and hence v()  v()  v(). Since HT is a deductive base, we
conclude that
 |  &   B1  . . .  Bn  .
Now, since v()  v()  v(), Bi 6 v() for i = 1, n. It follows that in HT(v()), each Bi
is false in every equilibrium model of . So each such model M satisfies (B1  . . .  Bn ).7
Since each also satisfies , we have  |cw .
7. Notice that in this case adding to  the sentence (B1  . . .  Bn ) does not change its set of equilibrium
models.

928

fiInterpolable Formulas in Equilibrium Logic and Answer Set Programming

Case (ii). If  has no equilibrium models then the hypothesis is that   . In that
case we simply choose an interpolant  for (, ).

Corollary 1 (|, -Interpolation) Let ,  be formulas such that  |cw  and v() 
v(). There is a formula  such that v()  v()  v() and  |cw  and   .
Proof. Immediate from Proposition 7 by the fact that v() \ v() = .



Proposition 8 (|, -Interpolation) Let ,  be formulas and set v = v()  v() and
v  = v() \ v(). If  |ow , there is a formula  such that v()  v()  v(),  | , and
  .
Proof. Let ,  and v, v  be as in the statement of the proposition and suppose that |ow .
Then  holds in all expansions of elements of EMv() () to the language v. Case (i): suppose
that  is coherent and consider EMv() ().
Again construct the formulas i and the formula  exactly as in the proof of Lemma 1.
Now consider  which defines the set EMv() (). Then  holds in all expansions of models
of  to v. Hence  |=  and therefore    We can now apply the interpolation
theorem for HT to infer that there is a formula  such that    and   , where
v()  v( )  v() and hence v()  v()  v(). Since  |ow  and HT is a deductive
base we conclude that
 |ow  &   .
Case (ii). If  has no equilibrium models, choose  as an interpolant for (, ).



4. Interpolation in Quantified Equilibrium Logic
We now turn to first-order logic. Given inferences of the form  | , a key element in the
proofs of Propositions 7 and 8 is the existence of a formula  that defines the collection
EMv() () of equilibrium models. In the propositional case we have seen how the existence
of such an  can be established. In the first-order case, on the other hand, such an  need
not exist. In other words, EML() () need not be first-order definable for arbitrary . This
fact is not hard to show. As Ferraris et al. (2007) have pointed out, in the general form of
answer set programming where first-order formulas are allowed, and a fortiori in quantified
equilibrium logic, the property of transitive closure is expressible. Yet this property is not
definable in classical first-order logic and therefore it also cannot be defined in QHTs= .
In the usual way we say that a collection K of QHTs= (L) models is (QHTs= ) definable
if there is an L-sentence, , such that M  K  M |= . It is easy to see that whenever
the class EML() () is first-order definable in QHTs= we do obtain first-order analogs
of Propositions 7 and 8. The method of proof is essentially the same as before. For
completeness we outline the main steps for the case of (|, |)-interpolation.
Proposition 9 (|, |-Interpolation) Let ,  be formulas such that the collection of equilibrium models of  is QHTs= - definable. Set L = L()  L() and L = L() \ L(). Let
{pi : i = 1, n} be the (finite, possibly empty) set of predicates in L and suppose for each i
929

fiGabbay, Pearce, & Valverde

that pi is of arity ki . If  |cw , there is a formula  such that L()  L()  L(),  | ,
and
^

xpi (x) |= 
i=1,n

Hence in particular  |cw .
Proof. Assume the hypotheses. Then  holds in all equilibrium models of  in the language
L. We treat just the case where  is coherent and has a non-empty collection of equilibrium
models, EML() (). By assumption this collection is definable by a QHTs= (L())-sentence,
 , say. Now consider the equilibrium models of  in the expanded language L, i.e. the
collection EML (). By the equilibrium construction we claim that EML () |= xpi (x),
for all i = 1, n. Since we are now working with the first-order semantics, let us rehearse
briefly the argument for this. If it were not true there would be a model hU, T, T i  EML (),
a predicate symbol pi  L and some tuple a of elements in the domain of hU, T, T i, such
that hU, T, T i |= pi (a), ie pi (a)  T . However, since  does not refer to the relation
pi , the structure hU, H, T i with H = T \ pi (a) must Valso be a model of , contradicting
that hU, T, T i is in equilibrium.
So EML () |=   i=1,n xpi (x) and since  defines
V
EML() () clearly   i=1,n xpi (x) defines EML ().
V
Now we proceed as in the propositional case.   i=1,n xpi (x)  , so
^
xpi (x)  .
 
i=1,n

By the interpolation
theorem for QHTs= there is a formula  such that L()  L()  L(),
V
   and   i=1,n xpi (x)  . Consequently we also have
^
xpi (x)  
 |  &  
i=1,n

By the same token as in the propositional case, we infer that  |cw .

The case of (|, )-interpolation for |ow is analogous and we state the main property
without proof.
Proposition 10 (|, -Interpolation) Let ,  be formulas such that the collection of
equilibrium models of  is QHTs= - definable. If  |ow , there is a formula  such that
L()  L()  L(),  |  and   .

5. An Illustration: Interpolation for Safe Formulas
How restrictive is the definability assumption? Is it often met in practice? Actually in
mainstream answer set programming, whose language equilibrium logic captures and extends (see the next section), non-definable classes of answers sets play no significant role.
The reason is that for query answering existing solvers rely on grounders that instantiate all
or parts of a program before computing the intended models or solutions. The grounding
process essentially eliminates variables and reduces the original program to propositional
form. In such practical cases, then, the collection of stable or equilibrium models will be
definable.
930

fiInterpolable Formulas in Equilibrium Logic and Answer Set Programming

For this computational approach to work in general, syntactic restrictions need to be
imposed on admissible programs or theories. The most common form of restriction is called
safety. For standard types of logic programs based on rules one regards a rule as safe
if every variable appearing in rules head also appears in its body. For the more complex
formulas admitted by equilibrium logic and by the general approach to answer sets (Ferraris
et al., 2007; Ferraris, 2008), new concepts of safety need to be devised. Proposals for suitable
safety concepts were made by Lee, Lifschitz and Palla (2008b) for general first-order formulas
and by Bria, Faber and Leone (2008) for a more restricted syntactic class. More recently
Cabalar, Pearce and Valverde (2009) have generalised both these approaches and suggested
a safety concept for arbitrary function-free formulas in equilibrium logic. Since this new
concept of safety defines a quite broad class of interpolable formulas, let us review here its
main features. In the following section we will mention some other kinds of interpolable
formulas that may arise in answer set programming.
5.1 General Concept of Safety
For the remainder of this section we assume that all languages are function-free. As usual
a sentence is said to be in prenex form if it has the following shape, for some n  0:
Q 1 x1 . . . Q n xn 
where Qi is  or  and  is quantifier-free. A sentence is said to be universal if it is
in prenex form and all quantifiers are universal. A universal theory is a set of universal
sentences. The safety concept is defined for prenex formulas which provide a normal form
for QHTs= (Pearce & Valverde, 2005).
We first introduce a concept called semi-safety. The main property of semi-safety formulas will be that their equilibrium models only refer to objects from their language. Note
that for the remainder of this section we use the fact that negation can be treated as a
defined operator, by     , and do not consider additional semantic clauses for
negation.
Definition 9 (Semi-safety) A quantifier free formula  is semi-safe it is has not nonsemi-safe variable; that is, NSS() = , where the NSS operator is recursively defined as
follows:
 If  is an atom, NSS() is the set of variables in ;
 NSS(1  2 ) = NSS(1 )  NSS(2 );
 NSS(1  2 ) = NSS(1 )  NSS(2 );
 NSS(1  2 ) = NSS(2 ) r RV(1 ),
where operator RV computes the restricted variables as follows:
 For atomic , if  is an equality between two variables then RV() = ; otherwise,
RV() is the set of all variables occurring in ;
 RV() = ;
931

fiGabbay, Pearce, & Valverde

 RV(1  2 ) = RV(1 )  RV(2 );
 RV(1  2 ) = RV(1 )  RV(2 );
 RV(1  2 ) = .
This definition of semi-safe formulas was introduced by Cabalar, Pearce and Valverde (2009)
and generalises the former definition of Lee, Lifschitz and Palla (2008b). In short, a variable x is semi-safe in  if every occurrence is inside some subformula    such that,
either x  RV() or x is semi-safe in .
Some examples of semi-safe formulas are, for instance:
p(x)  (q(x)  r(x))
p(x)  q  r(x)

(6)

Note how in (6), x is not restricted in p(x)  q but the consequent r(x) is semi-safe and
thus the formula itself. On the contrary, the following formulas are not semi-safe:
p(x)  q  r(x)
p(x)  r(x)  q(x)
The following results set the previously referred property for semi-safe formulas: their
equilibrium models only include objects from the language.
Proposition 11 (Cabalar et al., 2009)
If  is function free, semi-safe, and h(D, I), T, T i |= , then h(D, I), T |C , T i |= .
Theorem 2 (Cabalar et al., 2009) If  is function free, semi-safe, and h(D, I), T, T i is
an equilibrium model of , then T |C = T .
The equilibrium models of semi-safe formulas only refer to objects from the language,
however a model could be or not in equilibrium depending of the considered domain. To
guarantee the independence from the domain, we need an additional property to the semisafety. Specifically, we need to analyse whether the unnamed elements could modify an
interpretation of the formula. To do that, we use the assignments of the Kleenes threevalued logic; the three-valued interpretation  : At  {0, 1/2, 1}, are extended to evaluate
arbitrary formulas () as follows:
(  ) = min((), ())
(  ) = max((), ())

() = 0
(  ) = max(1  (), ())

For every variable x, we are going to use the Kleenes interpretations x , defined as follows:
x () = 0 if x occurs in the atom  and x () = 1/2 otherwise. Intuitively, x () fixes
all atoms containing the variable x to 0 (falsity) leaving all the rest undefined and then
evaluates  using Kleenes three-valued operators, that is nothing else but exploiting the
defined values 1 (true) and 0 (false) as much as possible.
An occurrence of a variable x in Qx  is weakly-restricted if it occurs in a subformula
 of  such that:
932

fiInterpolable Formulas in Equilibrium Logic and Answer Set Programming

 Q = ,  is positive8 and x () = 1
 Q = ,  is negative and x () = 0
 Q = ,  is positive and x () = 0
 Q = ,  is negative and x () = 1
In all cases, we further say that  makes the ocurrence weakly restricted in . This property
is added to the semi-safety condition to complete the definition of safety.
Definition 10 A semi-safe sentence is said to be safe if all its positive occurrences of
universally quantified variables, and all its negative occurrences of existentially quantified
variables are weakly restricted.
For instance, the formula  = x(q(x)  (r  p(x))) is safe: the occurrence of x in
p(x) is negative, whereas the occurrence in q(x) is inside a positive subformula,  itself, for
which x is weakly-restricted, since x () = 0  ( 1/2  0) = 1. Another example of a safe
formula is x((p(x)  q(x))  r).
Proposition 12 (Cabalar et al., 2009) If  is function free, safe, and prenex formula,
then: h(D, I), T, T i is an equilibrium model of  if and only if it is an equilibrium model of
GrC () (the grounding of  over C).
5.2 Interpolation
On the basis of Proposition 12 we could already establish interpolation theorems for safe
formulas in prenex form, essentially by replacing such formulas by their ground versions and
working in propositional logic. However, we can also apply Propositions 9 and 10 directly by
noting the property shown by Cabalar et al. (2009) that safe prenex formulas have definable
classes of equilibrium models.
Theorem 3 (interpolation for safe formulas)
Safe formulas in prenex form have
QHTs= -definable classes of equilibrium models. Therefore for such formulas (|, |)-interpolation for |cw inference holds as in Proposition 9 and (|, )-interpolation holds for |ow
inference as in Proposition 10.

6. Interpolation in Answer Set Semantics
Answer set programming (ASP) has become an established form of declarative, logic-based
programming and its basic ideas are now well-known. For a textbook treatment the reader
is referred to Barals book (2003). As is also well-known, the origins of ASP lie in the
stable model and answer set semantics for logic programs introduced by Gelfond and Lifschitz (1988, 1990, 1991). This semantics made use of a fixpoint condition involving a certain
reduct operator. Subsequent extensions of the concept to cover more general kinds of rules
8. Recall that a subexpression of a formula is said to be positive in it if the number of implications that
contain that subexpression in the antecedent is even, and negative if it is odd. Here we also consider
that  is defined as   .

933

fiGabbay, Pearce, & Valverde

also relied on a reduct operator of similar sort. For the original definitions, the reader is
referred to the various papers cited.
The correspondence between answer set semantics and equilibrium logic is also wellestablished and has been discussed in many publications, beginning with Pearce (1997), who
first showed how the answer sets of disjunctive programs can be regarded as equilibrium
models (Lifschitz et al., 2001, 2007; Ferraris et al., 2007; Pearce & Valverde, 2005, 2006,
2008). For our purposes it will suffice to recall just two important syntactic classes of
programs and the main features of the correspondence with equilibrium logic.
At one extreme we have ground, disjunctive logic programs; we treat them here without
strong negation, so their answer sets are simply collections of atoms. These programs consist
of sets of ground rules of the form
K1  . . .  Kk  L1 , . . . Lm , notLm+1 , . . . , notLn

(7)

where the Li and Kj are atoms. The translation from the syntax of programs to HT
propositional formulas is the trivial one, viz. (7) corresponds to the HT sentence
L1  . . .  Lm  Lm+1  . . .  Ln  K1  . . .  Kk

(8)

Under this translation the correspondence between the answer sets and the equilibrium
models of ground disjunctive programs is also the direct one:
Proposition 13 Let  be a disjunctive logic program. Then hT, T i is an equilibrium model
of  if and only if T is an answer set of .
This was first shown by Pearce (1997) but the basic equivalence was later shown to hold
for more general classes of programs by Pearce, P. de Guzman and Valverde (2000).
It is also common to treat non-ground rules of form (7) where variables may appear.
These variables are thought of as being universally quantified, so the corresponding translation into a logical formula would simply be the universal closure of formula (8).
At the other extreme, Ferraris, Lee and Lifschitz (2007) provided a new definition of
stable model for arbitrary first-order formulas. In this case the property of being a stable
model is defined syntactically via a second-order condition that resembles parallel circumscription. However they also showed that the new notion of stable model is equivalent to
that of equilibrium model as defined here for first-order languages. In a sequel to this paper,
Lee, Lifschitz and Palla (2008a) have applied the new definition and made the following refinements. The stable models of a formula are defined as Ferraris et al. (2007) were, while
the answer sets of a formula are those Herbrand models of the formula that are stable in
the sense of Ferraris et al. Using this new terminology, it follows that in general stable
models and equilibrium models coincide, while answer sets are equivalent to SNA-QHT
models that are equilibrium models.
In between these two extremes many syntactically different kinds of programs have
been considered and several variations in the concept of answer set have been proposed.
However all the main varieties display a similar correspondence to equilibrium logic. It is
merely necessary in some cases to restrict attention to specific kinds of equilibrium models, e.g. Herbrand models, UNA-models or SNA-models. It is important to notice also that
this correspondence extends to many of the additional constructs that have been introduced
934

fiInterpolable Formulas in Equilibrium Logic and Answer Set Programming

in ASP, such as cardinality and weight constraints and even general forms of aggregates (Lee
& Meng, 2009). All these can be accommodated in equilibrium logic by translation into
logical formulas.
In ASP the main emphasis is on finding answer sets and this is what most answer
set solvers compute. Less attention is placed on implementing a non-monotonic inference
relation or a query answering mechanism. However there is a standard, skeptical concept of
inference or entailment associated with answer set semantics. This notion of entailment or
consequence for programs under the answer set semantics is that a query Q is entailed by
a program  if Q is true in all answer sets of  (Balduccini, Gelfond, & Nogueira, 2000).
Let us denote this entailment or consequence relation by |AS . Evidently atoms are true in
an answer set if and only if they belong to it. Conjunctions and disjunctions are handled
in the obvious way (Lifschitz, Tang, & Turner, 1999; Balduccini et al., 2000). Sometimes,
queries of the form not a, or in logical notation a, are not explicitly dealt with (Balduccini
et al., 2000). However it seems to be in keeping with the semantics to regard a formula of
form not  or  to be true in an answer set if and only if  is not true. Another way
to express this would be to say that an answer set satisfies  if it does not violate the
constraint { }, understanding constraint violation as Lifschitz, Tang and Turner (1999).9
In this way we would say that  |AS A if no answer set of  contains A. Similarly, the
interpretation of queries containing quantifiers in answer set semantics should also conform
to that of equilibrium logic, taking account of any specific restrictions, such as Herbrand
models, that might be imposed.
We can therefore transfer interpolation properties from equilibrium logic to answer set
semantics and ASP. It remains to consider whether |AS is best identified with the closed
world version of inference, |cw , or the more open world version, |ow . Again, since ASP
solvers do not generally implement inference engines, the difference is largely a theoretical one. In traditional logic programming, however, a query that does not belong to the
language of the program is usually answered false. It also seems quite natural in an ASP
context that, given a program  and a query Q, one should consider the stable models of 
in the language L()  L(Q) even if this is a proper extension of the language of .10 So in
general |cw seems a natural choice for answer set inference. On the other hand, there are
contexts where answer set semantics is used in a more open world setting, for example in the
setting of hybrid knowledge bases (Rosati, 2005) where non-monotonic rules are combined
with ontologies formalised in description logics. For such systems a semantics in terms of
equilibrium logic was provided by de Bruijn, Pearce, Polleres and Valverde (2007). Here an
entailment relation in the style of |ow might sometimes be more appropriate.
In general answer set semantics is defined only for coherent programs or theories. For
these, by identifying |AS with |cw , we can apply Proposition 9 directly:
Corollary 2 For coherent formulas , (|, |)-interpolation in the form of Proposition 9
holds for entailment |AS in answer set semantics.
9. In logical terms this constraint would be written   .
10. Notice that by Proposition 12 if a program consists of safe formulas, an atomic query q(a) is automatically
false if a does not belong to the language of the program (even if q does), simply because grounding with
the program constants is sufficient to generate all answer sets.

935

fiGabbay, Pearce, & Valverde

7. An Application of Interpolation
The Interpolation property has been applied in various areas of computer science, notably
in software specification (Bicarregui et al., 2001) and in the construction of formal ontologies (Lutz & Wolter, 2010). In both areas it is relevant to modularity issues. Here we
discuss a simple application related to a concept described by Lutz and Wolter that we can
adapt to the case of nonmonotonic logic programs.
One way to compare two theories is via their nonmonotonic consequence relations. When
two theories produce the same answers for a given query language, we can call them inseparable; this term is used in mathematical logic and also in the study of formal ontologies (Lutz
& Wolter, 2010).
Let us say therefore that 1 and 2 are L-inseparable if for any  such that V ()  L,
1 |   2 | .
Proposition 14 Let 1 and 2 be L-inseparable theories such that V (1 ) = V (2 ) = V ,
say. Then for any L  L such that V  L  L, 1 and 2 are L -inseparable.
Proof. Assume that 1 and 2 are L-inseparable and that L is an extension of L such
that V  L  L. Suppose 1 | , where V () = L . Suppose L \ V = {B1 , . . . Bn }. By
Proposition 7 there is an interpolant  for (1 , ) such that  |= B1 . . .Bn  . Since
1 |  and V ()  L, by L-inseparability we have 2 | . By right absorption therefore
2 | B1  . . .  Bn  . However it is clear that B1 , . . . Bn are false in all equilibrium
models of 2 , so 2 | . Repeating this argument with 1 and 2 interchanged shows that
the theories are L -inseparable.

The above proof is similar to the argument given by Lutz and Wolter (2010) for Theorem 7 of that paper, applied to TBoxes in description logics. The property described is
called there robustness under signature extensions. Notice however that, since | is not in
general transitive we cannot immediately infer from 2 |  and  |  that also 2 | .
This highlights the added strength of using explicitly the set {B1 , . . . Bn } and the property
that HT forms a deductive basis for |.
In the study of modularity and logical relations between programs in ASP, it is more
common to compare their sets of answer sets rather than their consequence classes. However
it turns out that the notion of inseparability is very close to a concept that has already
been studied in ASP. Two theories or programs are said to be projectively equivalent if
the projections of their answer sets onto a common sublanguage agree (Eiter, Tompits,
& Woltran, 2005). Formally, let 1 , 2 be theories and L be a signature such that L 
V (1 )  V (2 ). Then 1 and 2 are said to be projectively equivalent relative to L if
E(1 )L = E(2 )L , where for any class of models K, KL = {ML : M  K}.
Proposition 15 Let 1 , 2 be theories and L a signature such that L  V (1 )  V (2 ).
1 and 2 are projectively equivalent relative to L if and only if they are L-inseparable.
In other words these two concepts agree whenever L is a common sublanguage of 1 , 2 .
The main advantage of L-inseparability is that it seems the more natural one to use if we
want to consider signatures that extend the language of either program or theory.
936

fiInterpolable Formulas in Equilibrium Logic and Answer Set Programming

8. Uniform Interpolation and Forgetting
A stronger form of interpolation known as uniform interpolation is also important for certain
applications in computer science (Konev et al., 2009). As usual, given ,  with   , we
are interested in interpolants  such that
 & 

(9)

where  contains only predicate and constant symbols that belong to both  and . The
difference now is that  is said to be a uniform interpolant if (9) holds for any  in the
same signature such that   . A logic is said to have the uniform interpolation property
if such uniform interpolants exist for all , .
In classical propositional logic, the uniform interpolation holds, however it fails in first
order classical logic and in many non-classical logics. It may hold when certain restrictions
are placed on the theory language in which  is formulated and on the query language
containing . For example it has been shown to hold for some description logics (Kontchakov
et al., 2008) where such syntactic restrictions apply. Even in ASP it turns out that a form of
uniform interpolation holds for a very restricted query language, essentially one that allows
just instance retrieval. We can show this by using some known results in ASP about the
concept of forgetting (Eiter & Wang, 2008) that is quite closely related to interpolation.
Variable forgetting, as studied by Eiter and Wang (2008), is concerned with the following
problem. Given a disjunctive logic program  and a certain atom a occurring in , construct
a new program, to be denoted by forget(, a), that does not contain a but whose answer
sets are in other respects as close as possible to those of . For the precise notion of
closeness the reader is referred to paper of Eiter and Wang, however some consequences will
be evident shortly. Eiter and Wang define forget(, a) (as a generic term), show that such
programs exist whenever  is coherent, and provide different algorithms to compute such
programs.
Given coherent  and a in , the results forget(, a), of forgetting about a in  may
be different but are always answer set equivalent. Moreover for our purposes they satisfy
the following key property, where  is coherent, a, b are distinct atoms in  and as usual |
denotes nonmonotonic consequence,
 | b



forget(, a) | b.

(10)

showing that indeed the answer sets of  and forget(, a) are closely related.
To establish a version of uniform interpolation for the case of disjunctive programs and
simple, atomic queries, we need to show that we can always find a  = forget(, a) such
that  |  . For this we can examine the first algorithm of Eiter and Wang for computing
forget(, a); this is also the simplest of the three algorithms presented. Let  be a coherent
program with rules of form (7) that we write as formulas of form (8) and let a be an atom
in . The method for constructing a  = forget(, a) is as follows.
1. Compute the equilibrium models E().
2. Let E  be the result of removing a from each M  E().
3. Remove from E  any model that is non-minimal to form E  (= {A1 , . . . , Am }, say).
937

fiGabbay, Pearce, & Valverde

4. Construct a program  whose answer sets are precisely {A1 , . . . , Am } as follows:
 for each Ai , set i = {Ai  a : a  Ai }, where Ai = V () \ Ai .
 Set  = 1  . . .  m .
We can now verify the desired property. Let L be the simple query language composed of
conjunctions of literals.
Proposition 16 In equilibrium logic (or answer set programming) uniform interpolation
holds for (coherent) disjunctive programs and queries in L(V ()).
Proof. To prove the claim we shall show the following. Let  be a coherent disjunctive
program and let L = L(V ) for some V  V (). Then there is a program  such that
V ( ) = V and for any   L,
 |   ( |  &  | )
To begin, let  and  be as above with  | . Let X = {a1 , . . . , an } = V () \ V . Then
we choose  to be the result of forgetting about X in , defined by Eiter and Wang (2008)
as follows:
forget(, X) := forget(forget(forget(, a1 ), a2 ), . . . , an ),
and it is shown there that the order of the atoms in X does not matter. Now we know
by (10) that for any atom a  V and any i = 1, n,
 | a  forget(, ai ) | a,

(11)

 | a  forget(, X) | a.

(12)

therefore
Let  be forget(, X) as determined by algorithm 1 of Eiter and Wang (2008) described
above. It is easy to see by (11) and the semantics of | that (12) continues to hold where a
is replaced by a negated atom b and therefore also by any conjunction of literals since a
conjunction is entailed only if each element holds in every equilibrium model.11 So it remains
to show that  |  . Again, it will suffice to show this entailment for one member of the
sequence forget(, ai ) and since the order is irrelevant wlog we can choose the first element
forget(, a1 ) and show that  | forget(, a1 ). We compute the programs 1 , . . . , m as
in the algorithm. Then we need to check that  | i for any i = 1, n, i.e. that for each
M  E(), M |= {Ai  a : a  Ai }.
Consider M  E() where M = hT, T i. We distinguish two cases. (i) Ai  T . Then
M |= a for each a  Ai . It follows that M |= Ai  a for each a  Ai and so
M |= {Ai  a : a  Ai }. Case (ii) Ai 6 T . Then T and Ai are incomparable. In
particular we cannot have T  Ai by the minimality property of Ai obtained in step 3.
Hence T  Ai 6= . Choose a  T  Ai . Then M |= a , so M 6|= a and hence M 6|= Ai .
Consequently, for any a , M |= Ai  a and so M |= {Ai  a : a  Ai }. It follows
that for any i,  | i and so by construction  |  , which establishes the proposition. 
11. As Eiter and Wang (2008) point out, if an atom b is true in some answer set of forget(, a), then it
must also be true in some answer set of , showing that (12) holds for literals.

938

fiInterpolable Formulas in Equilibrium Logic and Answer Set Programming

8.1 Extending the Query Language
If we establish uniform interpolation in ASP using the method of forgetting, as defined
by Eiter and Wang (2008), it seems clear that we cannot extend in a non-trivial way the
expressive power of the query language L. Since the method of forgetting a in  removes
non-minimal sets from E() (once a has been removed), an atom b might be true in some
equilibrium model of  but not in any equilibrium model of forget(, a). Hence we might
have a disjunction, say a  b, derivable from  but not from forget(, a). Likewise, if we
consider programs with variables in a first-order setting, we cannot in general extend L to
include existential queries.
On the other hand, the property of uniform interpolation certainly holds for any L(V )
even without the condition that V  V (). Suppose that  |  where V () \ V () 6= ,
say V () \ V () = {b1 , . . . , bk }. Then b1 , . . . , bk are false in all equilibrium models of .
Trivially, if b is not in V () we can regard the result of forgetting about b in  as just . So
we can repeat the proof of Proposition 16, but now setting X = {V () \ V }  {V \ V ()}.
All the relevant properties will continue to hold.
An interesting open question is whether we can extend the theory language to include
more general kinds of program rules such as those allowing negation in the head. Accommodating these kinds of formulas would constitute an important generalisation since they
amount to a normal form in equilibrium logic. However, the answer sets of such programs do
not satisfy the minimality property that holds for the answer sets of disjunctive programs,
so it is clear that the definition of forgetting would need to be appropriately modified - a
task that we do not attempt here.

9. Literature and Related Work
The interpolation theorem for classical logic is due to Craig (1957); it was extended to intutionistic logic by Schutte (1962). Maksimova (1977) characterised the super-intuitionistic
propositional logics possessing interpolation. A modern, comprehensive treatment of interpolation in modal and intuitionistic logics can be found in the monograph of Gabbay and
Maksimova (2005).
In non-monotonic logics, interpolation has received little attention. A notable exception
is an article (Amir, 2002) establishing some interpolation properties for circumscription and
default logic. By the well-known relation between the answer sets of disjunctive programs
and the extensions of corresponding default theories, he also derives a form of interpolation
for ASP. With regard to answer set semantics, the approach of Amir is quite different from
ours. Since it is founded on an analysis of default logic, it uses classical logic as an underlying
base. So Amirs version of interpolation is a form of (3) where L is classical logic; there is
no requirement that L form a well-behaved sublogic of |, e.g. a deductive base. As Amir
remarks, one cannot deduce in general from property (4) that | . However if L is classical
logic one cannot even deduce  |  from (3). More generally, there is no counterpart to
our Proposition 1 in this case. Another difference with respect to our approach is that
Amir does not discuss the nature of the | relation for ASP in detail, in particular how
to understand  |  in case  contains atoms not present in the program . In fact, if
we interpret |AS as in Section 6 above, it is easy to refute (|, L )-interpolation where L
is classical logic. Let  be the program B  A and q the query B  C. Then clearly
939

fiGabbay, Pearce, & Valverde

 |AS q, but there is no formula in the vocabulary B that would classically entail C.
Under any interpretation of answer set inference such that atoms not in the program are
regarded as false, (|, L )-interpolation would be refuted.

10. Conclusions
We have discussed two kinds of interpolation properties for non-monotonic inference relations and shown that these properties hold in turn for the two different inference relations
that we can associate with propositional equilibrium logic. In each case we use the fact that
the collection of equilibrium models is definable in the logic HT of here-and-there and that
this logic possesses the usual form of interpolation. One of the forms of inference studied
seems to be in many cases an appropriate concept to associate with answer set programming, although in general ASP systems are not tailored to query answering or deduction.
Using results of Eiter and Wang (2008) about variable forgetting in ASP, we could also show
how the property of uniform interpolation holds for disjunctive programs and a restricted
query language.
We have also discussed the interpolation property for first-order equilibrium logic based
on a quantified version QHT of the logic of here-and-there, obtaining analogous results as
for the propositional case whenever the collection of equilibrium models is definable. These
positive results transfer to answer set programming under the assumption usually made in
ASP systems that programs are safe and therefore have definable collections of answer sets.
As we saw, the notion of safety can be quite generally defined for theories and is not limited
to normal or disjunctive programs.

Acknowledgments
David Pearce is partially supported by MEC projects TIN2009-14562-C05-02 and CSD200700022. Agustn Valverde is partially supported by MEC project TIN2009-14562-C05-01, and
Junta de Andalucia projects P09-FQM-05233 and TIC-115. The authors are grateful to the
anonymous referees for helpful comments.

References
Amir, E. (2002). Interpolation theorems for nonmonotonic reasoning systems.. In Proceedings of NMR02, pp. 4150.
Balduccini, M., Gelfond, M., & Nogueira, M. (2000). A-prolog as a tool for declarative
programming. In Proc. of SEKE 2000).
Baral, C. (2003). Knowledge Representation, Reasoning and Declarative Problem Solving.
Cambridge University Press.
Bicarregui, J., Dimitrakos, T., Gabbay, D. M., & Maibaum, T. S. E. (2001). Interpolation
in practical formal development. Logic Journal of the IGPL, 9 (2).
Bria, A., Faber, W., & Leone, N. (2008). Normal form nested programs. In Holldobler, S.,
Lutz, C., & Wansing, H. (Eds.), Proc. of JELIA08, Vol. 5293 of LNCS, pp. 7688.
Springer.
940

fiInterpolable Formulas in Equilibrium Logic and Answer Set Programming

Cabalar, P., Pearce, D., & Valverde, A. (2009). A revised concept of safety for general answer
set programs. In Erdem, E., Lin, F., & Schaub, T. (Eds.), Proc. of LPNMR09, Vol.
5753 of LNCS, pp. 5870. Springer.
Craig, W. (1957). Linear reasoning. a new form of the herbrand-gentzen theorem.. J. Symb.
Logic, 22, 250268.
de Bruijn, J., Pearce, D., Polleres, A., & Valverde, A. (2007). Quantified equilibrium logic
and hybrid rules. In Marchiori, M., Pan, J. Z., & de Sainte Marie, C. (Eds.), Proc. of
RR07, Vol. 4524 of LNCS, pp. 5872. Springer.
Diaconescu, R., Goguen, J., & Stefaneas, P. (1993). Logical support for modularisation. In
Logical Environments, pp. 83130. Cambridge University Press.
Dietrich, J. (1994). Deductive bases of nonmonononic inference operations. Ntz report,
University of Leipzig.
Eiter, T., Tompits, H., & Woltran, S. (2005). On solution correspondences in answer-set
programming.. In Kaelbling, L. P., & Saffiotti, A. (Eds.), Proc. of IJCAI05, pp.
97102. Professional Book Center.
Eiter, T., & Wang, K. (2008). Semantic forgetting in answer set programming. Artificial
Intelligence, 172 (14), 16441672.
Ferraris, P. (2008). Logic programs with propositional connectives and aggregates. CoRR,
abs/0812.1462.
Ferraris, P., Lee, J., & Lifschitz, V. (2007). A new perspective on stable models. In Veloso,
M. M. (Ed.), Proc. of IJCAI07, pp. 372379.
Gabbay, D. M., & Maksimova, L. (2005). Interpolation and Definability: Modal and Intuitionistic Logic. Oxford University Press, USA.
Gelder, A. V., Ross, K. A., & Schlipf, J. S. (1991). The well-founded semantics for general
logic programs. Journal of ACM, 38 (3), 620650.
Gelfond, M., & Lifschitz, V. (1988). The stable model semantics for logic programming.
In Kowalski, R. A., & Bowen, K. (Eds.), Proc. of ICLP88, pp. 10701080. The MIT
Press.
Gelfond, M., & Lifschitz, V. (1990). Logic programs with classical negation. In Warren,
David H.D.; Szerdei, P. (Ed.), Proc. of ICLP90, pp. 579597. MIT Press.
Gelfond, M., & Lifschitz, V. (1991). Classical negation in logic programs and disjunctive
databases. New Generation Computing, 9, 365385.
Konev, B., Walther, D., & Wolter, F. (2009). Forgetting and uniform interpolation in largescale description logic terminologies. In Boutilier, C. (Ed.), Proc. of IJCAI09, pp.
830835.
Kontchakov, R., Wolter, F., & Zakharyaschev, M. (2008). Can you tell the difference
between dl-lite ontologies?. In Brewka, G., & Lang, J. (Eds.), Principles of Knowledge
Representation and Reasoning: Proc. of KR08, pp. 285295. AAAI Press.
Kunen, K. (1987). Negation in logic programming. Journal of Logic Programming, 4 (4),
289308.
941

fiGabbay, Pearce, & Valverde

Lee, J., Lifschitz, V., & Palla, R. (2008a). A reductive semantics for counting and choice in
answer set programming. In Fox, D., & Gomes, C. P. (Eds.), Proc. of AAAI08, pp.
472479. AAAI Press.
Lee, J., Lifschitz, V., & Palla, R. (2008b). Safe formulas in the general theory of stable
models (preliminary report). In de la Banda, M. G., & Pontelli, E. (Eds.), Proc. of
ICLP08, Vol. 5366 of LNCS, pp. 672676. Springer.
Lee, J., & Meng, Y. (2009). On reductive semantics of aggregates in answer set programming. In Erdem, E., Lin, F., & Schaub, T. (Eds.), Proc. of LPNMR09, Vol. 5753 of
LNCS, pp. 182195. Springer.
Lifschitz, V., Pearce, D., & Valverde, A. (2001). Strongly equivalent logic programs. ACM
Transactions on Computational Logic, 2 (4), 526541.
Lifschitz, V., Pearce, D., & Valverde, A. (2007). A characterization of strong equivalence
for logic programs with variables. In Baral, C., Brewka, G., & Schlipf, J. S. (Eds.),
Proc. of LPNMR07, Vol. 4483 of LNCS, pp. 188200. Springer.
Lifschitz, V., Tang, L. R., & Turner, H. (1999). Nested expressions in logic programs. Annals
of Mathematics and Artificial Intelligence, 25 (34), 369389.
Lutz, C., & Wolter, F. (2010). Deciding inseparability and conservative extensions in the
description logic el. Journal of Symbolic Computation, 45 (2), 194228.
Maher, M. J. (1988). Equivalences of logic programs. In Foundations of Deductive Databases
and Logic Programming., pp. 627658. Morgan Kaufmann.
Makinson, D. (1994). General patterns in nonmonotonic reasoning, pp. 35110. Oxford
University Press, Inc.
Maksimova, L. (1997). Interpolation in superintuitionistic predicate logics with equality.
Algebra and Logic, 36, 543561.
Maksimova, L. (1998). Interpolation in superintuitionistic and modal predicate logics with
equality. In M.Kracht, de Rijke, M., Wansing, H., & Zakharyaschev, M. (Eds.), Advances in Modal Logic, Vol. I, pp. 133141. CSLI Publications.
Maksimova, L. (1977). Craigs interpolation theorem and amalgamable varieties. Doklady
Akademii Nauk SSSR, 237 (6), 12811284.
McMillan, K. L. (2005). Applications of craig interpolants in model checking. In Halbwachs,
N., & Zuck, L. D. (Eds.), Proc. of TACAS05, Vol. 3440 of LNCS, pp. 112. Springer.
Ono, H. (1983). Model extension theorem and craigs interpolation theorem for intermediate
predicate logics. Reports on Mathematical Logic, 15, 4158.
Pearce, D. (1997). A new logical characterization of stable models and answer sets. In Dix,
J., Pereira, L. M., & Przymusinski, T. C. (Eds.), Proc. of NMELP96, Vol. 1216 of
LNCS, pp. 5770. Springer.
Pearce, D. (2006). Equilibrium logic. Annals of Mathematics and Artificial Intelligence,
47 (1-2), 341.
Pearce, D., de Guzman, I. P., & Valverde, A. (2000). Computing equilibrium models using
signed formulas. In Proc. of CL2000, Vol. 1861 of LNCS, pp. 688703. Springer.
942

fiInterpolable Formulas in Equilibrium Logic and Answer Set Programming

Pearce, D., & Valverde, A. (2005). A first order nonmonotonic extension of constructive
logic. Studia Logica, 80 (2-3), 321346.
Pearce, D., & Valverde, A. (2006). Quantified equilibrium logic. Technical report, Universidad Rey Juan Carlos. (http://www.matap.uma.es/investigacion/tr/ma06_02.
pdf).
Pearce, D., & Valverde, A. (2008). Quantified equilibrium logic and foundations for answer
set programs. In de la Banda, M. G., & Pontelli, E. (Eds.), Proc. of ICLP08, Vol.
5366 of LNCS, pp. 546560. Springer.
Pearce, D., & Valverde, A. (2012). Synonymous theories and knowledge representations in
answer set programming. Journal of Computer and System Sciences, 78, 86104.
Rosati, R. (2005). Semantic and computational advantages of the safe integration of ontologies and rules. In Fages, F., & Soliman, S. (Eds.), Proc. of PPSWR05, Vol. 3703
of LNCS, pp. 5064. Springer.
Schutte, K. (1962). Der interpolationsatz der intuitionistischen pradikatenlogik.. Math.
Ann., 148, 192200.
van Dalen, D. (1997). Logic and Structure (3th edition). Springer.

943

fi