Journal of Artificial Intelligence Research 30 (2007) 501-523

Submitted 06/07; published 12/07

On the Semantics of Logic Programs with Preferences
Sergio Greco

greco@deis.unical.it

DEIS, Universita della Calabria
via P. Bucci, 87030 Rende - Italy

Irina Trubitsyna

irina@deis.unical.it

DEIS, Universita della Calabria
via P. Bucci, 87030 Rende - Italy

Ester Zumpano

zumpano@deis.unical.it

DEIS, Universita della Calabria
via P. Bucci, 87030 Rende - Italy

Abstract
This work is a contribution to prioritized reasoning in logic programming in the presence
of preference relations involving atoms. The technique, providing a new interpretation for
prioritized logic programs, is inspired by the semantics of Prioritized Logic Programming
and enriched with the use of structural information of preference of Answer Set Optimization Programming. Specifically, the analysis of the logic program is carried out together
with the analysis of preferences in order to determine the choice order and the sets of
comparable models. The new semantics is compared with other approaches known in the
literature and complexity analysis is also performed, showing that, with respect to other
similar approaches previously proposed, the complexity of computing preferred stable models does not increase.

1. Introduction
The increased interest in preferences is witnessed by an extensive number of proposals and
systems for preference handling (Grell, Konczak, & Schaub, 2005; Van Nieuwenborgh &
Vermeir, 2003; Wakaki, Inoue, Sakama, & Nitta, 2003, 2004). The literature distinguishes
static from dynamic preferences. Static preferences are fixed at the time a theory is specified, i.e. they are external to the logic program, whereas dynamic preferences appear
within the logic program and are determined on the fly. The most common form of
preference consists in specifying preference conditions among rules (Brewka, 1996; Brewka
& Eiter, 1999, 2000; Delgrande, Schaub, & Tompits, 2000a, 2000b, 2003; Gelfond & Son,
1997; Schauba & Wang, 2001; Van Nieuwenborgh & Vermeir, 2002, 2004; Wang, Zhou, &
Lin, 2000; Zhang & Foo, 1997), whereas, some recent proposals admit the expression of
preference relations among atoms (Brewka, Niemela, & Truszczynski, 2003; Brewka, 2004;
Sakama & Inoue, 2000; Wakaki et al., 2003). More sophisticated forms of preferences also
allow the specification of priorities between conjunctions (disjunctions) of literals (Brewka
et al., 2003; Delgrande et al., 2000a; Sakama & Inoue, 2000) and numerical penalties for
suboptimal options (Brewka, 2004).
This work is a contribution to prioritized reasoning in logic programming in the presence
of preference conditions involving atoms. In particular, priorities are applied by following
the natural ordering defined by dependencies, as proposed in the Answer Set Optimizac
2007
AI Access Foundation. All rights reserved.

fiGreco, Trubitsyna, & Zumpano

tion (ASO) semantics (Brewka et al., 2003), and the comparison strategy, proposed in the
Preferred Stable Model (PSM) semantics (Sakama & Inoue, 2000), is reviewed by also introducing the concept of comparable models. The next example describes the intuition at
the basis of the proposed approach.
Example 1 The following prioritized program hP 1 , 1 i, inspired by a program presented
by Brewka et al. (2003), describes different menus and the preferences among drinks and
desserts:
P1 :

fish  beef 
red  white 
pie  ice-cream 
 fish, white
 beef, pie
 fish, ice-cream

1 :

%1 : white > red  fish
%2 : red > white  beef
%3 : pie > ice-cream  red

The symbol  denotes exclusive disjunction, i.e. if the body of the rule is true exactly
one atom in the head is true, whereas a rule with empty head defines a constraint, i.e. a
rule which is satisfied only if the body is false. The first three rules of P 1 select the main
dish, the drink and the dessert; the last three rules are constraints and state that a feasible
solution cannot contain i) fish and white or ii) beef and pie or iii) fish and ice-cream.
Prioritized rules in 1 introduce preferences among drinks (%1 , %2 ) and desserts (%3 ).
The program P 1 has three stable models: M1 = {fish, red, pie}, M2 = {beef, white,
ice-cream} and M3 = {beef, red, ice-cream}. The PSM returns M1 as the unique preferred model; whereas the ASO technique, following the natural ordering of preference rules
(%1 and %2 precede %3 ), derives that M3 is the unique solution. Thus, the two approaches
provide different results.
2
The structure of preference rules in the above example suggests that i) fish and beef are
alternative options for the main dish and ii) the choice of drink depends on the selected main
dish and precedes the choice of dessert. The second conclusion is based on the observation
that %1 and %2 provide opposite valuations of the choice of drink and they define two different
classes of models (menus), which should be considered separately. In other words, the model
M1 (associated with the menu containing fish) should not be compared with the models
M2 and M3 (associated with the menus containing beef). Consequently, both M1 and M3
should be preferred.
Observe that in the above example the PSM semantics derives that M1 is the preferred
model as M1 is preferable to M3 (due to the presence of rule %3 ), M3 is preferable to M2
(due to the presence of rule %2 ) and, transitively, that M1 is also preferable to M2 . It is
worth noting that the use of the transitive closure makes the comparison of models much
more complex as two models cannot be compared directly. On the other hand the ASO
semantics is sensitive to syntactic changes of programs. This fact is illustrated by means of
the following example.
Example 2 Consider the prioritized program hP2 , 2 i, an extension of the prioritized program defined in Example 1:
502

fiOn the Semantics of Logic Programs with Preferences

P2 :

fish  beef 
red  white  beer 
pie  ice-cream 
 fish, white
 beef, pie
 fish, ice-cream
 beer

2 :

%b1 : beer > white > red  fish
%b2 : beer > red > white  beef
%b3 : pie > ice-cream  red

This program is equivalent to the one reported in Example 1 as, even if it contains an additional choice (beer), this option is not feasible, for the presence of the constraint  beer.
The set of stable models associated with the program P2 , coincides with those reported
for the program P 1 in Example 1, and consists of: M1 = {fish, red, pie}, M2 = {beef,
white, ice-cream} and M3 = {beef, red, ice-cream}. Considering the set of preference
rules, note that both preferences regarding the choice of drink have beer as the best option,
but there is no stable model containing it. Intuitively, as the two problems hP 1 , 1 i in Example 1 and hP2 , 2 i are equivalent they must have the same preferred models. The ASO
semantics is sensitive to the program change and gives M1 and M3 as a solution, whereas,
for the equivalent program in Example 1, the returned preferred model is M3 only. No
change occurs in the set of preferred models for the PSM semantics.
2
Thus, in this paper we present a new semantics, inspired by the PSM and ASO semantics, which seems to better capture the intuitive meaning of programs and avoids the above
mentioned problems.
1.1 Contribution
The paper provides a new semantics for prioritized logic programs enriching the one proposed by Sakama and Inoue (2000) with additional information gained from the structure
of preference rules as proposed by Brewka et al. (2003). In particular, the new semantics
uses different preference relations among stable models and introduces a natural ordering
among preferences that fixes the order of choices, on the basis of the stratification of the
preference program. Each decision is determined by the set of choices belonging to the
corresponding level and provides the subset of models given in input as solution. Once a
decision is made, this output subset becomes the input set of the following decision and so
on. The proposed semantics drives the decision making process taking into account catching
additional information regarding non comparable sets of models so partitioning the set of
models of the program by looking at their alternative decisions. To this end the concept of
incomparability, not taken into account by previous approaches, is introduced.
The paper presents a detailed comparison of the approaches dealing with preference
relations among atoms. Particular attention is devoted to the PSM and the ASO semantics.
The analysis of the complexity of computing preferred answer sets is also performed, showing
that, w.r.t. previous proposals, such as the PSM and the ASO semantics, the complexity
of computing preferred stable models does not increase.
503

fiGreco, Trubitsyna, & Zumpano

1.2 Plan Of The Paper
The rest of the paper is organized as follows: in Section 2 preliminaries on Disjunctive
and Abductive Logic Programs, Prioritized Logic Programs and Answer Set Optimization
semantics are given; in Section 3 a new interpretation for prioritized logic programs is
presented; in Section 4 complexity results are provided; in Section 5 a comparison of the
presented semantics with the PSM and ASO semantics is performed, and other approaches,
known in the literature, are briefly described; finally, Section 6 outlines our conclusions.

2. Preliminaries
We assume familiarity with relational database theory, disjunctive logic programs, disjunctive deductive databases, (disjunctive) stable model semantics and computational complexity (Eiter, Gottlob, & Mannila, 1997b; Gelfond & Lifschitz, 1988, 1991; Papadimitriou,
1994).
2.1 Background
A (disjunctive) logic program is a finite set of rules r of the form a1      ak  b1 , ..., bm ,
not c1 , ..., not cn with k + m + n > 0, where a1 , ..., ak , b1 , ..., bm , c1 , ..., cn are atoms. The
disjunction a1      ak , denoted by head(r), is called head of r, while the conjunction
b1 , ..., bm , not c1 , ..., not cn , denoted by body(r), is called body of r.
The Herbrand Universe UP of a program P is the set of all constants appearing in P 1 ,
and its Herbrand Base BP is the set of all ground atoms constructed from the predicates
appearing in P and the constants from UP . A term (resp. an atom, a rule or a program) is
ground if no variables occur in it. A rule r0 is a ground instance of a rule r, if r0 is obtained
from r by replacing every variable in r with some constant in UP ; ground(P) denotes the
set of all ground instances of the rules in P.
The intuitive meaning of the previous disjunctive rule is that if body(r) is true, i.e.
b1 , ..., bm are true and c1 , ..., cn are false, then head(r) must be true, i.e at least one of
a1 , ..., ak has to be true (otherwise r is not satisfied). Rules with empty head, called denials
or constraints, will be used to define constraints and are satisfied only if the body is false. In
this paper exclusive disjunction, denoted by , is used in the head; the statement head(r) =
a1  ...  ak is true, if exactly one of a1 , ..., ak is true, i.e. a disjunctive rule of the form
a1      ak  body is a shorthand for the rule a1      ak  body and (k  (k  1)/2)
constraints of the form  ai , aj , body with 1  i < j  k. The solution of a logic program P
is given in terms of stable model (answer set) semantics (Gelfond & Lifschitz, 1988, 1991).
An interpretation M for P is a model of P if M satisfies all rules in ground(P). The
minimal model semantics, defined for positive P, assigns to P the set of its minimal models
MM(P), where a model M for P is minimal, if no proper subset of M is a model for P
(Minker, 1982). The more general disjunctive stable model semantics also applies to programs with (unstratified) negation (Gelfond & Lifschitz, 1991). Disjunctive stable model
semantics generalizes stable model semantics, previously defined for normal programs (Gelfond & Lifschitz, 1988). For any interpretation M , denote with P M the ground positive
program derived from ground(P) by i) removing all rules that contain a negated atom
1. We are considering function free programs.

504

fiOn the Semantics of Logic Programs with Preferences

not a in the body and a  M , and ii) removing all negated atoms from the remaining rules.
An interpretation M is a (disjunctive) stable model of P if and only if M  MM(P M ).
For general P, the stable model semantics assigns to P the set SM(P) of its stable models. It is well known that stable models are minimal models (i.e. SM(P)  MM(P))
and that for negation free programs, minimal and stable model semantics coincide (i.e.
SM(P) = MM(P)).
2.2 Extended And Abductive Programs
Given an atom p(t), a literal is either p(t) or its strong negation p(t). An extended
program is a program where atoms are replaced by literals. The semantics of extended
disjunctive programs can also be given in terms of stable models by considering p and p as
different predicate symbols and considering the implicit constraint  p(X), p(X) (Gelfond
& Lifschitz, 1991).
Abductive logic programming is an extension of logic programming to perform abductive
reasoning (Kakas, Kowalski, & Toni, 1992; Inoue & Sakama, 1998). An abductive program
(ALP) is a pair hP, Ai, where P is an extended program and A is a set of literals called
abducibles. hP, Ai can be represented by means of an extended program  = P  {g(t) 
g 0 (t)  | g(t)  A}  {g 0 (t)  not g(t) | g(t)  A}.
Let  be an ALP and G a ground atom denoting an observation. Then, a set S  A is an
explanation of G iff there is a stable model M of  such that S = M A and G  M ; a stable
model M is A-minimal if there is no stable model N such that N  A  M  A. Moreover,
S is a minimal explanation (i.e. there is no explanation S 0  S) of G iff   { not G} has
a consistent A-minimal stable model M such that S = M  A (Inoue & Sakama, 1998).
It has been shown that given an ALP P and a ground atom G denoting an observation,
deciding whether there exists a A-minimal explanation S for G is p3 -complete (Eiter,
Gottlob, & Leone, 1997a).
The rest of this section will briefly review the two main approaches for prioritizing reasoning we refer to, i.e. Prioritized Logic Programs and Answer Set Optimization, proposed,
respectively, by Sakama and Inoue (2000) and Brewka et al. (2003).
2.3 Prioritized Logic Programs
A (partial) preference relation  among atoms is defined as follows: given two atoms e1
and e2 , the statement e1  e2 (called priority) means that e1 has higher priority than e2 .
Moreover, if e1  e2 and e2  e3 , then e1  e3 . A priority statement e1  e2 states that for
each a1 instance of e1 and for each a2 instance of e2 the preference relation a1  a2 holds.
A prioritized logic program (PLP) is a pair hP, i where P is a disjunctive program and 
is a set of priorities.  denotes the set of priorities which can be reflexively or transitively
derived from .
The statement e1  e2 stands for e1  e2 and e2 6 e1 . Clearly, if e1  e2 , the sets of
ground instantiations of e1 and e2 have an empty intersection.
Definition 1 Given a prioritized logic program hP, i, the relation w is defined over the
stable models of P as follows. For any stable models M1 , M2 and M3 of P:
505

fiGreco, Trubitsyna, & Zumpano

1. M1 w M1 ,
2. M1 w M2 if e1  M1  M2 , e2  M2  M1 such that (e1  e2 )   and 6 e3 
M2  M1 such that (e3  e1 )   ,
3. if M1 w M2 and M2 w M3 , then M1 w M3 .
If M1 w M2 then M1 is preferable to M2 . Moreover, if M1 w M2 and M2 6w M1 then
M1 = M2 .
2
An interpretation M is a preferred stable model of hP, i if M is a stable model of P and
N w M implies M w N for any stable model N (equivalently, if there is no interpretation N
which is a stable model of P and N = M ). The set of preferred stable models of hP, i will
be denoted by PSM(hP, i). Note that the relation 1  2 between two PLPs hP, 1 i
and hP, 2 i does not imply PSM(hP, 2 i)  PSM(hP, 1 i).
In PLP priority relations are used to express priorities over atoms, whereas priorities over
more general forms of knowledge (conjunctive, disjunctive knowledge, rules, preconditions)
can be expressed by a simple rewriting of the preference program. For instance, a preference
rule with precondition of the form (e1  e2 )  B is expressed in PLP as e01  e02 , where
e01  e1 , B and e02  e2 , B.
The semantics of prioritized programs proposed by Sakama and Inoue (2000) will be
denoted by PSM semantics. A sound and complete procedure that allows preferred answer
sets for a PLP program to be computed using a generate and test algorithm has been
proposed by Wakaki et al. (2003). This algorithm translates a PLP program hP, i and
any answer set S of the program P into a single logic program T [P, , S], such that its
answer sets are answer sets of P preferable to S. More details can be found in works
presenting the semantics and the implementation (Sakama & Inoue, 2000; Wakaki et al.,
2004).
The complexity of answering queries over PLP programs is at least one level above
the complexity of answering queries over standard programs (without preferences). In
particular, let hP, i be a prioritized logic program, then i) deciding the existence of a
preferred stable model is p2 -hard; ii) deciding whether an atom is true in some (resp. all)
preferable stable model of hP, i is p3 -hard (resp. p3 -hard). It is worth noting that in the
original work (Sakama & Inoue, 2000) it has been claimed that the complexity is exactly one
level above the complexity of standard programs, but the proof does not take into account
the transitivity property of the preference relation.
2.4 Answer Set Optimization
An answer set optimization program, denoted as ASO program, is a pair hP, i, where P is
a disjunctive program, called Generating Program, and  is a Preference Program consisting
of a finite set of rules of the form: a1 >    > ak  b1 , ..., bm , not c1 , ..., not cn where bi s and cj s
are literals and ai s are boolean combinations2 of literals; here a literal is either an atom L or
its (strong) negation L.  determines a preference ordering on the answer sets described
by the generating program P.
2. A boolean combination is a formula built of atoms by means of disjunctions, conjunctions, and default
negation.

506

fiOn the Semantics of Logic Programs with Preferences

Definition 2 Let hP, i be an ASO program where  = {%1 , ..., %n } and S be an answer
set of P, then S induces a satisfaction vector VS = (vS (%1 ), ..., vS (%n )) where:
 vS (%j ) = I, if %j is Irrelevant to S, i.e. i) the body of %j is not satisfied in S or ii) the
body of %j is satisfied, but none of the atoms in the head of %j is satisfied in S.
 vS (%j ) = min{i | S |= ai %j = a1 >    > ak  b1 , .., bm , not c1 , .., not cn }, otherwise. 2
In the comparison of models it is assumed that I is equal to 1 (i.e., vS (%j ) = I is
equivalent to vS (%j ) = 1).
Definition 3 Let S1 and S2 be two answer sets, then i) VS1  VS2 if vS1 (%i )  vS2 (%i ) for
every i  [1..n]; ii) VS1 < VS2 if VS1  VS2 and for some i  [1..n] vS1 (%i ) < vS2 (%i ). In these
cases S1 w S2 and S1 = S2 3 , respectively.
A set of literals S is an optimal model of an ASO program hP, i if S is an answer set
of P and there is no answer set S 0 of P such that S 0 = S.
2
The complexity of ASO programs depends on the class of generating programs. For
disjunctive programs the complexity of answering queries over ASO programs is exactly
one level above the complexity of answering queries over standard programs (without preferences), i.e. i) deciding the existence of a preferred stable model is p2 -complete; ii) deciding
whether a literal is true in some (resp. all) preferable stable model of hP, i is p3 -complete
(resp. p3 -complete).
The strategy is further extended by introducing meta-preferences among preference
rules: a ranked ASO program is a sequence hP, 1 , ..., n i consisting of a generating program
P and a sequence of pairwise disjoint preference programs i . The rank of a rule % 
1      n , denoted rank(%), is the unique integer i for which %  i . Given two answer
sets S1 and S2 , S1 wrank S2 if for every preference rule %0 such that vS1 (%0 )  vS2 (%0 ) does
not hold, there is a rule %00 such that rank(%00 ) < rank(%0 ) and vS1 (%00 ) < vS2 (%00 ).
Moreover, a procedure deriving the natural ordering of the preference rules is introduced.
Firstly, given a preference program , its dependency graph G() is defined. The atoms
appearing in  form the vertex set of G(). There is a directed edge from a vertex b to a
vertex a in G() if there is a rule % in  such that a appears in the head of r and b appears
in the body of r. If the graph G() is acyclic, there is a natural ranking of its atoms which
can be defined recursively as follows: rank(a) = 0 for every atom a that has no predecessors
in G(); otherwise rank(a) is the maximum of the ranks of all predecessors of a in G()
incremented by 1. The rank of a preference rule % is then defined as the maximum rank of
atoms in its head.
The standard semantics of ASO programs, where priorities are examined all together,
will be denoted as ASO semantics. The alternative semantics, where priorities are divided
into strata following the natural order, will be denoted by RASO (ranked ASO) semantics.
3. In the original work (Brewka et al., 2003) the symbols  and > are used instead of w and =.

507

fiGreco, Trubitsyna, & Zumpano

3. Preferred Answer Sets
In this paper a syntax similar to the one proposed by Brewka et al. (2003) is used. Given
two atoms a1 and a2 , the statement a2 > a1 means that a2 has higher priority than a1 . A
(partial) preference relation > among atoms is defined as follows.
Definition 4 A prioritized program  is a pair hP, i where P is a disjunctive program
and  is set of preference rules of the form:
a1 > a2 >    > ak  b1 , ..., bm , not c1 , ..., not cn
where k > 1 and a1 , ..., ak , b1 , ..., bm , c1 , ..., cn are atoms.

(1)
2

In the following the head and body of a preference rule % will be denoted by head(%)
and body(%), respectively. A ground prioritized program, denoted by ground(hP, i) =
hground(P), ground()i is a prioritized program, where each rule r  (P  ) with variables
is replaced with the set of its ground instances, i.e the set of rules obtained by replacing
variables with constants.
Intuitively, a preference rule % of the form (1) describes the choice among a1 , ..., ak
(choice options) under the condition specified by the body of %. The head of % introduces
the preference order among atoms: ai is preferred to aj for 1  i < j  k. As % can be
applied only if body(%) is true, the body of % specifies the decisions which have to precede
this choice. For instance, a > c  b states that if b is true, then a is preferred to c. A
preference rule with exactly two atoms in the head will be called binary preference rule,
whereas preference rules with empty bodies will be called preference facts. A prioritized
program is said to be in binary form if all its preference rules are binary.
The following example, presenting a classical program proposed by Brewka et al. (2003),
will be used as running example.
Example 3 Consider the prioritized program hP 3 , 3 i whose stable models define the
menus of a restaurant:
P 3:

fish  beef 
red  white  beer 
pie  ice-cream 
 beef, pie
 fish, ice-cream

3 :

%1
%2
%3
%4

:
:
:
:

white > red > beer  fish
red > white  beef
beer > white  beef
pie > ice-cream  beer

The first three rules of P 3 select the main dish, the drink and the dessert; the constraints
state that a feasible solution cannot contain both beef and pie or both fish and ice-cream;
while the rules in 3 introduce preferences among drinks and desserts.
The program P 3 has six stable models:
M1 = {fish, white, pie}
M2 = {fish, red, pie}
M3 = {fish, beer, pie}

M4 = {beef, white, ice-cream}
M5 = {beef, red, ice-cream}
M6 = {beef, beer, ice-cream}

Both techniques proposed by Sakama and Inoue (2000) and Brewka et al. (2003) select
the stable models M1 and M5 as preferred ones, but the motivation is different. Indeed,
the PSM semantics states that M1 w M2 w M3 w M6 w M4 and M5 w M4 , whereas the
508

fiOn the Semantics of Logic Programs with Preferences

(R)ASO semantics states that Mi w M2 w M3 , Mi w M6 and Mi w M4 for i  {1, 5}, i.e. in
the (R)ASO semantics the models M1 and M6 are compared directly, whereas in the PSM
semantics the models M1 and M6 are compared transitively.
2
Before presenting the formal semantics of programs, some preliminary definitions are
needed. A preference rule of the form a1 > a2 >    > ak  body is shorthand for the k  1
binary rules of the form ai > ai+1  body, with i  [1..k  1] and the set of preferences
established by  is given by its transitive closure  defined as follows:
Definition 5 Given a prioritized program hP, i, the (ground) transitive closure of  is
 = 0  {a > c  body1 , body2 | a > b  body1    b > c  body2    a 6= c},
where 0 is the set of binary preference rules derived from ground().
2
Thus,  is defined as the set of rules explicitly representing the preference relations
among choice options. In Section 4 we will show that any ground prioritized program
 = hP, i can be rewritten into an equivalent program  = hP, i such that  contains
a number of rules which is polynomial in the size of .
The structure of prioritized programs can be examined in order to establish the precedence relation among choices made. For instance, the presence of the preference rule
a > c  b suggests that the selection of b precedes the choice between a and c and thus
establishes the precedence relation between {b} and {a, c}. This idea was used by Brewka
et al. (2003) for determining the natural ordering among preference rules. In more detail,
the relational order among atoms appearing in  was captured by means of the corresponding dependency graph G(); and the stratification of preference rules was established by
considering their head atoms.
Unfortunately, the natural ordering among the preference rules can be established only if
the corresponding dependency graph is acyclic. Thus, the presence of two rules coffee >
tea  pie and pie > ice-cream  coffee in  does not admit the stratification of ,
as they introduce two mutually dependent choices.
The stratification algorithm proposed in this paper overcomes this problem by introducing the concept of collapsed graph, which maps to the same node the options of mutually
dependent choices.
Given a (ground) prioritized program  = hP, i, G = (V, E) denotes the dependency
graph whose set of nodes consists of all atoms in P   whereas there is an arc from b to a
labeled  (resp. p) if there is a rule in  (resp. P) containing a in the head and b in the
body (resp. b in either the head or the body). As the body of (preference) facts is empty,
we assume that their bodies contain the built-in atom true, so that every fact a  can be
C
considered as a rule a  true. G denotes the (acyclic) collapsed dependency graph derived
from G by replacing maximal sets of mutual dependent nodes (i.e. nodes belonging to the
C
same cycle) with a unique node. Clearly, each node in G is associated with a set of nodes
in G .
C

To each node in G it is possible to assign a level as follows:
C

 For each node A in G with input degree zero, level(A) = 0;
509

fiGreco, Trubitsyna, & Zumpano

C

 For each node A in G with input degree greater than zero,
C
C
level(A) = max{max{level(B)+1|(B, Z, ) in G }, max{level(B)|(B, Z, p) in G }}.
Observe that the function level assigns to each node the maximum distance from some
node with input degree zero. The following definition introduces the concept of stratification
for preference rules.
Definition 6 Stratification. Given a (ground) prioritized program  = hP, i,  can be
partitioned into h [0],  [1], ...,  [n]i subprograms (called strata) such that
C

 For each atom a in , level(a) = level(A), where A is the node of G associated with a;
 For each rule % in  , level(%) = max{ level(a) | a  Body(%) };
  [i] = { % | %    level(%) = i } consists of all ground preference rules associated
with the level i.
2
The partition of  into h [0],  [1], ...,  [n]i is called stratification.
The above definition of stratification of preference rules establishes the order in which
preferences are applied by considering both P and . Moreover, the assignment of the level
to each rule differs from the one proposed by Brewka et al. (2003) in two main aspects:
the level of atoms is defined by analyzing the collapsed dependency graph and the level
of rules is established by considering body atoms instead of head atoms. A more detailed
comparison of the two approaches will be presented in Section 5.
Example 4 Consider the prioritized program hP 3 , 3 i of Example 3. The transitive closure
3 consists of the binary preference rules %1,1 : white > red  fish, %1,2 : red > beer 
fish and %1,3 : white > beer  fish, derived from %1 , and the rules %2 , %3 and %4 . 3 can
be stratified into the two strata 3 [1] = {%1,1 , %1,2 , %1,3 , %2 , %3 } and 3 [2] = {%4 }.
2
The structural analysis performed in our approach goes beyond the stratification process
and tries to understand the comparability of models. To this end the concepts of conflicting
preferences and comparable models are introduced.
Two ground (binary) preferences of the form a > b  body1 and b > a  body2
are said to be conflicting. For instance, the preferences %1 : white > red  fish and
%2 : red > white  beef of Example 1 are conflicting, whereas the preferences %1 and
%02 : red > water  beef are not. A set of preferences  is said to be conflicting if 
contains two conflicting preference rules.
The intuition on the basis of our approach is clarified in this example. Suppose there
are two conflicting preferences %1 : a > b  c and %2 : b > a  d. The two conflicting
preferences %1 and %2 specify the preference between a and b in two different sets of models,
having a or b, characterized by the presence of c and d, respectively. Thus, c and d, (and
atoms on which c and d depend) define the alternative decisions. Once a decision has been
made, the associated solutions (models) are no longer comparable.
A preference rule % is said to be relevant for a stable model M , if % can be used
to compare M with other stable models, that is if M |= body() and some of its head
510

fiOn the Semantics of Logic Programs with Preferences

atoms belongs to M . Given a prioritized program hP, i and a (ground) preference rule
% : a > b  body   , the set of stable models, for which % is relevant, is SM(P, %) =
{M | M  SM(P)  M |= body  (a  b)}.
Definition 7 Comparable models. Let hP, i be a prioritized program, M1 and M2 two
stable models for P and h [0], ...,  [n]i be a stratification of  , then
1. M1 and M2 are comparable on  [0];
2. M1 and M2 are comparable on  [i + 1] for i  [1..n], if
(a) they are comparable on  [i], and
(b) there do not exist two conflicting preference rules %1 , %2   [i] such that
M1  SM(P, 1 )  SM(P, 2 ) and M2  SM(P, 2 )  SM(P, 1 ).
2
Observe that, the second condition in the previous definition of comparable models
states that the presence of two conflicting preference rules in a given level i identifies two
sets of models, for which only one of the two conflicting rules is relevant. Two models,
appearing in the different sets have to be considered separately in the next levels. In other
words, two stable models M1 and M2 , having as relevant preferences the conflicting rules
%1 : a > b  body1 and %2 : b > a  body2 in a given level i, are not comparable at levels
greater than i, if M1  SM(P, 1 )  SM(P, 2 ) and M2  SM(P, 2 )  SM(P, 1 ), that is
M1 |= body1  (a  b)  not body2 and M2 |= body2  (a  b)  not body1 .
Example 5 Consider the stable models M3 = {fish, beer, pie}, M6 = {beef, beer,
ice-cream}, and the set of preference rules 3 of Example 4. The stable models M3
and M6 are comparable on 3 [0] by definition, while they are not comparable on 3 [1],
because %1,3 is relevant only for M3 (as M3 |= fish  (white  beer)  not beef), %3 is
relevant only for M6 (as M6 |= beef  (white  beer)  not fish), and these conflicting
preferences belong to 3 [0].
2
Fact 1 Let hP, i be a prioritized program without conflicting preferences and h [0],
 [1], ...,  [n]i be the stratification of  . Then, any two models M1 and M2 are comparable
on  [i], i  [0..n].
2
Proof. The proof of the above fact follows directly from Definition 7.

2

On the basis of Definition 7 the declarative semantics of prioritized logic programs can
now be provided. This new semantics, denoted with PAS (Preferred Answer Sets), is given
by preferred stable models as follows:
Definition 8 Preference between Answer Sets. Given a prioritized program hP, i, the
relation w is defined over the stable models of P as follows. For any pair of stable models
M1 and M2 of P, being h [0],  [1], ...,  [n]i be the stratification of  , M1 w M2 if
1. %1 : (e1 > e2 )  body1   [i] such that e1  M1  M2 , e2  M2  M1 , such that
M1 and M2 are comparable on  [i], and %1 is relevant for M1 and M2 , and
511

fiGreco, Trubitsyna, & Zumpano

2. 6 %2 : (e3 > e4 )  body2   [j], such that j < i, e3  M2  M1 , e4  M1  M2 and
%2 is relevant for M1 and M2 .
Moreover, M1 is strictly preferable to M2 (M1 = M2 ) if M1 w M2 and M2 6w M1 .

2

Note also that the relation = could be defined directly by replacing the condition j < i
with j  i in Item 2 of the above definition.
Definition 9 Preferred Answer Sets. An interpretation M is a preferred stable model for
a prioritized program hP, i if M is a stable model of P and there does not exist a stable
model N such that N = M . The set of preferred stable models for hP, i will be denoted
by PAS(hP, i).
2
Note that Definition 8 introduces preferences between pairs of models by also considering
additional information gained from the structure of preference rules.
Example 6 Consider the prioritized program hP3 , 3 i of Example 3 and the stratification
h3 [0], 3 [1]i presented in Example 4. We have that
 all models are comparable on  [0] by definition and
 owing to %1,1 , %1,2 , %1,3 , M1 = M2 = M3 ;
 owing to %2 , %3 , M5 = M4 and M6 = M4 ;
 as %1,3 and %3 are conflicting, models M1 and M3 , for which %1,3 is relevant, cannot
be compared in  [1] with models M4 and M6 , for which %3 is relevant.
Therefore, as discussed in Example 5, M3 and M6 are not comparable on 3 [1] and,
consequently, the preferred models are: M1 , M5 and M6 .
2
In the previous example the stable model M6 is considered as good as M5 because both
have beef as main dish, the best choice of drink (red wine and beer, respectively) and the
same dessert (ice-cream). Observe that both ASO and PSM semantics discard M6 . As
already stated, the ASO semantics deduces that M1 and M5 are preferable to M6 owing to
%3 , while the PSM semantics states that M1 is preferable to M3 and M3 is preferable to
M6 , owing to %1 , %3 .
b 3i
Example 7 Let hP 3 , 3 i be the program of Example 3, consider the program hP 3 , 
b 3 is derived from 3 by replacing %4 with
where 

%04 : pie > ice-cream 
b  [0] = {%1,1 , %1,2 , %1,3 , %2 , %3 , %0 },
The new ground preference program has the unique level 
3
4
where %1,1 , %1,2 and %1,3 are derived from %1 , as shown in Example 4. Due to %04 , the following relations also hold: Mi = Mj for i  {1, 2, 3} and j  {4, 5, 6}. Therefore, M1 is the
unique preferred model. The same result is obtained by both PSM and ASO semantics. 2
512

fiOn the Semantics of Logic Programs with Preferences

4. Complexity
This section provides some results concerning the computational complexity of computing
preferred stable models and answering queries under PAS semantics. We consider here data
complexity where the input domain UP consists of the Herbrand universe (we assume that
all constants occurring in  also occur in P). Clearly, the size of the Herbrand base BP as
well as the sizes of ground(P) and ground() are polynomial in the size of UP .
The following results demonstrate that allowing preferences among atoms in the semantics proposed here increases the complexity and expressivity of the language by one level
in the polynomial hierarchy. Thus the use of additional information does not increase the
computational complexity of the proposed approach with respect to the above mentioned
techniques (Brewka et al., 2003; Sakama & Inoue, 2000).
Proposition 1 Let  = hP, i be a prioritized program, then there exists a program  =
hP, i equivalent to hground(P),  i such that i) the stratification of  can be computed in
polynomial time, and ii) hP, i can be derived from hground(P),  i in polynomial time.
Proof. We start by considering the program 0 = hground(P), 0 i, where 0 is the binary
C
ground version of . The size of the graphs G0 and G0 is polynomial in the size of 0
C
and can be computed in polynomial time. As the assignment of levels to nodes in G0 can
be done in polynomial time, the assignment of levels to atoms and rules in 0 can also be
done in polynomial time.
Let h0 [0], ..., 0 [n]i be the stratification of 0 . We generate a new ground prioritized
program hP, i which is equivalent to hground(P),  i and such that the size of  is polynomial in the size of 0 .
Initially, assign to each ground atom ai appearing in the head of a preference rule in 0
a unique index i. Let a1 , ..., ap be the (indexed) atoms appearing in the head of rules in 0 ,
P denotes the program ground(P)  P  where
P  = {b(i, j, l)  bodyi,j | ai > aj  bodyi,j  0 [l] } 
{b(i, j, l)  b(i, k, l1), b(k, j, l2), l = max(l1, l2) | i, j, k  [1..p], l1 , l2  [1..n]}
and b is a new predicate symbol. Then,  denotes the new set of ground preference rules
defined as follows:
 = {ai > aj  b(i, j, l) | i, j  [1..p]  l  [0..n] }
The stratification of  is obtained by associating to each stratum l the preference rules
whose body atom has the value of the level attribute equal to l, that is [l] = {ai > aj 
b(i, j, l) | ai > aj  b(i, j, l)  }.
In order to show the equivalence between hground(P),  i and hP, i, observe that the
set of stable models of ground(P) and P are equivalent, i.e. for each M  SM(P) there
is a stable model N  SM(ground(P)) such that N = M  {b(i, j, l) | b(i, j, l)  M }
and for each N  SM(ground(P)) there is a stable model M  SM(P) such that N =
M  {b(i, j, l) | b(i, j, l)  M }, as the rules in ground(P) do not contain atoms of the form
b(i, j, l) in their bodies.
513

fiGreco, Trubitsyna, & Zumpano

Moreover, let N be a stable model of ground(P) and M be the corresponding stable
model of P (N  M ), for each ground preference rule ai > aj  bodyi,j in  [l] whose
body is true in N , there is a ground rule ai > aj  b(i, j, l) in [l] whose body is also true
in M and vice versa. Therefore the two sets [l] and  [l] are equivalent, for all l  [1..n].
Clearly, the program hP, i is derived from hground(P),  i in polynomial time.
2
In the following, for the sake of simplicity of presentation, we continue to refer to the
program hP, i and to the stratification of  .
Proposition 2 Let hP, i be a prioritized program, M1 and M2 two stable models for P,
and h [0],  [1], ...,  [n]i a stratification of  . The problem of checking whether, for a
given k  n, M1 and M2 are comparable on  [0], ...,  [k] can be solved in polynomial time.
Proof. Obviously M1 and M2 are comparable in  [0]. Assuming that M1 and M2 are
comparable for a given level j < k, M1 and M2 are comparable for the level j + 1 if there
are no two conflicting preference rules 1 = a > b  body1 and 2 = b > a  body2 in  [j]
such that M1 |= body1  (a  b)  not body2 and M2 |= body2  (a  b)  not body1 . This check
can be done in polynomial time as the number of rules in  [j] is polynomial in the size of
UP . Moreover, as the maximum value of k is bounded by the size of  (which is bounded
by the set of atoms in BP ), the global complexity is also polynomial.
2
Corollary 1 Let hP, i be a prioritized program, M1 and M2 two interpretations for P.
The problem of checking whether M1 = M2 can be solved in polynomial time.
Proof. Straightforward from Definition 8 and Proposition 2.

2

Lemma 1 Let hP, i be a prioritized program and M an interpretation for P. The problem
of deciding whether M is a preferred stable model for hP, i is in p2 .
Proof. Consider the complementary problem of deciding whether M is not a preferred
stable model for hP, i. In such a case it is sufficient to first check if M is a stable model.
If M is a stable model it is sufficient to guess an interpretation N and to check that i) N
is a stable model for P and ii) N = M . The check on part i) (as well as the check that
M is a stable model) can be done by means of a N P oracle as the problem of deciding
whether an interpretation is a stable model for a disjunctive program is coN P-complete,
whereas the check on part ii) can be done in polynomial time (see Corollary 1). Therefore,
the complexity of the complementary problem is N P N P and, consequently, the complexity
of the original problem is coN P N P .
2
Theorem 1 Let hP, i be a prioritized program. Then
1. Deciding whether a ground atom G is true in some preferred stable models of hP, i
is p3 -complete;
2. Deciding whether a ground atom G is true in all preferred stable models of hP, i is
p3 -complete.
514

fiOn the Semantics of Logic Programs with Preferences

Proof. Membership: We first demonstrate that deciding whether G is true in some
preferred stable model of hP, i is in p3 . This result suffices to prove that the complementary problem, consisting in deciding whether A is true in all preferred stable models, is
p3 -complete.
To show the membership it is sufficient to guess an interpretation M containing G and
to check whether M is a preferred stable model. From Lemma 1 the problem of deciding
whether M is a preferred stable model is in p2 and can be solved by means of a p2
oracle.
Therefore, deciding whether there exists a preferred stable model containing G is in
p2
N P = p3 .
Hardness: Given an abductive logic program consisting of a disjunctive program P and a
set of abducibles (positive) atoms A, the ground abductive logic program derived prom P
and A is
 = ground(P)  { g 0 (t)  not g(t) | g(t)  ground(A) }
 { g 0 (t)  g(t)  | g(t)  ground(A) }
Let
 = { g 0 (t) > g(t)  | g(t)  ground(A) }
h, i denotes the prioritized program derived from P and A.
For any two stable models M, N  SM(), M w N with respect to  means that
a preference p0 (u) > p(u)    such that p0 (u)  M and p(u)  N exists and no
preference q 0 (v) > q(v)    such that q 0 (v)  N and q(v)  M exists. This implies
that M  ground(A)  N  ground(A) and, consequently, that preferred stable models are
A-minimal.
Therefore, the problem of deciding whether h, i has an A-minimal explanation for a
goal G is equivalent to deciding whether h, i has a preferred stable model containing G.
Consequently, as the problem of deciding whether a A-minimal explanation S for G exists
is p3 -complete, the problem of deciding whether a preferred stable model M for h, i
containing G exits is also p3 -hard, whereas the problem of deciding whether all preferred
2
stable models of hP, i contain G is p3 -hard.
Corollary 2 Let hP, i be a disjunction-free, prioritized program. Then deciding
whether a ground atom is true in some (all) preferred stable models of hP, i is p2 -complete
(p2 -complete).
Proof. The complexity is one level lower as the problem of deciding whether an interpretation M is a stable model for a disjunction-free program is polynomial.
2

5. Analysis And Comparison
This section compares the semantics introduced here with the PSM and (R)ASO semantics
and briefly discusses other recently proposed semantics.
The PSM semantics is very elegant and compares pairs of models on the basis of their
common preferences and not on the basis of their degree of satisfaction. It does not consider the natural ordering between preference rules and, in some cases, as in Example 1
and 3, compares (and consequently discards) models which in the PAS approach are not
515

fiGreco, Trubitsyna, & Zumpano

comparable. An interesting feature of the PSM technique is the application of transitive
property in order to derive additional preference relations among problem solutions so that
new, not immediately visible, preference relations are captured. However, as the test of the
transitive property cannot be performed by a direct comparison of two models, this lies in
a more complex implementation.
The (R)ASO technique is a very powerful tool as it determines the preferred models
by evaluating the degree of satisfaction of all preference rules. Thus, it compares two
models even in the absence of common preferences; and the preference relation between
the two models can be established directly. In more detail, the RASO technique considers
the structure of preference rules by associating a degree of satisfaction to choice options
and introduces a natural ordering among preferences. As in the case of PSM semantics,
the (R)ASO semantics also compares and, consequently, discards models which are not
comparable using the PAS technique. For instance, for the program hP1 , 1 i, presented in
the Introduction, RASO discards M1 , having the second best option of drink, even if this is
the unique possible choice in the presence of fish.
More specifically, the preference relation w used in the PSM approach is a preorder
relation as it is reflexive and transitive; it determines equivalent answer set classes and
establishes the partial preference order among the above mentioned classes. Consequently
the preferred answer sets are those appearing in the preferred classes. It should be noted
that PSM semantics requires the use of the transitive property in order to derive, on the
basis of relations obtained by the direct comparison of pairs of models, new preference
relations. On the contrary, the (R)ASO semantics uses a strict preference relation which
is just asymmetric and it does not require the application of the transitive property to
compare solutions.
The PAS semantics, proposed here, compares two solutions on the basis of their common preferences by introducing the concept of comparable models and by considering a
refinement of the natural order among preference choices. Thus, it can be seen as an extension of PSM semantics that also uses additional information derived from the structure of
preference rules, but which instead of comparing models transitively, compares models by
considering the transitive closure of the (ground) preference rules.
A novelty of PAS semantics is the consideration of the structural information of preference rules. It introduces the concept of comparable models in order to avoid comparing
models which (in our opinion) should not be compared as they are associated with alternative decisions. Moreover, it proposes a refinement of the natural order among preferences in
order to define the order of choices. RASO semantics establishes the relational order among
atoms appearing in  by means of the corresponding dependency graph G() and cannot
treat the case of mutually dependent choices. The stratification algorithm, proposed in
C
this paper, overcomes this problem by considering the collapsed graph G , which is acyclic
by construction and is not sensitive to syntactic changes. Moreover, in RASO semantics
the stratification of preference rules is established by considering their head atoms; whereas
in PAS semantics levels are assigned to rules on the basis of the body atoms, following the
intuition that they describe the contexts of choices. Thus, the stratification proposed here
always assigns preference facts to the first level because the level of a rule is fixed by looking
at the level of body atoms.
Some of the advantages of the adopted approach are clarified by the following example.
516

fiOn the Semantics of Logic Programs with Preferences

Example 8 The problem defined by means of the prioritized program hP8 , 8 i consists in
selecting the colors of the trousers and the shirt, having only black or blue trousers (r1 )
and white, yellow or red shirts (r2 ) available. The fashion consultant suggests that blue
trousers are better than black ones (%1 ); a white shirt is better than a yellow shirt (%2 );
and in the case of black trousers a white shirt is preferred to a red one (%3 ). Moreover,
blue trousers do not go with a white shirt (c1 ) and a red shirt does not go with blue
trousers (c2 ).
P8 :

r1
r2
c1
c2

:
:
:
:

black  blue 
white  yellow  red 
 blue, white
 red, blue

8 :

%1 : blue > black 
%2 : white > yellow 
%3 : white > red  black

The program P8 has four stable models: M1 = {black, white}, M2 = {black, yellow},
M3 = {blue, yellow} and M4 = {black, red}. In order to define the stratification of
preference rules, both RASO and PAS semantics firstly assign the level to atoms: first level
to blue, black and yellow and second level to white and red. In the second step the
RASO approach, by considering the maximum level of head atoms, assigns %1 to the first
level and %2 and %3 to the second level, whereas PAS defines the level of preferences on the
basis of body atoms and assigns %1 and %2 to the first level and %3 to the second level. Note
that in this case the order of %2 is relevant for determining the preferred models. In fact,
RASO gives only M3 , while PAS returns M1 and M3 as preferred models.
2
A formal comparison of the three semantics can be carried out only for the class of
programs where the specific definition of stratification is not significant. Moreover, as
the PSM semantics is defined only for prioritized programs hP, i where  consists only
of binary facts (preference rules are rewritten into preference facts), in the following the
comparison is carried out by considering programs whose preference rules consist of only
facts. For such a class of programs the closure  used in the PSM and PAS semantics
coincide.
Given a prioritized program hP, i we denote with GSEM = (V, ESEM ) a preference
graph on the stable models of P, where V = SM(P) denotes the set of stable models
of P and ESEM denotes the preference relation = defined by the semantics SEM 
{PSM, ASO, PAS}. In particular, ESEM consists of the arcs (Mi , Mj ) such that Mi = Mj
holds in the SEM semantics. Therefore, the comparison of the different semantics can be
performed by analyzing the corresponding preference graphs. A stable model Mi is preferred
under the SEM semantics if there is no arc (Mj , Mi ) in GSEM .
The following example shows the relation between the PSM and PAS semantics.
Example 9 Consider the prioritized program hP 9 , 9 i below
P 9 : fish  beef  pork  chicken 
white  fish
red  beef
beer  pork
water  chicken
517

9 : fish > beef 
chicken > pork 
red > white 
red > water 
beer > water 

fiGreco, Trubitsyna, & Zumpano

The program has four stable models: M1 = {fish, white}, M2 = {beef, red}, M3 =
{pork, beer} and M4 = {chicken, water}, whereas the direct preference relations, for the
PSM semantics, are as follows: M1 w M2 , M2 w M1 , M3 w M4 , M4 w M3 and M2 w M4 .
Consequently, we have that the graph GPSM consists of four nodes (M1 , M2 , M3 and
M4 ) and four arcs: M1 = M3 , M1 = M4 , M2 = M3 and M2 = M4 . Therefore, the preferred
models are M1 and M2 .
Regarding the PAS semantics, we have that only the relation M2 = M4 holds and, thus,
there are three preferred stable models, namely M1 and M2 and M3 .
2
Theorem 2 For any prioritized program hP, i such that  consists in preference facts,
PSM(hP, i)  PAS(hP, i).
Proof. Consider the graphs GPSM = (V, EPSM ) and GPAS = (V, EPAS ). Both graphs are
acyclic and EPAS  EPSM . As the two graphs are acyclic, by adding edges which do not
create cycles, the number of nodes without incoming edges decreases. Therefore, the set of
nodes without incoming edges in GPAS contains all nodes without incoming edges in GPSM
and, consequently, PSM(hP, i)  PAS(hP, i).
2
We now analyze the relation between ASO and PAS semantics. First of all note that,
as observed in the Introduction, the ASO semantics is sensitive to syntax changes. For
instance, the prioritized program
abc

1 = a > b > c 
2 = b > a 

has two preferred stable models: M1 = {a} and M2 = {b}. However, for the program below
01 = a > b 
001 = b > c 
2 = b > a 

abc

derived from the rewriting of the rule 1 , M3 = {c} is also a preferred model.
Thus, we consider a special class of constraints which is not sensitive to syntactic
changes. Since every (ground) prioritized program  = hP, i, such that  can be partitioned into n strata, with n > 1, can be rewritten into a program  = hP, i, such that
 and  are equivalent under the PAS semantics (as shown in the proof of Proposition
1), and may not be equivalent under the RASO semantics (as all rules in  belong to the
unique stratum 0), we continue to consider programs  = hP, i where  consists of a
single stratum and, in particular, of facts.
Given a prioritized program hP, i such that  consists only of facts, we denote with
+ = {a1 >    > an  | ai > ai+1    for i  [1..n-1]  n is maximum }
the set of preference rules which can be obtained from the merging of ground preference facts.
Lemma 2 Let hP, i be a prioritized program such that  consists only of preference facts
and ground() = + . Then, ASO(hP, i)  PAS(hP, i).
518

fiOn the Semantics of Logic Programs with Preferences

Proof. Consider the two graphs GASO = (V, EASO ) and GPAS = (V, EPAS ). (M1 , M2 ) 
EPAS means that M1 = M2 , i.e. that
i) there is a ground rule %1 : e1 > e2    such that e1  M1M2 , e2  M2M1 , and
ii) there is no ground rule %2 : e3 > e4    , such that e3  M2 M1 and e4  M1 M2 .
This implies that if ground() = +
i) there must be a ground rule 1 :    > e1 >    > e2 >      + such that
e1  M1  M2 , e2  M2  M1 , and
ii) there must not be ground rule 2 :    > e3 >    > e4 >      + , such that
e3  M2  M1 and e4  M1  M2 .
Therefore, M1 = M2 also with respect to the ASO semantics, and the graph GASO contains an arc (M1 , M2 ). Consequently, as EPAS  EASO , ASO(hP, + i)  PAS(hP, + i). 2
To find a tight relation between the two semantics, we consider a further restriction of
+ which is obtained by deleting atoms which do not appear in any model from the ground
preference rules:
+

b = {a1 >    > an  | ai > ai+1    for i  [1..n-1]  n is maximum 

M  SM(P) s.t. ai , ai+1  M }

Theorem 3 Let hP, i be a prioritized program such that  consists only of preference
b + . Then, ASO(hP, i) = PAS(hP, i).
facts and ground() = 
b + is derived from + by
Proof. ASO(hP, i)  PAS(hP, i) derives from Lemma 2, as 
deleting nodes which do not appear in any model and do not influence the relation = in the
ASO semantics.
To show that ASO(hP, i)  PAS(hP, i) consider the relation in the ASO semantics.
M1 = M2 means that
b + such that e1  M1  M2 ,
1. there is a ground rule 1 :    > e1 >    > e2 >      
e2  M2  M1 , and

2. there is no ground rule 2 :    > e3 >    > e4 >   
e3  M2  M1 and e4  M1  M2 .

  + , such that

b+
This implies that if ground() = 

1. there must be a ground rule %1 : e1 > e2    such that e1  M1  M2 , e2 
M2  M1 , and
2. there is no ground rule %2 : e3 > e4    , such that e3  M2 M1 and e4  M1 M2 .
519

fiGreco, Trubitsyna, & Zumpano

Therefore, M1 = M2 also holds with respect to the PAS semantics. Consequently,
as EASO  RPAS , ASO(hP, + i)  PAS(hP, + i).
2
An extension of the ASO semantics has been proposed by Brewka (2004) and Brewka,
Niemela, and Truszczynski (2005). In more detail, Brewka (2004) provided a preference
description language, allowing to express complex preferences by combining qualitative and
quantitative penalty based preferences, whereas Brewka et al. (2005) proposed a framework to specify problem solutions (outcomes) and preferences among them. The latter
proposal combines ideas from answer-set programming, answer-set optimization and CPnets (Boutilier, Brafman, Domshlak, Hoos, & Poole, 2004). The semantics that we have
proposed in this paper is different from both those proposed by Brewka (2004) and Brewka
et al. (2005), as in some cases it returns different results (see Examples 2 and 4).

6. Other Approaches
Besides the approaches managing preferences among atoms, some other works proposed in
the literature specify preferences among rules.
Early proposals expressing preferences on rules focus on Default Logic (Brewka & Eiter,
2000; Delgrande et al., 2000b; Rintanen, 1998), whereas more recently the emphasis has
been given to logic programs. In this regard, different proposals have been developed for
representing and reasoning about user preferences such as ordered logic programs (Delgrande et al., 2000a; Van Nieuwenborgh & Vermeir, 2002, 2004) and preferred answer sets
of extended logic programs (Brewka & Eiter, 1999). Most of the approaches propose an
extension of Gelfond and Lifschitzs extended logic programming by adding preference information (Delgrande et al., 2003; Wang et al., 2000; Zhang & Foo, 1997). Other proposals
attempt to extend the well founded semantics to logic programs with preferences (Brewka,
1996; Schauba & Wang, 2001), and an extension of van-Gelders alternating fixpoint theory
for logic programs with priorities has been proposed by Wang et al. (2000).
Gelfond and Son (1997) have proposed a methodology of reasoning with prioritized
default in the language of logic programming under answer set semantics. This approach
enables the specification of preferences among rules and allows the definition of a set of
default rules which must be satisfied as well as a second set of default rules which could be
ignored.
Ordered logic programs have been introduced by Delgrande et al. (2000a) as extended
logic programs whose rules are subject to a strict partial order with both static and dynamic
preferences. This approach is fully prescriptive as it enforces the ordering information during
the construction of the answer set. The original program is transformed into a second
extended logic program in which preferences are taken into account in the sense that the
answer sets obtained by evaluating the transformed theory correspond to the preferred
answer sets of the original theory.
Another methodology in which logic programs containing preferences on the set of rules
can be translated into logic programs under stable model semantics has been proposed by
Delgrande et al. (2003).
520

fiOn the Semantics of Logic Programs with Preferences

7. Conclusions
In this paper the case of preferences involving atoms in logic programming has been studied.
In particular, the behavior of the technique proposed by Sakama and Inoue (2000) and
Brewka et al. (2003) has been analyzed and a semantics, interpreting each preference rule as
a tool for representing a choice over alternative options, has been proposed. Specifically, the
proposed approach extends the PSM semantics by considering a refinement of the natural
order among preferences and introduces the concept of comparable models. Preferences and
logic programs are examined together in order to determine the choice order and the sets
of models which can be compared.
The new semantics has been compared with the PSM and the ASO semantics. Complexity analysis has also been performed showing that the use of additional information,
regarding the preference order and the sets of non comparable models, does not increase the
complexity of computing preferred stable models. Although the semantics presented here
has the same complexity as other approaches proposed in the literature, the advantage lies
in the fact that it seems to better capture the intuitive meaning of prioritized programs by
also considering the structural information of preference rules.
Prioritized reasoning in logic programming under the PAS semantics can be easily
implemented on the top of deductive systems based on stable model semantics such as
DeRes, DLV, Smodels (Cholewinski, Marek, & Truszczynski, 1996; Leone, Pfeifer, Faber,
Calimeri, & DellArmi, 2002; Syrjanen & Niemela, 2001). An architecture and a system
prototype implementing prioritized reasoning (with different semantics) on the top of the
DLV system has been presented by Caroprese, Trubitsyna, and Zumpano (2007).

Acknowledgments
A preliminary version of the papers has been presented by Greco, Trubitsyna, and Zumpano
(2006). The authors would like to thank the anonymous referees for their useful suggestions
and Filippo Furfaro for his comments.

References
Boutilier, C., Brafman, R., Domshlak, C., Hoos, H., Poole, D. (2004). CP-nets: A tool
for representing and reasoning with conditional ceteris paribus preference statements.
Journal of Artificial Intelligence Research, 21, 135-191.
Brewka, G. (1996). Well-Founded Semantics for Extended Logic Programs with Dynamic
Preferences. Journal of Artificial Intelligence Research, 4, 19-36.
Brewka, G., Eiter, T. (1999). Preferred Answer Sets for Extended Logic Programs. Artificial
Intelligence, 109(1-2), 297-356.
Brewka, G., Eiter, T. (2000). Prioritizing Default Logic. Intellectics and Computational
Logic, Kluwer, 27-45.
Brewka, G. (2002). Logic programming with ordered disjunction. Proceedings 18th National
Conference on Artificial Intelligence (AAAI/IAAI), 100-105.
521

fiGreco, Trubitsyna, & Zumpano

Brewka, G., Niemela, I., Truszczynski, M. (2003). Answer Set Optimization. Proceedings
18th International Joint Conference on Artificial Intelligence (IJCAI), 867-872.
Brewka, G. (2004). Complex Preferences for Answer Set Optimization, Proceedings 9th
International Conference on Principles of Knowledge Representation and Reasoning
(KR), 213-223.
Brewka, G., Niemela, I., Truszczynski, M. (2005). Prioritized Component Systems. Proceedings 20th National Conference on Artificial Intelligence (AAAI), 596-601.
Caroprese, L., Trubitsyna, I., Zumpano, E. (2007). Implementing Prioritized Reasoning in
Logic Programming. Proceedings International Conference on Enterprice Information
Systems (ICEIS), 94-100.
Cholewinski, P., Marek, V. W., Truszczynski, M. (1996). Default Reasoning System DeReS.
Proceedings 5th International Conference on Principles of Knowledge Representation
and Reasoning (KR), 518-528.
Delgrande, J., P., Schaub, T., Tompits, H. (2000). Logic Programs with Compiled Preferences. Proceedings 14th European Conference on Artificial Intelligence (ECAI), 464-468.
Delgrande, J., P., Schaub, T., Tompits, H. (2000). A Compilation of Brewka and Eiters
Approach to Prioritization. Proceedings European Workshop on Logics in Artificial
Intelligence (JELIA), 376-390.
Delgrande, J., P., Schaub, T., Tompits, H. (2003). A Framework for Compiling Preferences
in Logic Programs. Theory and Practice of Logic Programming, 3(2), 129-187.
Eiter, T., Gottlob, G., Leone, N. (1997). Abduction from Logic Programs: Semantics and
Complexity. Theoretical Computer Science 189(1-2), 129177.
Eiter, T., Gottlob, G., Mannila, H. (1997). Disjunctive Datalog. ACM Transaction On
Database Systems, 22(3), 364418, 1997.
Gelfond, M., Lifschitz, V. (1988). The Stable Model Semantics for Logic Programming,
Proceedings International Conference on Logic Programming (ICLP), 10701080.
Gelfond, M., Lifschitz, V. (1991). Classical Negation in Logic Programs and Disjunctive
Databases, New Generation Computing, 9, 365385.
Gelfond, M., Son, T.C. (1997). Reasoning with prioritized defaults. Proc. 3rd International
Workshop on Logic Programming and Knowledge Representation (LPKR), 164-223.
Greco, S., Trubitsyna, I., Zumpano, E. (2006). On the Semantics of Logic Programs with
Preferences. Proceedings 10th European Conference on Logics in Artificial Intelligence
(JELIA), 203-215.
Grell, S., Konczak, K., Schaub, T. (2005). nomore<: A System for Computing Preferred
Answer Sets. Proceedings 8th International. Conference on Logic Programming and
Nonmonotonic Reasoning (LPNMR), 394-398.
Janhunen, T., Niemela, I., Simons, P., You, J.-H. (2000). Unfolding partiality and disjunctions in stable model semantics, Proceedings 7th International Conference on Principles of Knowledge Representation and Reasoning (KR), 411-419.
522

fiOn the Semantics of Logic Programs with Preferences

Inoue, K., Sakama, S. (1998). Negation as Failure in the Head. Journal of Logic Programming, 35(1), 39-78.
Kakas, A. C., Kowalski, R. A., Toni, F. (1992). Abductive Logic Programming. Journal of
Logic anc Computation, 2(6), 719-770.
Leone, N., Pfeifer, G., Faber, W., Calimeri, F., DellArmi, T., Eiter, T., Gottlob, G., Ianni,
G., Ielpa, G., Koch, K., Perri, S., Polleres, A. (2002). The DLV System. Proceedings
8th European Conference on Logics in Artificial Intelligence (JELIA), 537-540, 2002.
Minker, J. (1982). On Indefinite Data Bases and the Closed World Assumption, Proc. 6-th
Conf. on Automated Deduction, 292-308, 1982.
Papadimitriou, C. H. (1994). Computational Complexity. Addison-Wesley.
Rintanen J. (1998). Complexity of Prioritized Default Logics, Journal of Artificial Intelligence Research, 9, 423-461.
Sakama, C., Inoue, K. (2000). Priorized logic programming and its application to commonsense reasoning. Artificial Intelligence, 123, 185-222.
Schaub, T., Wang , K. (2001). A Comparative Study of Logic Programs with Preference.
Proceedings 17th International Joint Conference on Artificial Intelligence (IJCAI),
597-602.
Syrjanen, T., and Niemela, I. (2001). The Smodels System. Proceedings International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR), 434-438.
Van Nieuwenborgh, D., Vermeir, D. (2002). Preferred Answer Sets for Ordered Logic
Programs. Proceedings 10th European Conference on Logics in Artificial Intelligence
(JELIA), 432-443.
Van Nieuwenborgh, D., Vermeir, D. (2002). Ordered Diagnosis, Proceedings 10th International Conference on Logic for Programming, Artificial Intelligence, and Reasoning
(LPAR), 244-258.
Van Nieuwenborgh, D., Heymans, S., Vermeir, D. (2004). On Programs with Linearly Ordered Multiple Preferences. Proceedings International Conference on Logic Programming (ICLP), 180-194.
Wakaki, T., Inoue, K., Sakama, C., Nitta, K. (2003). Computing Preferred Answer Sets
in Answer Set Programming. Proceedings 10th International Conference on Logic for
Programming, Artificial Intelligence, and Reasoning (LPAR), 259-273.
Wakaki, T., Inoue, K., Sakama, C., Nitta, K. (2004). The PLP System. Proceedings 9th
European Conference on Logics in Artificial Intelligence (JELIA), 706-709.
Wang, K., Zhou, L., Lin, F. (2000). Alternating Fixpoint Theory for Logic Programs with
Priority. Proceedings First International Conference on Computational Logic, 164-178.
Zhang, Y., Foo, N. (1997). Answer sets for prioritized logic programs. Proceedings International Logic Programming Symposium (ILPS), 69-83.

523

fi