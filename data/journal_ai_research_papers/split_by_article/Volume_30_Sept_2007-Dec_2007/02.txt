Journal of Artificial Intelligence Research 30 (2007) 101-132

Submitted 10/05; published 9/07

The Planning Spectrum  One, Two, Three, Infinity
Marco Pistore

pistore@dit.unitn.it

Department of Information and Communication Technology
University of Trento
Via Sommarive 14, 38050 Povo (Trento), Italy

Moshe Y. Vardi

vardi@cs.rice.edu

Department of Computer Science
Rice University
6100 S. Main Street, Houston, Texas

Abstract
Linear Temporal Logic (LTL) is widely used for defining conditions on the execution
paths of dynamic systems. In the case of dynamic systems that allow for nondeterministic
evolutions, one has to specify, along with an LTL formula , which are the paths that are
required to satisfy the formula. Two extreme cases are the universal interpretation A.,
which requires that the formula be satisfied for all execution paths, and the existential
interpretation E., which requires that the formula be satisfied for some execution path.
When LTL is applied to the definition of goals in planning problems on nondeterministic
domains, these two extreme cases are too restrictive. It is often impossible to develop plans
that achieve the goal in all the nondeterministic evolutions of a system, and it is too weak
to require that the goal is satisfied by some execution.
In this paper we explore alternative interpretations of an LTL formula that are between
these extreme cases. We define a new language that permits an arbitrary combination of
the A and E quantifiers, thus allowing, for instance, to require that each finite execution
can be extended to an execution satisfying an LTL formula (AE.), or that there is some
finite execution whose extensions all satisfy an LTL formula (EA.). We show that only
eight of these combinations of path quantifiers are relevant, corresponding to an alternation
of the quantifiers of length one (A and E), two (AE and EA), three (AEA and EAE), and
infinity ((AE) and (EA) ). We also present a planning algorithm for the new language
that is based on an automata-theoretic approach, and study its complexity.

1. Introduction
In automated task planning (Fikes & Nilsson, 1971; Penberthy & Weld, 1992; Ghallab, Nau,
& Traverso, 2004), given a description of a dynamic domain and of the basic actions that can
be performed on it, and given a goal that defines a success condition to be achieved, one has
to find a suitable plan, that is, a description of the actions to be executed on the domain in
order to achieve the goal. Classical planning concentrates on the so called reachability
goals, that is, on goals that define a set of final desired states to be reached. Quite often
practical applications require plans that deal with goals that are more general than sets of
final states. Several planning approaches have been recently proposed, where temporal logic
formulas are used as goal language, thus allowing for goals that define conditions on the
whole plan execution paths, i.e., on the sequences of states resulting from the execution of
plans (Bacchus & Kabanza, 1998, 2000; Calvanese, de Giacomo, & Vardi, 2002; Cerrito &
c
2007
AI Access Foundation. All rights reserved.

fiPistore & Vardi

Mayer, 1998; Dal Lago, Pistore, & Traverso, 2002; de Giacomo & Vardi, 1999; Kvarnstrom
& Doherty, 2001; Pistore & Traverso, 2001). Most of these approaches use Linear Temporal
Logic (LTL) (Emerson, 1990) as the goal language. LTL allows one to express reachability
goals (e.g., F q  reach q), maintainability goals (e.g., G q  maintain q), as well as goals
that combine reachability and maintainability requirements (e.g., F G q  reach a set of
states where q can be maintained), and Boolean combinations of these goals.
In planning in nondeterministic domains (Cimatti, Pistore, Roveri, & Traverso, 2003;
Peot & Smith, 1992; Warren, 1976), actions are allowed to have different outcomes, and it is
not possible to know at planning time which of the different possible outcomes will actually
take place. Nondeterminism in action outcome is necessary for modeling in a realistic way
several practical domains, ranging from robotics to autonomous controllers to two-player
games.1 For instance, in a realistic robotic application one has to take into account that
actions like pick up object might result in a failure (e.g., if the object slips out of the
robots hand). A consequence of nondeterminism is that the execution of a plan may lead to
more than one possible execution path. Therefore, one has to distinguish whether a given
goal has to be satisfied by all the possible execution paths (in this case we speak of strong
planning), or only by some of the possible execution paths (weak planning). In the case
of an LTL goal , strong planning corresponds to interpreting the formula in a universal
way, as A., while weak planning corresponds to interpreting it in an existential way, as
E..
Weak and strong plans are two extreme ways of satisfying an LTL formula. In nondeterministic planning domains, it might be impossible to achieve goals in a strong way: for
instance, in the robotic application it might be impossible to fulfill a given task if objects
keep slipping from the robots hand. On the other hand, weak plans are too unreliable,
since they achieve the goal only under overly optimistic assumptions on the outcomes of
action executions.
In the case of reachability goals, strong cyclic planning (Cimatti et al., 2003; Daniele,
Traverso, & Vardi, 1999) has been shown to provide a viable compromise between weak and
strong planning. Formally, a plan is strong cyclic if each possible partial execution of the
plan can always be extended to an execution that reaches some goal state. Strong cyclic
planning allows for plans that encode iterative trial-and-error strategies, like pick up an
object until succeed. The execution of such strategies may loop forever only in the case
the action pick up object continuously fails, and a failure in achieving the goal for such
an unfair execution is usually acceptable. Branching-time logics like CTL and CTL* allow
for expressing goals that take into account nondeterminism. Indeed, Daniele et al. (1999)
show how to encode strong cyclic reachability goals as CTL formulas. However, in CTL
and CTL* path quantifiers are interleaved with temporal operators, making it difficult to
extend the encoding of strong cyclic planning proposed by Daniele et al. (1999) to generic
temporal goals.
In this paper we define a new logic that allows for exploring the different degrees in which
an LTL formula  can be satisfied that exist between the strong goal A. and the weak goal
E.. We consider logic formulas of the form ., where  is an LTL formula and  is a
path quantifier that generalizes the A and E quantifiers used for strong and weak planning.
1. See the work of Ghallab et al. (2004) for a deeper discussion on the fundamental role of nondeterminism
in planning problems and in practical applications.

102

fiThe Planning Spectrum  One, Two, Three, Infinity

A path quantifier is a (finite or infinite) word on alphabet {A, E}. The path quantifier can
be seen as the definition of a two-player game for the selection of the outcome of action
execution. Player A (corresponding to symbol A) chooses the action outcomes in order to
make goal  fail, while player E (corresponding to symbol E) chooses the action outcomes
in order to satisfy the goal . At each turn, the active player controls the outcome of action
execution for a finite number of actions and then passes the control to the other player.2
We say that a plan satisfies the goal . if the player E has a winning strategy, namely if,
for all the possible moves of player A, player E is always able to build an execution path
that satisfies the LTL formula .
Different path quantifiers define different alternations in the turns of players A and E.
For instance, with goal A. we require that the formula  is satisfied independently of how
the hostile player A chooses the outcomes of actions, that is, we ask for a strong plan.
With goal E. we require that the formula  is satisfied for some action outcomes chosen
by the friendly player E, that is, we ask for a weak plan. With goal AE. we require that
every plan execution led by player A can be extended by player E to a successful execution
that satisfies the formula ; in the case of a reachability goal, this corresponds to asking
for a strong cyclic solution. With goal EA. we require that, after an initial set of actions
controlled by player E, we have the guarantee that formula  will be satisfied independently
of how player A will choose the outcome of the following actions. As a final example, with
goal (AE) . = AEAEA    . we require that formula  is satisfied in all those executions
where player E has the possibility of controlling the action outcome an infinite number of
times.
Path quantifiers can define arbitrary combinations of the turns of players A and E, and
hence different degrees in satisfying an LTL goal. We show, however, that, rather surprisingly, only a finite number of alternatives exist between strong and weak planning: only
eight canonical path quantifiers give rise to plans of different strength, and every other
path quantifier is equivalent to a canonical one. The canonical path quantifiers correspond
to the games of length one (A and E), two (AE and EA), and three (AEA and EAE), and
to the games defining an infinite alternation between players A and E ((AE) and (EA) ).
We also show that, in the case of reachability goals  = F q, the canonical path quantifiers
further collapse. Only three different degrees of solution are possible, corresponding to weak
(E. F q), strong (A. F q), and strong cyclic (AE. F q) planning.
Finally, we present a planning algorithm for the new goal language and we study its
complexity. The algorithm is based on an automata-theoretic approach (Emerson & Jutla,
1988; Kupferman, Vardi, & Wolper, 2000): planning domains and goals are represented
as suitable automata, and planning is reduced to the problem of checking whether a given
automaton is nonempty. The proposed algorithm has a time complexity that is doubly
exponential in the size of the goal formula. It is known that the planning problem is
2EXPTIME-complete for goals of the form A. (Pnueli & Rosner, 1990), and hence the
complexity of our algorithm is optimal.
The structure of the paper is as follows. In Section 2 we present some preliminaries
on automata theory and on temporal logics. In Section 3 we define planning domains and
plans. In Section 4 we define AE-LTL, our new logic of path quantifier, and study its basic
2. If the path quantifier is a finite word, the player that has the last turn chooses the action outcome for
the rest of the infinite execution.

103

fiPistore & Vardi

properties. In Section 5 we present a planning algorithm for AE-LTL, while in Section 6
we apply the new logic to the particular cases of reachability and maintainability goals. In
Section 7 we make comparisons with related works and present some concluding remarks.

2. Preliminaries
This section introduces some preliminaries on automata theory and on temporal logics.
2.1 Automata Theory
Given a nonempty alphabet , an infinite word on  is an infinite sequence 0 , 1 , 2 , . . . of
symbols from . Finite state automata have been proposed as finite structures that accept
sets of infinite words. In this paper, we are interested in tree automata, namely in finite
state automata that recognize trees on alphabet , rather than words.
Definition 1 (tree) A (leafless) tree  is a subset of N such that:
    is the root of the tree;
 if x   then there is some i  N such that x  i   ;
 if x  i   , with x  N and i  N, then also x   ;
 if x  (i+1)   , with x  N and i  N, then also x  i   .
The arity of x   is the number of its children, namely arity(x) = |{i : x  i   }|. Let
D  N. Tree  is a D-tree if arity(x)  D for each x   . A -labelled tree is a pair (,  ),
where  is a tree and  :   . In the following, we will denote -labelled tree (,  ) as
 , and let  = dom( ).
Let  be a -labelled tree. A path p of  is a (possibly infinite) sequence x0 , x1 , . . . of nodes
xi  dom( ) such that xk+1 = xk  ik+1 . In the following, we denote with P  ( ) the set of
finite paths and with P  ( ) the set of infinite paths of  . Given a (finite or infinite) path p,
we denote with  (p) the string  (x0 )   (x1 )    , where x0 , x1 , . . . is the sequence of nodes
of path p. We say that a finite (resp. infinite) path p0 is a finite (resp. infinite) extension of
the finite path p if the sequence of nodes of p is a prefix of the sequence of nodes of p0 .
A tree automaton is an automaton that accepts sets of trees. In this paper, we consider
a particular family of tree automata, namely parity tree automata (Emerson & Jutla, 1991).
Definition 2 (parity tree automata) A parity tree automaton with parity index k is a
tuple A = h, D, Q, q0 , , i, where:
  is the finite, nonempty alphabet;
 D  N is a finite set of arities;
 Q is the finite set of states;
 q0  Q is the initial state;
104

fiThe Planning Spectrum  One, Two, Three, Infinity



d

  : Q    D  2Q is the transition function, where (q, , d)  2Q ;
  : Q  {0, . . . , k} is the parity mapping.
A tree automaton accepts a tree if there is an accepting run of the automaton on the tree.
Intuitively, when a parity tree automaton is in state q and it is reading a d-ary node of the
tree that is labeled by , it nondeterministically chooses a d-tuple hq1 , . . . , qd i in (q, , d)
and then makes d copies of itself, one for each child node of the tree, with the state of the
i-th copy updated to qi . A run of the parity tree automaton is accepting if, along every
infinite path, the minimal priority that is visited infinitely often is an even number.
Definition 3 (tree acceptance) The parity tree automaton A = h, D, Q, q0 , , i accepts the -labelled D-tree  if there exists an accepting run r for  , namely there exists a
mapping r :   Q such that:
 r() = q0 ;
 for each x   with arity(x) = d we have hr(x  0), . . . r(x  (d1))i  (r(x),  (x), d);
 along every infinite path x0 , x1 , . . . in
for infinitely many nodes xi is even.

 , the minimal integer h such that (r(xi )) = h

The tree automaton A is nonempty if there exists some tree



that is accepted by A.

Emerson and Jutla (1991) have shown that the emptiness of a parity tree automaton can
be decided in a time that is exponential in the parity index and polynomial in the number
of states.
Theorem 1 The emptiness of a parity tree automaton with n states and index k can be
determined in time nO(k) .
2.2 Temporal Logics
Formulas of Linear Temporal Logic (LTL) (Emerson, 1990) are built on top of a set Prop
of atomic propositions using the standard Boolean operators, the unary temporal operator
X (next), and the binary temporal operator U (until). In the following we assume to have
a fixed set of atomic propositions Prop, and we define  = 2Prop as the set of subsets of
Prop.
Definition 4 (LTL) LTL formulas  on Prop are defined by the following grammar, where
q  Prop:
 ::= q |  |    | X  |  U 
We define the following auxiliary operators: F  = > U  (eventually in the future ) and
G  =  F  (always in the future ). LTL formulas are interpreted over infinite words
on . In the following, we write w |=LTL  whenever the infinite word w satisfies the LTL
formula .
Definition 5 (LTL semantics) Let w = 0 , 1 , . . . be an infinite word on  and let  be
an LTL formula. We define w, i |=LTL , with i  N, as follows:
105

fiPistore & Vardi

 w, i |=LTL q iff q  i ;
 w, i |=LTL  iff it does not hold that w, i |=LTL ;
 w, i |=LTL   0 iff w, i |=LTL  and w, i |=LTL 0 ;
 w, i |=LTL X  iff w, i+1 |=LTL ;
 w, i |=LTL  U 0 iff there is some j  i such that w, k |=LTL  for all i  k < j and
w, j |=LTL 0 .
We say that w satisfies , written w |=LTL , if w, 0 |=LTL .
CTL* (Emerson, 1990) is an example of branching-time logic. Path quantifiers A
(for all paths) and E (for some path) can prefix arbitrary combinations of linear time
operators.
Definition 6 (CTL*) CTL* formulas  on Prop are defined by the following grammar,
where q  Prop:
 ::= q |  |    | A  | E 
 ::=  |  |    | X  |  U 
CTL* formulas are interpreted over -labelled trees. In the following, we write
whenever  satisfies the CTL* formula .



|=CTL* 

Definition 7 (CTL* semantics) Let  be a -labelled tree and let  be a CTL* formula.
We define  , x |=CTL* , with x   , as follows:


 , x |=CTL* q iff q   (x);



 , x |=CTL*  iff it does not hold that  , x |=CTL* ;



 , x |=CTL*   0



 , x |=CTL* A  iff  , p |=CTL*  holds for all infinite paths p = x0 , x1 , . . . with x0 = x;



,x

where

iff

|=CTL* E  iff
x0 = x;

 , x |=CTL*  and  , x |=CTL* 0 ;

,p

|=CTL*  holds for some infinite path p = x0 , x1 , . . . with

 , p |=CTL* , with p  P  ( ), is defined as follows:



 , p |=CTL*  iff p = x0 , x1 , . . . and  , x0 |=CTL* ;



 , p |=CTL*  iff it does not hold that  , p |=CTL* ;



 , p |=CTL*   0



 , p |=CTL* X  iff  , p0 |=CTL* , where p0 = x1 , x2 , . . . if p = x0 , x1 , x2 , . . .;



 , p |=CTL*  U 0 iff there is some j  0 such that  , pk |=CTL*  for all 0  k < j
and  , pj |=CTL* 0 , where pi = xi , xi+1 , . . . if p = x0 , x1 , . . ..

iff

 , p |=CTL*  and  , p |=CTL* 0 ;

106

fiThe Planning Spectrum  One, Two, Three, Infinity

put_B_on_A
A

B

C

B
A

put_C_on_B
C

C
B
A

Figure 1: A possible scenario in the blocks-world domain.
We say that



satisfies the CTL* formula , written



|=CTL* , if

 ,  |=CTL* .

The following theorem states that it is possible to build a tree automaton that accepts
all the trees satisfying a CTL* formula. The tree automaton has a number of states that is
doubly exponential and a parity index that is exponential in the length of the formula. A
proof of this theorem has been given by Emerson and Jutla (1988).
Theorem 2 Let  be a CTL* formula, and let D  N be a finite set of arities. One can
build a parity tree automaton AD
 that accepts exactly the -labelled D-trees that satisfy .
2
The automaton AD
 has 2
formula .

O(||)

states and parity index 2O(||) , where || is the length of

3. Planning Domains and Plans
A (nondeterministic) planning domain (Cimatti et al., 2003) can be expressed in terms of a
set of states, one of which is designated as the initial state, a set of actions, and a transition
function describing how (the execution of) an action leads from one state to possibly many
different states.
Definition 8 (planning domain) A planning domain is a tuple D = h, 0 , A, Ri where:
  is the finite set of states;
 0   is the initial state;
 A is the finite set of actions;
 R :   A  2 is the transition relation.
We require that for each    there is some a  A and some  0   such that  0  R(, a).
We assume that states  are ordered, and we write R(, a) = h1 , 2 , . . . , n i whenever
R(, a) = {1 , 2 , . . . , n } and 1 < 2 <    < n .
Example 1 Consider a blocks-world domain consisting of a set of blocks, which are initially
on a table, and which can be stacked on top of each other in order to build towers (see
Figure 1).
The states  of this domain are the possible configurations of the blocks: in the case of
three blocks there are 13 states, corresponding to all the blocks on the table (1 configuration),
a 2-block tower and the remaining block on the table (6 configurations), and a 3-block tower
(6 possible configurations). We assume that initially all blocks are on the table.
107

fiPistore & Vardi

The actions in this domain are put X on Y , put X on table, and wait, where X and
Y are two (different) blocks. Actions put X on Y and put X on table are possible only if
there are no blocks on top of X (otherwise we could not pick up X). In addition, action
put X on Y requires that there are no blocks on top of Y (otherwise we could not put X
on top of Y ).
We assume that the outcome of action put X on Y is nondeterministic: indeed, trying
to put a block on top of a tower may fail, in which case the tower is destroyed. Also action
wait is nondeterministic: it is possible that the table is bumped and that all its towers are
destroyed.
A plan guides the evolution of a planning domain by issuing actions to be executed.
In the case of nondeterministic domains, conditional plans (Cimatti et al., 2003; Pistore &
Traverso, 2001) are required, that is, the next action issued by the plan may depend on
the outcome of the previous actions. Here we consider a very general definition of plans: a
plan is a mapping from a sequence of states, representing the past history of the domain
evolution, to an action to be executed.
Definition 9 (plan) A plan is a partial function  : + * A such that:
 if (w  ) = a, then  0  R(, a) for some  0 ;
 if (w  ) = a, then  0  R(, a) iff w     0  dom();
 if w    dom() with w 6= , then w  dom();
 () is defined iff  = 0 is the initial state of the domain.
The conditions in the previous definition ensure that a plan defines an action to be executed
for exactly the finite paths w  + that can be reached executing the plan from the initial
state of the domain.
Example 2 A possible plan for the blocks-world domain of Example 1 is represented in Figure 2. We remark the importance of having plans in which the action to be executed depends
on the whole sequence of states corresponding to the past history of the evolution. Indeed,
according to the plan if Figure 2, two different actions put C on A and put C on table are
performed in the state with block B on top of A, depending on the past history.
Since we consider nondeterministic planning domains, the execution of an action may
lead to different outcomes. Therefore, the execution of a plan on a planning domain can be
described as a (A)-labelled tree. Component  of the label of the tree corresponds to
a state in the planning domain, while component A describes the action to be executed in
that state.
Definition 10 (execution tree) The execution tree for domain D and plan  is the
(A)-labelled tree  defined as follows:


 () = (0 , a0 ) where 0

is the initial state of the domain and a0 = (0 );
108

fiThe Planning Spectrum  One, Two, Three, Infinity

w

(w)

ABC

put B on A

B
ABC  AC

put C on B

B
ABC  AC

C
B
 A

B
ABC  AC

C
B
 A

B
 AC

B
ABC  AC

C
B
 A

B
 AC

put C on table

any other history

put B on table

 ABC

wait
wait

Figure 2: A plan for the blocks-world domain.
 if p = x0 , . . . , xn  P  ( ) with  (p) = (0 , a0 )  (1 , a1 )    (n , an ), and if R(n , an ) =
0
h00 , . . . , d1
i, then for every 0  i < d the following conditions hold: xn  i  dom( )
and  (xn  i) = (i0 , a0i ) with a0i = (0  1    n  i0 ).
A planning problem consists of a planning domain and of a goal g that defines the set
of desired behaviors. In the following, we assume that the goal g defines a set of execution
trees, namely the execution trees that exhibit the behaviors described by the goal (we say
that these execution trees satisfy the goal).
Definition 11 (planning problem) A planning problem is a pair (D, g), where D is a
planning domain and g is a goal. A solution to a planning problem (D, g) is a plan  such
that the execution tree for  satisfies the goal g.

4. A Logic of Path Quantifiers
In this section we define a new logic that is based on LTL and that extends it with the
possibility of defining conditions on the sets of paths that satisfy the LTL property. We
start by motivating why such a logic is necessary for defining planning goals.
Example 3 Consider the blocks-world domain introduced in the previous section. Intuitively, the plan of Example 2 is a solution to the goal of building a tower consisting of
blocks A, B, C and then of destroying it. This goal can be easily formulated as an LTL
109

fiPistore & Vardi

formula:
1 = F ((C on B  B on A  A on table)  F (C on table  B on table  A on table)).
Notice however that, due to the nondeterminism in the outcome of actions, this plan may
fail to satisfy the goal. It is possible, for instance, that action put C on B fails and the
tower is destroyed. In this case, the plan proceeds performing wait actions, and hence the
tower is never finished. Formally, the plan is a solution to the goal which requires that there
is some path in the execution structure that satisfies the LTL formula 1 .
Clearly, there are better ways to achieve the goal of building a tower and then destroying
it: if we fail building the tower, rather than giving up, we can restart building it and keep
trying until we succeed. This strategy allows for achieving the goal in most of the paths:
only if we keep destroying the tower when we try to build it we will not achieve the goal. As
we will see, the logic of path quantifiers that we are going to define will allow us to formalize
what we mean by most of the paths.
Consider now the following LTL formula:
2 = F G ((C on B  B on A  A on table).
The formula requires building a tower and maintaining it. In this case we have two possible
ways to fail to achieve the goal. We can fail to build the tower; or, once built, we can fail to
maintain it (remember that a wait action may nondeterministically lead to a destruction of
the tower). Similarly to the case of formula 1 , a planning goal that requires satisfying the
formula 2 in all paths of the execution tree is unsatisfiable. On the other hand, a goal that
requires satisfying it on some paths is very weak; our logic allows us to be more demanding
on the paths that satisfy the formula.
Finally, consider the following LTL formula:
3 = G F ((C on B  B on A  A on table).
It requires that the tower exists infinitely many time, i.e., if the tower gets destroyed, then
we have to rebuild it. Intuitively, this goal admits plans that can achieve it more often, i.e.,
on more paths, than 2 . Once again, a path logic is needed to give a formal meaning to
more paths.
In order to be able to represent the planning goals discussed in the previous example,
we consider logic formulas of the form ., where  is an LTL formula and  is a path
quantifier and defines a set of infinite paths on which the formula  should be checked. Two
extreme cases are the path quantifier A, which is used to denote that  must hold on all the
paths, and the path quantifier E, which is used to denote that  must hold on some paths.
In general, a path quantifier is a (finite or infinite) word on alphabet {A, E} and defines an
alternation in the selection of the two modalities corresponding to E and A. For instance,
by writing AE. we require that all finite paths have some infinite extension that satisfies
, while by writing EA. we require that all the extensions of some finite path satisfy .
The path quantifier can be seen as the definition of a two-player game for the selection of
the paths that should satisfy the LTL formula. Player A (corresponding to A) tries to build
a path that does not satisfy the LTL formula, while player E (corresponding to E) tries to
110

fiThe Planning Spectrum  One, Two, Three, Infinity

build the path so that the LTL formula holds. Different path quantifiers define different
alternations in the turns of players A and E. The game starts from the path consisting only
of the initial state, and, during their turns, players A and E extend the path by a finite
number of nodes. In the case the path quantifier is a finite word, the player that moves last
in the game extends the finite path built so far to an infinite path. The formula is satisfied
if player E has a winning strategy, namely if, for all the possible moves of the player A, it
is always able to build a path that satisfies the LTL formula.
Example 4 Let us consider the three LTL formulas defined in Example 3, and let us see
how the path quantifiers we just introduced can be applied.
In the case of formula 1 , the plan presented in Example 2 satisfies requirement E.1 :
there is a path on which the tower is built and then destroyed. It also satisfies the stronger
requirement EA.1 that stresses the fact that, in this case, once the tower has been built and
destroyed, we can safely give the control to player A. Formula 1 can be satisfied in a
stronger way, however. Indeed, the plan that keeps trying to build the tower satisfies the
requirement AE.1 , as well as the requirement AEA.1 : player A cannot reach a state where
the satisfaction of the goal is prevented.
Let us now consider the formula 2 . In this case, we can find plans satisfying AE.2 ,
but no plan can satisfy requirement AEA.2 . Indeed, player A has a simple strategy to win,
if he gets the control after we built the tower: bump the table. Similar considerations hold
also for formula 3 . Also in this case, we can find plans for requirement AE.3 , but not for
requirement AEA.3 . In this case, however, plans exist also for requirement AEAEAE    .3 :
if player E gets the control infinitely often, then it can rebuild the tower if needed.
In the rest of the section we give a formal definition and study the basic properties of
this logic of path quantifiers.
4.1 Finite Games
We start considering only games with a finite number of moves, that is path quantifiers
corresponding to finite words on {A, E}.
Definition 12 (AE-LTL) An AE-LTL formula is a pair g = ., where  is an LTL
formula and   {A, E}+ is a path quantifier.
The following definition describes the games corresponding to the finite path quantifiers.
Definition 13 (semantics of AE-LTL) Let p be a finite path of a -labelled tree
Then:
 p |= A. if for all finite extensions p0 of p it holds that p0 |= ..
 p |= E. if for some finite extension p0 of p it holds that p0 |= ..
 p |= A. if for all infinite extensions p0 of p it holds that

 (p0 ) |=LTL .

 p |= E. if for some infinite extension p0 of p it holds that
111

 (p0 ) |=LTL .

.

fiPistore & Vardi

We say that the -labelled tree  satisfies the AE-LTL formula g, and we write
p0 |= g, where p0 =  is the root of  .



|= g, if

AE-LTL allows for path quantifiers consisting of an arbitrary combination of As and
Es. Each combination corresponds to a different set of rules for the game between A and
E. In Theorem 4 we show that all this freedom in the definition of the path quantifier is
not needed. Only six path quantifiers are sufficient to capture all the possible games. This
result is based on the concept of equivalent path quantifiers.
Consider formulas A. F p and AE. F p. It is easy to see that the two formulas are equisatisfiable, i.e., if a tree  satisfies A. F p then it also satisfies AE. F p, and vice-versa. In
this case, path quantifiers A and AE have the same power, but this depends on the fact
that we use the path quantifiers in combination with the LTL formula F p. If we combine
the two path quantifiers with different LTL formulas, such as G p, it is possible to find
trees that satisfy the latter path quantifier but not the former. For this reason, we cannot
consider the two path quantifiers equivalent. Indeed, in order for two path quantifiers to
be equivalent, they have to be equi-satisfiable for all the LTL formulas. This intuition is
formalized in the following definition.
Definition 14 (equivalent path quantifiers) Let  and 0 be two path quantifiers. We
say that  implies 0 , written 
0 , if for all -labelled trees  and for all LTL formulas
0
,  |= . implies  |=  .. We say that  is equivalent to 0 , written   0 , if 
0
0
and 
.
The following lemma describes some basic properties of path quantifiers and of the
equivalences among them. We will exploit these results in the proof of Theorem 4.
Lemma 3 Let , 0  {A, E} . The following implications and equivalences hold.
1. AA0  A0 and EE0  E0 .
2. A0

0 and 0

E0 , if 0 is not empty.

3. A0

AEA0 and EAE0

E0 .

4. AEAE0  AE0 and EAEA0  EA0 .
Proof. In the proof of this lemma, in order to prove that 0
00 we prove that, given
0
an arbitrary tree  and an arbitrary LTL formula , p |=  . implies p |= 00 . for every
finite path p of  . Indeed, if p |= 0 . implies p |= 00 . for all finite paths p, then it is easy
to prove, by induction on , that p |= 0 . implies p |= 00 . for all finite paths p. In the
following, we will refer to this proof technique as prefix induction.
1. We show that, for every finite path p, p |= AA0 . if and only if p |= A0 .: then the
equivalence of AA0 and A0 follows by prefix induction.
Let us assume that p |= AA0 .. We prove that p |= A0 ., that is, that p0 |= 0 .
for every finite3 extension p0 of p. Since p |= AA0 ., by Definition 13 we know that,
3. We assume that 0 is not the empty word. The proof in the case 0 is the empty word is similar.

112

fiThe Planning Spectrum  One, Two, Three, Infinity

for every finite extension p0 of p, p0 |= A0 .. Hence, again by Definition 13, we know
that for every finite extension p00 of p0 , p00 |= 0 .. Since p0 is a finite extension of p0 ,
we can conclude that p0 |= 0 .. Therefore, p0 |= 0 . holds for all finite extensions p0
of p.
Let us now assume that p |= A0 .. We prove that p |= AA0 ., that is, for all finite
extensions p0 of p, and for all finite extensions p00 of p0 , p00 |= 0 .. We remark that
the finite path p00 is also a finite extension of p, and therefore p00 |= 0 . holds since
p |= A0 ..
This concludes the proof of the equivalence of AA0 and A0 . The proof of the
equivalence of EE0 and E0 is similar.
2. Let us assume first that 0 is not an empty word. We distinguish two cases, depending
on the first symbol of 0 . If 0 = A00 , then we should prove that AA00
A00 ,
0
00
which we already did in item 1 of this lemma. If  = E , then we show that, for
every finite path p, if p |= AE00 . then p |= E00 .: then A0
0 follows by
00
prefix induction. Let us assume that p |= AE .. Then, for all finite extensions p0 of
p there exists some finite4 extension p00 of p0 such that p00 |= 0 .. Let us take p0 = p.
Then we know that there is some finite extension p00 of p such that p00 |= 0 ., that is,
according to Definition 13, p |= E0 ..
Let us now assume that 0 is the empty word. By hypothesis, 0 6= , so  is not
empty. We distinguish two cases, depending on the last symbol of . If  = 00A, then
we should prove that 00AA
00A, which we already did in item 1 of this lemma.
If  = 00 E, then we prove that for every finite path p, if p |= EA. then p |= E.:
then 00 EA
00 E follows by prefix induction. Let us assume that p |= EA.. By
Definition 13, there exists some finite extension p0 of p such that, for every infinite
extension p00 of p0 we have  (p00 ) |=LTL . Let p00 be any infinite extension of p0 . We
know that p00 is also an infinite extension of p, and that  (p00 ) |=LTL . Then, by
Definition 13 we deduce that p |= E..
This concludes the proof that A0

0 . The proof that 0

E0 is similar.

3. By item 1 of this lemma we know that A0
AA0 and by item 2 we know that
0
0
AA
AEA . This concludes the proof that A0
AEA0 . The proof that
EAE0
E0 is similar.
4. By item 3 of this lemma we know that (A)EAE0
(A)E0 . Moreover, again
0
0
by item 3, we know that A(E )
AEA(E ). Therefore, we deduce AE0 
0
0
AEAE . The proof that EA  EAEA0 is similar.

We can now prove the first main result of the paper: each finite path quantifier is
equivalent to a canonical path quantifier of length at most three.
Theorem 4 For each finite path quantifier  there is a canonical finite path quantifier
0  {A, E,AE, EA,AEA, EAE}
4. We assume that 00 is not the empty word. The proof in the case where 00 is empty is similar.

113

fiPistore & Vardi

such that   0 . Moreover, the following implications hold between the canonical finite
path quantifiers:
(1)
A /o /o /o / AEA o/ /o /o / AE
O

O

O

O

O

o
/
o
/
/
/
o
EA
EAE /o /o o/ / E


O

Proof. We first prove that each path quantifier  is equivalent to some canonical path
quantifier 0 . By an iterative application of Lemma 3(1), we obtain from  a path quantifier
00 such that   00 and 00 does not contain two adjacent A or E. Then, by an iterative
application of Lemma 3(4), we can transform 00 into an equivalent path quantifier 0 of
length at most 3. The canonical path quantifiers in (1) are precisely those quantifiers of
length at most 3 that do not contain two adjacent A or E.
For the implications in (1):
A

AEA and EAE

E come from Lemma 3(3);

 AEA

EA and AE

EAE come from Lemma 3(2);

 AEA

AE and EA

EAE come from Lemma 3(2).



We remark that Lemma 3 and Theorem 4 do not depend on the usage of LTL for formula
. They depend on the general observation that 
0 whenever player E can select for
game 0 a set of paths which is a subset of those selected for game .
4.2 Infinite Games
We now consider infinite games, namely path quantifiers consisting of infinite words on
alphabet {A, E}. We will see that infinite games can express all the finite path quantifiers
that we have studied in the previous subsection, but that there are some infinite games, corresponding to an infinite alternation of the two players A and E, which cannot be expressed
with finite path quantifiers.
In the case of infinite games, we assume that player E moves according to a strategy 
that suggests how to extend each finite path. We say that  |= ., where  is an infinite
game, if there is some winning strategy  for player E. A strategy  is winning if, whenever
p is an infinite path of  obtained according to   i.e., by allowing player A to play in an
arbitrary way and by requiring that player E follows strategy   then p satisfies the LTL
formula .
Definition 15 (strategy) A strategy for a -labelled tree  is a mapping  : P  ( ) 
P  ( ) that maps every finite path p to one of its finite extensions (p).
Definition 16 (semantics of AE-LTL) Let  = 0 1    with i  {A, E} be an infinite
path quantifier. An infinite path p is a possible outcome of game  with strategy  if there
is a generating sequence for it, namely, an infinite sequence p0 , p1 , . . . of finite paths such
that:
 pi are finite prefixes of p;
114

fiThe Planning Spectrum  One, Two, Three, Infinity

 p0 =  is the root of tree

;

 if i = E then pi+1 = (pi );
 if i = A then pi+1 is an (arbitrary) extension of pi .
We denote with P (, ) the set of infinite paths of  that are possible outcomes of game 
with strategy . The tree  satisfies the AE-LTL formula g = ., written  |= g, if there
is some strategy  such that  (p) |=LTL  for all paths p  P (, ).
We remark that it is possible that the paths in a generating sequence stop growing, i.e.,
that there is some pi such that pi = pj for all j  i. In this case, according to the previous
definition, all infinite paths p that extend pi are possible outcomes.
In the next lemmas we extend the analysis of equivalence among path quantifiers to
infinite games.5 The first lemma shows that finite path quantifiers are just particular cases
of infinite path quantifiers, namely, they correspond to those infinite path quantifiers that
end with an infinite sequence of A or of E.
Lemma 5 Let  be a finite path quantifier. Then (A)  A and (E)  E.
Proof. We prove that (A)  A. The proof of the other equivalence is similar.
First, we prove that (A)
A. Let  be a tree and  be an LTL formula such that
 |= (A) .. Moreover, let  be any strategy such that all p  P ((A) , ) satisfy . In
order to prove that  |= A. it is sufficient to use the strategy  in the moves of player
E, namely, whenever we need to prove that p |= E0 . according to Definition 13, we take
p0 = (p) and we move to prove that p0 |= 0 .. In this way, the infinite paths selected by
Definition 13 for A coincide with the possible outcomes of game (A) , and hence satisfy
the LTL formula .
This concludes the proof that (A)
A. We now prove that A
(A) . We distinguish
three cases.
 Case  = (A)n , with n  0.
In this case, A  A (Lemma 3(1)) and (A) = (A) . Let  be a tree and  be an
LTL formula. Then  |= A. if and only if all the paths of  satisfy formula . It is
easy to check that also  |= (A) . if and only if all the paths of  satisfy formula .
This is sufficient to conclude that (A)nA  (A)n (A) .
 Case  = E0 .
In this case, A  EA. Indeed, A is an arbitrary path quantifier that starts with E
and ends with A. By Lemma 3(1), we can collapse adjacent occurrences of A and of
E , thus obtaining A  (EA)n for some n > 0. Moreover, by Lemma 3(4) we have
(EA)n  EA.
Let  be a tree and  be an LTL formula. Then  |= EA. if and only if there is
some finite path p of  such that all the infinite extensions of p satisfy . Now, let
5. The definitions of the implication and equivalence relations (Definition 14) also apply to the case of
infinite path quantifiers.

115

fiPistore & Vardi

 be any strategy such that () = p. Then every infinite path p  P (E0 (A) , )
satisfies . Indeed, since player E has the first turn, all the possible outcomes are
infinite extensions of () = p.
This concludes the proof that E0A

E0 (A) .

 Case  = (A)n E0 , with n > 0.
Reasoning as in the proof of the previous case, it is easy to show that A  AEA.
Let  be a tree and  be an LTL formula. Then  |= AEA. if and only if for
every finite path p of  there is some finite extension p0 of p such that all the infinite
extensions of p0 satisfy the formula . Let  be any strategy such that p0 = (p) is a
finite extension of p such that all the infinite extensions of p0 satisfy . Then every
infinite path p  P ((A)n E0 (A) , ) satisfies . Indeed, let p0 , p1 , . . . , pn , pn+1 , . . . be
a generating sequence for p. Then pn+1 = (pn ) and p is an infinite extension of pn+1 .
By construction of  we know that p satisfies .
This concludes the proof that (A)n E0A

(A)n E0 (A) .

Every finite path quantifier  falls in one of the three considered cases. Therefore, we can
conclude that A
(A) for every finite path quantifier .

The next lemma defines a sufficient condition for proving that 
is useful for the proofs of the forthcoming lemmas.

0 . This condition

Lemma 6 Let  and 0 be two infinite path quantifiers. Let us assume that for all -labelled
trees and for each strategy  there is some strategy  0 such that P (0 ,  0 )  P (, ). Then

0 .
Proof. Let us assume that  |= .. Then there is a suitable strategy  such that all
p  P (, ) satisfy the LTL formula . Let  0 be a strategy such that all P (0 ,  0 ) 
P (, ). By hypothesis, all possible outcomes for game 0 and strategy  0 satisfy the LTL
formula , and hence  |= 0 .. This concludes the proof that 
0 .

In the next lemma we show that all the games where players A and E alternate infinitely
often are equivalent to one of the two games (AE) and (EA) . That is, we can assume that
each player extends the path only once before the turn passes to the other player.
Lemma 7 Let  be an infinite path quantifier that contains an infinite number of A and
an infinite number of E. Then   (AE) or   (EA) .
Proof. Let  = (A)m1 (E)n1 (A)m2 (E)n2    with mi , ni > 0. We show that   (AE) .
First, we prove that (AE)
. Let  be a strategy for the tree  and let p be an infinite
path of  . We show that if p  P (, ) then p  P ((AE) , ). By Lemma 6 this is
sufficient for proving that (AE)
.
Let p0 , p1 , . . . be a generating sequence for p according to  and . Moreover, let p00 = ,
p02i+1 = pm1 +n1 ++mi1 +ni1 +mi and and p02i+2 = pm1 +n1 ++mi1 +ni1 +mi +1 . It is easy to
check that p00 , p01 , p02 , . . . is a valid generating sequence for p according to game (AE) and
strategy . Indeed, extensions p00  p01 , p02  p03 , p04  p05 , . . . are moves of player A,
116

fiThe Planning Spectrum  One, Two, Three, Infinity

and hence can be arbitrary. Extensions p01  p02 , p03  p04 , . . . correspond to extensions
pm1  pm1 +1 , pm1 +n1 +m2  pm1 +n1 +m2 +1 , . . . , which are moves of player E and hence
respect strategy .
We now prove that 
(AE) . Let  be a strategy for the tree  . We define a strategy 
 then p  P (, ). By Lemma 6 this is sufficient for proving
such that if p  P ((AE) , ),

that 
(AE) .
 =  kp (p) with kp = P|p| ni . That is, strategy  on path
Let p be a finite path. Then (p)
i=1
p is obtained by applying kp times strategy . The number of times strategy  is applied
depends on the length |p| of path p.
 then p is a possible
We show that, if p is a possible outcome of the game  with strategy ,

outcome of the game (AE) with strategy . Let p0 , p1 , . . . be a generating sequence for p
 Then
according to (AE) and .
p0 , p1 , ..., p1 , (p1 ),  2 (p1 ), ...,  n1 (p1 ), p3 , ..., p3 ,
| {z } |
{z
} | {z }
m1 times

m2 times
n1 times
2
n2
(p3 ),  (p3 ), ...,  (p3 ), p5 , ..., p5 , ...

|

{z

n2 times

} | {z }
m3 times

is a valid generating sequence for p according to  and . The extensions corresponding to
an occurrence of symbol E in  consist of an application of the strategy  and are hence valid
for player E. Moreover, extension  ni (p2i1 )  p2i+1 is a valid move for player A because
p2i+1 is an extension of  ni (p2i1 ). Indeed,  ni (p2i1 ) is a prefix of p2i (and hence of p2i+1 )
P|p2i1 |
 2i1 ) =  kp2i1 (p2i1 ) and kp
since p2i = (p
2i1 =
x=1 nx  ni , since |p2i1 |  i. The
other conditions of Definition 16 can be easily checked.
This concludes the proof that   (AE) for  = (A)m1 (E)n1 (A)m2 (E)n2    . The proof that
  (EA) for  = (E)m1 (A)n1 (E)m2 (A)n2    is similar.

The next lemma contains other auxiliary results on path quantifiers.
Lemma 8 Let  be a finite path quantifier and 0 be an infinite path quantifier.
1. A0
2. (A)

0 and 0

E0 .

A0 and E0

(E) .

Proof.
1. We prove that A0
0 . Let  be a strategy for tree  and let p be an infinite
path of  . We show that if p  P (0 , ) then p  P (A0 , ). Let p0 , p1 , . . .
be a generating sequence for p according to 0 and . Then it is easy to check that
p0 , p1 , . . . , pi1 , pi , pi , pi+1 , . . ., where i is the length of , is a valid generating sequence
for p according to A0 and . Indeed, the extension pi  pi is a valid move for player
A. This concludes the proof that A0
0 .
Now we prove that 0
E0 . If 0 = (E) , then E0 = E(E) = (E) = 0 ,
and E0
0 is trivially true. If 0 6= (E) , we can assume, without loss of
generality, that 0 = A00 . In this case, let  be a strategy for tree  and let p be a
117

fiPistore & Vardi

path of  . We show that if p  P (E0 , ) then p  P (0 , ). Let p0 , p1 , . . . be
a generating sequence for p according to E0 and . Then it is easy to check that
p0 , p1 , . . . , pi , pi+2 , . . ., where i is the length of , is a valid generating sequence for p
according to 0 and . Indeed, extension pi  pi+2 is valid, as it corresponds to the
first symbol of 0 and we have assumed it to be symbol A. This concludes the proof
that 0
E0 .
2. We prove that (A)

0 . The proof that 0

(E) is similar.

Let  be a strategy for tree  and let p be an infinite path of  . We show that if
p  P ((A) , ) then p  P (0 , ). Let p0 , p1 , . . . be a generating sequence for p
according to 0 and . Then it is easy to check that p0 , p1 , . . . is a valid generating sequence for p according to (A) and . In fact, (A) defines less restrictive
conditions on generating sequences than 0 .
This is sufficient to conclude that (A)

0 .



We can now complete the picture of Theorem 4: each finite or infinite path quantifier is
equivalent to a canonical path quantifier that defines a game consisting of alternated moves
of players A and E of length one, two, three, or infinity.
Theorem 9 For each finite or infinite path quantifier  there is a canonical path quantifier
0  {A, E,AE, EA,AEA, EAE, (AE) , (EA) }
such that   0 . Moreover, the following implications hold between the canonical path
quantifiers:
(2)
A /o /o /o / AEA /o /o /o / (AE) /o /o /o / AE
O

O

O


O

EA /o /o /o /

O


O

O

(EA)

O


O

/o /o o/ / EAE /o /o o/ / E

Proof. We first prove that each path quantifier is equivalent to a canonical path quantifier.
By Theorem 4, this is true for the finite path quantifiers, so we only consider infinite path
quantifiers.
Let  be an infinite path quantifier. We distinguish three cases:
  contains an infinite number of A and an infinite number of E: then, by Lemma 7, 
is equivalent to one of the canonical games (AE) or (EA) .
  contains a finite number of A: in this case,  ends with an infinite sequence of E,
and, by Lemma 5,   00 for some finite path quantifier 00 . By Theorem 4, 00 is
equivalent to some canonical path quantifier, and this concludes the proof for this
case.
  contains a finite number of E: this case is similar to the previous one.
For the implications in (2):
118

fiThe Planning Spectrum  One, Two, Three, Infinity

 (AE)
(AE) .

(EA) comes from Lemma 8(1), by taking the empty word for  and 0 =

 AEA
(AE) , (AE)
and 8(2).

AE, EA

(EA) , and (EA)

EAE come from Lemmas 5

 The other implications come from Theorem 4.



4.3 Strictness of the Implications
We conclude this section by showing that all the arrows in the diagram of Theorem 9
describe strict implications, namely, the eight canonical path quantifiers are all different.
Let us consider the following {i, p, q}-labelled binary tree, where the root is labelled by i
and each node has two children labelled with p and q:
'&%$
!"#
iM
qqq MMMMM
q
q
MMM
q
M&
qqq
()*+
/.-,
()*+
/.-,
p =xq
q
=

 ===
=


==
=

==

=




()*+
/.-,
/.-,
()*+
()*+
/.-,
()*+
/.-,
p.
q.
p.
q.
  ...
  ...
  ...
  ...








()*+
/.-,
/.-,
/.-,
()*+
/.-,
()*+
/.-,
/.-,
/.-,
()*+
/.-,
()*+
p ()*+
p
p ()*+
q
q
p
q
q ()*+

Let us consider the following LTL formulas:
 F p: player E can satisfy this formula if he moves at least once, by visiting a p-labelled
node.
 G F p: player E can satisfy this formula if he can visit an infinite number of p-labelled
nodes, that is, if he has the final move in a finite game, or if he moves infinitely often
in an infinite game.
 F G p: player E can satisfy this formula only if he takes control of the game from a
certain point on, that is, only if he has the final move in a finite game.
 G q: player E can satisfy this formula only if player A never plays, since player A
can immediately visit a q-labelled node.
 X p: player E can satisfy this formula by playing the first turn and moving to the left
child of the root node.
The following graph shows which formulas hold for which path quantifiers:
Fp

GFp

FGp

G q

A /o o/ / AEA /o / (AE) /o o/ / AE
O

Xp

O

O


O

O


O

O

O


O

EA /o o/ / (EA) /o o/ / EAE /o /o o/ / E
119

fiPistore & Vardi

5. A Planning Algorithm for AE-LTL
In this section we present a planning algorithm for AE-LTL goals. We start by showing
how to build a parity tree automaton that accepts all the trees that satisfy a given AE-LTL
formula. Then we show how this tree automaton can be adapted, so that it accepts only
trees that correspond to valid plans for a given planning domain. In this way, the problem
of checking whether there exists some plan for a given domain and for an AE-LTL goal is
reduced to the emptiness problem on tree automata. Finally, we study the complexity of
planning for AE-LTL goals and we prove that this problem is 2EXPTIME-complete.
5.1 Tree Automata and AE-LTL Formulas
Berwanger, Gradel, and Kreutzer (2003) have shown that AE-LTL formulas can be expressed directly as CTL* formulas. The reduction exploits the equivalence of expressive
power of CTL* and monadic path logic (Moller & Rabinovich, 1999). A tree automaton
can be obtained for an AE-LTL formula using this reduction and Theorem 2. However,
the translation proposed by Berwanger et al. (2003) has an upper bound of non-elementary
complexity, and is hence not useful for our complexity analysis. In this paper we describe
a different, more direct reduction that is better suited for our purposes.
A -labelled tree  satisfies a formula . if there is a suitable subset of paths of the
tree that satisfy . The subset of paths should be chosen according to . In order to
characterize the suitable subsets of paths, we assume to have a w-marking of the tree  ,
and we use the labels w to define the selected paths.
Definition 17 (w-marking) A w-marking of the -labelled tree  is a ({w, w})-labelled tree w such that dom( ) = dom(w ) and, whenever  (x) = , then w (x) = (, w)
or w (x) = (, w).
We exploit w-markings as follows. We associate to each AE-LTL formula . a CTL*
formula [[.]] such that the tree  satisfies the formula . if and only if there is a wmarking of  that satisfies [[.]].
Definition 18 (AE-LTL and CTL*) Let . be an AE-LTL formula. The CTL* formula
[[.]] is defined as follows:
[[A.]] = A 
[[E.]] = E 
[[EA.]] = EF w  A(F w  )
[[AEA.]] = AG EF w  A(F w  )
[[AE.]] = AG EXG w  A(F G w  )
[[EAE.]] = EF AG EXG w  A(F G w  )
[[(AE) .]] = AG EF w  A(G F w  )
[[(EA) .]] = EF AG EF w  A(G F w  )
In the case of path quantifiers A and E, there is a direct translation into CTL* that does
not exploit the w-marking. In the other cases, the CTL* formula [[.]] is the conjunction
120

fiThe Planning Spectrum  One, Two, Three, Infinity

of two sub-formulas. The first one characterizes the good markings according to the path
quantifier , while the second one guarantees that the paths selected according to the
marking satisfy the LTL formula . In the case of path quantifiers EA and AEA, we mark
with w the nodes that, once reached, guarantee that the formula  is satisfied. The selected
paths are hence those that contain a node labelled by w (formula F w). In the case of
path quantifiers AE and EAE, we mark with w all the descendants of a node that define an
infinite path that satisfies . The selected paths are hence those that, from a certain node
on, are continuously labelled by w (formula F G w). In the case of path quantifiers (AE)
and (EA) , finally, we mark with w all the nodes that player E wants to reach according
to its strategy before passing the turn to player A. The selected paths are hence those that
contain an infinite number of nodes labelled by w (formula G F w), that is, the paths along
which player E moves infinitely often.
Theorem 10 A -labelled tree  satisfies the AE-LTL formula . if and only if there is
some w-marking of  that satisfies formula [[.]].
Proof. In the proof, we consider only the cases of  = AEA,  = AE and  = (AE) . The
other cases are similar.
Assume that a tree  satisfies .. Then we show that there exists a w-marking w of 
that satisfies [[.]].
 Case  = AEA. According to Definition 13, if the tree  satisfies AEA., then every
finite path p of  can be extended to a finite path p0 such that all the infinite extensions
p00 of p0 satisfy . Let us mark with w all the nodes of w that correspond to the
extension p0 of some path p. By construction, the marked tree satisfies AG EF w. It
remains to show that the marked tree satisfies A(F w  ).
Let us consider any path p00 in the tree that satisfies F w, and let us show that p00 also
satisfies . Since p00 satisfies F w, we know that it contains nodes marked with w. Let
p0 be the finite prefix of path p00 up to the first node marked by w. By construction,
there exists a finite path p such that p0 is a finite extension of p and all the infinite
extensions of p0 satisfy . As a consequence, also p00 satisfies .
 Case  = AE. According to Definition 13, if the tree  satisfies AE., then for all the
finite paths p there is some infinite extension of p that satisfies . Therefore, we can
define a mapping m : P  ( )  P  ( ) that associates to a finite path p an infinite
extension m(p) that satisfies . We can assume, without loss of generality, that, if p0
is a finite extension of p and is also a prefix of m(p), then m(p0 ) = m(p). That is, as
far as p0 extends the finite path p along the infinite path m(p) then m associates to
p0 the same infinite path m(p).
For every finite path p, let us mark with w the node of w that is the child of p
along the infinite path m(p). By construction, the marked tree satisfies AG EXG w.
It remains to show that the marked tree satisfies A(F G w  ).
Let us consider a path p00 in the tree that satisfies F G w, and let us show that p00 also
satisfies . Since p00 satisfies F G w, we know that there is some path p such that all
the descendants of p along p00 are marked with w. In order to prove that p00 satisfies 
121

fiPistore & Vardi

we show that p00 = m(p). Assume by contradiction that m(p) 6= p00 and let p0 be the
longest common prefix of m(p) and p00 . We observe that p is a prefix of p0 , and hence
m(p) = m(p0 ). This implies that the child node of p0 along p00 is not marked with w,
which is absurd, since by definition of p all the descendants of p along p00 are marked
with w.
 Case  = (AE) . According to Definition 16, if the tree  satisfies (AE) ., then
there exists a suitable strategy  for player E so that all the possible outcomes of game
 with strategy  satisfy . Let us mark with w all the nodes in w that correspond
to the extension (p) of some finite path p. That is, we mark with w all the nodes
that are reached after some move of player E according to strategy . The marked
tree satisfies the formula AG EF w, that is, every finite path p can be extended to a
finite path p0 such that the node corresponding to p0 is marked with w. Indeed, by
construction, it is sufficient to take p0 = (p00 ) for some extension p00 of p. It remains
to show that the marked tree satisfies A(G F w  ).
Let us consider a path p in the tree that satisfies G F w, and let us show that p also
satisfies . To this purpose, we show that p is a possible outcome of game  with
strategy . We remark that, given an arbitrary finite prefix p0 of p it is always possible
to find some finite extension p00 of p0 such that (p00 ) is also a prefix of p. Indeed, the
set of paths P = {p : (p) is a finite prefix of p} is infinite, as there are infinite nodes
marked with w in path p.
Now, let p0 , p1 , p2 , . . . be the sequence of finite paths defined as follows: p0 = () is
the root of the three; p2k+1 is the shortest extension of p2k such that (p2k+1 ) is a
prefix of p; and p2k+2 = (p2k+1 ). It is easy to check that p0 , p1 , p2 , . . . is a generating
sequence for p according to (AE) and . Hence, by Definition 16, the infinite path p
satisfies the LTL formula .
This concludes the proof that if  satisfies ., then there exists a w-marking of  that
satisfies [[.]].
Assume now that there is a w-marked tree w that satisfies [[.]]. We show that  satisfies
..
 Case  = AEA. The marked tree satisfies the formula AG EF w. This means that for
each finite path p (AG) there exists some finite extension p0 such that the final node
of p0 is marked by w (EF w) . Let p00 be any infinite extension of such a finite path p0 .
We show that p00 satisfies the LTL formula . Clearly, p00 satisfies the formula F w.
Since the tree satisfies the formula A(F w  ), all the infinite paths that satisfy F w
also satisfy . Therefore, p00 satisfies the LTL formula .
 Case  = AE. The marked tree satisfies the formula AG EXG w. Then, for each
finite path p (AG) there exists some infinite extension p0 such that, from a certain
node on, all the nodes of p0 are marked with w (EXG w). We show that, if p0 is the
infinite extension of some finite path p, then p0 satisfies the LTL formula . Clearly,
p0 satisfies the formula F G w. Since the tree satisfies the formula A(F G w  ), all
the infinite paths that satisfy F G w also satisfy . Therefore, p0 satisfies the LTL
formula .
122

fiThe Planning Spectrum  One, Two, Three, Infinity

 Case  = (AE) . Let  be any strategy so that, for every finite path p, the node
corresponding to (p) is marked with w. We remark that it is always possible to define
such a strategy. In fact, the marked tree satisfies the formula AG EF w, and hence,
each finite path p can be extended to a finite path p0 such that the node corresponding
to p0 is marked with w.
Let p be a possible outcome of game  with strategy . We should prove that p satisfies
the LTL formula . By Definition 16, the infinite path p contains an infinite set of
nodes marked by w: these are all the nodes reached after a move of player E. Hence,
p satisfies the formula G F w. Since the tree satisfies the formula A(G F w  ), all
the infinite paths that satisfy G F w also satisfy . Therefore, path p satisfies the LTL
formula .
This concludes the proof that, if there exists a w-marking of tree
then  |= ..



that satisfies [[.]],


Kupferman (1999) defines an extension of CTL* with existential quantification over
atomic propositions (EGCTL*) and examines complexity of model checking and satisfiability
for the new logic. We remark that AE-LTL can be seen as a subset of EGCTL*. Indeed,
according to Theorem 10, a -labelled tree satisfies an AE-LTL formula . if and only if
it satisfies the EGCTL* formula w.[[.]].
In the following definition we show how to transform a parity tree automaton for the
CTL* formula [[.]] into a parity tree automaton for the AE-LTL formula .. This
transformation is performed by abstracting away the information on the w-marking from
the input alphabet and from the transition relation of the tree automaton.
Definition 19 Let A = h{w, w}, D, Q, q0 , , i be a parity tree automaton. The parity
tree automaton Aw = h, D, Q, q0 , w , i, obtained from A by abstracting away the wmarking, is defined as follows: w (q, , d) = (q, (, w), d)  (q, (, w), d).
Lemma 11 Let A and Aw be two parity tree automata as in Definition 19. Aw accepts
exactly the -labelled trees that have some w-marking which is accepted by A.
Proof. Let w be a ({w, w})-labelled tree and let  be the corresponding -labelled
tree, obtained by abstracting away the w-marking. We show that if w is accepted by A,
then  is accepted by Aw . Let r :   Q be an accepting run of w on A. Then r is also
an accepting run of  on Aw . Indeed, if x   , arity(x) = d, and w (x) = (, m) with
m  {w, w}, then we have hr(x  0), . . . , r(x  d1)i  (r(x), (, m), d). Then  (x) = ,
and, by definition of Aw , we have hr(x  0), . . . , r(x  d1)i  w (r(x), , d).
Now we show that, if the -labelled tree  is accepted by Aw , then there is a ({w, w})labelled tree w that is a w-marking of  and that is accepted by A. Let r :   Q be an
accepting run of  on Aw . By definition of run, we know that if x   , with arity(x) = d
and  (x) = , then hr(x  0), . . . , r(x  d1)i  w (r(x), , d). By definition of w , we
know that hr(x  0), . . . , r(x  d1)i  (r(x), (, w), d)  (r(x), (, w), d). Let us define
w (x) = (, w) if hr(x  0), . . . , r(x  d1)i  (r(x), (, w), d), and w (x) = (, w) otherwise.
It is easy to check that r is an accepting run of w on A.

123

fiPistore & Vardi

Now we have all the ingredients for defining the tree automaton that accepts all the
trees that satisfy a given AE-LTL formula.
Definition 20 (tree automaton for AE-LTL) Let D  N be a finite set of arities, and
let . be an AE-LTL formula. The parity tree automaton AD
. is obtained by applying the
transformation described in Definition 19 to the parity automaton AD
[[.]] built according to
Theorem 2.
Theorem 12 The parity tree automaton AD
. accepts exactly the -labelled D-trees that
satisfy the formula ..
Proof. By Theorem 2, the parity tree automaton AD
[[.]] accepts all the D-trees that satisfy
the CTL* formula [[.]]. Therefore, the parity tree automaton AD
. accepts all the D-trees
that satisfy the formula . by Lemma 11 and Theorem 10.

The parity tree automaton AD
. has a parity index that is exponential and a number of
states that is doubly exponential in the length of formula .
2
Proposition 13 The parity tree automaton AD
. has 2

O(||)

states and parity index 2O(||) .

Proof. The construction of Definition 19 does not change the number of states and the
parity index of the automaton. Therefore, the proposition follows from Theorem 2.

5.2 The Planning Algorithm
We now describe how the automaton AD
. can be exploited in order to build a plan for goal
. on a given domain.
We start by defining a tree automaton that accepts all the trees that define the valid
plans of a planning domain D = h, 0 , A, Ri. We recall that, according to Definition 8,
transition relation R maps a state    and an action a  A into a tuple of next states
h1 , 2 , . . . , n i = R(, a).
In the following we assume that D is a finite set of arities that is compatible with domain
D, namely, if R(, a) = h1 , . . . , d i for some    and a  A, then d  D.
Definition 21 (tree automaton for a planning domain) Let D = h, 0 , A, Ri be a
planning domain and let D be a set of arities that is compatible with domain D. The
D
tree automaton AD
D corresponding to the planning domain is AD = hA, D, , 0 , D , 0 i,
where h1 , . . . , d i  D (, (, a), d) if h1 , . . . , d i = R(, a) with d > 0, and 0 () = 0 for
all   .
According to Definition 10, a (A)-labelled tree can be obtained from each plan  for
domain D. Now we show that also the converse is true, namely, each (A)-labelled tree
accepted by the tree automaton AD
D induces a plan.
Definition 22 (plan induced by a tree) Let  be a (A)-labelled tree that is accepted by automaton AD
D . The plan  induced by  on domain D is defined as follows: (0 , 1 , . . . , n ) = a if there is some finite path p in  with  (p) = (0 , a0 ) 
(1 , a1 )    (n , an ) and a = an .
124

fiThe Planning Spectrum  One, Two, Three, Infinity

The following lemma shows that Definitions 10 and 22 define a one-to-one correspondence between the valid plans for a planning domain D and the trees accepted by automaton
AD
D.
Lemma 14 Let  be a tree accepted by automaton AD
D and let  be the corresponding
induced plan. Then  is a valid plan for domain D, and  is the execution tree corresponding
to . Conversely, let  be a plan for domain D and let  be the corresponding execution
structure. Then  is accepted by automaton AD
D and  is the plan induced by  .
Proof. This lemma is a direct consequence of Definitions 10 and 22.



We now define a parity tree automaton that accepts only the trees that correspond to the
plans for domain D and that satisfy goal g = .. This parity tree automaton is obtained
by combining in a suitable way the tree automaton for AE-LTL formula g (Definition 20)
and the tree automaton for domain D (Definition 21).
Definition 23 (instrumented tree automaton) Let D be a set of arities that is compatible with planning domain D. Let also AD
g = h, D, Q, q0 , , i be a parity tree automaton that accepts only the trees that satisfy the AE-LTL formula g. The parity tree
automaton AD
D,g corresponding to planning domain D and goal g is defined as follows:
D
AD,g = hA, D, Q, (q0 , 0 ),  0 ,  0 i, where h(q1 , 1 ), . . . , (qd , d )i   0 ((q, ), (, a), d) if
hq1 , . . . , qd i  (q, , d) and h1 , . . . , d i = R(, a) with d > 0, and where  0 (q, ) = (q).
The following lemmas show that solutions to planning problem (D, g) are in one-to-one
correspondence with the trees accepted by the tree automaton AD
D,g .
Lemma 15 Let  be a (A)-labelled tree that is accepted by automaton AD
D,g , and let 
be the plan induced by  on domain D. Then the plan  is a solution to planning problem
(D, g).
Proof. According to Definition 11, we have to prove that the execution tree corresponding
to  satisfies the goal g. By Lemma 14, this amounts to proving that the tree  satisfies g.
By construction, it is easy to check that if a (A)-labeled tree  is accepted by AD
D,g , then
D
it is also accepted by Ag . Indeed, if rD,g :   Q   is an accepting run of  on AD
D,g ,
D
then rg :   Q is an accepting run of  on Ag , where rg (x) = q whenever rD,g = (q, )
for some   .

Lemma 16 Let  be a solution to planning problem (D, g). Then the execution tree of 
is accepted by automaton AD
D,g .
Proof. Let  be the execution tree of . By Lemma 14 we know that  is accepted by AD
D.
Moreover, by definition of solution of a planning problem, we know that  is accepted also
by AD
g . By construction, it is easy to check that if a (A)-labeled tree  is accepted by
D
D
AD and by AD
g , then it is also accepted by AD,g . Indeed, let rD :    be an accepting
D
run of  on AD
D and let rg :   Q be an accepting run of  on Ag . Then rD,g :   Q  
D
is an accepting run of  on AD,g , where rD,g (x) = (q, ) if rD (x) =  and rg (x) = q.

125

fiPistore & Vardi

As a consequence, checking whether goal g can be satisfied on domain D is reduced to
the problem of checking whether automaton AD
D,g is nonempty.
Theorem 17 Let D be a planning domain and g be an AE-LTL formula. A plan exists for
goal g on domain D if and only if the tree automaton AD
D,g is nonempty.
Proposition 18 The parity tree automaton AD
D,g for domain D = (, 0 , A, R) and goal
g = . has ||  22

O(||)

states and parity index 2O(||) .

Proof. This is a consequence of Proposition 13 and of the definition of automaton AD
D,g . 
5.3 Complexity
We now study the time complexity of the planning algorithm defined in Subsection 5.2.
Given a planning domain D, the planning problem for AE-LTL goals g = . can
be decided in a time that is doubly exponential in the size of the formula  by applying
Theorem 1 to the tree automaton AD
D,g .
Lemma 19 Let D be a planning domain. The existence of a plan for AE-LTL goal g = .
O(||)
on domain D can be decided in time 22
.
Proof. By Theorem 17 the existence of a plan for goal g on domain D is reduced to the
emptiness problem on parity tree automaton AD
D,g . By Proposition 18, the parity tree
O(||)

2
automaton AD
 || states and parity index 2O(||) . Since we assume that
D,g has 2
domain D is fixed, by Theorem 1, the emptiness of automaton AD
D,g can be decided in time

22

O(||)

.



The doubly exponential time bound is tight. Indeed, the realizability problem for an
LTL formula , which is known to be 2EXPTIME-complete (Pnueli & Rosner, 1990), can
be reduced to a planning problem for the goal A.. In a realizability problem one assumes
that a program and the environment alternate in the control of the evolution of the system.
More precisely, in an execution 0 , 1 , . . . the states i are decided by the program if i is
even, and by the environment if i is odd. We say that a given formula  is realizable if
there is some program such that all its executions satisfy  independently on the actions of
the environment.
Theorem 20 Let D be a planning domain. The problem of deciding the existence of a plan
for AE-LTL goal g = . on domain D is 2EXPTIME-complete.
Proof. The realizability of formula  can be reduced to the problem of checking the exis
tence of a plan for goal A. on planning domain D = {init}  (  {p, e}), init,   {e}, R ,
with:
R(init,  0 ) = {( 0 , e)}
0

R(init, e) = 

0

R((, p),  ) = {( , e)}

R((, p), e) = 

0

R((, e), e) = {( 0 , p) :  0  }

R((, e),  ) = 
126

fiThe Planning Spectrum  One, Two, Three, Infinity

for all ,  0  .
States (, p) are those where the program controls the evolution through actions  0  .
States (, e) are those where the environment controls the evolution; only the nondeterministic action e can be performed in this state. Finally, state init is used to assign the initial
move to the program.
Since the realizability problem is 2EXPTIME-complete in the size of the LTL formula
(Pnueli & Rosner, 1990), the planning problem is 2EXPTIME-hard in the size of the goal
g = .. The 2EXPTIME-completeness follows from Lemma 19.

We remark that, in the case of goals of the form E., an algorithm with a better
complexity can be defined. In this case, a plan exists for E. if and only if there is an
infinite sequence 0 , 1 , . . . of states that satisfies  and such that i+1  R(i , ai ) for some
action ai . That is, the planning problem can be reduced to a model checking problem
for LTL formula , and this problem is known to be PSPACE-complete (Sistla & Clarke,
1985). We conjecture that, for all the canonical path quantifiers  except E, the doubly
exponential bound of Theorem 20 is tight.
Some remarks are in order on the complexity of the satisfiability and validity problems
for AE-LTL goals. These problems are PSPACE-complete. Indeed, the AE-LTL formula
. is satisfiable if and only if the LTL formula  is satisfiable6 , and the latter problem is
known to be PSPACE-complete (Sistla & Clarke, 1985). A similar argument holds also for
validity.
The complexity of the model checking problem for AE-LTL has been recently addressed
by Kupferman and Vardi (2006). Kupferman and Vardi introduce mCTL*, a variant of
CTL*, where path quantifiers have a memoryful interpretation. They show that memoryful quantification can express (with linear cost) the semantics of path quantifiers in our
AE-LTL. For example, the AE-LTL formula AE. is expressed in mCTL* by the formula
AG E . Kupferman and Vardi show that the model checking problem for the new logic is
EXPSPACE-complete, and that this result holds also for the subset of mCTL* that corresponds to formulas AE.. Therefore, the model checking problem for AE-LTL with finite
path quantifiers is also EXPSPACE-complete. To the best of our knowledge the complexity
of model checking AE-LTL formulas (AE) . and (EA) . is still an open problem.

6. Two Specific Cases: Reachability and Maintainability Goals
In this section we consider two basic classes of goals that are particularly relevant in the
field of planning.
6.1 Reachability Goals
The first class of goals are the reachability goals corresponding to the LTL formula F q,
where q is a propositional formula. Most of the literature in planning concentrates on this
class of goals, and there are several works that address the problem of defining plans of
different strength for this kind of goals (see, e.g., Cimatti et al., 2003 and their citations).
6. If a tree satisfies . then some of its paths satisfy , and a path that satisfies  can be seen also as a
tree that satisfies ..

127

fiPistore & Vardi

In the context of AE-LTL, as soon as player E takes control, it can immediately achieve
the reachability goal if possible at all. The fact that the control is given back to player A
after the goal has been achieved is irrelevant. Therefore, the only significant path quantifiers
for reachability goals are A, E, and AE.
Proposition 21 Let q be a propositional formula on atomic propositions Prop. Then, the
following results hold for every labelled tree  .  |= E. F q iff  |= EA. F q iff  |= EAE. F q
iff  |= (EA) . F q. Moreover  |= AE. F q iff  |= AEA. F q iff  |= (AE) . F q.
Proof. We prove that  |= AE. F q iff  |= AEA. F q iff  |= (AE) . F q. The other cases are
similar.
Let us assume that  |= AE. F q. Moreover, let p be a finite path of  . We know that p
can be extended to an infinite path p0 such that  (p0 ) |= F q. According to the semantics of
LTL,  (p0 ) |= F q means that there is some node x in path p0 such that q   (x). Clearly,
all infinite paths of  that contain node x also satisfy the LTL formula F q. Therefore,
there is a finite extension p00 of p such that all the infinite extensions of p00 satisfy the LTL
formula F q: it is sufficient to take as p00 an finite extension of p that contains node x. Since
this property holds for every finite path p, we conclude that  |= AEA. F q.
We have proven that  |= AE. F q implies  |= AEA. F q. By Theorem 9 we know that
AEA
(AE)
AE, and hence  |= AEA. F q implies  |= (AE) . F q implies  |= AE. F q.
This concludes the proof.

The following diagram shows the implications among the significant path quantifiers for
reachability goals:
(3)
A /o /o /o / AE /o /o /o / E
We remark that the three goals A. F q, E. F q, and AE. F q correspond, respectively, to the
strong, weak, and strong cyclic planning problems of Cimatti et al. (2003).
6.2 Maintainability Goals
We now consider another particular case, namely the maintainability goals G q, where q is
a propositional formula. Maintainability goals have properties that are complementary to
the properties of reachability goals. In this case, as soon as player A takes control, it can
violate the maintainability goal if possible at all. The fact that player E can take control
after player A is hence irrelevant, and the only interesting path quantifiers are A, E, and
EA.
Proposition 22 Let q be a propositional formula on atomic propositions Prop. Then, the
following results hold for every labelled tree  . Then  |= A. G q iff  |= AE. G q iff  |=
AEA. G q iff  |= (AE) . G q. Moreover  |= EA. G q iff  |= EAE. G q iff  |= (EA) . G q.
Proof. The proof is similar to the proof of Proposition 21.



The following diagram shows the implications among the significant path quantifiers for
maintainability goals:
A /o /o /o / EA /o /o /o / E
128

fiThe Planning Spectrum  One, Two, Three, Infinity

The goals A. G q, E. G q, and EA. G q correspond to maintainability variants of strong, weak,
and strong cyclic planning problems. Indeed, they correspond to requiring that condition q is
maintained for all evolutions despite nondeterminism (A. G q), that condition q is maintained
for some of the evolutions (E. G q), and that it is possible to reach a state where condition
q is always maintained despite nondeterminism (EA. G p).

7. Related Works and Concluding Remarks
In this paper we have defined AE-LTL, a new temporal logic that extends LTL with the
possibility of declaring complex path quantifiers that define the different degrees in which an
LTL formula can be satisfied by a computation tree. We propose to use AE-LTL formulas
for expressing temporally extended goals in nondeterministic planning domains. We have
defined a planning algorithm for AE-LTL goals that is based on an automata-theoretic
framework: the existence of a plan is reduced to checking the emptiness of a suitable parity
tree automaton. We have studied the time complexity of the planning algorithm, proving
that it is 2EXPTIME-complete in the length of the AE-LTL formula.
In the field of planning, several works use temporal logics for defining goals. Most of
these approaches (Bacchus & Kabanza, 1998, 2000; Calvanese et al., 2002; Cerrito & Mayer,
1998; de Giacomo & Vardi, 1999; Kvarnstrom & Doherty, 2001) use linear temporal logics
as the goal language, and are not able to express conditions on the degree in which the goal
should be satisfied with respect to the nondeterminism in the execution. Notable exceptions
are the works described by Pistore, Bettin, and Traverso (2001), Pistore and Traverso (2001)
and by Dal Lago et al. (2002). Pistore et al. (2001) and Pistore and Traverso (2001) use CTL
as goal language, while Dal Lago et al. (2002) define a new branching time logic that allows
for expressing temporally extended goals that can deal explicitly with failure and recovery
in goal achievement. In these goal languages, however, path quantifiers are interleaved with
the temporal operators, and are hence rather different from AE-LTL.
In the field of temporal logics, the work on alternating temporal logic (ATL) (Alur,
Henzinger, & Kupferman, 2002) is related to our work. In ATL, the path quantifiers in
CTL and CTL* are replaced by game quantifiers. Nevertheless, there is no obvious way to
expressed formulas of the form ., where  is a path quantifier and  is an LTL formula
in ATL , which is the most expressive logic studied by Alur et al. (2002). Our conjecture
is that our logic and ATL are of incomparable expressiveness.
Some comments are in order on the practical impact of the 2EXPTIME complexity of
the planning algorithm. First of all, in many planning problems we expect to have very
complex and large domains, but goals that are relatively simple (see, e.g., the experimental
evaluation performed by Pistore et al. (2001) in the case of planning goals expressed as CTL
formulas). In these cases, the doubly exponential complexity of the algorithm in the size of
the formula may not be a bottleneck. For larger AE-LTL goals, a doubly exponential time
complexity may not be feasible, but it should be noted that this is worst-case complexity.
We also note that improved algorithms for plan synthesis is an active research area, including
the analysis of simpler LTL goals (Alur & La Torre, 2004) and the development of improved
automata-theoretic algorithms (Kupferman & Vardi, 2005).
The automata-theoretic framework that we have used in the paper is of wider applicability than AE-LTL goals. An interesting direction for future investigations is the application
129

fiPistore & Vardi

of the framework to variants of AE-LTL that allow for nesting of path quantifiers, or for
goals that combine AE-LTL with propositional or temporal operators. This would allow,
for instance, to specify goals which compose requirements of different strength. A simple
example of such goals is (AE. F p)(A. G p), which requires to achieve condition p in a strong
cyclic way, maintaining condition q in a strong way. The impossibility to define such kind
of goals is, in our opinion, the strongest limitation of AE-LTL with respect to CTL and
CTL*.
Another direction for future investigations is the extension of the approach proposed in
this paper to the case of planning under partial observability (de Giacomo & Vardi, 1999),
where one assumes that the agent executing the plan can observe only part of the state and
hence its choices on the actions to execute may depend only on that part.
We also plan to explore implementation issues and, in particular, the possibility of
exploiting BDD-based symbolic techniques in a planning algorithm for AE-LTL goals. In
some cases, these techniques have shown to be able to deal effectively with domains and
goals of a significant complexity, despite the exponential worst-case time complexity of the
problems (Bertoli, Cimatti, Pistore, Roveri, & Traverso, 2001; Pistore et al., 2001).

Acknowledgments
A shorter version of this paper, without proofs, has been published by Pistore and Vardi
(2003). The authors would like to thank Erich Gradel for his comments on the reduction
of AE-LTL formulas to CTL* formulas.

References
Alur, R., Henzinger, T., & Kupferman, O. (2002). Alternating-time temporal logic. Journal
of the ACM, 49 (5), 672713.
Alur, R., & La Torre, S. (2004). Deterministic generators and games for LTL fragments.
ACM Trans. Comput. Log., 5 (1), 125.
Bacchus, F., & Kabanza, F. (1998). Planning for temporally extended goals. Ann. of
Mathematics and Artificial Intelligence, 22, 527.
Bacchus, F., & Kabanza, F. (2000). Using temporal logic to express search control knowledge
for planning. Artificial Intelligence, 116 (1-2), 123191.
Bertoli, P., Cimatti, A., Pistore, M., Roveri, M., & Traverso, P. (2001). MBP: A Model
Based Planner. In Proc. of IJCAI01 workshop on Planning under Uncertainty and
Incomplete Information.
Berwanger, D., Gradel, E., & Kreutzer, S. (2003). Once upon a time in the West - Determinacy, definability, and complexity of path games. In Prof. of 10th Int. Conf on Logic
for Programming, Artificial Intelligence, and Reasoning (LPAR03), pp. 229243.
Calvanese, D., de Giacomo, G., & Vardi, M. (2002). Reasoning about actions and planning
in LTL action theories. In Proc. of 8th Int. Conf. on the Principles of Knowledge
Representation and Reasoning (KR02), pp. 593602.
130

fiThe Planning Spectrum  One, Two, Three, Infinity

Cerrito, S., & Mayer, M. (1998). Bounded model search in linear temporal logic and its
application to planning. In Proc. of 2nd Int. Conf. on Analytic Tableaux and Related
Methods (TABLEAUX98), Vol. 1397 of LNAI, pp. 124140. Springer Verlag.
Cimatti, A., Pistore, M., Roveri, M., & Traverso, P. (2003). Weak, strong, and strong cyclic
planning via symbolic model checking.. Artificial Intelligence, 147 (1-2), 3584.
Dal Lago, U., Pistore, M., & Traverso, P. (2002). Planning with a language for extended
goals. In Proc. of 18th National Conf. on Artificial Intelligence (AAAI02). AAAI
Press.
Daniele, M., Traverso, P., & Vardi, M. (1999). Strong cyclic planning revisited. In Proc.
of 5th European Conf. in Planning (ECP99), Vol. 1809 of LNAI, pp. 3548. Springer
Verlag.
de Giacomo, G., & Vardi, M. (1999). Automata-theoretic approach to planning with temporally extended goals. In Proc. of 5th European Conf. in Planning (ECP99), Vol.
1809 of LNAI, pp. 226238. Springer Verlag.
Emerson, E. A. (1990). Temporal and modal logic. In van Leeuwen, J. (Ed.), Handbook of
Theoretical Computer Science, Volume B: Formal Models and Semantics. Elsevier.
Emerson, E., & Jutla, C. (1988). The complexity of tree automata and logics of programs.
In Proc. of 29th IEEE Symp. on Foundations of Computer Science, pp. 328337.
Emerson, E., & Jutla, C. (1991). Tree automata, -calculus and determinacy. In Proc. of
32nd IEEE Symp. on Foundations of Computer Science, pp. 368377.
Fikes, R., & Nilsson, N. (1971). STRIPS: A new approach to the application of theorem
proving to problem solving. Artificial Intelligence, 2 (3-4), 189208.
Ghallab, M., Nau, D., & Traverso, P. (2004). Automated Planning: Theory and Practice.
Elsevier.
Kupferman, O. (1999). Augmenting branching temporal logics with existential quantification over atomic propositions. Journal of Logic and Computation, 9 (2), 135147.
Kupferman, O., & Vardi, M. (2005). Safraless decision procedures. In Proc. of 46th IEEE
Symp. on Foundations of Computer Science (FOCS05), pp. 531542. IEEE Computer
Society.
Kupferman, O., & Vardi, M. (2006). Memoryful branching-time logic. In Proc. of the
21th IEEE Symposium on Logic in Computer Science (LICS 2006). IEEE Computer
Society.
Kupferman, O., Vardi, M., & Wolper, P. (2000). An automata-theoretic approach to branching time model checking. Journal of the ACM, 47 (2).
Kvarnstrom, J., & Doherty, P. (2001). TALplanner: A temporal logic based forward chaining
planner. Ann. of Mathematics and Artificial Intelligence, 30, 119169.
Moller, F., & Rabinovich, A. (1999). On the expressive power of CTL*. In Proc. of 14th
Annual IEEE Symposium on Logic in Computer Science (LICS99), pp. 360369.
IEEE Computer Science Press.
131

fiPistore & Vardi

Penberthy, J., & Weld, D. (1992). UCPOP: A sound, complete, partial order planner for
ADL. In Proc. of 3rd Int. Conf. on the Principles of Knowledge Representation and
Reasoning (KR92).
Peot, M., & Smith, D. (1992). Conditional nonlinear planning. In Proc. of 1st Int. Conf.
on AI Planning Systems (AIPS92), pp. 189197. Morgan Kaufmann Publisher.
Pistore, M., Bettin, R., & Traverso, P. (2001). Symbolic techniques for planning with
extended goals in non-deterministic domains. In Proc. of 6th European Conf. in
Planning (ECP01).
Pistore, M., & Traverso, P. (2001). Planning as model checking for extended goals in nondeterministic domains. In Proc. of 17th Int. Joint Conf. on Artificial Intelligence
(IJCAI01). AAAI Press.
Pistore, M., & Vardi, M. (2003). The planning specturm  one, two, three, infinity. In
Proc. of the 18th IEEE Symposium on Logic in Computer Science (LICS 2003), pp.
234243.
Pnueli, A., & Rosner, R. (1990). Distributed reactive systems are hard to synthesize. In
Proc. of 31st IEEE Symp. on Foundation of Computer Science, pp. 746757.
Sistla, A., & Clarke, E. (1985). The complexity of propositional linear temporal logic.
Journal ACM, 32, 733749.
Warren, D. (1976). Generating conditional plans and programs. In Proc. of the Summer
Conf. on Artificial Intelligence and Simulation of Behaviour (AISB76), pp. 344354.

132

fi