Journal of Artificial Intelligence Research 37 (2010) 189-246

Submitted 10/2009; published 02/2010

On Action Theory Change
Ivan Jose Varzinczak

ivan.varzinczak@meraka.org.za

Meraka Institute, CSIR
Pretoria, South Africa

Abstract
As historically acknowledged in the Reasoning about Actions and Change community,
intuitiveness of a logical domain description cannot be fully automated. Moreover, like any
other logical theory, action theories may also evolve, and thus knowledge engineers need
revision methods to help in accommodating new incoming information about the behavior
of actions in an adequate manner. The present work is about changing action domain
descriptions in multimodal logic. Its contribution is threefold: first we revisit the semantics
of action theory contraction proposed in previous work, giving more robust operators that
express minimal change based on a notion of distance between Kripke-models. Second
we give algorithms for syntactical action theory contraction and establish their correctness
with respect to our semantics for those action theories that satisfy a principle of modularity
investigated in previous work. Since modularity can be ensured for every action theory
and, as we show here, needs to be computed at most once during the evolution of a domain
description, it does not represent a limitation at all to the method here studied. Finally
we state AGM-like postulates for action theory contraction and assess the behavior of our
operators with respect to them. Moreover, we also address the revision counterpart of
action theory change, showing that it benefits from our semantics for contraction.

1. Introduction
Consider an intelligent agent designed to perform rationally in a dynamic world, and suppose
that she should reason about the dynamics of an automatic coffee machine (Figure 1).

NiceCaf
$

Figure 1: The coffee deliverer agent.
Suppose, for example, that the agent believes that coffee is always a hot beverage.
Suppose now that some day she gets a coffee at the machine and observes that it is cold.
In such a case, the agent must change her beliefs about the relationship between the two
propositions I hold a coffee and I hold a hot drink. This example is an instance of
the problem of changing propositional belief bases and has been largely addressed in the
c
2010
AI Access Foundation. All rights reserved.

fiVarzinczak

literature about belief revision (Alchourron, Gardenfors, & Makinson, 1985; Gardenfors,
1988; Hansson, 1999) and belief update (Katsuno & Mendelzon, 1992).
Next, let our agent believe that whenever she buys a coffee from the machine, she gets a
hot drink. This means that in every state of the world that follows the execution of buying
a coffee, the agent ends up with a hot drink. Now, in a situation where the machine is
running out of cups, after buying, the coffee runs through the shelf and the agent, contrary
to what she was expecting, does not hold a hot drink in her hands.
Imagine now that the agent never considered any relation between buying a coffee on the
machine and its service availability, in the sense that she always believed (quite reasonably)
that buying does not prevent other users from using the machine. Nevertheless, someday
our agent is queuing to buy a coffee and observes that just after the agent before her has
bought, the machine went out of order (maybe due to a lack of coffee powder).
Completing our agents struggle in discovering the intricacies of operating a coffee machine, let us suppose now that she always believed that if she has a token, then it is possible
to buy coffee, provided that some other preconditions like being close enough to the button,
having a free hand, etc, are satisfied. Eventually, due to a blackout, the agent realizes that
she does not manage to buy her coffee, even with a token.
The last three examples illustrate cases in which changing the beliefs about the behavior
of the action of buying coffee is mandatory. In the first one, buying coffee, once believed to
have a deterministic outcome, namely always a hot drink, has now to be seen as nondeterministic or, alternatively, to have a different effect in a more specific context (e.g. if there
is no cup in the machine). In the second example, buying a coffee is now known to have
side-effects (ramifications) which one was not aware of. Finally, in the last example, the
feasibility of the action under concern is questioned in the light of new information showing
a context that was not known to preclude its execution.
Such cases of theory change are very important when one deals with logical descriptions
of dynamic domains: it may always happen that one discovers that an action actually has
a behavior that is different from that one has always believed it had.
Up to now, theory change has been studied mainly for knowledge bases in classical logics,
both in terms of revision and update. Since the work by Fuhrmann (1989), only in a few recent studies has it been considered in the realm of modal logics, viz. in epistemic logic (Hansson, 1999) and in dynamic logics (Herzig, Perrussel, & Varzinczak, 2006). Recently some
studies have investigated revision of beliefs about facts of the world (Shapiro, Pagnucco,
Lesperance, & Levesque, 2000; Jin & Thielscher, 2005) or the agents goals (Shapiro,
Lesperance, & Levesque, 2005). In our scenario, this would concern for instance the truth
of token in a given state: the agent believes that she has a token, but is actually wrong
about that. Then she might subsequently be forced to revise her beliefs about the current
state of affairs or change her goals according to what she can perform in that state. Such
belief revision operations do not modify the agents beliefs about the action laws. On the
other hand, here we are interested exactly in such modifications. Starting with Baral and
Lobos work (1997), some recent studies have been done on that issue (Eiter, Erdem, Fink,
& Senko, 2005) for domain descriptions in action languages (Gelfond & Lifschitz, 1993).
We here take a step further in this direction and propose a method which is more robust
by integrating a notion of minimal change and complying with postulates of theory change.
190

fiOn Action Theory Change

The present text is structured as follows: in Section 2 we establish the formal background that will be used throughout this article. Sections 36 are the core of the work: in
Section 3 we present the central definitions for a semantics of action theory change, providing justifications for the design choices here made (Section 4). Section 5 is devoted to
the syntactical counterpart of our operators while Section 6 to the proof of its correspondence with the semantics under certain acceptable conditions. In Section 7 we discuss some
postulates for contraction/erasure and then present a semantics for action theory revision
(Section 8). After a discussion on and comparison with existing work in the field (Section 9),
we conclude with an overview and future directions of research.

2. Logical Preliminaries
Following the tradition in the Reasoning about Actions and Change (RAC) community,
we consider action theories to be finite collections of statements that have the particular
form (Shanahan, 1997):
 if context, then effect after every execution of action (effect laws);
 if precondition, then action executable (executability laws).
Statements mentioning no action at all represent laws about the underlying structure of the
world, i.e., its possible states (static laws).
Several logical frameworks have been proposed to formalize such statements (Shanahan,
1997). Among the most prominent ones are the first-order based Situation Calculus (McCarthy & Hayes, 1969; Reiter, 2001), the family of Action Languages (Gelfond & Lifschitz,
1993; Giunchiglia, Kartha, & Lifschitz, 1997), the Fluent Calculus (Thielscher, 1997), and
Propositional Dynamic Logic (PDL) (Harel, Tiuryn, & Kozen, 2000) with different specific extensions thereof (De Giacomo & Lenzerini, 1995; Castilho, Gasquet, & Herzig, 1999;
Zhang & Foo, 2001; Castilho, Herzig, & Varzinczak, 2002).
Here we opt to formalize action theories using the multimodal logic Kn (Popkorn, 1994).
Among the main reasons for such a choice are:
 We benefit from the well defined semantics for multimodal logics which, as we are
going to see in the sequel, provides simple and intuitive foundations on which to build
the meaning of changing action domain descriptions.
 Kn syntax allows us to express all the afore mentioned types of laws without requiring
the full expressiveness of PDL or the machinery of a first-order language.
 Since Kn is the core of all above mentioned PDL-based action formalisms, all we shall
say in the sequel should smoothly transfer to them.
 Contrary to first-order based approaches, Kn is decidable and has several implemented
theorem provers for it available in the literature.
191

fiVarzinczak

2.1 Action Theories in Multimodal Logic
Let Act = {a1 , a2 , . . . , an } be the set of all atomic action constants of a given dynamic
domain. An example of atomic action is buy. To each atomic action a there is associated
a modal operator [a]. We here suppose that our multimodal logic is independently axiomatized (Kracht & Wolter, 1991), i.e., the logic is a fusion and there is no interaction between
the different modal operators.1
Prop = {p1 , p2 , . . . , pn } denotes a finite set of propositional constants, also called fluents
or elementary atoms. Examples of those are token (the agent has a token) and coffee
(the agent holds a coffee). Lit = {p, p : p  Prop} is the set of literals. We use ` to
denote a literal. If ` = p, then we identify ` with p. By |`| we denote the atom in `.
We use small Greek letters , , . . . to denote Boolean (propositional) formulas. They
are recursively defined in the usual way:
 ::= p | > |  |  |    |    |    |   
(   denotes (  )  (  ).) Fml is the set of all Boolean formulas. An example of a
Boolean formula is coffee  hot. A propositional valuation v is a maximal consistent set of
literals. We denote by v   the fact that v satisfies a propositional formula . By val()
we denote the set of all valuations satisfying . By CPL we denote Classical Propositional
Logic and |=CPL is its respective consequence relation. Cn() denotes all logical consequences
of  in CPL, i.e., Cn() = { :  |=
}.
CPL
If  is a propositional formula, atm() denotes the set of elementary atoms actually
occurring in . For example, atm(p1  (p1  p2 )) = {p1 , p2 }.
For  a Boolean formula, IP() denotes the set of its prime implicants (Quine, 1952),
i.e., the weakest terms (conjunctions of literals) that imply . As an example, IP(p1  p2 ) =
{p1  p2 , p1  p2 }. For more on prime implicants, their properties and how to compute
them, see the chapter by Marquis (2000). With  we denote a prime implicant, and given `
and , `   abbreviates ` is a literal of . For a given set X, X denotes its complement.
Hence atm() denotes Prop \ atm().
We denote complex formulas (possibly with modal operators) by , , . . . They are
recursively defined in the following way:
 ::=  | [a] |  |    |    |    |   
hai is the dual operator of [a], defined by hai =def [a]. An instance of a complex
formula in our scenario example is coffee  [buy]coffee.
Given a complex formula , with act() we denote the action names occurring in ,
i.e., the modalities of . For example, act([a2 ]p1  ([a1 ]p2  [a2 ]p3 )) = {a1 , a2 }.
The semantics here is the standard semantics of multimodal logic Kn (Popkorn, 1994).
Definition 2.1 (Kn -Model) A Kn -model is a tuple M = hW, Ri where W is a set of valuations (also called possible worlds), and R maps action constants a to accessibility relations
Ra  W  W.
1. Later on we will see that this is a requirement to ensure that an action theory is modular.

192

fiOn Action Theory Change

As an example, for Act = {a1 , a2 } and Prop = {p1 , p2 }, we have the Kn -model M =
hW, Ri, where
W = {{p1 , p2 }, {p1 , p2 }, {p1 , p2 }},


({p1 , p2 }, {p1 , p2 }), ({p1 , p2 }, {p1 , p2 }),
R(a1 ) =
({p1 , p2 }, {p1 , p2 }), ({p1 , p2 }, {p1 , p2 })
R(a2 ) = {({p1 , p2 }, {p1 , p2 }), ({p1 , p2 }, {p1 , p2 })}
Figure 2 gives a graphical representation of the model M .
a1
w1
p1 , p2

w2

a1

p1 , p2

a2

M :

a1

a1

w3
p1 , p2
a2

Figure 2: Example of a Kn -model for Act = {a1 , a2 }, and Prop = {p1 , p2 }.
Notice that our definition of Kn -model does not follow the traditional notion from modal
logics: here no two worlds satisfy the same valuation. This is a pragmatic choice, as we
will see in Section 5. Nevertheless, all we shall say in the sequel can be straightforwardly
formulated for standard Kn models as well.
Definition 2.2 (Truth Conditions) Given a Kn -model M = hW, Ri,
M

 |=
p (p is true at world w of M ) iff w  p (valuation w satisfies p, i.e., p  w);
w
M

M

 |=
[a] iff |= 0  for every w0 such that (w, w0 )  Ra ;
w
w

M

M

M

 |=
   iff |=
 and |=
;
w
w
w
M

M

M

 |=
 iff 6|=w , i.e., not |=w ;
w
 truth conditions for the other connectives are as usual.
By M we will denote a (possibly empty) set of Kn -models.
M

M

A Kn -model M is a model of  (denoted |= ) if and only if for all w  W, |=
. In the
w
M

M

model depicted in Figure 2, we have |= p1  [a2 ]p2 and |= p1  p2 . M is a model of a set
M
M
of formulas  (noted |= ) if and only if |=  for every   . If  is the set of formulas
we start off with (our non-logical theory), then each    is called a global axiom.
193

fiVarzinczak

Definition 2.3 (Global Consequence) A formula  is a global consequence of a set
of global axioms  in the class of all Kn -models (noted  |=
) if and only if for every
K
M

n

M

Kn -model M , if |= , then |= .
With Kn we can state laws describing the behavior of actions. One way of doing this is by
stating some formulas as global axioms.2 As usually done in the RAC community (Shanahan, 1997), we here distinguish three types of laws. The first kind of statements are static
laws, which are constraints on the allowed states of a dynamic domain.
Definition 2.4 (Static Law) A static law is a global axiom   Fml.
An example of a static law is coffee  hot, saying that if the agent holds a coffee, then she
holds a hot drink. In the Situation Calculus formalism (Reiter, 2001) one would write the
first-order formula s.[coffee(s)  hot(s)]. The set of all static laws of a scenario is denoted
by S  Fml. In our example we will have S = {coffee  hot}.
The second kind of action law we consider is given by the effect laws. These are formulas
relating an action to its effects, which can be conditional.
Definition 2.5 (Effect Law) Let ,   Fml. An effect law for action a is a global axiom
of the form   [a].
The consequent  is the effect which always obtains in accessible states (which need not
exist in general) when action a is executed in a state where the antecedent  holds. In our
Kripke semantics, this means that in every possible world where  holds, every transition
by an a-labeled arrow (if any) leads to a possible world where  holds. If a is a nondeterministic action, then the consequent  is typically a disjunction. An example of an effect
law is coffee  [buy]coffee, saying that in a situation where the agent has no coffee, after
buying, the agent has a coffee. If  is inconsistent, then we have a special kind of effect
law that we call an inexecutability law. For example, we could also have token  [buy],
expressing that buy cannot be executed if the agent has no token. In the Situation Calculus our examples of effect and inexecutability laws would be expressed respectively as
s.[coffee(s)  coffee(do(buy, s))] and s.[token(s)  Poss(buy, s)].
The set of effect laws of a given scenario is denoted by E . In our coffee machine scenario,
we could have for example:


 coffee  [buy]coffee, 
token  [buy]token,
E =


token  [buy]
Finally, we also define executability laws, which stipulate the context where an action is
guaranteed to be executable. In Kn , the operator hai is used to express executability. hai>
thus reads the execution of a is possible. Formally, hai> being true in a world w means
that there is at least one world w0 accessible from w via Ra (cf. Definition 2.2).
2. An alternative to that is given by Castilho et al. (1999, 2002), with laws being stated with the aid of an
extra universal modality and local consequence being thus considered.

194

fiOn Action Theory Change

Definition 2.6 (Executability Law) Let   Fml. An executability law for action a is
a global axiom of the form   hai>.
For instance, token  hbuyi> says that buying can be executed whenever the agent has a
token. The set of all executability laws of a given domain is denoted by X . In our scenario
example we will have X = {token  hbuyi>}.
Note that in principle one needs to know nothing about the accessible world w0 . However,
a common (albeit tacit) assumption in the RAC community is that we state executability
laws only for actions of which we know the effects, in other words act(X )  act(E ).
In the Situation Calculus our example would be stated as s.[token(s)  Poss(buy, s)].
However, we point out that, traditionally, in Reiter basic action theories (Reiter, 2001)
executability laws and inexecutability laws are mixed together in the form of bi-conditionals
like s.[token(s)  Poss(buy, s)], called precondition axioms. For a critique of such a
practice and its implications in formalizing dynamic domains, see the work by Herzig and
Varzinczak (2007).
With our three basic types of laws, we are able to define action theories:
Definition 2.7 (Action Theory) Given any (possibly empty) sets of laws S , E , and X ,
T = S  E  X is an action theory.
Given an action theory T and an action a, Ea (resp. Xa ) will denote the set of only those
effect (resp. executability) laws about a in E (resp. X ). Ta = S  Ea  Xa is then the action
theory for a.
It is worth noting that for a1 , a2  Act, a1 6= a2 , the intuition is indeed that Ta1 and Ta2
overlap only on S , i.e., the only laws that are common to both Ta1 and Ta2 are the laws
about the structure of the world. This requirement is somehow related with the underlying
modal logic being independently axiomatized (see note above).
2.2 The Frame, Ramification and Qualification Problems
During the last 40 years, most of the effort in the reasoning about actions community has
been devoted to searching for satisfactory solutions to the frame problem, the ramification
problem and the qualification problem.
Roughly speaking, the frame problem (McCarthy & Hayes, 1969) relates to the need for
inferring the persistence of some facts of the world after the execution of an action known
not to affect them, without having to state that explicitly in the form of frame axioms.
(Frame axioms are a special type of effect law, having the form `  [a]`, for `  Lit.)
In our example, buying a coffee in a context where the agent has already got one does
not make it lose the coffee: coffee  [buy]coffee should be a consequence of our theory.
The ramification problem (Finger, 1987) comes from the observation that an action may
have several possibly interdependent effects and stating all of them explicitly is a huge
task. In our scenario, we want to be able to infer [buy]hot without saying it in the theory,
and in such a way some intrinsic causal connection between coffee and hot is taken into
account. Finally, the qualification problem (McCarthy, 1977) amounts to addressing the
issue of ensuring that an action is executable in a given context. Specifying all the sufficient
195

fiVarzinczak

conditions for an action to be executable is an incredibly hard task. In our example, one
may state token  hbuyi>, but it may well be the case that buying fails due to some
condition unforeseen at design time, like the agents arm being rusty and stuck.
For more on these core problems of the RAC community, the reader is referred to the
book by Shanahan (1997).
For the sake of clarity, here we abstract from the frame and ramification problems, and
suppose that the agents theory already entails all the relevant frame axioms. We point out
however that all we shall say could have been defined within a formalism with a solution to
the frame and ramification problems. For instance, we could have used any suitable solution
to the frame problem, like e.g. the dependence relation (Castilho et al., 1999), which is used
in the work of Herzig et al. (2006), or a kind of successor state axioms in a slightly modified
setting (Demolombe, Herzig, & Varzinczak, 2003). To make the presentation more clear
to the reader, here we do not bother with a particular solution to the frame problem and
just assume that all frame axioms can be inferred from the action theory. Actually we
can suppose that all intended frame axioms are automatically recovered and stated in the
theory, more specifically, in the set of effect laws.
Given the largely acknowledged difficulty of the qualification problem in the literature (Shanahan, 1997), we do not assume here any a priori solution to it. Instead, as tacitly
assumed in many approaches to reasoning about actions (Castilho et al., 1999; Zhang &
Foo, 2001; Reiter, 2001), we suppose that the knowledge engineer may want to state some
(not necessarily fully specified) executability laws for some actions. These may be incorrect
at the starting point (and in all probability they will be), but revising wrong executability
laws is an approach towards its solution and one of the aims of this work. With further
information the knowledge engineer will have the chance to change them so that eventually
they will correspond to the intuition (cf. Sections 3 and 8).
Having agreed on these points, the action theory of our example will be:


coffee

hot,
token

hbuyi>,






coffee  [buy]coffee,
T=
token  [buy]token, token  [buy], 





coffee  [buy]coffee, hot  [buy]hot
(We have not stated the frame axiom token  [buy]token because it can be trivially
deduced from the inexecutability law token  [buy].)
Figure 3 below shows a Kn -model for the action theory T above.
We are going to see in the sequel that the finite base T formalizing the action theory
plays a role in the contraction of laws. In particular, the base representing the static laws
turns out to be quite important. So given an action theory T, it will be useful to consider
models of T whose possible worlds are all the possible valuations allowed by S :
Definition 2.8 (Canonical Frame) Let T = S  E  X be an action theory. Then the
tuple Mcan = hWcan , Rcan i is the canonical frame of T if and only if:
 Wcan = val(S ); and
S
M
M
 Rcan = aAct Ra s.t. Ra = {(w, w0 ) : for all   [a]  Ea , if |=w , then |= 0 }.
w

196

fiOn Action Theory Change

w1
t, c, h
b

b
w3

w2

M :

t, c, h

t, c, h

b

w4
t, c, h

Figure 3: A model for our coffee machine scenario: b, t, c, and h stand for, respectively,
buy, token, coffee, and hot.

The canonical frame of an action theory need not be one of its models. To witness why,
let Prop = {p}, Act = {a}, and consider the simple action theory {p  [a], p  hai>}.
Then in the associated canonical frame we have Wcan = {{p}, {p}}. Clearly the world {p}
does not satisfy this theory.
Definition 2.9 (Canonical Model) M is a canonical model of T if and only if M is a
M
canonical frame of T and |= T.
Figure 4 below shows the canonical model of our action theory example T.
w1
t, c, h
b

M :

b
w3

w2
t, c, h

w5

b

t, c, h

w6

w4
t, c, h

t, c, h

t, c, h

Figure 4: The canonical model for the coffee machine scenario.

2.3 Prime Valuations
We say that an atom p is essential to a formula  if and only if p  atm(0 ) for every 0
such that |=
  0 . For instance, p1 is essential to p1  (p1  p2 ). Given , atm!()
CPL
denotes the set of essential atoms of . (If  is not contingent, i.e.,  is a tautology or a
contradiction, then atm!() = .)
Given  a Boolean formula,  is the set of all formulas 0 such that  |=
0 and
CPL
0
atm( )  atm!(). ForV instance, p1 V
 p2 
/ p1 , as p1 |=
p  p2 but atm(p1  p2 ) 6
CPL 1
atm!(p1 ). Clearly, atm( ) = atm!( ), moreover whenever |=CPL   0 is the case,
then atm!() = atm!(0 ) and also  = 0 .
197

fiVarzinczak

Theorem 2.1 (LeastVAtom-Set Theorem, Parikh, 1999) Let  be a propositional formula. Then |=CPL   , and for every 0 such that |=CPL   0 , atm()  atm(0 ).
A proof of this theorem is given by Makinson (2007) and we do not state it here.
Essentially, the theorem establishes that for every Boolean formula , there is a unique
least set of elementary atoms such that  may equivalently be expressed using only atoms
from that set. Hence, Cn() = Cn().
Given a valuation v, v0  v is a subvaluation. Given a set of valuations W, a subvaluation
v0 satisfies a propositional formula  modulo W (noted v0 W ) if and only if v   for all
v  W such that v0  v. We say that a subvaluation v essentially satisfies  (modulo W),
!
!
noted v W , if and only if v W  and {|`| : `  v}  atm!(). If v W , we call v an
essential subvaluation of  (modulo W).
Definition 2.10 (Prime Subvaluation) Let  be a Boolean formula and W a set of val!
uations. A subvaluation v is a prime subvaluation of  (modulo W) if and only if v 

W
!

and there is no v0  v such that v0 W .
A prime subvaluation of a formula  is thus one of the weakest states of truth in which 
is true. Hence, prime subvaluations are just another way of seeing prime implicants (Quine,
1952) of . By base(, W) we will denote the set of all prime subvaluations of  modulo W.
Proposition 2.1 W
Let   FmlVand W be a set of valuations. Then for all w  W, w  
if and only if w  vbase(,W) `v `.
Proof: Right to left direction is straightforward. For the left to right direction, if w  ,
0
then w  . Let w0  w be the least subset of w still
Vsatisfying . Clearly, w is a prime
subvaluation of  modulo W, and then because w  `w0 `, the result follows.
2
2.4 Closeness between Models
When contracting a formula from a model, we will perform a change in its structure. Because
there can be several different ways of modifying a model (not all of them minimal), we need
a notion of distance between models to identify those that are closest to the original one.
As we are going to see in more depth in the next section, changing a model amounts
to modifying its possible worlds or its accessibility relation. Hence, the distance between
two Kn -models will depend upon the distance between their sets of worlds and accessibility
relations. These here will be based on the symmetric difference between sets, defined as
X Y = (X \ Y )  (Y \ X).
Definition 2.11 (Closeness between Kn -Models) Let M = hW, Ri be a model. Then
M 0 = hW0 , R0 i is at least as close to M as M 00 = hW00 , R00 i, noted M 0 M M 00 , if and only if
 either WW0  WW00 ;
 or WW0 = WW00 and RR0  RR00 .
198

fiOn Action Theory Change

This is an extension of Burger and Heidemas relation (Burger & Heidema, 2002) to our
modal case. It defines a lexicographic order on the set of all Kn -models. Although simple,
this notion of closeness turns out to be sufficient for our purposes here, as we shall see in the
sequel. Notice that other notions of distance between models could have been considered as
well, namely the cardinality of symmetric differences or Hamming distance. (See Section 4
for a discussion on this.)

3. Semantics of Action Theory Change
When admitting the possibility of a law  failing, one must ensure that  becomes invalid,
i.e., not true in at least one model of the dynamic domain that is formalized. Because there
can be lots of such models, we may have a set M of models in which  is (potentially) valid.
Thus contracting  amounts to making it no longer valid in this set of models. What are
the operations that must be carried out to achieve that? Throwing models out of M does
not work, since  will keep on being valid in all models of the remaining set. Thus one
should add new models to M. Which models? Well, models in which  is not true. But
not any of such models: taking models falsifying  that are too different from our original
models will certainly violate the principle of minimal change.
Hence, we shall take some model M  M as basis and manipulate it to get a new model
0
M in which  is not true. In our modal semantics, the removal of a law  from a model
M = hW, Ri means modifying the possible worlds or the accessibility relation in M so that
 becomes false. Such an operation gives as result a set M of models each of which is no
longer a model of . But if there are several candidates, which ones should we choose? We
shall take those models that are minimal modifications of the original M , i.e., those which
are minimal with respect to our distance M between models. Of course, there can be more
than one such an M 0 that is minimal with respect to M . In that case, because adding
just one of these new models is enough to invalidate , we take all possible combinations
M  {M 0 } of expanding our original set of models M by one of these minimal models.
(Observe that this approach relates to orderly maxichoice contraction Hansson, 1999.) The
result will be a set of sets of models. In each set of models there will be precisely one model
M 0 falsifying .
It might be claimed that, as such, our contraction method described above does not
respect the so-called principle of categorical matching: the input and output are different
sorts of objects, namely a set of models and a set of sets of models. It is easy to see,
however, that the reasoning above can be stated in such a way that each output set of
models corresponds precisely to the result of one contraction operator, satisfying then the
referred principle. The choice for defining the result of an operation as a set of possible
outputs will become more clear in Section 5, where we are going to present algorithms that
correspond exactly to our semantic constructions.
3.1 Model Contraction of Executability Laws
To contract an executability law   hai> from one model, intuitively we should remove
transitions leaving -worlds. In order to succeed in the operation, we have to guarantee
that in the resulting model there will be at least one -world with no departing a-arrow.

199

fiVarzinczak


Definition 3.1 Let M = hW, Ri. M 0 = hW0 , R0 i  Mhai>
if and only if

 W0 = W;
 R0  R;
M

; and
 if (w, w0 )  R \ R0 , then |=
w
M0

 there is w  W0 such that 6|=w   hai>.


Observe that Mhai>
6=  if and only if  is satisfiable in W. Moreover, M  Mhai>
M

if and only if 6|=   hai>.
Just to provide the reader with an insight on how this operation would be carried out
in the Situation Calculus, there one should look at a given situation s in which  holds
and then modify the interpretation of the predicate Poss(a) so that it becomes false in s.
Like in our case, there may be many of such situations and then all of them must be taken
into account. An essential difference here is that our Kripke structures are always finite,
whereas the space of situations is possibly infinite (Reiter, 2001).
To get minimal change, we want such an operation of removing transitions to be minimal
with respect to the original model: one should remove a minimum set of transitions which
is sufficient to get the desired result.
Definition 3.2 contract(M ,   hai>) =

S


min{Mhai>
, M }

And now we define the sets of possible models resulting from the contraction of an
executability law in a set of models:
Definition 3.3 Let M be a set of models, and   hai> an executability law. Then
0
0
0
0
M
hai> = {M : M = M  {M }, M  contract(M ,   hai>), M  M}

In our running example, consider M = {M }, where M is the model in Figure 4. When
the agent discovers that even with a token she does not manage to buy a coffee any more,
she has to change her models in order to admit (new) models with states where token is
the case but from which there is no buy-transition at all. Because having just one such
a world in each new model is enough, taking those resulting models whose accessibility
relations are maximal guarantees minimal change. Hence we will have M
tokenhbuyi> =
0
0
0
0
{M  {M1 }, M  {M2 }, M  {M3 }}, where each Mi is depicted in Figure 5.
M

Clearly, if  is not satisfied in M, i.e., |=  for all M  M, then the contraction
of   hai> does not succeed. This is in line with the expectations and it relates to the
Success Postulate (cf. Section 7.2).
200

fiOn Action Theory Change

w1

w1
t, c, h

t, c, h
b

M10 :

b
w3

w2
t, c, h

w5

w6

w4
t, c, h

t, c, h

b

t, c, h

w6

w4

w5

t, c, h

t, c, h

w3

w2

M20 :

t, c, h

b

t, c, h

t, c, h

t, c, h

w1
t, c, h
b

M30 :

b
w3

w2
t, c, h

t, c, h

w5

w6

w4
t, c, h

t, c, h

t, c, h

Figure 5: Models resulting from contracting token  hbuyi> in the model M of Figure 4.
3.2 Model Contraction of Effect Laws
When our agent discovers that there may be some cases where after buying she gets no
hot drink, she must e.g. give up the belief in the effect law token  [buy]hot in her set of
models. This means that token  hbuyihot shall now be admitted in at least one world of
some of the new models of her set of beliefs. Therefore, to contract an effect law   [a]
from a given model, intuitively we have to add new transitions from -worlds to worlds not
satisfying . As we shall see, the great challenge in such an operation is precisely how to
guarantee minimal change.
In our example, when contracting token  [buy]hot from the model of Figure 4 we shall
add transitions from token-worlds to hot-worlds. Because coffee  hot is a static law and
so is hot  coffee, this should also give us hbuyicoffee in some token-world (coffee is
causally relevant to hot, i.e., to have hot we must also have coffee). This means that if
we allow for hbuyihot in some token-world, we also have to allow for hbuyicoffee in that
same world. The same argument does not necessarily hold for token: allowing for hbuyihot
does not necessarily oblige us to allow for hbuyitoken in the respective world. This is because
token is not relevant to hot (as coffee is). This means that we have the freedom either
to allow for it or not.
Hence, in our running example we can add transitions from token-worlds to hot 
coffee  token-worlds, as well as to hot  coffee  token. This situation is depicted in
Figure 6. For instance, we can add a new buy-arrow from the world {token, coffee, hot}
to one of these candidates (Figure 7).
In the Situation Calculus, such a modification would be slightly different, but with the
same intuition behind: one should look at a given situation s in which  holds and then
modify the interpretation of the fluents (atoms) in do(a, s), the situation resulting from
performing a in s. Alternatively, new -situations should lead to at least one -situation.
201

fiVarzinczak

w1
t, c, h
b

M :

b
w3

w2
t, c, h

w5

t, c, h

b

w6

w4
t, c, h

t, c, h

t, c, h

Figure 6: Candidate worlds to receive transitions coming from token-worlds.
w1
t, c, h
b

M :

b
w3

w2
t, c, h

w5

b

t, c, h

w6

w4
t, c, h

b

t, c, h

t, c, h

b

Figure 7: Two candidate new buy-arrows to falsify token  [buy]hot in M .
Notice however that this would require the addition of new whole branches to the tree-like
first-order model induced by Reiter basic action theories (Reiter, 2001).
Back to our example, observe that adding the new transition to {token, coffee, hot}
itself would make us lose the effect token, true after every execution of buy in the original
M
model (|= token  [buy]token). How do we preserve this law while allowing for the new
transition to a hot-world? That is, how do we get rid of the effect hot without losing effects
that are not relevant for that? We here develop an approach for this issue.
When adding a new transition leaving a world w we intuitively want to preserve as many
effects as we had before doing so. To achieve this, it is enough to preserve old effects only
in w (because the remaining structure of the model remains unchanged after adding the
new transition). Of course, we cannot preserve effects that are inconsistent with  (those
will all be lost). Hence it suffices to preserve only the effects that are consistent with .
To achieve that we must observe what is true in w and in the target world w0 :
 The proper effects of the action in world w0 , i.e., what changes from w to w0 (w0 \ w)
through the new execution of a must be what is obliged to be so: either because those
literals that now change from w to w0 are necessary to having  in w0 (like coffee
in our example) or because they are necessary to have another effect (independent of
, like token) in world w0 .
202

fiOn Action Theory Change

 The non-effects of action a in world w0 , i.e., what does not change from w to w0
(w  w0 ) through as new execution should be only what is allowed to be so: certain
literals are never preserved (like token in our example), then when pointing the new
transition towards a world where it does not change with respect to the leaving world
(hot  coffee  token in our example), we may lose effects that held in w before
adding the transition.
This means that the only things allowed to change in the candidate target world must
be those that are forced to change, either by some non-related law or because of having
 modulo a set of states W. In other words, we want the literals that (now) change from
w to w0 to be at most those that are sufficient to get  modulo W, while preserving the
maximum of other effects. Every change beyond that is not an intended one. Similarly,
we want the literals from w that are (now) preserved in the target world w0 to be at most
those that are usually preserved in a given set of models. Every preservation beyond those
may make us lose some law. This looks like prime implicants, and that is where prime
subvaluations play their role: the worlds to which the new transition will point are those
whose difference with respect to the departing world are literals that are relevant and whose
similarity with respect to it are literals that we know do not change.
Definition 3.4 (Relevant Target Worlds) Let M = hW, Ri be a model, w, w0  W, M
a set of models such that M  M, and   [a] an effect law. Then w0 is a relevant target
world of w with respect to   [a] for M in M if and only if
M

M

 |=
 and 6|= 0 ;
w
w

 for all `  w0 \ w:
 either there is v  base(, W) such that v  w0 and `  v;
 or there is  0  Fml such that there is v0  base( 0 , W) such that v0  w0 , `  v0 ,
M
and for every Mi  M, |=w i [a] 0
 for all `  w  w0 :
 either there is v  base(, W) such that v  w0 and `  v;
M

i
 or there is Mi  M such that 6|=
[a]`;
w

By RelTarget(w,   [a], M , M) we denote the set of all relevant target worlds of w with
respect to   [a] for M in M.
Note that we need the set of models M (and here we can suppose it contains all models
of the theory we want to change) because preserving effects depends on what other effects
hold in the other models that interest us. We need to take them into account in the
local operation of changing one model. (The reason we do not need M in the definition

of the local, one model contraction of executability laws Mhai>
is that when removing
transitions there is no way of losing effects, as every effect law that held in the world from
which a transition has been removed remains true in the same world in the resulting model.)
203

fiVarzinczak

Definition 3.5 Let M = hW, Ri, and M be such that M  M. Then M 0 = hW0 , R0 i 

M[a]
if and only if
 W0 = W;
 R  R0 ;
 If (w, w0 )  R0 \ R, then w0  RelTarget(w,   [a], M , M); and
M0

 there is w  W0 such that 6|=w   [a].

Observe that M[a]
6=  if and only if  and  are both satisfiable in W. Moreover,
M


M  M[a]
if and only if 6|=   [a].

Because having just one world where the law is no longer true in each model is enough,
taking those resulting models whose accessibility relations are minimal with respect to the
original one guarantees minimal change.
Definition 3.6 contract(M ,   [a]) =

S


min{M[a]
, M }

Now we can define the possible sets of models resulting from contracting an effect law
from a set of models:
Definition 3.7 Let M be a set of models, and   [a] an effect law. Then
0
0
0
0
M
[a] = {M : M = M  {M }, M  contract(M ,   [a]), M  M}

Taking again M = {M }, where M is the model in Figure 4, after contracting token 
0
0
0
[buy]hot from M we get M
token[buy]hot = {M  {M1 }, M  {M2 }, M  {M3 }}, where all
Mi0 s are as depicted in Figure 8.
In both cases where  is not satisfiable in M or  is valid in M , of course our operator
does not succeed in falsifying   [a] (cf. end of Section 3.1). Again, this works as
expected and it has to do with the Success Postulate (see also Section 7.2).
3.3 Model Contraction of Static Laws
When contracting a static law from a model, we want to admit the existence of at least
one (new) possible state falsifying it. This means that intuitively we should add new worlds
to the original model. (In a Situation Calculus setting that would correspond to allowing
for situations not satisfying some of the domain constraints.) This is quite easy. A very
delicate issue however is what to do with the accessibility relation: should new transitions
leave/arrive at the new world? If no transition leaves the new added world, we may lose
some executability law. If some transition leaves it, then we may lose some effect law, the
same holding if we add a transition pointing to the new world. On the other hand, if no
transition arrives at the new world, what about the intuition? Is it intuitive to have an
unreachable state? (Similar issues would also arise in Situation Calculus interpretations,
which means that they are independent of the underlying formalism.)
204

fiOn Action Theory Change

w1

w1
t, c, h

b

M10 :

t, c, h
b

b
w3

w2
t, c, h

w3

w2

M20 :

t, c, h

b

b

t, c, h

b

t, c, h

b
w5

w6

w4
t, c, h

w5

t, c, h

t, c, h

b

t, c, h

w6

w4
t, c, h

t, c, h

w1
t, c, h
b

M30 :

b
w3

w2
t, c, h

b

t, c, h

b
w5

w6

w4
t, c, h

t, c, h

t, c, h

Figure 8: Models resulting from contracting token  [buy]hot in the model M of Figure 4.

All this discussion shows how drastic a change in the static laws might be: it is a change
in the underlying structure (possible states) of the world! Changing them may have as an
indirect, unexpected (and in all probability unwanted) consequence the loss of some effect
law(s) or some executability law(s). What we can do is choose which type(s) of laws we
may accept to lose in this process and then postpone their change (by the other operators).
Following the tradition in the RAC community, which states that executability laws are
in general more difficult to formalize than effect laws, and therefore they are more likely
to be incorrect (Shanahan, 1997), here we prefer not to change the accessibility relation,
which means that we preserve effect laws and postpone the correction of executability laws,
if required. (Remember that this is an approach towards a solution to the qualification
problem  cf. Section 2.2 above.)
One may argue that doing things this way makes our three operators incoherent in the
sense that for effect and executability laws we adopt a minimal change approach, giving
stronger theories, whereas for static laws we adopt a more cautious approach, giving weaker
theories (see the next section). It is worth noting however that as largely recognized by the
RAC community, the different laws of a domain description do not have the same status:
a minimal change approach for static law contraction that preserves as many executability
laws as possible, even if coherent, would definitely fail to cope with the qualification problem.
Moreover, by propagating wrong executability laws, such a coherent method would definitely
be less elaboration tolerant (McCarthy, 1998) than the one we are defining with regards to
further modifications of the theory.
For those reasons, our contention here is that static law contraction should be cautious.
(For a detailed discussion on this, see Section 4.2 below and the end of Section 5.3.)

205

fiVarzinczak

Definition 3.8 Let M = hW, Ri. M 0 = hW0 , R0 i  M if and only if
 W  W0 ;
 R = R0 ; and
M0

 there is w  W0 such that 6|=w .
M

Note that M =  if and only if |= . Moreover, M  M if and only if 6|= .
The minimal modifications of one model are defined as usual:
S
Definition 3.9 contract(M , ) = min{M , M }
And now we define the sets of models resulting from contracting a static law from a
given set of models:
Definition 3.10 Let M be a set of models, and  a static law. Then
0
0
0
0
M
 = {M : M = M  {M }, M  contract(M , ), M  M}

In our scenario example, if the initial set of models is M = {M }, where M is the model
in Figure 4, then contracting the static law coffee  hot from M would give us the resulting
0
0
0
new set of models M
coffeehot = {M  {M1 }, M  {M2 }}, where each Mi is as depicted
in Figure 9 below.
w1

w7
t, c, h

b

M10 :

w5

t, c, h
b

w3
b

M20 :

t, c, h

w6

w4
t, c, h

t, c, h

b

w2
t, c, h

w1

w7

t, c, h

t, c, h

t, c, h

b
w3

w2
t, c, h

b

t, c, h

w6

w4

w5
t, c, h

t, c, h

t, c, h

Figure 9: Models resulting from contracting coffee  hot in the model M of Figure 4.
Notice that by not modifying the accessibility relation all the effect laws which are true
in the original model M are preserved in the resulting models. This is ensured by [buy]
being true in the new world w7 .
It is only some executability laws that are potentially lost, due to the cautiousness of
our approach. For instance, in M10 above, it is no longer the case that token  hbuyi> is
true, since now there is a world, namely w7 , which does not satisfy it anymore. (In M20 this
executability law is still true in every possible world.)
It is worth point out, however, how our approach is indeed in line with intuition: when
learning that a new state is now possible, we do not necessarily know all the behavior of the
actions in the new added state. We may expect some action laws to hold in the new world
(see end of Section 5.3), but, with the information we dispose, not touching the accessibility
relation is the safest way of contracting static laws (cf. Section 4.2 below).
206

fiOn Action Theory Change

4. Interlude
Before presenting the algorithmic counterpart of our action theory change operators, in this
section we discuss alternatives to some of our technical constructions. We point out the
issues that such alternatives would raise. We also provide more justifications for some of
the design choices that have been made in the previous sections.
4.1 Other Distance Notions
Here we have defined and used a model distance which is based on the symmetric difference between sets (Definition 2.11). This distance is an extension to Kripke structures of
Winsletts (1988) notion of closeness between propositional interpretations in the Possible
Models Approach (PMA). Instead of it, however, we could have considered other distance
notions as well, like Dalals (1988) distance, Hamming distance (1950), or weighted distance. Due to space limitations, we do not develop a through comparison among all these
distances here. (For more details, the reader may want to refer to Schlechtas 2004 book.)
We nevertheless do show that with a cardinality-based distance, for example, we may not
always get the intended result.
Let card(X) denote the number of elements in set X. Then suppose that our closeness
between Kn -models was defined as follows:
Definition 4.1 (Cardinality-based Closeness between Kn -Models) Let M = hW, Ri
be a model. Then M 0 = hW0 , R0 i is at least as close to M as M 00 = hW00 , R00 i, noted
M 0 M M 00 , if and only if
 either card(WW0 )  card(WW00 );
 or card(WW0 ) = card(WW00 ) and card(RR0 )  card(RR00 ).
Such a notion of distance is closely related to Dalals (1988) closeness.
Because when contracting a static law  from a model M we usually add one new
possible world, it is easy to see that with this cardinality-based distance we get the same
result in contract(M , ) as with the distance from Definition 2.11.
When it comes to the contraction of action laws, and then changing the accessibility
relations, however, this cardinality-based distance does not seem to fit with the intuitions.
To witness, consider the model M in Figure 10, in which the law p1  hai> is true.
a

w1

w2
p1 , p2

p1 , p2
a

M :

a
w3
p1 , p2

Figure 10: A model of the executability law p1  hai>.
207

fiVarzinczak

Then, the models resulting from contraction of p1  hai> in the model M will be
Mphai> = {M 0 , M 00 }, where M 0 and M 00 are as depicted in Figure 11.
1

w2

w1

a

w1

p1 , p2

p1 , p2

w2
p1 , p2

p1 , p2

a

M0 :

a

M 00 :

w3

w3

p1 , p2

p1 , p2

Figure 11: Models resulting from contracting p1  hai> in the model M of Figure 10.
M 00

Note that M 00 is an intended contracted model: 6|= p1  hai>. However, with the
0
cardinality-based distance above we will get {M }
p1 hai> = {{M , M }}. We do not have
00
0
00
0
{M , M } in the result since M M M : in M only one transition has been removed,
while in M 00 two.
4.2 Minimal Change v. Cautiousness
As usually done in the literature on classical belief revision, when defining a (traditional)
theory change operator one must always make the fundamental decision which of two opposing principles should be the guiding one: that of minimizing change, which leads to
strong modified theories, versus that of cautious change, which leads to weak theories. In
this regard, one might argue that our action theory change operators are incoherent. That
is because we adopt the first principle for the contraction of effect and executability laws,
but then the latter principle for contraction of static laws.3
It turns out, however, that this view is debatable. From a different perspective one can
think of our three operators as being coherent in the following sense: all of them perform a
version of maxichoice, namely the addition of precisely a single model to the original models
of the theory.4
In any case, in the sequel we give a justification for the behavior of our operators and
show that there can be no such an operator for contraction of static laws that is not cautious
while being coherent with the operators for contraction of effect and executability laws. (We
say that an operator for static law contraction is coherent with respect to our operators for
contraction of effect and executability laws if it also performs minimal change with respect
to the other types of laws, i.e., if it preserves effect and executability laws.)
Where does the claimed incoherence come from? Here our contention is that it is
inherent to the problem of action theory change itself, and not a flaw of our definitions.
The justification is as follows. Remembering the intuitions for our semantic constructions,
it is easy to see that for the contraction of executability laws knowledge about some actions
feasibility (the transitions) is removed and only that. For the contraction of effect laws, a
3. We thank an anonymous referee for having pointed this out.
4. We thank another anonymous referee for having pointed this out.

208

fiOn Action Theory Change

piece of knowledge is also added (the new transition), but notice that this one is guided
by some given concrete extra information, namely the  effect that we want to allow.
Now, for the contraction of static laws, notice that no extra information whatsoever is
given about the new possible state which could guide the addition of some knowledge about
the feasibility of an action. The only thing that we know is that the new world should exist.
Nothing more is said about whether there should be any transition leaving it or arriving at
it at all. This is a property of the problem per se: the problem of removing a static law
does not mention executabilities, and it is just reflected by our operator.
Therefore, such an incoherence is already in the problem, and as such it is not surprising
to find it again in the proposed operators. These are designed to do what they are allowed
to do given the constraints of the problem. Should we have more information in our hands
regarding the new added state, a coherent version of the corresponding operator would
have been defined. (See the discussion in Section 9 for a comparison with Eiter et al.s 2005
constraint-based method for update of action theories.)
Proposition 4.1 There is no minimal change operator for static law contraction that is
coherent with our operators for contraction of effect and executability laws.
Proof: Suppose that we have a minimal change based (non-cautious) contraction operator
for static laws that is coherent with the other operators. This operator must be such that
when contracting   Fml only formulas of the type of  are removed (otherwise it is
not coherent with the other operators). This means that both effect and executability laws
should be preserved. In particular, this operator is coherent in this respect when contracting
the formula p1  p2 from model M in Figure 12 below.
w1

w1
p1 , p2

M :

a

p1 , p2

w3

M0 :

w2

a

w2
p1 , p2

p1 , p2

a

p1 , p2

Figure 12: Adding a transition from a new added world in the alternative semantics to
static law contraction. M denotes the original model, while M 0 shows the new
added world and a candidate transition to add to Ra .
Following the intuition about contraction of Boolean formulas, a new world, viz. the
valuation {p1 , p2 }, is added to W in M . Because the operator in question is non-cautious,
a transition should also be added from the new added world {p1 , p2 } in M , in order to
preserve the executability law p1  hai>. Also because the operator is non-cautious, the
effect law p1  [a]p1 should be preserved. Hence, such a new transition should point
neither to world {p1 , p2 } nor to {p1 , p2 } itself. Now, if we direct the new transition to
{p1 , p2 } (the only world that is left), we get the model M 0 in Figure 12.
209

fiVarzinczak

M

M0

Observe that |= (p1  p2 )  [a]p1 . However, 6|= (p1  p2 )  [a]p1 : the operator
makes us lose an effect law! This means that it is not coherent. In order for us to keep this
effect law, the only option is not to direct the new transition to {p1 , p2 }. But then, no
transition is added at all: the operator is cautious! Hence there is no such an operator for
static law contraction that is based on minimal change and is coherent with the operators
for the other laws.
2
The result above supports our contention that we cannot have a coherent set of minimal
change operators for action theory contraction. This is a general result and it holds not
only for modal-based approaches like ours, but it applies to any framework for reasoning
about actions which is based on transition systems and which also allows for the three types
of laws that we consider here.
Furthermore, the result also illustrates well the difference between action theory change
and classical belief change. To witness, even though contraction of static laws amounts to
propositional contraction of Boolean formulas, it remains a special case of the latter. The
reason is that when contracting static laws one always asks what happens to the laws of
other types?, a question that is not asked in classical propositional contraction for the
obvious reason that there simply there are no other types of formulas.

5. Syntactic Operators for Contraction of Laws
Once having given a semantic construction for action theory change, we now turn our
attention to the definition of syntactic operators for changing sets of formulas describing a
dynamic domain.
As Nebel (1989) says, [. . . ] finite bases usually represent [. . . ] laws, and when we
are forced to change the theory we would like to stay as close as possible to the original
[. . . ] base. Hence, besides the definition of syntactical operators, we should also guarantee
that they perform minimal change at the theory level. By that we mean that the resulting
theory should of course not entail the law we want to contract the theory with, and it should
also preserve as much of the previous knowledge as possible when performing syntactical
manipulations on the laws in the original theory. Ideally, from the knowledge engineers
perspective, the modified theory should also keep a certain degree of resemblance with the
original one: the resulting laws should be slight modifications of the relevant ones in the
original action theory.
By T 
 we denote in the sequel the result of contracting a law  from the set of laws T.
5.1 Contracting Executability Laws
For the case of contracting an executability law   hai> from an action theory, first we
have to ensure that action a keeps its executability state in all those contexts where the
antecedent  holds, if that is the case. We achieve that by strengthening the antecedents
of the relevant executability laws. Second, in order to get minimality, we must make a
executable in some contexts where  is true, viz. all -worlds but one. Since there are
possibly many different alternatives for that, this means that we can have several action
theories as outcome. Algorithm 1 gives a syntactical operator to achieve this.
210

fiOn Action Theory Change

It can be easily checked that Algorithm 1 always terminates: the input action theory
T is always finite; from finiteness of Prop follows that of atm(), for any   IP(S  ).
Moreover, the entailment problem of multimodal K is decidable (Harel et al., 2000), as is
that of classical propositional logic. Therefore contracting executability laws is decidable.
Algorithm 1: Contraction of an Executability Law
Input: T,   hai>
Output: T 
hai> /* set of theories output to the knowledge engineer */
1

begin

2

:= 
T
hai>

3

if T |=
  hai> and S 6|=
 then
K
CPL
n

foreach   IP(S  ) do

4

forall A  atm() do
V
V
A := pi atm() pi  pi atm() pi /* extend  to a valuation */

5
6

pi A

if S 6|=
(  A )   then
CPL

7

9

else
:= {T}
T
hai>

11
12
13

/* it is an allowed state */

/* construct a theory that is weaker for that state */
T 0 := (T \ Xa )  {(i  (  A ))  hai> : i  hai>  Xa }
0
:= T 
T
hai>
hai>  {T }

8

10

pi A
/

return T 
hai>
end

It is straightforward to see that Algorithm 1 above can be adapted to Situation Calculus
action theories as well. The crucial point however would be its termination, since entailment
in the Situation Calculus is in general undecidable.
In our running example, contracting the executability law token  hbuyi> from the
0
0
0
action theory T would give us T 
tokenhbuyi> = {T1 , T2 , T3 }, where:


coffee  hot, coffee  [buy]coffee, 





token  [buy]token, token  [buy],
0
T1 =
coffee  [buy]coffee, hot  [buy]hot, 





(token  (coffee  hot))  hbuyi>


coffee

hot,
coffee

[buy]coffee,






token  [buy]token, token  [buy],
0
T2 =
coffee  [buy]coffee, hot  [buy]hot, 





(token  (coffee  hot))  hbuyi>
211

fiVarzinczak






coffee  hot, coffee  [buy]coffee,
token
 [buy]token, token  [buy],
T30 =
coffee
 [buy]coffee, hot  [buy]hot,



(token  (coffee  hot))  hbuyi>









Now all the knowledge engineer has to do is choose which theory is more in line with
her intuitions and implement the required changes (cf. Figure 5).
5.2 Contracting Effect Laws
When contracting an effect law   [a] from an action theory T, intuitively we should contract those effect laws that preclude  in target worlds. In order to cope with minimality,
we must change only those laws that are relevant to the unwanted   [a].
Let (Ea, )1 , . . . , (Ea, )n denote minimal subsets (with respect to set inclusion) of Ea such
that S , (Ea, )i |=
  [a], for 1  i  n. In other words, each (Ea, )i is a support set for
Kn
the effect law   [a] in T. To make a parallel with the terminology usually adopted in
the belief change community, we shall see each (Ea, )i as a special type of kernel (Hansson,
1994) for the formula   [a].
According to Herzig and Varzinczak (2007), given any action theory one can always
ensure that at least one support set for   [a] exists. Now let
[
Ea =
(Ea, )i
1in

The laws in Ea will serve as guidelines to get rid of [a] in each -world allowed by the
theory T: they are the effect laws to be weakened to allow for hai in some -contexts.
This resembles classical kernel contraction (Hansson, 1994): finding minimal sets implying
a formula and changing them. A crucial difference, however, is that instead of completely
removing a formula from each kernel, what we do here is weaken the laws.
When modifying the support sets, the first thing we must do is to ensure that action
a still has effect  in all those contexts in which  does not hold, if that is the case. This
means we shall weaken the laws in Ea, specializing them to . Now, we need to preserve
all old effects in all -worlds but one. To achieve that we specialize the above laws to
each possible valuation (maximal consistent conjunction of literals) satisfying  but one.
Then, in the left -valuation, we must ensure that action a has either its old effects or 
as outcome. We achieve that by weakening the consequent of the laws in Ea . Finally, in
order to get minimal change, we must ensure that all literals in this -valuation that are
not forced to change in -worlds should be preserved. We do this by stating an effect law
of the form (k  `)  [a](  `), where k is the above -valuation. The reason this is
needed is clear: there can be several -valuations, and as far as we want at most one to
be reachable from the k -world, we should force it to be the one whose difference to this
k -valuation is minimal.
In Situation Calculus terms, all these syntactical operations would correspond to strengthening the right-hand side of the relevant successor state axioms and/or weakening their
212

fiOn Action Theory Change

left-hand side. Alternatively, the same can be done with the original effect axioms, then
recompiling them again into new successor state axioms afterwards.
The output of the operations described above will be a set of action theories which will
be output to the knowledge engineer. Algorithm 2 below gives the operator.
Algorithm 2: Contraction of an Effect Law
Input: T,   [a]
Output: T 
[a] /* set of theories output to the knowledge engineer */
1

begin

2

:= 
T
[a]

3

if T |=K   [a] and S 6|=
 then
CPL
n

foreach   IP(S  ) do

4

forall A  atm() do
V
V
A := pi atm() pi  pi atm() pi /* extend  to a valuation */

5
6

pi A

pi A
/

if S 6|=
(  A )   then
CPL

7

/* it is an allowed state */

0

foreach  IP(S  ) do
T 0 := T \ Ea /* the support sets will be weakened */
T 0 := T 0  {(i  (  A ))  [a]i : i  [a]i  Ea }

8
9
10

11

/* allow for  after a in this state */
T 0 := T 0  {(i    A )  [a](i   0 ) : i  [a]i  Ea }

12

forall L  Lit do
if S |=
(  A ) 
CPL

13

V

`L `)

  then

n

T 0 := T 0  {(  A  `)  [a](  `)}

16

0
:= T 
T
[a]
[a]  {T }

17

else
:= {T}
T
[a]

19

21

and S 6|=
( 0 
CPL

if T 6|=
(  A  `)  [a]` or `   0 then
K

15

20

`L `

foreach `  L do

14

18

V

return T 
[a]
end

Again, from the finiteness of the action theory T and that of atm(), for any  
IP(S  ), and from the decidability of multimodal K (Harel et al., 2000) as well as that
of classical propositional logic, it can be easily verified that Algorithm 2 always terminates.
213

fiVarzinczak

Therefore, contracting effect laws is decidable. Of course, the complexity of computing all
the support sets as well as the prime implicants is quite high (see Section 5.4 later on for a
discussion on this matter).
For an example of execution of Algorithm 2, let us suppose that we want to contract
the effect law token  [buy]hot from the action theory T of our running example. First we
have to compute the support sets for token  [buy]hot in T (i.e., the minimal subsets of
Ebuy which together with S entail token  [buy]hot). These are the following:
token,hot
(Ebuy
)1

token,hot
(Ebuy
)2



coffee  [buy]coffee,
coffee  [buy]coffee





hot  [buy]hot,
coffee  [buy]coffee



=

=

Now for each possible context in which the antecedent token is the case, we have to
token,hot
token,hot

)2 . Since S = {coffee  hot}, such
)1  (Ebuy
= (Ebuy
weaken the effect laws in Ebuy
contexts are token  coffee  hot, token  coffee  hot and token  coffee  hot.

with
For token  coffee  hot: Algorithm 2 replaces in T the laws from Ebuy



 (coffee  (token  coffee  hot))  [buy]coffee, 
(hot  (token  coffee  hot))  [buy]hot,


(coffee  (token  coffee  hot))  [buy]coffee
so that we preserve their effects in all possible contexts but token  coffee  hot. Now, in
order to preserve some effects in token  coffee  hot-contexts while allowing for reachable
hot-worlds, the algorithm adds the laws:


(token  coffee  hot)  [buy](coffee  hot),
(token  coffee  hot)  [buy](hot  coffee)
Now, we search all possible combinations of laws from Ebuy that apply on token  coffee  hot
contexts and find token  [buy]token. Because token must be true after every execution
of action buy, we do not state the law (token  coffee  hot)  [buy](hot  token), and end
up with the following theory:


coffee  hot, token  hbuyi>,








token

[buy]token,
token

[buy],







 (coffee  (token  coffee  hot))  [buy]coffee, 

(hot  (token  coffee  hot))  [buy]hot,
T10 =



 (coffee  (token  coffee  hot))  [buy]coffee, 









(token

coffee

hot)

[buy](coffee

hot),




(token  coffee  hot)  [buy](hot  coffee)
On the other hand, if in our language we also had an atom p with the same theory T,
then we should have added a law (token  coffee  hot  p)  [buy](hot  p) to meet minimal
change by preserving effects that are not relevant to  (cf. Definition 3.4).
214

fiOn Action Theory Change

The execution for contexts token  coffee  hot and token  coffee  hot are analogous
0
0
0
and the algorithm ends with T 
token[buy]hot = {T1 , T2 , T3 }, where:

T20 =

















coffee  hot, token  hbuyi>,
token  [buy]token, token  [buy],
(coffee  (token  coffee  hot))  [buy]coffee,
(hot  (token  coffee  hot))  [buy]hot,
(coffee  (token  coffee  hot))  [buy]coffee,
(token  coffee  hot)  [buy](coffee  hot)


coffee  hot, token  hbuyi>,




token  [buy]token, token  [buy],




 (coffee  (token  coffee  hot))  [buy]coffee,
(hot  (token  coffee  hot))  [buy]hot,
T30 =


(coffee
 (token  coffee  hot))  [buy]coffee,





(token
 coffee  hot)  [buy](hot  coffee),


(token  coffee  hot)  [buy](coffee  hot)




































Looking at Figure 8, we can see the correspondence between these theories and their
respective models. It is now up to the knowledge engineer to look at these action theories
and pick up the one corresponding to her expectations.
5.3 Contracting Static Laws
Finally, in order to contract a static law from a theory, we can use any contraction/erasure
operator 	 for classical logic that is available in the literature. Because contracting static
laws means admitting new possible states (cf. the semantics), just modifying the set S of
static laws may not be enough for the multimodal logic case. However, since in general
we do not necessarily know the behavior of the actions in a new discovered state of the
world, a careful approach is to change the theory so that all action laws remain the same
in the contexts where the contracted law is the case. (The reader is invited to see that in
the Situation Calculus by allowing a new situation to exist one may need to change the
precondition axioms as well, which means that the problem here described is independent
of the logical formalism chosen.)
In our scenario example, if in contracting the static law coffee  hot the knowledge
engineer is not really sure whether action buy is still executable or not, then she should
weaken the set of executability laws specializing them to the context coffee  hot, and
make buy a priori inexecutable in all (coffee  hot)-contexts. It is worth noting that
this is in line with the assumption commonly made in the RAC community according to
which executability laws are by and large much more likely to be incorrect right from the
beginning (Shanahan, 1997). Therefore extrapolating them to previously unknown states
might (and in all probability will) result in the propagation of errors and, even worse, the
loss of effect laws (remember the discussion in Sections 3.3 and 4.2). The operator given in
Algorithm 3 formalizes this.
215

fiVarzinczak

Algorithm 3: Contraction of a Static Law
Input: T, 
Output: T 
 /* set of theories output to the knowledge engineer */
1

begin

2

T
 := 

3

if S |=CPL  then
/* call classical contraction S 	  of S with  */
foreach S   S 	  do

4

/* build a theory preserving executability in old states */
T 0 := ((T \ S )  S  ) \ Xa

5

T 0 := T 0  {(i  )  hai> : i  hai>  Xa }  {  [a]}

0
T
 := T   {T }

6
7
8

else
T
 := {T}

9
10
11

return T 

end

In our running coffee example, contracting the static law coffee  hot from the action
0
0
theory T produces T 
coffeehot = {T1 , T2 }, where

T10 =













T20 =













(token  coffee  hot),
(token  coffee  hot)  hbuyi>,
coffee  [buy]coffee, token  [buy]token,
token  [buy], coffee  [buy]coffee,
hot  [buy]hot, (coffee  hot)  [buy]








(token  coffee  hot),
(token  coffee  hot)  hbuyi>,
coffee  [buy]coffee, token  [buy]token,
token  [buy], coffee  [buy]coffee,
hot  [buy]hot, (coffee  hot)  [buy]




















Observe that the effect laws are not affected at all by the change: as far as we do not
pronounce ourselves about the executability of some action in the new added world, all the
effect laws remain true in it.
If the knowledge engineer is not happy with (coffee  hot)  [buy], she can contract
this formula from the theory using Algorithm 2. Ideally, besides stating that buy is executable in the context coffee  hot, we should want to specify its outcome in this context
as well. For example, we could want (coffee  hot)  hbuyihot to be true in the result.
This requires theory revision. See Section 8 for the semantics of such an operation.
216

fiOn Action Theory Change

5.4 Complexity Issues
While terminating, our algorithms come with a considerable computational cost: the Kn entailment tests with global axioms in the beginning of the algorithms and inside the loops
are known to be exptime-complete (Harel
V et al., 2000).
V The computation of all possible
contexts allowed by the theory, namely pi atm() pi  pi atm() pi , for all A  atm() and
pi A

pi A
/

all   IP(S  ), is clearly exponential. Moreover, the computation of prime implicants
IP(.) might result in exponential growth (Marquis, 2000).
Given that theory change can be carried out offline, from the perspective of the knowledge engineer what is more important is the complexity of the size of the computed contracted theories: the number of formulas as well as the length of the modified ones. This
plays an important role when deciding among several output theories which one corresponds
to the knowledge engineers expectations. In that matter, whereas the length of new added
formulas may increase exponentially, with respect to the number of laws our results are
positive: the size of the computed contracted theories is linear in the size of the original
action theory. (Remember that card(X) denotes the number of elements in set X.)
Proposition 5.1 Let T be an action theory,   hai> an executability law, and T 0 
0
T
hai> . Then card(T ) = card(T).
0
Proof: If T 6|=
  hai>, then T 
hai> = {T}, and then T = T, from which the result
Kn
0
follows. Suppose T |=
  hai> is the case. Then T is such that T 0 = (T \ Xa )  Xa 0 ,
Kn
where Xa 0 is obtained from Xa in such a way that (i  0 )  hai>  Xa 0 if and only
if i  hai>  Xa , for a fixed 0 . From this it follows card(Xa 0 ) = card(Xa ). Now,
card((T \ Xa )  Xa 0 ) = card(T \ Xa )+card(Xa 0 )card((T \ Xa )  Xa 0 ) = card(T)card(Xa )+
card(Xa 0 )  card() = card(T)  card(Xa ) + card(Xa )  0 = card(T).
2

Proposition 5.2 Let T be an action theory,   [a] an effect law, and T 0  T 
[a] .
Then card(T 0 )  card(T) + card(Ea ) + card(Lit).
0
Proof: If T 6|=
  [a], then T 
[a] = {T}, and then T = T, from what we get
Kn
card(T 0 ) = card(T). Since card(T)  card(T) + card(Ea ) + card(Lit), the result follows.
Suppose that T |=K   [a] is the case. Then T 0 = (T \ Ea )  Ea 0  Ea 00  Fa , where:
n

0

00

 Ea and Ea are both obtained from Ea in such a way that (i  0 )  [a]i  Ea 0
and (i  0 )  [a](i   0 )  Ea 00 if and only if i  [a]i  Ea , for fixed 0 ,  0 ;
 Fa  {(0  `)  [a](  `) : `  Lit}, for a fixed 0 ; and
 T, Ea 0 , Ea 00 , Fa are pairwise disjoint.
Hence card(Ea 0 ) = card(Ea 00 ) = card(Ea ), and card(Fa )  card(Lit). Then card(T 0 ) =
card(T \ Ea ) + card(Ea 0 ) + card(Ea 00 ) + card(Fa ) = card(T \ Ea ) + card(Ea ) + card(Ea ) +
card(Fa ) = card(T)  card(Ea ) + card(Ea ) + card(Ea ) + card(Fa ) = card(T) + card(Ea ) +
card(Fa )  card(T) + card(Ea ) + card(Lit).
2
217

fiVarzinczak

Given the arbitrary choice of the contraction operator for static laws, without loss of
generality we can resort to a slightly modified version of it, viz. one that always gives us
as result a set of static laws with the same cardinality as the original S . (This is possible
since, contrary to E and X , a conjunction of static laws is still a static law, with no further
rewriting.) By agreeing on that, the following proposition is straightforward:
0
Proposition 5.3 Let T be an action theory,  a static law, and T 0  T 
 . Then card(T ) =
card(T) + 1.

Propositions 5.15.3 are positive results: if the knowledge engineer can deal with the
original action theory, then she will be able to deal with the output of the algorithms.
(Observe that for a given T 0 all the conditional frame axioms added to Fa in the contraction
of an effect law can be factored into a single law, so that the resulting theory has a
cardinality of at most card(T) + card(Ea ) + 1.)
We finish this section by observing that the size of T 
 , the set of resulting contracted
theories, depends solely on the set of static laws plus the law we contract T with:
Proposition 5.4 Let T be an action theory, and let  be a law such that T |=
. Then
K
n

 card(T 
 ) = card(S 	 ), if  is 
 card(T 
 ) = card(val(S  {})), if  is either   hai> or   [a].
Proof: The proof follows straightforwardly from the outermost loops in Algorithms 13. 2

6. Correctness of the Operators
We now address the correctness of our algorithms with respect to our semantics for contraction. Correctness here is understood as completeness and adequacy. Adequacy means that
the algorithms output only theories whose models result from our semantic modifications
of models of the original theory. Conversely, completeness says that every model resulting
from the semantic modifications of models of the original theory is indeed a model of some
theory output by the algorithm.
6.1 Challenges to Completeness and Adequacy
Let the theory T = {p1  hai>, (p1  p2 )  [a], [a]p2 } and consider its model M
depicted in Figure 13. (Notice that T |=
(p1  p2 ).) When contracting p1  [a]p2 in M ,
Kn
0
we get M in Figure 13.
0
Now contracting p1  [a]p2 from T using Algorithm 2 gives T 
p [a]p = {T }, where
1

2



 p1  hai>, (p1  p2 )  [a], 
(p1  p2 )  [a](p2  p2 ),
T0=


(p1  p2 )  [a](p2  p1 )
Notice that the formula (p1  p2 )  [a](p2  p1 ) is put in T 0 by Algorithm 2 because
there is {p1 }  Lit such that S 6|=
(p  p2 )   and T 6|=K (p1  p2 )  [a]p1 . It is
CPL 1
n

218

fiOn Action Theory Change

a

a

w1

a

p1 , p2

w2

w1

p1 , p2

M :

M0 :
w3

w2
p1 , p2

a

p1 , p2

a
w3

p1 , p2

p1 , p2

Figure 13: A model M of T and the result M 0 of contracting p1  [a]p2 in it.
M0

0
clearly the case that 6|= T 0 and no theory in T 
p1 [a]p2 has M as model. This means that
there are theories for which the contraction operators are not complete.
This issue arises because Algorithm 2 tries to allow a transition from the p1  p2 -world
to a p2 -world that is closest to it, viz. {p1 , p2 }, but has no way of knowing
V that such a
0 
world does not exist. A remedy for that is replacing the test T 6`
(
`L `)   for
Kn
V
0
S 6`CPL (  `L `)  , but that would increase even more the complexity of the algorithm.
A better option would be to have S complete enough to allow the algorithm to determine
the worlds to which a new transition could exist.

The other way round, it does not hold in general that the models of each T 0  T 
 result
from the semantic contraction of models of T by . To see why suppose that there is only
one atom p and one action a, and consider the action theory T = {p  [a], hai>}. The
only model of T is M = h{{p}}, {({p}, {p})}i in Figure 14.
a

a

w2

w1

w1

M :

p

M0 :

p

p

Figure 14: Inadequacy of contraction: a model M of T and a model M 0 of the theory
resulting from contracting p  hai> from T.
From our definitions, contract(M , p  hai>) = {M }. (There is no p-world in M from
0
which to remove an arrow.) On the other hand, T 
phai> is the singleton {T } such that
T 0 = {p  [a], p  hai>}. Then M 0 = h{{p}, {p}}, ({p}, {p})i in Figure 14 is a
model of the resulting contracted theory. Clearly, M 0 does not result from the semantic
contraction of p  hai> from M : while p is valid in the contraction of the models of T, it
is not valid in the models of T 0 . This means that there are theories for which the operators
are not adequate.
This problem occurs because, in our example, the worlds that are forbidden by T, e.g.
{p}, are not preserved as such in T 0 . When contracting an executability or an effect law,
we are not supposed to change the possible worlds of a theory (cf. Section 3).
Fortunately correctness of the algorithms with respect to our semantics can be established for those action theories whose S is maximal, i.e., the set of static laws in S alone
219

fiVarzinczak

characterize what worlds are possible in the models of the theory. This is the principle of
modularity (Herzig & Varzinczak, 2005b) and we briefly review it in the next section.
6.2 Modular Action Theories
A quite useful, albeit simple, property of domain descriptions in reasoning about actions is
that of action theory modularity (Herzig & Varzinczak, 2005b).
Definition 6.1 (Modularity) An action theory T is modular if and only if for every
Boolean formula   Fml, if T |=
, then S |=CPL .
K
n

For an example of a non-modular theory, let us suppose that the action theory T of our
coffee machine scenario were stated as


coffee

hot,
hbuyi>,






coffee  [buy]coffee,
T=

token  [buy]token, token  [buy], 




coffee  [buy]coffee, hot  [buy]hot
The modified law is underlined: we have (in this case wrongly) stated that the agent can
always buy at the machine. Then T |=K token, but S 6|=
token.
CPL
n

Since the underlying multimodal logic is independently axiomatized (see Section 2.1), we
can use the algorithms given by Herzig and Varzinczak (2005b) to check whether an action
theory satisfies the principle of modularity. Whenever this is not the case, the algorithms
return the Boolean formulas entailed by the theory which are not consequences of S alone.
For the theory T above, they would return {token}: as we have stated hbuyi>, from this and
the inexecutability law token  [buy] we have that T |=
token. Because S 6|=
token,
Kn
CPL
token is what is called an implicit static law (Herzig & Varzinczak, 2004) of the action
theory T.5
Modular action theories have several interesting computational properties. For example, consistency can be checked by just checking consistency of the static laws in S : if
T is modular, then T |=
 if and only if S |=
. Deduction of effect laws does not
Kn
CPL
need the executability ones and vice versa. Deduction of an effect of a sequence of actions a1 ; . . . ; an (prediction) does not need to take into account the effect laws for actions
other than a1 , . . . , an . This applies in particular to plan validation when deciding whether
ha1 ; . . . ; an i is the case.
Modularity is not an exclusive property of action theories formalized in Kn : similar
notions have also been investigated for different contexts in other formalisms, like regulation consistency in deontic logic (Cholvy, 1999), Situation Calculus (Herzig & Varzinczak,
2005a), DL ontologies (Herzig & Varzinczak, 2006), dynamic logic (Zhang, Chopra, & Foo,
2002) and also in the Fluent Calculus (Thielscher, 2010). For more details on modularity
in Kn action theories, as well as its role in the presence of a solution to the frame and
ramification problems, see the work by Varzinczak (2006).
5. Implicit static laws are closely related to veridical paradoxes (Quine, 1962). It turns out that sometimes
they are intuitive, but sometimes they are not. For a deep discussion on implicit static laws, see the
work by Varzinczak (2006).

220

fiOn Action Theory Change

Another interesting property of modular action theories is the following:
Theorem 6.1 T is modular if and only if T has a canonical model.
Proof: Let Mcan = hWcan , Rcan i be the canonical frame of T.
Mcan

Mcan

(): By definition, Mcan is such that |= S  E . It remains to show that |= X . Let
Mcan
i  hai>  Xa , and let w  Wcan be such that |=w i . Therefore for all j  Fml such
Mcan

that T |=K j  [a], we must have 6|=
w
n

Mcan

S |=
(i  j ), and hence |=
CPL

Mcan

some w0  Wcan such that |= 0
Mcan

and |=

w

j , because T |=
(i  j ), and as T is modular,
K
n

(i  j ). Then by the construction of Mcan , there is
Mcan

 for all   [a]  Ea such that |=
w

. Thus Ra (w) 6= 

i  hai>.

(): Suppose T is not modular. Then there must be some   Fml such that T |=
 and
Kn
S 6|=
. This means that there is v  val(S ) such that v 6 . As v  Wcan (because Wcan
CPL
contains all possible valuations of S ), Mcan is not a model of T.
2
6.3 Correctness Under Modularity
As shown by Herzig and Varzinczak (2007), given an action theory formalized with any
framework available in the literature allowing for the expression of our three basic types of
laws, it is always possible to ensure modularity. Moreover, as we are going to see in the
sequel (cf. Section 7.2), it has to be computed at most once during the evolution of the
action theory. Hence, relying on modular theories is not a limitation at all to our approach.
The following theorem establishes that under the assumption that the action theory T
is modular, the semantic contraction of a formula  from the set of models of T produces
models of some contracted theory in T 
.
M

Theorem 6.2 Let T be modular, and  be a law. For all M0  M
 such that |= T for
M0

0
0
0
every M  M, there is T 0  T 
 such that |= T for every M  M .

2

Proof: See Appendix A.

The next theorem establishes the other way round: under modularity models of theories
in T 
 are all models of the semantic contraction of  from models of T.
M0

0
0
Theorem 6.3 Let T be modular,  a law, and T 0  T 
 . For all M such that |= T , there
M

0
0
is M0  M
 such that M  M and |= T for every M  M.

2

Proof: See Appendix B.
With these two theorems we get the correctness of our operators:
M0

0
Corollary 6.1 Let T be modular,  a law, and T 0  T 
 if and only if |= 
 . Then T |=
K
M

n

for every M 0  M0 such that M0  M
 for some M such that |= T for all M  M.
221

fiVarzinczak

Proof:
M0
0
0
(): Let M 0 be such that |= T 0 . By Theorem 6.3, there is M0  M
 such that M  M
M

M0

for some M such that |= T for all M  M. From this and T 0 |=
 , we have |=  .
K
n

(): Suppose T 0 6|=K  . (We show that there is some model M 0  M0 such that M0  M

n

M

M0

for some M with |= T for all M  M, and 6|=  .)
Given that T is modular, by Lemma B.1 T 0 is modular, too. Then, by Lemma B.3,
M0
M0
there is some M 0 = hval(S 0 ), R0 i such that 6|=  . Clearly |= T 0 , and from Lemma B.4 the
result follows.
2

7. Assessment of Postulates for Change
Do our action theory change operators satisfy the classical postulates for change? Before
answering this question, one should ask: do our operators behave like revision or update
operators? We here address this issue and then show which postulates for theory change
are satisfied by our definitions.
7.1 Contraction or Erasure?
The distinction between revision/contraction and update/erasure for classical theories is
historically controversial in the literature. The same is true for the case of modal theories
describing actions and their effects. We here rephrase Katsuno and Mendelzons definitions (1992) in our terms so that we can see to which one our method is closer.
In Katsuno and Mendelzons view, contracting a law  from an action theory T intuitively means that the description of the possible behavior of the dynamic world T must be
adjusted to the possibility of  being false. This amounts to selecting from the models of
 those that are closest to models of T and allow them as models of the result.
In contrast, update methods select, for each model M of T, the set of models of  that
are closest to M . Erasing  from T means adding models to T; for each model M , we add
all those models closest to M in which  is false. Hence, from our constructions so far it
seems that our operators are closer to update than to revision.
Moreover, according to Katsuno and Mendelzons view (1992), our change operators
would also be classified as update because we make modifications in each model independently, i.e., without changing other models.6 Besides that, in our setting a different
ordering on the resulting models is induced by each model of the theory T (see Definitions 3.3, 3.7 and 3.10), which according to Katsuno and Mendelzon is a typical property
of an update/erasure method.
Nevertheless, things get quite different when it comes to the postulates for theory change.
7.2 The Postulates
In this section we analyze the behavior of our action theory change operators with respect
to AGM-like postulates. Here we follow Katsuno and Mendelzons presentation of the
6. Even if when contracting an effect law from one particular model we need to check the other models of
the theory, those are not modified.

222

fiOn Action Theory Change

postulates to assess both contraction and erasure. Let T = S  E  X denote an action
theory and  denote a law.
T 0 , for all T 0  T 
Monotonicity Postulate: T |=
.
K
n

This postulate is our version of Katsuno and Mendelzons (C1) and (E1) postulates
for contraction and erasure, respectively, and it is satisfied by our change operators. The
proof is in Lemma A.1. Such a postulate is not satisfied by the operators proposed by
Herzig et al. (2006): there when removing e.g. an executability law   hai> one may
make   [a] valid in all models of the resulting theory.
Preservation Postulate: If T 6|=
, then |=
T  T 0 , for all T 0  T 
.
K
K
n

n

This is Katsuno and Mendelzons (C2) postulate. Our operators satisfy it as far as
whenever T 6|=
, then the models of the resulting theory are exactly the models of T,
Kn
because these are the minimal models falsifying .
The corresponding version of Katsuno and Mendelzons (E2) postulate about erasure,
i.e., if T |=
, then |=K T  T 0 , for all T 0  T 
 , is clearly also satisfied by our operators
Kn
n
as a special case of the postulate above. Satisfaction of (C2) indicates that our operators
are closer to contraction than to erasure.
If T 6|=K  and 6|=K , then T 0 6|=K , for all T 0  T 
.

Success Postulate:

n

n

n

This postulate is our version of Katsuno and Mendelzons (C3) and (E3) postulates. If
 is a propositional   Fml, our operators satisfy it, as long as the classical propositional
change operator satisfies it as well. For the general case, however, as stated the postulate is
not always satisfied. This is shown by the following example: let T = {p, hai>, p  [a]}.
Note that T is modular and consistent. Now, contracting the (contingent) formula p  hai>
from T gives us T 0 = T. Clearly T 0 |=K p  hai>. This happens because, despite not being a
n
tautology, p  hai> is a trivial formula with respect to T: since p is valid in all T-models,
p  hai> is trivially true in these models (cf. end of Section 3.1).
Fortunately, for all those formulas that are non-trivial consequences of the theory, our
operators guarantee success of contraction:
Theorem 7.1 Let T be consistent, and  be an executability or an effect law such that
S 6|=
. If T is modular, then T 0 6|=K  for every T 0  T 
.
K
n

n

0
Proof: Let us suppose that there is some T 0  T 
. Since T is modular,
 such that T |=
K
n

M0

Corollary 6.1 tells us that |=  for every M 0  M0 such that M0  M
 , where M = {M :
M

|= T and M = hval(S ), Ri}.
M0

M 00

If |=  for every M 0  M0 , then even for M 00  M0 \M we have |= . But M 00  M
M 00

for some M  M, and by definition 6|= . Hence M = , and then the truth of  in M
does not depend on the accessibility relation Ra . Hence, whether  has the form   hai>
or   [a], for ,   Fml, this holds only if S |=CPL  (see Definitions 3.1 and 3.5), and
therefore we get S |=K .
2
n

223

fiVarzinczak

Equivalences Postulate: If |=K T1  T2 and |=
1  2 , then |=K T10  T20 , for some
K

0
T10  (T1 )
2 and T2  (T2 )1 .

n

n

n

This postulate corresponds to Katsuno and Mendelzons (C4) and (E4) postulates. It
is worth noting that equivalence here is considered always modulo action laws, i.e., the
formulas are assumed to be either static laws, effect laws or executability laws, as well as
their equivalents. Moreover we remember that the theories here must be action theories,
i.e., sets of action laws of our three basic types. Under modularity and the assumption that
the propositional change operator satisfies (C4)/(E4), our operations satisfy this postulate:
T1  T2 and |=K 1  2 , then for each
Theorem 7.2 Let T1 and T2 be modular. If |=
K
n

n


0
T 0  T20 , and vice-versa.
T10  (T1 )
2 there is T2  (T2 )1 such that |=
K 1
n

Proof: The proof follows straight from our results: since |=
T  T2 and |=K 1  2 , they
K 1
n

M

M

n

have pairwise the same models. Hence, given M such that |= T1 and |= T2 , the semantic
contraction of 1 and that of 2 from M have the same operations on M . As T1 and T2
are modular, Corollary 6.1 guarantees we get the same syntactical results. Moreover, as the
classical operator 	 satisfies (C4)/(E4), if follows that |=K T10  T20 .
2
n

Recovery Postulate: T 0  {} |=
T, for all T 0  T 
.
K
n

This is the action theory counterpart of Katsuno and Mendelzons (C5) and (E5) postulates. Again we rely on modularity in order to satisfy it.
Theorem 7.3 Let T be modular. T 0  {} |=
T, for all T 0  T 
.
K
n

Proof: If T 6|=K , because our operators satisfy the preservation postulate, T 0 = T, and
n
then the result follows by monotonicity.
Let T |=
, and let M0 denote the set of all models of T 0 . As T is modular, by CorolK
n

M0

M0

lary 6.1 every M 0  M0 is such that either |= T (and then |= ) or M 0  contract(M , )
M
(and then M 0  M ) for some M such that |= T.
Let M00 denote the set of all models of T 0  {}. Clearly M00  M0 , by monotonicity.
M 00

Moreover, every M 00  M00 is such that |= , hence M 00 
/ M for every M such that
M

|= T, and then M 00 
/ contract(M , ), for any M model of T. Thus M 00 is a model of T
0
and then T  {} |=K T.
2
n
W

0
Let T 
 denote the disjunction of all T in T  .
W
W
Disjunctive Rule: (T1  T2 )
(T1 )
(T2 )
 is equivalent to
 
.
This is our version of (E8) erasure postulate by Katsuno and Mendelzon. Clearly our
syntactical operators do not manage to contract a law from a disjunction of theories: T1 T2
is not an action theory and cannot in general be rewritten as one. Nevertheless, by proving
that it holds in the semantics, from the correctness of our operators, we get an equivalent
operation. Again the fact that the theories under concern are modular gives us the result.
224

fiOn Action Theory Change

Theorem 7.4 Let T1 and T2 be modular, and  be a law. Then
_
_
_
(T2 )
(T1 )
|=K
(T1  T2 )
)
 
 (
n

Proof:
W
M 0W
M 0W
M 0W

(T2 )
(T1 )
(): Let M 0 be such that |=
(T1 )
 . Suppose
 or |=
  (T2 ) . Then |=
0
M0
M W


|=
(T1 ) (the other case is analogous). Then there is (T1 )0  (T1 ) such that |= (T1 )0 .
0
0
Then by Corollary 6.1, there is M0  M
 such that M  M , for M a set of models of
0
T1 . Then M is a model resulting from contracting  from models of T1 , and then M 0 also
results from contracting  in models of T1  T2 , viz. those models of T1 . Then by CorolM0
M 0W
0 , and then |=
such
that
|=
(T

T
)
(T1  T2 )
lary 6.1, there is (T1  T2 )0  (T1  T2 )
1
2
.

M 0W

(): Let M 0 be such that |=
M0


0
(T1  T2 )
 . Then there is (T1  T2 )  (T1  T2 ) such that

0
0
|= (T1  T2 )0 . By Corollary 6.1, there is M0  M
 such that M  M , for M a set of
0
models of T1  T2 . Then M is a model resulting from contracting  from models of T1  T2 .
Hence M 0 results from contracting  from models of T1 or from models of T2 . Suppose the
former is the case (the second is analogous). Then by Corollary 6.1 there is (T1 )0  (T1 )

M0
M 0W
such that |= (T1 )0 , and then |=
(T1 )
.
2


We have thus shown that our constructions satisfy the (E8) postulate. Nevertheless,
as far as we see, it is not immediate whether it is really expected here. This supports our
position that our operators behavior is closer to contraction than to erasure.
As we have seen from the results above, modularity is a sufficient condition for the
satisfaction of the AGM-like postulates for action theory contraction. To finish up we state
a new postulate:
Preservation of Modularity: If T is modular, then every T 0  T 
 is modular.
Changing a modular theory should not make it non-modular. This is not a standard
postulate, but we think that since it is a good property modularity should be preserved
across changing an action theory. If so, this means that whether a theory is modular or
not can be checked once for all and one does not need to care about it during the future
evolution of the action theory, i.e., when other changes will be made on it. Our operators
satisfy this postulate and the proof is given in Appendix B.
Now one may naturally asks whether we can get a characterization result in the traditional AGM sense, i.e., whether any contraction operator satisfying all our versions of
the postulates is one of our three contraction operations. Unfortunately, good sense points
towards a negative answer: there might well be an operator satisfying all the above postulates that, by not complying with all the assumptions in the RAC community (Shanahan,
1997), is not necessarily one of the operators defined in Section 3 (cf. the discussion on
general formula contraction in Section 10). To witness, consider for example an operator
that also modifies worlds when contracting effect laws. This supports one of the contentions
of the present work, viz. that classical belief change cannot be fully transposed to action
theories and expected to give exactly the same kind of outcome. Similar negative results
have also been found for revision in DL ontologies (Flouris, Plexousakis, & Antoniou, 2004)
and contraction of Horn theories (Booth, Meyer, & Varzinczak, 2009).
225

fiVarzinczak

8. A Semantics for Action Theory Revision
So far we have analyzed the case of contraction: the knowledge engineer realizes that the
theory is too strong and therefore it has to be weakened. Let us now take a look at the
other way round, i.e., the theory is (possibly) too liberal and the agent discovers new laws
about the world that should be added to her beliefs, which amounts to strengthening them.
Suppose that the action theory of our scenario example were initially stated as follows:


coffee  hot, token  hbuyi>,


coffee  [buy]coffee, token  [buy],
T=


coffee  [buy]coffee, hot  [buy]hot
Then the canonical model of theory T is as shown in Figure 15.
w1
t, c, h
b

b

w2

M :

b

w3

b

t, c, h

t, c, h

b
b

w5
t, c, h

w6

w4
t, c, h

t, c, h

Figure 15: Canonical model of the new initial action domain description.
Looking at model M in Figure 15 we can see that, for example, the agent does not know
that she loses her token every time she buys coffee at the machine. This is a new law that
she should incorporate to her knowledge base at some stage of her action theory evolution.
Contrary to contraction, where we want the negation of some law to become satisfiable,
in revision we want to make a new law valid. This means that one has to eliminate all cases
satisfying its negation. This depicts the duality between revision and contraction: whereas
in the latter one invalidates a formula by making its negation satisfiable, in the former one
makes a formula valid by forcing its negation to be unsatisfiable prior to adding the new
law to the theory.
The idea behind our semantics for revision is as follows: we initially have a set of models
M in which a given formula  is (potentially) not valid, i.e.,  is (possibly) not true in
every model in M. In the result we want to have only models of . Adding -models to
M is of no help. Moreover, adding models makes us lose laws: the corresponding resulting
theory would be more liberal.
One solution amounts to deleting from M those models that are not -models. Of
course removing only some of them does not solve the problem, we must delete every such a
model. By doing that, all resulting models will be models of . (This corresponds to theory
expansion, when the resulting theory is satisfiable.) However, if M contains no model of
, we will end up with . Consequence: the resulting theory is inconsistent. (This is the
main revision problem.) In this case the solution is to substitute each model M in M by
226

fiOn Action Theory Change

its nearest modification M? that makes  true. This lets us to keep as close as possible to
the original models we had. But, what if for one model in M there are several minimal
(incomparable) modifications of it validating ? In that case we shall consider all of them.
The result will also be a list of models M? , all being models of .
Before defining the revision of sets of models, we present what modifications of (individual) models are.
8.1 Revising a Model by a Static Law
Suppose that our coffee deliverer agent discovers that the only hot drink that is served on
the machine is coffee. In this case, she might want to revise her beliefs with the new static
law coffee  hot: she cannot hold a hot drink that is not a coffee.
Considering the model depicted in Figure 15, one can see that the Boolean formula
coffee  hot is satisfiable (there is a world of the model in which it holds). Since we do
not want this to be the case, the first step is to remove all worlds in which coffee  hot is
true. The second step is to guarantee that all the remaining worlds (if any) satisfy the new
static law. Such an issue has been largely addressed in the literature on propositional belief
base revision and update (Gardenfors, 1988; Winslett, 1988; Katsuno & Mendelzon, 1992;
Herzig & Rifi, 1999). Here we can achieve that with a semantics similar to that of classical
revision operators: basically one can change the set of possible valuations, by removing or
adding worlds.
In our example, removing the possible worlds {t, c, h} and {t, c, h} would do the job
(there is no need to add new valuations since the new incoming law is already satisfied in at
least one world of the original model, and therefore the resulting set of worlds is non-empty).
The delicate point in removing worlds is that this may have as consequence the loss of
some executability laws: in the example, if there were some transition from some world w
to say {t, c, h}, then removing the latter from the model would make the action under
concern no longer executable in w, if it was the only transition labeled by that action leaving
it. From a semantic point of view, this is intuitive: if the state of the world to which we
could move is no longer possible, then we do not have a transition to that state anymore.
Therefore, if that transition was the only one we had, it is natural to lose it.
Similarly, one could ask what to do with the accessibility relation if new worlds are
added, i.e., when expansion is not possible. Following the discussion in Section 3.3, we here
prefer not to add new transitions systematically to the accessibility relation. Hence we shall
postpone correction of executability laws, if needed. This approach may be debatable, but
with the information we have at hand, this is the safest way of changing static laws. (See
also the discussion in Sections 3.3 and 4.2.)
The semantics for revision of one model by a static law is as follows:
Definition 8.1 Let M = hW, Ri. M 0 = hW0 , R0 i  M? if and only if:
 W0 = (W \ val())  W , where W  val(); and
 R0  R.
227

fiVarzinczak

M0

Clearly unless  |=
, we have that |=  for each M 0  M? . The minimal models
CPL
resulting from revising a model M by  are those closest to M with respect to M :
Definition 8.2 Let M be a model and  a static law. revise(M , ) =

S

min{M? , M }.

In the example of model M in Figure 15, revise(M , coffee  hot) is the singleton
{M 0 }, where M 0 is as shown in Figure 16.
w1
t, c, h
b
w2

M0 :

b

t, c, h
b
b

w5
t, c, h

w4
t, c, h

Figure 16: Model resulting from revising the model M in Figure 15 with coffee  hot.

8.2 Revising a Model by an Effect Law
Let us suppose now that our agent eventually discovers that after buying coffee she does
not keep her token anymore. (That was a design mistake that the agent still possesses a
token even after ordering a coffee at the machine). This means that her theory should now
be revised in such a way that the new effect law token  [buy]token holds. Looking at
model M in Figure 15, this amounts to guaranteeing that the formula token  hbuyitoken
is satisfiable in none of its worlds. To do that, we have to look at all the worlds satisfying
this formula (if any) and either (i) make token false in each of these worlds; or (ii) make
hbuyitoken false in all of them. If we chose the first option, we will essentially flip the truth
value of literal token in the respective worlds, which changes the set of valuations of the
model. If we chose the latter, we will basically remove buy-arrows leading to token-worlds.
In that case, a change in the accessibility relation will be made.
In our example, we have that the possible worlds {token, coffee, hot}, {token, coffee, hot}
and {token, coffee, hot} satisfy token  hbuyitoken and all they have to change.
Flipping token in all these worlds to token would do the job, but would also have
as consequence the introduction of a new static law: token would now be valid, i.e., the
agent never has a token! Another issue with this approach is that by making token true
everywhere, the new incoming law token  [buy]token will be trivially true in the resulting
model, which does not mean that there is an execution of action buy from a token-world
to a token one. This defeats the purpose of changing the action theory on the basis that
it has been observed that every execution of the action under consideration should lead to
token-contexts.
One of our contentions in the present work is that changing action laws should never
have as a side effect a change in the static laws (cf. Sections 3 and 4). Given their special status (Shanahan, 1997), these should change only if explicitly required. In this case, each world
228

fiOn Action Theory Change

satisfying token  hbuyitoken has to be changed so that hbuyitoken is no longer true in it.
In our example, we should remove the transitions ({token, coffee, hot}, {token, coffee, hot}),
({token, coffee, hot}, {token, coffee, hot}) and ({token, coffee, hot}, {token, coffee, hot}).
The semantics of one model revision for the case of a new effect law is:
?
Definition 8.3 Let M = hW, Ri. M 0 = hW0 , R0 i  M[a]
if and only if:

 W0 = W;
 R0  R;
M

 If (w, w0 )  R \ R0 , then |=w ; and
M0

 |=   [a].
The minimal models resulting from the revision of a model M by a new effect law are
those that are closest to M with respect to our order on the models M :
Definition 8.4 Let M be a model and   [a] an effect law. revise(M ,   [a]) =
S
?
min{M[a]
, M }.
Taking once again M as shown in Figure 15, revise(M , token  [buy]token) will be
the singleton {M 0 } (Figure 17).
w1
t, c, h
b

b
w3

w2

M0 :

t, c, h

t, c, h
b

w5

w6

w4
t, c, h

t, c, h

t, c, h

Figure 17: Model resulting from revising the model M in Figure 15 with the new effect law
token  [buy]token.

8.3 Revising a Model by an Executability Law
Let us now suppose that in some stage it has been decided to grant free coffee to everybody.
Faced with this information, the agent will now revise her laws to reflect the fact that buy
can also be executed in token-contexts: token  hbuyi> is a new executability law (and
therefore we will have hbuyi> in all new models of the agents beliefs).
Considering again the model in Figure 15, we observe that (token  hbuyi>) is
satisfiable in M . This means that we must throw token  [buy] away to ensure that the
new formula becomes true in the new model, i.e., satisfied by all of its worlds.
229

fiVarzinczak

To remove token  [buy] we have to look at all worlds satisfying it and modify M
so that they no longer satisfy that formula. Given worlds {token, coffee, hot} and
{token, coffee, hot}, we have two options: change the interpretation of token or add new
transitions leaving these worlds. A question that arises is what choice is more drastic:
change a world or a transition ? Again, here we think that changing the worlds content
(the valuation) is more drastic, as the existence of such a world was foreseen by some static
law and is hence assumed to be as it is, unless we have enough information supporting
the contrary, in which case we explicitly change the static laws (see above). Moreover,
changing the truth value of token in these worlds would trivialize the new incoming law
token  hbuyi> in the new model, defeating the purpose of guaranteeing the existence of
a buy-transition from a token-context. Therefore we shall add a new buy-arrow from each
of {token, coffee, hot} and {token, coffee, hot}.
Having agreed on that, the issue now is: which worlds should the new transitions be
directed to? Recalling the reasoning developed in Section 3.2, in order to comply with
minimal change, the new transitions shall be directed to worlds that are relevant targets
of each of the token-worlds in question. In our example, {token, coffee, hot} is the only
relevant target world here: the two other token-worlds violate the effect coffee of buy, while
the three token-worlds would make us violate the frame axiom token  [buy]token.
The semantics for one model revision by a new executability law is as follows:
?
Definition 8.5 Let M = hW, Ri. M 0 = hW0 , R0 i  Mhai>
if and only if:

 W0 = W;
 R  R0 ;
 If (w, w0 )  R0 \ R, then w0  RelTarget(w,   [a], M , M); and
M0

 |=   hai>.
The minimal models resulting from revising a model M by a new executability law are
those closest to M with respect to M :
Definition
M be a model and   hai> be an executability law. revise(M ,  
S 8.6 Let
?
hai>) = min{Mhai>
, M }.
In our running example, revise(M , token  hbuyi>) is the singleton {M 0 }, where M 0
is as depicted in Figure 18.
In this example, observe that because we have a single relevant target world we get a
single model in the result of revision.
8.4 Revising Sets of Models
Up until now we have seen what the revision of single models means. This is needed when
expansion by the new law is not possible due to inconsistency. We here give a unified
definition of revision of a set of models M by a new law :
230

fiOn Action Theory Change

b
w1
t, c, h
b

b

b

w2

M0 :

b

t, c, h
b

t, c, h

t, c, h

b
b

w5

b
w3

w6

w4
t, c, h

t, c, h

Figure 18: Result of revising M in Figure 15 by the new executability law token  hbuyi>.

Definition 8.7 Let M be a set of models and  be a law. Then
(
M
M
M \ {M : 6|= }, if there is M  M such that |= ;
?
M =
S
M M revise(M , ), otherwise.
Observe that Definition 8.7 comprises both expansion and revision: in the first one, simple
addition of the new law gives a satisfiable theory; in the latter a deeper change is needed
to get rid of inconsistency.

9. Related Work
To the best of our knowledge, the first work on updating an action domain description is
that by Li and Pereira (1996) in a narrative-based action description language (Gelfond &
Lifschitz, 1993). Contrary to us, however, they mainly investigate the problem of updating
the narrative with new observed facts and (possibly) with occurrences of actions that explain
those facts. This amounts to updating a given state/configuration of the world (in our terms,
what is true in a possible world) and focusing on the models of the narrative in which some
actions took place (in our terms, the models of the action theory with a particular sequence
of action executions). Clearly the models of the action laws remain the same.
Baral and Lobo (1997) introduce extensions of action languages that allow for some
causal laws to be stated as defeasible. Their work is similar to ours in that they also allow
for weakening of laws: in their setting, effect propositions can be replaced by what they call
defeasible (weakened versions of) effect propositions. Our approach is different from theirs
in the way executability laws are dealt with. Here executability laws are explicit and we
are also able to contract them. This feature is important when the qualification problem is
considered: we may always discover contexts that preclude the execution of a given action
(cf. the Introduction).
Liberatore (2000) proposes a framework for reasoning about actions in which it is possible to express a given semantics of belief update, like Winsletts (1988) and Katsuno and
Mendelzons (1992). This means it is the formalism, essentially an action description lan231

fiVarzinczak

guage, that is used to describe updates (the change of propositions from one state of the
world to another) by expressing them as laws in the action theory.
The main difference between Liberatores work (2000) and Li and Pereiras (1996) is
that, despite not being concerned, at least a priori, with changing action laws, Liberatores
framework allows for abductively introducing in the action theory new effect propositions
(effect laws, in our terms) that consistently explain the occurrence of an event.
The work by Eiter et al. (2005) is similar to ours in that they also propose a framework
which is oriented to updating action laws. They mainly investigate the case where e.g.
a new effect law is added to the description (and then has to be true in all models of the
modified theory). This problem is the dual of contraction and is then closer to our definition
of revision (cf. Section 8).
In Eiter et al.s framework (2005), action theories are described in a variant of a narrativebased action description language. Like in the present work, the semantics is also in terms
of transition systems, with transitions (action occurrences) linking states (configurations
of the world). Contrary to us, however, the minimality condition on the outcome of the
update is in terms of inclusion of sets of laws, which means that the approach is more syntax
oriented to some extent.
In their setting, during an update an action theory T is seen as composed of two pieces,
Tu and Tm , where Tu stands for the part of T that is not supposed to change and Tm contains
the laws which may be modified. In our terms, when contracting a static law we would
have Tm = S  Xa ; when contracting an executability law Tm = Xa ; and when contracting
effects laws Tm = Ea . The difference here is that in our approach it is always clear what
laws should not change in a given type of contraction, and therefore Tu and Tm do not need
to be explicitly specified prior to the update.
Their approach and ours can both be described as constraint-based update, in that the
theory change is carried out relative to some constraints (a set of laws that we want to hold
in the result). In our framework, for example, all changes in the action laws are relative to
the set of static laws S (and that is why we concentrate on models of T having val(S ) as
worlds). When changing a law, we want to keep the same set of states. The difference with
respect to Eiter et al.s (2005) approach is that there it is also possible to update a theory
relatively to e.g. executability laws: when expanding T with a new effect law, one may want
to constrain the change so that the action under concern is guaranteed to be executable in
the result.7 As shown in the referred work, this may require the withdrawal of some static
law. Hence, in Eiter et al.s framework, static laws do not have the same status as in ours.
Herzig et al. (2006) define a method for action theory contraction that, despite the
similarity with the current work and the common underlying motivations, is more limited
than the present constructions.
First, with the referred approach we do not get minimal change. For example, in the
referred work the operator for contracting executability laws is such that in the resulting
theory the modified set of executability laws is given by
Xa = {(i  )  hai> : i  hai>  Xa }
7. We could simulate that in our approach with two successive modifications of T: first adding the effect
law and then an executability law (cf. Section 8).

232

fiOn Action Theory Change

which, according to its semantics, gives theories among whose models are those resulting
from removing transitions from all -worlds. A similar comment can be made with respect
to contraction of effect laws.
Second, Herzig et al.s (2006) contraction method does not satisfy most of the postulates
for action theory change that we have addressed in Section 7. Besides not satisfying the
monotonicity postulate, it does not satisfy the preservation one. To witness, suppose that
we have a language with only one atom p, and the model M depicted in Figure 19.
a
w1

M :

a

a

w2
p

p

a
a

w1

M :
0

a

w2
p

p
a

Figure 19: Counter-example to preservation in the method by Herzig et al. (2006).
M

M

Then |= p  [a]p and 6|= [a]p. Now the contraction operator defined there is such
that when removing [a]p from M yields the model M 0 in Figure 19 such that R0a = WW.
M0

Then 6|= p  [a]p, i.e., the effect law p  [a]p is not preserved.
Finally, another work that is related to ours is that by Zhang and Ding (2008). Like
ours, their approach is also about giving a semantic characterization of the basic operations
for changing Kripke models. Contrary to us however, their focus is on model checking, not
on entailment. Despite the definition and use of operations that in essence are similar to
ours (modifications of the set of possible worlds or of the accessibility relation), their work
is concerned mainly with modifications of a single model, not with that of sets of models
as we do, and hence it does not provide operations for changing action laws. Because of
that, their approach is not directly comparable to ours, since here we are interested in
entailment-based revision.

10. Concluding Remarks
In this work we have addressed the problem of changing an action domain description for
reasoning about actions, a problem not sufficiently investigated in the literature so far.
We have seen the intuitions behind such a kind of theory modification and have given a
semantics for action theory change in terms of distances between models that captures the
notion of minimal change. We have given algorithms to contract a formula from a theory
that terminate and that are correct with respect to our semantics (Corollary 6.1). We have
shown the importance that our modularity notion has in this result and in others.
We have also extended Varzinczaks investigations (2008) by defining a semantics for
action theory revision based on minimal modifications of models. For the corresponding
revision algorithms, the reader is referred to the work by Varzinczak (2009). One of our
ongoing research topics is on assessing our revision operators behavior with respect to
appropriate versions of the AGM postulates for revision (Alchourron et al., 1985) and its
links with the contraction counterpart.
With our algorithms we provide a set of tools to be used by the knowledge engineer in an
interactive and possibly iterative way to modify an action theory. These tools are guaranteed
233

fiVarzinczak

to perform minimal change when assisting the knowledge engineer in implementing her
desired modifications. They give her a set of options and it is up to the knowledge engineer
to decide which one is more in line with her intuitions.
Given that action theory change is not a single step operation, the knowledge engineer is
expected to make use of the contraction/revision operators to make a series of modifications
that eventually will give a fine-grained theory not entailing the contracted laws and entailing
the new learned laws about the domain.
For the sake of presentation, here we have abstracted from the frame and ramification
problems. However our definitions could have been stated in a formalism with a suitable solution to them, like Castilho et al.s approaches (1999, 2002). With regards to the
qualification problem, this is not ignored here: contracting wrong executability laws is an
approach towards its solution. Indeed, given the difficulty of stating all sufficient conditions
for executability of an action, the knowledge engineer writes down some of them and lets
the theory evolve via subsequent revisions.
A possible criticism to the approach here developed concerns the cautiousness of our
operator for contracting static laws: we prefer to lose some executability laws rather than
induce them and lose effect laws. This behavior could make our operators to be interpreted
as incoherent. We have pointed out nevertheless that this is in line with largely accepted
assumptions in the RAC community, and moreover we have shown the impossibility of a
non-cautious static law contraction operator that complies with all that and is coherent
with the other operators.
Indeed one of the purposes of the present work is to shed some light on the fundamental
differences between belief change in action domain descriptions and in logical theories in
general. Classical belief change cannot be fully transplanted to action theories, and here we
have shown why (cf. Sections 3.2, 4.2, 5.3 and 8.3).
In particular, looking at the postulates of classical belief change (or our versions thereof)
one sees that they are not enough to fully characterize operators for action theory change.
For that to be achieved the fundamental assumptions in reasoning about actions that we
have extensively used throughout this work should somehow be compiled into postulates
supplementing the classical ones. It is not immediately clear what these new postulates
would look like, but this is an interesting thread of investigation worth pursuing.
It might also be argued that our semantic operations do not respect the principle of
categorical matching, given that the input and output are different sorts of objects, viz. a
set of models and a set of sets of models (cf. Definitions 3.3, 3.7 and 3.10). It is easy to see,
however, that our semantic constructions could have been defined in such a way that each
M0  M
 corresponds to the result of one contraction operator. The choice for defining
the result of an operation as a set of possible outputs was driven by the definition of the
algorithms, where a theory (corresponding to a set of models) is given as input and the
output is a set of theories (hence corresponding to a set of set of models).
Although the semantic operators can be redefined to satisfy the principle of categorical matching, the same is not immediate about the algorithms (they would be nondeterministic). Therefore we preferred to keep a balance between the semantic and the
syntactic definitions so that we see more clearly their direct correspondence.
234

fiOn Action Theory Change

One of our contentions here is that sticking to modular theories (and hence to canonical models) is not a big deal: we can use existent algorithms in the literature (Herzig &
Varzinczak, 2007) to ensure that an action theory T is characterized by its canonical models.
We have seen that under modularity, our operators satisfy all the postulates for contraction: Modularity is one of the sufficient conditions for Success in Theorem 7.1. It is
also a sufficient condition in Theorem 7.2, and, as shown in Theorem 7.3, it is a sufficient
condition for Recovery. Finally it is also a sufficient condition for the Disjunctive Rule
to hold, and is shown to be preserved by the contraction operators (cf. last paragraph of
Section 7.2, proof in Appendix B). Preservation of modularity is an important result since
it means that it has to be checked/ensured at most once during the lifetime of the action
theory. All these results support the thesis that our modularity notion is fruitful.
By forcing formulas to be explicitly stated in their respective modules (and thus possibly
making them inferable in independently different ways), modularity intuitively could be
seen to diminish elaboration tolerance (McCarthy, 1998). For instance, when contracting a
Boolean formula  in a non-modular theory, it seems reasonable to expect not to change the
set of static laws S , while the theory being modular surely forces changing such a module. It
is not difficult, however, to conceive non-modular theories in which contraction of a formula
 may demand a change in S as well. As an example, suppose S = {1  2 } in an action
theory from whose dynamic part we (implicitly) infer 2 . In this case, contracting 1
while keeping 2 would necessarily ask for a change in S .
We point out nevertheless that in both cases (modular and non-modular) the extra work
in changing other modules stays in the mechanical level, i.e., in the algorithms that carry
out the modification, and does not augment in a significant way the amount of work the
knowledge engineer is expected to do.
Contrary to the trend in the belief change community, where the focus is either on belief
bases or belief sets (Hansson, 1999), the method here proposed is a hybrid one (Delgrande,
2009). On one hand, semantics plays a crucial role in the notion of minimal change here
studied. On the other hand, we deal only with domain descriptions in reasoning about
actions, which are sets of laws of specific types. On top of that, the modularity property (a
syntactical one) is fundamental to our main results.
Following those lines, another issue that drives our future research on the subject is how
to contract not only laws but any Kn -formula. As defined, the order of application of our
operators matter in the final result: if we contract  and then   [a] from a theory T,
the result may not be the same as contracting   [a] first and then removing . This
problem would not appear in a more general framework in which any formula could be
contracted: removing   (  [a]) should give the same result as (  [a])  . This
is the principle of syntax independence (Dalal, 1988).
Related to that is the question on how our revision definitions relate to our contraction
operators. What is known is that the Levi identity (1977), T ? = T 
  {}, in general
does not hold for action laws (effect and executability ones). The reason is that up to now
there is no contraction operator for  where  is an effect or an executability law. Indeed
this is the general contraction problem for non-classical logics: contraction of a general
formula (like  above) is still an open problem in the belief change area. Some insights in
this direction are given by our revision definitions, with which we make  false in every
possible world of a Kripke model.
235

fiVarzinczak

Definitions 3.1, 3.5 and 3.8 appear to be important for better understanding the problem
of contracting general formulas: basically the set of modifications to perform in a given
model in order to force it to falsify a general formula will comprise removal/addition of
transitions/worlds. The definition of a general revision/contraction method will then benefit
from our constructions.
Furthermore, given the well-known connection between multimodal logics and Description Logics (Baader, Calvanese, McGuinness, Nardi, & Patel-Schneider, 2003), we believe
that our definitions may also contribute to ontology evolution and debugging in some specific
families of DLs.

Acknowledgments
Parts of this work have been done during the authors stay at the Institut de Recherche en
Informatique de Toulouse (IRIT), France, and during his visit to the National ICT Australia
(NICTA), Sydney.
The author is grateful to the anonymous referees for their constructive and useful remarks, which helped improving the quality of the work. The paper has also benefited from
discussions with Andreas Herzig and Laurent Perrussel.
Special thanks to my colleagues at the Meraka Institute Arina Britz, Ken Halland,
Johannes Heidema and Tommie Meyer for their invaluable comments and suggestions on
earlier versions of this article.

Appendix A. Proof of Theorem 6.2
M

Let T be modular, and  be a law. For all M0  M
 such that |= T for every M  M,
M0

0
0
0
there is T 0  T 
 such that |= T for every M  M .

Before we give the proof of this theorem, we will need the following lemma (cf. the
Monotonicity Postulate in Section 7.2):
Lemma A.1 T |=
T 0.
K
n

Proof: Let T be an action theory, and let T 0  T 
 , for a given law . We are going to
analyze each case.
Let  be of the form   hai>, for some   Fml. Then T 0 is such that
T 0 = (T \ Xa )  {(i  (  A ))  hai> : i  hai>  Xa }
V
V
where   IP(S  ) and A = pi atm() pi  pi atm() pi , for some A  atm().
pi A

pi A
/

M

Let M = hW, Ri be such that |= T. It is enough to show that M is a model of the new
M
M
laws. For every (i  (  A ))  hai>, for every w  W, if |=w i  (  A ), then |=
.
w i
M

Because T |=K i  hai>, |= i  hai>, and then Ra (w) 6= .
n

M

Therefore we have that |= T 0 .
236

fiOn Action Theory Change

Let now  have the form   [a], for ,   Fml. Then T 0 is such that
(T \ Ea ) 
{(i  (  A ))  [a]i : i  [a]i  Ea } 
0

T 0 = {(i    A )  [a](i   ) : i  [a]i  Ea } 


`  L, forVsome L  Lit s.t.


(  A  `)  [a](  `) : S 6` ( 0  `L `)  , and `   0


or T 6`Kn (  A  `)  [a]`

where Ea =

S

,
1in (Ea )i ,

  IP(S  ), A =

V
pi atm()
pi A

pi 

V
pi atm()
pi A
/

pi , for some

A  atm(), and  0  IP(S  ).
M
Let M = hW, Ri be such that |= T. It is enough to show that M is a model of the
M
added laws. Given (i  (  A ))  [a]i , for every w  W, if |=w i  (  A ), then
M

M

M

|=w i . Because T |=K i  [a]i , |= i  [a]i , and then |= 0 i for every w0  W such that
w
n
(w, w0 )  Ra .
M
M
For (i    A )  [a](i   0 ), for every w  W, if |=w i    A , then again |= 0 i
w
for every w0  W such that (w, w0 )  Ra .
M
M
Now, given (  A  `)  [a](  `), for every w  W, if |=w   A  `, then |=
, and
w
M

M

M

then |=
. Since T |=
  [a], we have |=   [a], and then |= 0  for every w0  W
Kn
w
w
0
such that (w, w )  Ra .
M
Therefore |= T 0 .
Let  be a propositional . Then T 0 is such that
((T \ S )  S  ) \ Xa 
T 0 = {(i  )  hai> : i  hai>  Xa } 
{  [a]}
for some S   S 	 .
M
Let M = hW, Ri be such that |= T. It suffices to show that M satisfies the added laws.
Since we assume 	 behaves like a classical contraction operator, like e.g. Katsuno and
M
M
Mendelzons (1992), we have |=
S  S  , and then, because |= S , we have |= S  .
CPL
M

M

M

Now given (i  )  hai>, for every w  W, if |=w i  , then |=
i , and because
w

|= i  hai>, we have Ra (w) 6= .
M
Finally, for   [a], because |= , M trivially satisfies   [a].
M
Therefore |= T 0 .

2

Proof of Theorem 6.2
M

M0


0
0
Let M = {M : |= T}, and M0  M
 . We show that there is T  T  such that |= T
0
0
for every M  M .

237

fiVarzinczak

M0

M0

By definition, each M 0  M0 is such that either |= T or 6|= . Because T 
 6= , there
M0

M0

0
must be T 0  T 
 . If |= T, by Lemma A.1 |= T and we are done. Let us then suppose
M0

that 6|= . We analyze each case.
Let  have the form   hai> for some   Fml. Then M 0 = hW0 , R0 i, where W0 = W,
M

0
 and (w, w0 )  Ra }, for some M  M.
R0 = R \ R
a , with Ra = {(w, w ) : |=
w
M0

M0

Let u  W0 be such that 6|=
  hai>, i.e., |=
 and R0a (u) = .
u
u
V
0
Because u  , there must be v  base(, WV
) such that v  u. Let  = `v `. Clearly
 is a prime implicant of S  . Let also A = `u\v `, and consider
T 0 = (T \ Xa )  {(i  (  A ))  hai> : i  hai>  Xa }
(Clearly, T 0 is a theory produced by Algorithm 1.)
It is enough to show that M 0 is a model of the new added laws. Given (i (A )) 
M

M0

M0

i , from what it follows |=w i .
i  (  A ), then |=
hai>  T 0 , for every w  W0 , if |=
w
w
M

Because |= i  hai>, there is w0  W such that w0  Ra (w). We need to show that
M
M
0
0
(w, w0 )  R0a . If 6|=
, then R
, either w = u, and then from
a = , and (w, w )  Ra . If |=
w
w
M0

M0

|=u   A we conclude |=u (i  (  A ))  hai>, or w 6= u and then we must have



(w, w0 )  R0a , otherwise there is S
a  Ra such that R(R \ Sa )  R(R \ Ra ), and then
M 00

00
0
M 00 = hW0 , R \ S
a i is such that 6|=   hai> and M M M , a contradiction because
M0

M0

M 0 is minimal with respect to M . Thus (w, w0 )  R0a , and then |=
hai>. Hence |= T 0 .
w
Now let  be of the form   [a], for ,  both Boolean. Then M 0 = hW0 , R0 i, where
W0 = W, R0 = R  R,
, with
a
R,
= {(w, w0 ) : w0  RelTarget(w,   [a], M , M)}
a
for some M = hW, Ri  M.
M0

M0

  [a]. Then there is u0  W0 such that (u, u0 )  R0a and
Let u  W0 be such that 6|=
u

6|=0 . Because u  , there is v  base(, W0 ) such that v  u, and as u0  , there must
u
V
V
V
be v 0  base(, W0 ) such that v 0  u0 . Let  = `v `, A = `u\v `, and  0 = `v0 `.
Clearly  (resp.  0 ) is a prime implicant of S   (resp. S  ).
S
Now let Ea = 1in (Ea, )i and let the theory
(T \ Ea ) 
{(i  (  A ))  [a]i : i  [a]i  Ea } 
0

T 0 = {(i    A )  [a](i   ) : i  [a]i  Ea } 


`  L, forVsome L  Lit s.t.


(  A  `)  [a](  `) : S 6` ( 0  `L `)  , and `   0


or T 6`Kn (  A  `)  [a]`

(Clearly, T 0 is a theory produced by Algorithm 2.)
238

fiOn Action Theory Change

In order to show that M 0 is a model of T 0 , it is enough to show that it is a model of the
M0
added laws. Given (i (A ))  [a]i  T 0 , for every w  W0 , if |=w i (A ), then
M0

M

M

M

|=
i , and then |=w i . Because |= i  [a]i , |= 0 i for all w0  W such that (w, w0 )  Ra .
w
M

w

= , and then R0a (w) = Ra (w).
We need to show that R0a (w) = Ra (w). If 6|=w , then R,
a
M

M0

M0

If |=
, then either w = u, and from |=u   A we conclude |=
(i  (  A ))  [a]i ,
w
u
,
or w 6= u, and then we must have Ra
= , otherwise there would be S,
 R,
such
a
a
,
,
0
,
00
that R(R  Sa )  R(R  Ra ), and then M = hW , R  Sa i would be such that
M 00

6|=   [a] and M 00 M M 0 , a contradiction since M 0 is minimal with respect to M .
M0

Hence R0a (w) = Ra (w), and |= 0 i for all w0 such that (w, w0 )  R0a .
w

M0

M0

Now, given (i    A )  [a](i   0 ), for every w  W0 , if |=w i    A , then
M

M

M

|=w i , and then |=
i . Because, |= i  [a]i , we have |= 0 i for all w0  W such that
w
w

M0

(w, w0 )  Ra , and then |= 0 i for every w0  W0 such that (w, w0 )  R0a \ Ra, . Now, given
w

M0

, |= 0  0 , and the result follows.
(w, w0 )  R,
a
w

M0

M0

Now, for each (  A  `)  [a](  `), for every w  W0 , if |=
  A  `, then
w
M

M

M

|=w , and then |=
. Because |=   [a], we have |= 0  for every w0  W such that
w
(w, w0 )

w

M0

 Ra , and then |= 0  for all
w

M0

w0

0

 W such that (w, w0 )  R0a \ R,
. It remains to
a

show that |= 0 ` for every w0  W0 such that (w, w0 )  R,
. Since M 0 is minimal, it is
a
w

M0

M0

enough to show that |=0 ` for every `  Lit such that |=
  A  `. If `   0 , the result
u
u

M0

follows. Otherwise, suppose 6|=0 `. Then
u

 either `   0 , then  0 and ` are unsatisfiable, and in this case Algorithm 2 has not
put the law (  A  `)  [a](  `) in T 0 , a contradiction;
 or `  u0 \ v 0 . In this case, there is a valuation u00 = (u0 \ {`})  {`} such that
0
00
0
u00 6 . We
: `i  u00 } such that
iV
V must have u  W , otherwise there will be L = {`
0
0
T |=K (  `i L0 `i )  , and, because T is modular, S |=CPL (  `i L0 `i )  , and
n
then Algorithm 2 has not put the law (  A  `)  [a](  `) in T 0 , a contradiction.
Then u00  W0 , and moreover u00 
/ R,
(u), otherwise M 0 is not minimal. As
a
,
u00 \ u  u0 \ u, the only reason why u00 
/ Ra (u) is that there is `0  u  u00 such that
Mi V
0
|= `j u `j  [a]` for every Mi  M if and only if `0 
/ v0 for any v0  base(, W 0 )
M V
such that v0  u00 . Clearly `0 = `, and because ` 
/  0 , we have |= i `j u `j  [a]`
for every Mi  M. Then T |=
(  A  `)  [a]`, and then Algorithm 2 has not
Kn
put the law (  A  `)  [a](  `) in T 0 , a contradiction.
M0

Hence we have |= 0   ` for every w0  W0 such that (w, w0 )  R0a .
w

M0

Putting the above results together, we get |= T 0 .
Let now  be some propositional . Then M 0 = hW0 , R0 i, where W  W0 , R0 = R, is
minimal with respect to M , i.e., W0 is a minimal superset of W such that there is u  W0
239

fiVarzinczak

with u 6 . Because we have assumed the syntactical classical contraction operator is
sound and complete with respect to its semantics and is moreover minimal, then there must
M0
be S   S 	  such that W0 = val(S  ). Therefore |= S  .
Because R0 = R, every effect law of T remains true in M 0 .
Now, let
((T \ S )  S  ) \ Xa 
T 0 = {(i  )  hai> : i  hai>  Xa } 
{  [a]}
(Clearly, T 0 is a theory produced by Algorithm 3.)
M0

For every (i  )  hai>  T 0 and every w  W0 , if |=
i  , then Ra (w) 6= ,
w
M0

M

i  hai>. Given   [a], for every w  W0 , if |=
, then w = u, and
because |=
w
w
Ra (w) = .
M0

2

Putting all these results together, we have |= T 0 .

Appendix B. Proof of Theorem 6.3
M0


0
0
0
Let T be modular,  a law, and T 0  T 
 . For all M such that |= T , there is M  M
M

such that M 0  M0 and |= T for every M  M.
In order to prove this result, first we need to show four important lemmas.
Lemma B.1 Let  be a law. If T is modular, then every T 0  T 
 is modular.
0
Proof: Let  be nonclassical, and suppose there is T 0  T 
 such that T is not modular.
0
0
0
0
0
0
Then there is some   Fml such that T |=K  and S 6|=
 , where S is the set of static
CPL
n
0
0
laws in T . By Lemma A.1, T |=
T , and then we have T |=
0 . Because  is nonclassical,
Kn
Kn
0
S = S . Thus S 6|=CPL 0 , and therefore T is not modular.

Let now  be some   Fml. Then
((T \ S )  S  ) \ Xa 
T 0 = {(i  )  hai> : i  hai>  Xa } 
{  [a]}
for some S   S 	 .
Assume that T is modular, and let 0  Fml be such that T 0 |=
0 and S  6|=
0 .
Kn
CPL
As S  6|=
0 , there is v  val(S  ) such that v 6 0 . If v  val(S ), then S 6|=CPL 0 , and
CPL
as T is modular, T 6|=K 0 . By Lemma A.1, T |=K T 0 , and we have T 0 6|=K 0 , a contradiction.
n
n
n
Hence v 
/ val(S ). Moreover, we must have v 6 , otherwise 	 has not worked as expected.
M
Let M = hW, Ri be such that |= T 0 . (We extend M to another model of T 0 .) Let
M 0 = hW0 , R0 i be such that W0 = W  {v} and R0 = R. To show that M 0 is a model
M0

of T 0 , it suffices to show that v satisfies every law in T 0 . As v  val(S  ), |=
S  . Given
v
240

fiOn Action Theory Change

M0

  [a]  T 0 , as v 6  and R0a (v) = , |=v   [a]. Now, for every i  [a]i  T 0 ,
M0

M0

if |=v i , then we trivially have |=0 i for every v0 such that (v, v0 )  R0a . Finally, given
v

M0

(i  )  hai>  T 0 , as v 6 , the formula trivially holds in v. Hence |= T 0 , and because
M0

there is v  W0 such that 6|=
0 , we have T 0 6|=K 0 , a contradiction. Hence for all 0  Fml
v
n
0 , and then T 0 is modular.
such that T 0 |=K 0 , S  |=

2
CPL
n

Lemma B.2 If Mcan = hWcan , Rcan i is a model of T, then for every M = hW, Ri such
M
that |= T there is a minimal (with respect to set inclusion) extension R0  Rcan \ R such
that M 0 = hval(S ), R  R0 i is a model of T.
M

Proof: Let Mcan = hWcan , Rcan i be a model of T, and let M = hW, Ri be such that |= T.
M0

Consider M 0 = hval(S ), Ri. If |= T, we have R0 =   Rcan \ R that is minimal. Suppose
M0

M0

then 6|= T. We extend M 0 to a model of T that is a minimal extension of M . As 6|= T,
M0

M0

there is v  val(S ) \ W such that 6|=
T. Then there is   T such that 6|=v . If  is
v
some   Fml, as v  Wcan , Mcan is not a model of T. If  is of the form   [a], for
,   Fml, there is v0  val(S ) such that (v, v0 )  Ra and v0 6 , a contradiction since
M0

Ra (v) = . Let now  have the form   hai> for some   Fml. Then |=
. As v  Wcan ,
v
Mcan

Mcan

if 6|=v   hai>, then 6|= T. Hence, Rcana (v) 6= . Thus taking any (v, v0 )  Rcana gives
us a minimal R0 = {(v, v0 )} such that M 00 = hval(S ), R  R0 i is a model of T.
2
Lemma B.3 Let T be modular, and  be a law. Then T |=
 if and only if every M 0 =
K
0

hW,Ri

hval(S ), R i such that |=

n

0

T and R  R is a model of .

Proof:
M
M
(): Straightforward, since T |=
 implies |=  for every M such that |= T, in particular
Kn
for those which are extensions of some model of T.
M

M

(): Suppose T 6|=
. Then there is M = hW, Ri such that |= T and 6|= . As T is modular,
Kn
the canonical frame Mcan = hWcan , Rcan i of T is a model of T. Then by Lemma B.2 there is
a minimal extension R0 of R with respect to Rcan such that M 0 = hval(S ), R  R0 i is a model
M
M
of T. Because 6|= , there is w  W such that 6|=w . If  is some propositional   Fml or
M0

an effect law, any extension M 0 of M is such that 6|=w . If  is of the form   hai>,
M

then |=
 and Ra (w) = . As any extension of M is such that (u, v)  R0 if and only if
w
u  val(S ) \ W, only worlds other than those in W get a new departing transition. Thus
M0

2

(R  R0 )a (w) = , and then 6|=w .

0
0
0
Lemma B.4 Let T be modular,  a law, and T 0  T 
 . If M = hval(S ), R i is a model
M

of T 0 , then there is M = {M : M = hval(S ), Ri and |= T} such that M 0  M0 for some
M0  M
.
241

fiVarzinczak

M0

M0

Proof: Let M 0 = hval(S 0 ), R0 i be such that |= T 0 . If |= T, the result follows. Let us
M0

suppose then 6|= T. We analyze each case.
Let  be of the form   hai>, for some   Fml. Let M = {M : M = hval(S ), Ri}.
Since by hypothesis T is modular, from Lemmas B.2 and B.3 it follows that M is non-empty
and contains only models of T.
Suppose M 0 is not a minimal model of T 0 , i.e., there is M 00 such that M 00 M M 0 for
some M  M. Then M 0 and M 00 differ only in the executability
of a inVa given -world,
V
viz. a   A -context, for some   IP(S  ) and A = pi atm() pi  pi atm() pi such
pi A

M0

M 00

pi A
/

that A  atm(). Because 6|= (  A )  hai>, we must have |= (  A )  hai> and
M 00

then |= T. Hence M 0 is minimal with respect to M .
When contracting executability laws, S 0 = S . Hence taking the right R and a minimal
M
0


0
R
 and (w, w0 ) 
a such that M = hval(S ), Ri and R = R \ Ra , for some Ra  {(w, w ) :|=
w

Ra }, we construct M0 = M  {M 0 }  Mhai> .
Let  now be of the form   [a], for ,   Fml. Let M = {M : M = hval(S ), Ri}.
Since by hypothesis T is modular, from Lemmas B.2 and B.3 it follows that M is non-empty
and contains only models of T.
We claim that M 0 has only oneVtransition linking
V a -world, viz. a context i    A
for some   IP(S  ) and A = pi atm() pi  pi atm() pi , such that A  atm(), to a
pi A

pi A
/

 0 -world, where  0  IP(S  ). The proof is as follows: given `  Lit such that ` holds
in this i    A -world
 if (  A  `)  [a](  `) 
/ T 0 , then ` 
/  0 and T |=
(  A  `)  [a]`. Then
Kn
this world has only `-successors.
 if (  A  `)  [a](  `)  T 0 , then every  0 -successor is an `-world.
By successively applying this reasoning to each ` that holds in this i    A -world, we
will end up with only one  0 -successor.
M 00
Suppose now that M 0 is not a minimal model of T 0 , i.e., there is M 00 such that |= T 0
and M 00 M M 0 for some M  M. Then M 0 and M 00 differ only in the effects on
that i    A -world: M 00 has no transition linking it to a  0 -world. Then we have
M 00
M 00
|= (i    A )  [a]i , and then |= T. Therefore M 0 is a minimal model of T 0 with
respect to M .
When contracting effect laws, S 0 = S . Thus taking the right R and a minimal R,
a
M
0
,
,
0
such that M = hval(S ), Ri and R = R  Ra , for some Ra  {(w, w ) :|=
 and w0 
w

RelTarget(w,   [a], M , M)}, we construct M0 = M  {M 0 }  M[a] .
Let now  be  for some   Fml. Since T is modular, by Lemmas B.2 and B.3 there
M
is M = hval(S ), Ri such that |= T. We know val(S )  val(S  ). Because   [a]  T 0 ,
R0a (v) =  for every -world v added in M 0 . Hence, because 	 is minimal, taking M =
{M } gives us the result.
2
242

fiOn Action Theory Change

Proof of Theorem 6.3
From the hypothesis that T is modular and Lemma B.1, it follows that T 0 is modular,
too. Then M 0 = hval(S 0 ), Ri is a model of T 0 , by Lemma B.3. From this and Lemma B.4
the result follows.
2

References
Alchourron, C., Gardenfors, P., & Makinson, D. (1985). On the logic of theory change:
Partial meet contraction and revision functions. Journal of Symbolic Logic, 50, 510
530.
Baader, F., Calvanese, D., McGuinness, D., Nardi, D., & Patel-Schneider, P. (Eds.). (2003).
Description Logic Handbook. Cambridge University Press.
Baral, C., & Lobo, J. (1997). Defeasible specifications in action theories. In Pollack, M.
(Ed.), Proceedings of the 15th International Joint Conference on Artificial Intelligence
(IJCAI), pp. 14411446. Morgan Kaufmann Publishers.
Booth, R., Meyer, T., & Varzinczak, I. (2009). Next steps in propositional Horn contraction. In Boutilier, C. (Ed.), Proceedings of the 21st International Joint Conference on
Artificial Intelligence (IJCAI), pp. 702707. AAAI Press.
Burger, I., & Heidema, J. (2002). Merging inference and conjecture by information. Synthese, 131 (2), 223258.
Castilho, M., Gasquet, O., & Herzig, A. (1999). Formalizing action and change in modal
logic I: the frame problem. Journal of Logic and Computation, 9 (5), 701735.
Castilho, M., Herzig, A., & Varzinczak, I. (2002). It depends on the context! A decidable
logic of actions and plans based on a ternary dependence relation. In 9th International
Workshop on Nonmonotonic Reasoning (NMR).
Cholvy, L. (1999). Checking regulation consistency by using SOL-resolution. In Proceedings
of the 7th International Conference on AI and Law, pp. 7379.
Dalal, M. (1988). Investigations into a theory of knowledge base revision: preliminary report.
In Smith, R., & Mitchell, T. (Eds.), Proceedings of the 7th National Conference on
Artificial Intelligence (AAAI), pp. 475479. Morgan Kaufmann Publishers.
De Giacomo, G., & Lenzerini, M. (1995). PDL-based framework for reasoning about actions. In Gori, M., & Soda, G. (Eds.), Proceedings of the 4th Congress of the Italian Association for Artificial Intelligence (IA*AI), No. 992 in LNAI, pp. 103114.
Springer-Verlag.
Delgrande, J. (2009). Personal communication. Commonsense09, Toronto.
Demolombe, R., Herzig, A., & Varzinczak, I. (2003). Regression in modal logic. Journal of
Applied Non-Classical Logic, 13 (2), 165185.
Eiter, T., Erdem, E., Fink, M., & Senko, J. (2005). Updating action domain descriptions.
In Kaelbling, L., & Saffiotti, A. (Eds.), Proceedings of the 19th International Joint
Conference on Artificial Intelligence (IJCAI), pp. 418423. Morgan Kaufmann Publishers.
243

fiVarzinczak

Finger, J. (1987). Exploiting constraints in design synthesis. Ph.D. thesis, Stanford University.
Flouris, G., Plexousakis, D., & Antoniou, G. (2004). Generalizing the AGM postulates. In
10th International Workshop on Nonmonotonic Reasoning (NMR).
Fuhrmann, A. (1989). On the modal logic of theory change. In The Logic of Theory Change,
pp. 259281.
Gardenfors, P. (1988). Knowledge in Flux: Modeling the Dynamics of Epistemic States.
MIT Press.
Gelfond, M., & Lifschitz, V. (1993). Representing action and change by logic programs.
Journal of Logic Programming, 17 (2/3&4), 301321.
Giunchiglia, E., Kartha, G., & Lifschitz, V. (1997). Representing action: indeterminacy and
ramifications. Artificial Intelligence, 95 (2), 409438.
Hamming, R. (1950). Error detecting and error correcting codes. Bell System Technical
Journal, 26 (2), 147160.
Hansson, S. (1994). Kernel contraction. Journal of Symbolic Logic, 59 (3), 845859.
Hansson, S. (1999). A Textbook of Belief Dynamics: Theory Change and Database Updating.
Kluwer Academic Publishers.
Harel, D., Tiuryn, J., & Kozen, D. (2000). Dynamic Logic. MIT Press.
Herzig, A., Perrussel, L., & Varzinczak, I. (2006). Elaborating domain descriptions. In
Brewka, G., Coradeschi, S., Perini, A., & Traverso, P. (Eds.), Proceedings of the 17th
European Conference on Artificial Intelligence (ECAI), pp. 397401. IOS Press.
Herzig, A., & Rifi, O. (1999). Propositional belief base update and minimal change. Artificial
Intelligence, 115 (1), 107138.
Herzig, A., & Varzinczak, I. (2004). Domain descriptions should be modular. In Lopez de
Mantaras, R., & Saitta, L. (Eds.), Proceedings of the 16th European Conference on
Artificial Intelligence (ECAI), pp. 348352. IOS Press.
Herzig, A., & Varzinczak, I. (2005a). Cohesion, coupling and the meta-theory of actions.
In Kaelbling, L., & Saffiotti, A. (Eds.), Proceedings of the 19th International Joint
Conference on Artificial Intelligence (IJCAI), pp. 442447. Morgan Kaufmann Publishers.
Herzig, A., & Varzinczak, I. (2005b). On the modularity of theories. In Schmidt, R., PrattHartmann, I., Reynolds, M., & Wansing, H. (Eds.), Advances in Modal Logic, Vol. 5,
pp. 93109. Kings College Publications.
Herzig, A., & Varzinczak, I. (2006). A modularity approach for a fragment of ALC. In
Fisher, M., van der Hoek, W., Konev, B., & Lisitsa, A. (Eds.), Proceedings of the 10th
European Conference on Logics in Artificial Intelligence (JELIA), No. 4160 in LNAI,
pp. 216228. Springer-Verlag.
Herzig, A., & Varzinczak, I. (2007). Metatheory of actions: beyond consistency. Artificial
Intelligence, 171, 951984.
244

fiOn Action Theory Change

Jin, Y., & Thielscher, M. (2005). Iterated belief revision, revised. In Kaelbling, L., & Saffiotti, A. (Eds.), Proceedings of the 19th International Joint Conference on Artificial
Intelligence (IJCAI), pp. 478483. Morgan Kaufmann Publishers.
Katsuno, H., & Mendelzon, A. (1992). On the difference between updating a knowledge
base and revising it. In Gardenfors, P. (Ed.), Belief revision, pp. 183203. Cambridge
University Press.
Kracht, M., & Wolter, F. (1991). Properties of independently axiomatizable bimodal logics.
Journal of Symbolic Logic, 56 (4), 14691485.
Levi, I. (1977). Subjunctives, dispositions and chances. Synthese, 34, 423455.
Li, R., & Pereira, L. (1996). What is believed is what is explained. In Shrobe, H., & Senator, T. (Eds.), Proceedings of the 13th National Conference on Artificial Intelligence
(AAAI), pp. 550555. AAAI Press/MIT Press.
Liberatore, P. (2000). A framework for belief update. In Proceedings of the 7th European
Conference on Logics in Artificial Intelligence (JELIA), pp. 361375.
Makinson, D. (2007). Friendliness and sympathy in logic. In Beziau, J.-Y. (Ed.), Logica
Universalis, Vol. 2, pp. 195224. Springer-Verlag.
Marquis, P. (2000). Consequence finding algorithms. In Gabbay, D., & Smets, P. (Eds.),
Handbook on Defeasible Reasoning and Uncertainty Management Systems, Vol. 5:
Algorithms for Uncertainty and Defeasible Reasoning, edited by J. Kohlas and S.
Moral, chap. 2, pp. 41145. Kluwer Academic Publishers.
McCarthy, J. (1977). Epistemological problems of artificial intelligence. In Sridharan, N.
(Ed.), Proceedings of the 5th International Joint Conference on Artificial Intelligence
(IJCAI), pp. 10381044. Morgan Kaufmann Publishers.
McCarthy, J. (1998). Elaboration tolerance. In Proceedings of the 4th International Symposium on Logical Formalizations of Commonsense Reasoning.
McCarthy, J., & Hayes, P. (1969). Some philosophical problems from the standpoint of
artificial intelligence. In Meltzer, B., & Mitchie, D. (Eds.), Machine Intelligence,
Vol. 4, pp. 463502. Edinburgh University Press.
Nebel, B. (1989). A knowledge level analysis of belief revision. In Brachman, R., Levesque,
H., & Reiter, R. (Eds.), Proceedings of the 1st International Conference on Principles
of Knowledge Representation and Reasoning (KR), pp. 301311. Morgan Kaufmann
Publishers.
Parikh, R. (1999). Beliefs, belief revision, and splitting languages. In Moss, L. (Ed.),
Logic, Language and Computation, No. 96 in CSLI Lecture Notes, pp. 266278. CSLI
Publications.
Popkorn, S. (1994). First Steps in Modal Logic. Cambridge University Press.
Quine, W. (1952). The problem of simplifying truth functions. American Mathematical
Monthly, 59, 521531.
Quine, W. (1962). Paradox. Scientific American, 1, 8496.
245

fiVarzinczak

Reiter, R. (2001). Knowledge in Action: Logical Foundations for Specifying and Implementing Dynamical Systems. MIT Press.
Schlechta, K. (2004). Coherent Systems. Studies in Logic and Practical Reasoning 2.
Elsevier.
Shanahan, M. (1997). Solving the frame problem: a mathematical investigation of the common sense law of inertia. MIT Press.
Shapiro, S., Lesperance, Y., & Levesque, H. (2005). Goal change. In Kaelbling, L., & Saffiotti, A. (Eds.), Proceedings of the 19th International Joint Conference on Artificial
Intelligence (IJCAI), pp. 582588. Morgan Kaufmann Publishers.
Shapiro, S., Pagnucco, M., Lesperance, Y., & Levesque, H. (2000). Iterated belief change in
the situation calculus. In Cohn, T., Giunchiglia, F., & Selman, B. (Eds.), Proceedings
of the 7th International Conference on Principles of Knowledge Representation and
Reasoning (KR), pp. 527538. Morgan Kaufmann Publishers.
Thielscher, M. (1997). Ramification and causality. Artificial Intelligence, 89 (12), 317364.
Thielscher, M. (2010). A unifying action calculus. To appear in Artificial Intelligence.
Varzinczak, I. (2006). What is a good domain description? Evaluating and revising action
theories in dynamic logic. Ph.D. thesis, Universite Paul Sabatier, Toulouse.
Varzinczak, I. (2008). Action theory contraction and minimal change. In Lang, J., &
Brewka, G. (Eds.), Proceedings of the 11th International Conference on Principles of
Knowledge Representation and Reasoning (KR), pp. 651661. AAAI Press.
Varzinczak, I. (2009). On the revision of action laws: an algorithmic approach. In IJCAI
Workshop on Nonmonotonic Reasoning, Action and Change (NRAC).
Winslett, M.-A. (1988). Reasoning about action using a possible models approach. In Smith,
R., & Mitchell, T. (Eds.), Proceedings of the 7th National Conference on Artificial
Intelligence (AAAI), pp. 8993. Morgan Kaufmann Publishers.
Zhang, D., Chopra, S., & Foo, N. (2002). Consistency of action descriptions. In Ishizuka,
M., & Sattar, A. (Eds.), Proceedings of the 7th Pacific Rim International Conference
on Artificial Intelligence, No. 2417 in LNCS, pp. 7079. Springer-Verlag.
Zhang, D., & Foo, N. (2001). EPDL: A logic for causal reasoning. In Nebel, B. (Ed.), Proceedings of the 17th International Joint Conference on Artificial Intelligence (IJCAI),
pp. 131138. Morgan Kaufmann Publishers.
Zhang, Y., & Ding, Y. (2008). CTL model update for system modifications. Journal of
Artificial Intelligence Research, 31, 113155.

246

fi