Journal of Artificial Intelligence Research 32 (2008) 663-704

Submitted 03/08; published 07/08

Online Planning Algorithms for POMDPs
Stephane Ross
Joelle Pineau

stephane.ross@mail.mcgill.ca
jpineau@cs.mcgill.ca

School of Computer Science
McGill University, Montreal, Canada, H3A 2A7

Sebastien Paquet
Brahim Chaib-draa

spaquet@damas.ift.ulaval.ca
chaib@damas.ift.ulaval.ca

Department of Computer Science and Software Engineering
Laval University, Quebec, Canada, G1K 7P4

Abstract
Partially Observable Markov Decision Processes (POMDPs) provide a rich framework
for sequential decision-making under uncertainty in stochastic domains. However, solving
a POMDP is often intractable except for small problems due to their complexity. Here,
we focus on online approaches that alleviate the computational complexity by computing
good local policies at each decision step during the execution. Online algorithms generally consist of a lookahead search to find the best action to execute at each time step in
an environment. Our objectives here are to survey the various existing online POMDP
methods, analyze their properties and discuss their advantages and disadvantages; and to
thoroughly evaluate these online approaches in different environments under various metrics (return, error bound reduction, lower bound improvement). Our experimental results
indicate that state-of-the-art online heuristic search methods can handle large POMDP
domains efficiently.

1. Introduction
The Partially Observable Markov Decision Process (POMDP) is a general model for sequential decision problems in partially observable environments. Many planning and control problems can be modeled as POMDPs, but very few can be solved exactly because of
their computational complexity: finite-horizon POMDPs are PSPACE-complete (Papadimitriou & Tsitsiklis, 1987) and infinite-horizon POMDPs are undecidable (Madani, Hanks,
& Condon, 1999).
In the last few years, POMDPs have generated significant interest in the AI community and many approximation algorithms have been developed (Hauskrecht, 2000; Pineau,
Gordon, & Thrun, 2003; Braziunas & Boutilier, 2004; Poupart, 2005; Smith & Simmons,
2005; Spaan & Vlassis, 2005). All these methods are offline algorithms, meaning that they
specify, prior to the execution, the best action to execute for all possible situations. While
these approximate algorithms can achieve very good performance, they often take significant time (e.g. more than an hour) to solve large problems, where there are too many
possible situations to enumerate (let alone plan for). Furthermore, small changes in the
environments dynamics require recomputing the full policy, which may take hours or days.
c
2008
AI Access Foundation. All rights reserved.

fiRoss, Pineau, Paquet, & Chaib-draa

On the other hand, online approaches (Satia & Lave, 1973; Washington, 1997; Barto,
Bradtke, & Singhe, 1995; Paquet, Tobin, & Chaib-draa, 2005; McAllester & Singh, 1999;
Bertsekas & Castanon, 1999; Shani, Brafman, & Shimony, 2005) try to circumvent the complexity of computing a policy by planning online only for the current information state. Online algorithms are sometimes also called agent-centered search algorithms (Koenig, 2001).
Whereas an offline search would compute an exponentially large contingency plan considering all possible happenings, an online search only considers the current situation and a small
horizon of contingency plans. Moreover, some of these approaches can handle environment
changes without requiring more computation, which allows online approaches to be applicable in many contexts where offline approaches are not applicable, for instance, when the
task to accomplish, as defined by the reward function, changes regularly in the environment.
One drawback of online planning is that it generally needs to meet real-time constraints,
thus greatly reducing the available planning time, compared to offline approaches.
Recent developments in online POMDP search algorithms (Paquet, Chaib-draa, & Ross,
2006; Ross & Chaib-draa, 2007; Ross, Pineau, & Chaib-draa, 2008) suggest that combining
approximate offline and online solving approaches may be the most efficient way to tackle
large POMDPs. In fact, we can generally compute a very rough policy offline using existing
offline value iteration algorithms, and then use this approximation as a heuristic function
to guide the online search algorithm. This combination enables online search algorithms
to plan on shorter horizons, thereby respecting online real-time constraints and retaining a
good precision. By doing an exact online search over a fixed horizon, we can guarantee a
reduction in the error of the approximate offline value function. The overall time (offline
and online) required to obtain a good policy can be dramatically reduced by combining
both approaches.
The main purpose of this paper is to draw the attention of the AI community to online
methods as a viable alternative for solving large POMDP problems. In support of this, we
first survey the various existing online approaches that have been applied to POMDPs, and
discuss their strengths and drawbacks. We present various combinations of online algorithms
with various existing offline algorithms, such as QMDP (Littman, Cassandra, & Kaelbling,
1995), FIB (Hauskrecht, 2000), Blind (Hauskrecht, 2000; Smith & Simmons, 2005) and
PBVI (Pineau et al., 2003). We then compare empirically different online approaches in
two large POMDP domains according to different metrics (average discounted return, error
bound reduction, lower bound improvement). We also evaluate how the available online
planning time and offline planning time affect the performance of different algorithms. The
results of our experiments show that many state-of-the-art online heuristic search methods
are tractable in large state and observation spaces, and achieve the solution quality of stateof-the-art offline approaches at a fraction of the computational cost. The best methods
achieve this by focusing the search on the most relevant future outcomes for the current
decision, e.g. those that are more likely and that have high uncertainty (error) on their longterm values, such as to minimize as quickly as possible an error bound on the performance of
the best action found. The tradeoff between solution quality and computing time offered by
the combinations of online and offline approaches is very attractive for tackling increasingly
large domains.
664

fiOnline Planning Algorithms for POMDPs

2. POMDP Model
Partially observable Markov decision processes (POMDPs) provide a general framework
for acting in partially observable environments (Astrom, 1965; Smallwood & Sondik, 1973;
Monahan, 1982; Kaelbling, Littman, & Cassandra, 1998). A POMDP is a generalization
of the MDP model for planning under uncertainty, which gives the agent the ability to
effectively estimate the outcome of its actions even when it cannot exactly observe the state
of its environment.
Formally, a POMDP is represented as a tuple (S, A, T, R, Z, O) where:
 S is the set of all the environment states. A state is a description of the environment
at a specific moment and it should capture all information relevant to the agents
decision-making process.
 A is the set of all possible actions.
 T : S  A  S  [0, 1] is the transition function, where T (s, a, s0 ) = Pr(s0 |s, a)
represents the probability of ending in state s0 if the agent performs action a in state
s.
 R : S  A  R is the reward function, where R(s, a) is the reward obtained by
executing action a in state s.
 Z is the set of all possible observations.
 O : S  A  Z  [0, 1] is the observation function, where O(s0 , a, z) = Pr(z|a, s0 ) gives
the probability of observing z if action a is performed and the resulting state is s0 .
We assume in this paper that S, A and Z are all finite and that R is bounded.
A key aspect of the POMDP model is the assumption that the states are not directly
observable. Instead, at any given time, the agent only has access to some observation
z  Z that gives incomplete information about the current state. Since the states are not
observable, the agent cannot choose its actions based on the states. It has to consider
a complete history of its past actions and observations to choose its current action. The
history at time t is defined as:
ht = {a0 , z1 , . . . , zt1 , at1 , zt }.

(1)

This explicit representation of the past is typically memory expensive. Instead, it is
possible to summarize all relevant information from previous actions and observations in a
probability distribution over the state space S, which is called a belief state (Astrom, 1965).
A belief state at time t is defined as the posterior probability distribution of being in each
state, given the complete history:
bt (s) = Pr(st = s|ht , b0 ).

(2)

The belief state bt is a sufficient statistic for the history ht (Smallwood & Sondik, 1973),
therefore the agent can choose its actions based on the current belief state bt instead of
all past actions and observations. Initially, the agent starts with an initial belief state b0 ,
665

fiRoss, Pineau, Paquet, & Chaib-draa

representing its knowledge about the starting state of the environment. Then, at any time
t, the belief state bt can be computed from the previous belief state bt1 , using the previous
action at1 and the current observation zt . This is done with the belief state update function
 (b, a, z), where bt =  (bt1 , at1 , zt ) is defined by the following equation:
bt (s0 ) =  (bt1 , at1 , zt )(s0 ) =

1
Pr(zt |bt1 , at1 )

O(s0 , at1 , zt )

X

T (s, at1 , s0 )bt1 (s), (3)

sS

where Pr(z|b, a), the probability of observing z after doing action a in belief b, acts as a
normalizing constant such that bt remains a probability distribution:
Pr(z|b, a) =

X

O(s0 , a, z)

s0 S

X

T (s, a, s0 )b(s).

(4)

sS

Now that the agent has a way of computing its belief, the next interesting question is
how to choose an action based on this belief state.
This action is determined by the agents policy , specifying the probability that the
agent will execute any action in any given belief state, i.e.  defines the agents strategy
for all possible situations it could encounter. This strategy should maximize the amount of
reward earned over a finite or infinite time horizon. In this article, we restrict our attention
to infinite-horizon POMDPs where the optimality criterion is to maximize the expected
sum of discounted rewards (also called the return or discounted return). More formally, the
optimal policy   can be defined by the following equation:
#
"
X
X X
(5)
bt (s)
R(s, a)(bt , a) |b0 ,
  = argmax E
t


t=0

sS

aA

where   [0, 1) is the discount factor and (bt , a) is the probability that action a will be
performed in belief bt , as prescribed by the policy .
The return obtained by following a specific policy , from a certain belief state b, is
defined by the value function equation V  :
"
#
X
X


V (b) =
(b, a) RB (b, a) + 
Pr(z|b, a)V ( (b, a, z)) .
(6)
aA

zZ

Here the function RB (b, a) specifies the immediate expected reward of executing action a
in belief b according to the reward function R:
RB (b, a) =

X

b(s)R(s, a).

(7)

sS

The sum over Z in Equation 6 is interpreted as the expected future return over the infinite
horizon of executing action a, assuming the policy  is followed afterwards.
Note that with the definitions of RB (b, a), Pr(z|b, a) and  (b, a, z), one can view a
POMDP as an MDP over belief states (called the belief MDP), where Pr(z|b, a) specifies
the probability of moving from b to  (b, a, z) by doing action a, and RB (b, a) is the immediate
reward obtained by doing action a in b.
666

fiOnline Planning Algorithms for POMDPs

The optimal policy   defined in Equation 5 represents the action-selection strategy
that will maximize equation V  (b0 ). Since there always exists a deterministic policy that
maximizes V  for any belief states (Sondik, 1978), we will generally only consider deterministic policies (i.e. those that assign a probability of 1 to a specific action in every belief
state).
The value function V  of the optimal policy   is the fixed point of Bellmans equation
(Bellman, 1957):
"
#
X
V  (b) = max RB (b, a) + 
Pr(z|b, a)V  ( (b, a, z)) .
(8)
aA

zZ

Another useful quantity is the value of executing a given action a in a belief state b,
which is denoted by the Q-value:
Q (b, a) = RB (b, a) + 

X

Pr(z|b, a)V  ( (b, a, z)).

(9)

zZ

Here the only difference with the definition of V  is that the max operator is omitted. Notice
that Q (b, a) determines the value of a by assuming that the optimal policy is followed at
every step after action a.
We now review different offline methods for solving POMDPs. These are used to guide
some of the online heuristic search methods discussed later, and in some cases they form
the basis of other online solutions.
2.1 Optimal Value Function Algorithm
One can solve optimally a POMDP for a specified finite horizon H by using the value
iteration algorithm (Sondik, 1971). This algorithm uses dynamic programming to compute
increasingly more accurate values for each belief state b. The value iteration algorithm
begins by evaluating the value of a belief state over the immediate horizon t = 1. Formally,
let V be a value function that takes a belief state as parameter and returns a numerical
value in R of this belief state. The initial value function is:
V1 (b) = max RB (b, a).
aA

(10)

The value function at horizon t is constructed from the value function at horizon t  1 by
using the following recursive equation:
"
#
X
Vt (b) = max RB (b, a) + 
Pr(z|b, a)Vt1 ( (b, a, z)) .
(11)
aA

zZ

The value function in Equation 11 defines the discounted sum of expected rewards that the
agent can receive in the next t time steps, for any belief state b. Therefore, the optimal
policy for a finite horizon t is simply to choose the action maximizing Vt (b):
"
#
X
Pr(z|b, a)Vt1 ( (b, a, z)) .
(12)
t (b) = argmax RB (b, a) + 
aA

zZ

667

fiRoss, Pineau, Paquet, & Chaib-draa

This last equation associates an action to a specific belief state, and therefore must be
computed for all possible belief states in order to define a full policy.
A key result by Smallwood and Sondik (1973) shows that the optimal value function for
a finite-horizon POMDP can be represented by hyperplanes, and is therefore convex and
piecewise linear. It means that the value function Vt at any horizon t can be represented by
a set of |S|-dimensional hyperplanes: t = {0 , 1 , . . . , m }. These hyperplanes are often
called -vectors. Each defines a linear value function over the belief state space associated
with some action a  A. The value of a belief state is the maximum value returned by one
of the -vectors for this belief state. The best action is the one associated with the -vector
that returned the best value:
X
(s)b(s).
(13)
Vt (b) = max
t

sS

A number of exact value function algorithms leveraging the piecewise-linear and convex
aspects of the value function have been proposed in the POMDP literature (Sondik, 1971;
Monahan, 1982; Littman, 1996; Cassandra, Littman, & Zhang, 1997; Zhang & Zhang,
2001). The problem with most of these exact approaches is that the number of -vectors
needed to represent the value function grows exponentially in the number of observations
at each iteration, i.e. the size of the set t is in O(|A||t1 ||Z| ). Since each new -vector
requires computation time in O(|Z||S|2 ), the resulting complexity of iteration t for exact
approaches is in O(|A||Z||S|2 |t1 ||Z| ). Most of the work on exact approaches has focused
on finding efficient ways to prune the set t , such as to effectively reduce computation.
2.2 Offline Approximate Algorithms
Due to the high complexity of exact solving approaches, many researchers have worked
on improving the applicability of POMDP approaches by developing approximate offline
approaches that can be applied to larger problems.
In the online methods we review below, approximate offline algorithms are often used
to compute lower and upper bounds on the optimal value function. These bounds are
leveraged to orient the search in promising directions, to apply branch-and-bound pruning
techniques, and to estimate the long term reward of belief states, as we will show in Section
3. However, we will generally want to use approximate methods which require very low
computational cost. We will be particularly interested in approximations that use the
underlying MDP1 to compute lower bounds (Blind policy) and upper bounds (MDP, QMDP,
FIB) on the exact value function. We also investigate the usefulness of using more precise
lower bounds provided by point-based methods. We now briefly review the offline methods
which will be featured in our empirical investigation. Some recent publications provide a
more comprehensive overview of offline approximate algorithms (Hauskrecht, 2000; Pineau,
Gordon, & Thrun, 2006).
2.2.1 Blind policy
A Blind policy (Hauskrecht, 2000; Smith & Simmons, 2005) is a policy where the same
action is always executed, regardless of the belief state. The value function of any Blind
1. The MDP defined by the (S, A, T, R) components of the POMDP model.

668

fiOnline Planning Algorithms for POMDPs

policy is obviously a lower bound on V  since it corresponds to the value of one specific
policy that the agent could execute in the environment. The resulting value function is
specified by a set of |A| -vectors, where each -vector specifies the long term expected
reward of following its corresponding blind policy. These -vectors can be computed using
a simple update rule:
at+1 (s) = R(s, a) + 

X

T (s, a, s0 )at (s),

(14)

s0 S

where a0 = minsS R(s, a)/(1). Once these -vectors are computed, we use Equation 13
to obtain the lower bound on the value of a belief state. The complexity of each iteration
is in O(|A||S|2 ), which is far less than exact methods. While this lower bound can be
computed very quickly, it is usually not very tight and thus not very informative.
2.2.2 Point-Based Algorithms
To obtain tighter lower bounds, one can use point-based methods (Lovejoy, 1991; Hauskrecht,
2000; Pineau et al., 2003). This popular approach approximates the value function by updating it only for some selected belief states. These point-based methods sample belief
states by simulating some random interactions of the agent with the POMDP environment,
and then update the value function and its gradient over those sampled beliefs. These approaches circumvent the complexity of exact approaches by sampling a small set of beliefs
and maintaining at most one -vector per sampled belief state. Let B represent the set of
sampled beliefs, then the set t of -vectors at time t is obtained as follows:
a (s)
a,z
t
bt
t

=
=
=
=

R(s, a),
P
a,z
0 , a, z)0 (s0 ), 0  
{a,z
 s0 S T (s, a, s0 )O(s
t1 },
i
i
i |i (s) = P
P
a
a
a
a,z
{b |b =  + zZ argmaxt
sS (s)b(s), a  A},
P
{b |b = argmaxb sS b(s)(s), b  B}.

(15)

t

To ensure that this gives a lower bound, 0 is initialized with a single -vector 0 (s) =

mins0 S,aA R(s0 ,a)
.
1

Since |t1 |  |B|, each iteration has a complexity in O(|A||Z||S||B|(|S|+
|B|)), which is polynomial time, compared to exponential time for exact approaches.
Different algorithms have been developed using the point-based approach: PBVI (Pineau
et al., 2003), Perseus (Spaan & Vlassis, 2005), HSVI (Smith & Simmons, 2004, 2005)
are some of the most recent methods. These methods differ slightly in how they choose
belief states and how they update the value function at these chosen belief states. The
nice property of these approaches is that one can tradeoff between the complexity of the
algorithm and the precision of the lower bound by increasing (or decreasing) the number of
sampled belief points.
2.2.3 MDP
The MDP approximation consists in approximating the value function V  of the POMDP
by the value function of its underlying MDP (Littman et al., 1995). This value function is
an upper bound on the value function of the POMDP and can be computed using Bellmans
equation:
669

fiRoss, Pineau, Paquet, & Chaib-draa

"

M DP
Vt+1
(s) = max R(s, a) + 
aA

X

#

T (s, a, s0 )VtM DP (s0 ) .

s0 S

(16)

P
The value V (b) of a belief state b is then computed as V (b) = sS V M DP (s)b(s). This
can be computed very quickly, as each iteration of Equation 16 can be done in O(|A||S|2 ).
2.2.4 QMDP
The QMDP approximation is a slight variation of the MDP approximation (Littman et al.,
1995). The main idea behind QMDP is to consider that all partial observability disappear
after a single step. It assumes the MDP solution is computed to generate VtM DP (Equation
16). Given this, we define:
DP
QM
t+1 (s, a) = R(s, a) + 

X

T (s, a, s0 )VtM DP (s0 ).

(17)

s0 S

This approximation defines an -vector for each action, and gives an upper bound on V 
that is tighter than V M DP ( i.e. VtQM DP (b)  VtM DP (b) for all belief b). Again, to
obtain the value of a belief state, we use Equation 13, where t will contain one -vector
DP (s, a) for each a  A.
a (s) = QM
t
2.2.5 FIB
The two upper bounds presented so far, QMDP and MDP, do not take into account the
partial observability of the environment. In particular, information-gathering actions that
may help identify the current state are always suboptimal according to these bounds. To
address this problem, Hauskrecht (2000) proposed a new method to compute upper bounds,
called the Fast Informed Bound (FIB), which is able to take into account (to some degree)
the partial observability of the environment. The -vector update process is described as
follows:
at+1 (s) = R(s, a) + 

X

zZ

a0

max

t t

X

O(s0 , a, z)T (s, a, s0 )t (s0 ).

(18)

s0 S

can be initialized to the -vectors found by QMDP at convergence, i.e.
The -vectors
a0 (s) = QM DP (s, a). FIB defines a single -vector for each action and the value of a belief
state is computed according to Equation 13. FIB provides a tighter upper bound than
QMDP ( i.e. VtF IB (b)  VtQM DP (b) for all b ). The complexity of the algorithm remains
acceptable, as each iteration requires O(|A|2 |S|2 |Z|) operations.

3. Online Algorithms for POMDPs
With offline approaches, the algorithm returns a policy defining which action to execute in
every possible belief state. Such approaches tend to be applicable only when dealing with
small to mid-size domains, since the policy construction step takes significant time. In large
POMDPs, using a very rough value function approximation (such as the ones presented
in Section 2.2) tends to substantially hinder the performance of the resulting approximate
670

fiOnline Planning Algorithms for POMDPs

Offline Approaches
Policy Construction

Policy Execution

Online Approaches

Small policy construction step between policy execution steps

Figure 1: Comparison between offline and online approaches.
policy. Even more recent point-based methods produce solutions of limited quality in very
large domains (Paquet et al., 2006).
Hence in large POMDPs, a potentially better alternative is to use an online approach,
which only tries to find a good local policy for the current belief state of the agent. The
advantage of such an approach is that it only needs to consider belief states that are reachable from the current belief state. This focuses computation on a small set of beliefs. In
addition, since online planning is done at every step (and thus generalization between beliefs
is not required), it is sufficient to calculate only the maximal value for the current belief
state, not the full optimal -vector. In this setting, the policy construction steps and the
execution steps are interleaved with one another as shown in Figure 1. In some cases, online
approaches may require a few extra execution steps (and online planning), since the policy is
locally constructed and therefore not always optimal. However the policy construction time
is often substantially shorter. Consequently, the overall time for the policy construction
and execution is normally less for online approaches (Koenig, 2001). In practice, a potential
limitation of online planning is when we need to meet short real-time constraints. In such
case, the time available to construct the plan is very small compared to offline algorithms.
3.1 General Framework for Online Planning
This subsection presents a general framework for online planning algorithms in POMDPs.
Subsequently, we discuss specific approaches from the literature and describe how they vary
in tackling various aspects of this general framework.
An online algorithm is divided into a planning phase, and an execution phase, which
are applied alternately at each time step.
In the planning phase, the algorithm is given the current belief state of the agent and
computes the best action to execute in that belief. This is usually achieved in two steps.
First a tree of reachable belief states from the current belief state is built by looking at
several possible sequences of actions and observations that can be taken from the current
belief. In this tree, the current belief is the root node and subsequent reachable beliefs (as
calculated by the  (b, a, z) function of Equation 3) are added to the tree as child nodes of
their immediate previous belief. Belief nodes are represented using OR-nodes (at which we
must choose an action) and actions are included in between each layer of belief nodes using
AND-nodes (at which we must consider all possible observations that lead to subsequent
671

fiRoss, Pineau, Paquet, & Chaib-draa

b0

[14.4, 18.7]

1

3

[14.4, 17.9]

[12, 18.7]

a1

a2

0.7

z1
[13.7, 16.9]

b1

[15, 20]

b2

z1
[6, 14] b
5

b3

0.5

z2
[9, 15]

b4

[10, 18]

4

a1
0.6

z1

z2

-1

[5.8, 11.5]

0.5

0.3

a2
0.2

0.4

z2
b6

[9, 12]

z1

[13.7, 16.9]
0.8

[11, 20]

z2
b8

b7

[10, 12]

Figure 2: An AND-OR tree constructed by the search process for a POMDP with 2 actions and 2 observations. The belief states OR-nodes are represented by triangular nodes and the action AND-nodes
by circular nodes. The rewards RB (b, a) are represented by values on the outgoing arcs from
OR-nodes and probabilities Pr(z|b, a) are shown on the outgoing arcs from AND-nodes. The
values inside brackets represent the lower and upper bounds that were computed according to
Equations 19 - 22, assuming a discount factor  = 0.95. Also notice in this example that the
action a1 in belief state b1 could be pruned since its upper bound (= 11.5) is lower than the
lower bound (= 13.7) of action a2 in b1 .

beliefs). Then the value of the current belief is estimated by propagating value estimates
up from the fringe nodes, to their ancestors, all the way to the root, according to Bellmans
equation (Equation 8). The long-term value of belief nodes at the fringe is usually estimated
using an approximate value function computed offline. Some methods also maintain both
a lower bound and an upper bound on the value of each node. An example on how such a
tree is contructed and evaluated is presented in Figure 2.
Once the planning phase terminates, the execution phase proceeds by executing the best
action found for the current belief in the environment, and updating the current belief and
tree according to the observation obtained.
Notice that in general, the belief MDP could have a graph structure with cycles. Most
online algorithms handle such a structure by unrolling the graph into a tree. Hence, if they
reach a belief that is already elsewhere in the tree, it is duplicated. These algorithms could
always be modified to handle generic graph structures by using a technique proposed in the
LAO* algorithm (Hansen & Zilberstein, 2001) to handle cycles. However there are some
advantages and disadvantages to doing this. A more in-depth discussion of this issue is
presented in Section 5.4.
A generic online algorithm implementing the planning phase (lines 5-9) and the execution
phase (lines 10-13) is presented in Algorithm 3.1. The algorithm first initializes the tree to
contain only the initial belief state (line 2). Then given the current tree, the planning phase
of the algorithm proceeds by first selecting the next fringe node (line 6) under which it should
pursue the search (construction of the tree). The Expand function (line 7) constructs the
672

fiOnline Planning Algorithms for POMDPs

1: Function OnlinePOMDPSolver()
Static: bc : The current belief state of the agent.
T : An AND-OR tree representing the current search tree.
D: Expansion depth.
L: A lower bound on V  .
U : An upper bound on V  .

2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:

bc  b0
Initialize T to contain only bc at the root
while not ExecutionTerminated() do
while not PlanningTerminated() do
b  ChooseNextNodeToExpand()
Expand(b , D)
UpdateAncestors(b )
end while
Execute best action a for bc
Perceive a new observation z
bc   (bc , a, z)
Update tree T so that bc is the new root
end while

Algorithm 3.1: Generic Online Algorithm.
next reachable beliefs (using Equation 3) under the selected leaf for some pre-determined
expansion depth D and evaluates the approximate value function for all newly created
nodes. The new approximate value of the expanded node is propagated to its ancestors
via the UpdateAncestors function (line 8). This planning phase is conducted until some
terminating condition is met (e.g. no more planning time is available or an -optimal action
is found).
The execution phase of the algorithm executes the best action a found during planning
(line 10) and gets a new observation from the environment (line 11). Next, the algorithm
updates the current belief state and the search tree T according to the most recent action a
and observation z (lines 12-13). Some online approaches can reuse previous computations
by keeping the subtree under the new belief and resuming the search from this subtree at
the next time step. In such cases, the algorithm keeps all the nodes in the tree T under the
new belief bc and deletes all other nodes from the tree. Then the algorithm loops back to
the planning phase for the next time step, and so on until the task is terminated.
As a side note, an online planning algorithm can also be useful to improve the precision
of an approximate value function computed offline. This is captured in Theorem 3.1.
Theorem 3.1. (Puterman, 1994; Hauskrecht, 2000) Let V be an approximate value function and  = supb |V  (b)  V (b)|. Then the approximate value V D (b) returned by a Dstep lookahead from belief b, using V to estimate fringe node values, has error bounded by
|V  (b)  V D (b)|   D .
We notice that for   [0, 1), the error converges to 0 as the depth D of the search tends to
. This indicates that an online algorithm can effectively improve the performance obtained
by an approximate value function computed offline, and can find an action arbitrarily close
to the optimal for the current belief. However, evaluating the tree of all reachable beliefs
within depth D has a complexity in O((|A||Z|)D |S|2 ), which is exponential in D. This
becomes quickly intractable for large D. Furthermore, the planning time available during
the execution may be very short and exploring all beliefs up to depth D may be infeasible.
673

fiRoss, Pineau, Paquet, & Chaib-draa

Hence this motivates the need for more efficient online algorithms that can guarantee similar
or better error bounds.
To be more efficient, most of the online algorithms focus on limiting the number of reachable beliefs explored in the tree (or choose only the most relevant ones). These approaches
generally differ only in how the subroutines ChooseNextNodeToExpand and Expand
are implemented. We classify these approaches into three categories : Branch-and-Bound
Pruning, Monte Carlo Sampling and Heuristic Search. We now present a survey of these
approaches and discuss their strengths and drawbacks. A few other online algorithms do
not proceed via tree search; these approaches are discussed in Section 3.5.
3.2 Branch-and-Bound Pruning
Branch-and-Bound pruning is a general search technique used to prune nodes that are
known to be suboptimal in the search tree, thus preventing the expansion of unnecessary
lower nodes. To achieve this in the AND-OR tree, a lower bound and an upper bound
are maintained on the value Q (b, a) of each action a, for every belief b in the tree. These
bounds are computed by first evaluating the lower and upper bound for the fringe nodes
of the tree. These bounds are then propagated to parent nodes according to the following
equations:

L(b),
if b  F(T )
LT (b) =
(19)
maxaA LT (b, a), otherwise
X
LT (b, a) = RB (b, a) + 
Pr(z|b, a)LT ( (b, a, z)),
(20)
zZ



U (b),
if b  F(T )
maxaA UT (b, a), otherwise
X
UT (b, a) = RB (b, a) + 
Pr(z|b, a)UT ( (b, a, z)),
UT (b) =

(21)
(22)

zZ

where F(T ) denotes the set of fringe nodes in tree T , UT (b) and LT (b) represent the upper
and lower bounds on V  (b) associated to belief state b in the tree T , UT (b, a) and LT (b, a)
represent corresponding bounds on Q (b, a), and L(b) and U (b) are the bounds used at fringe
nodes, typically computed offline. These equations are equivalent to Bellmans equation
(Equation 8), however they use the lower and upper bounds of the children, instead of V  .
Several techniques presented in Section 2.2 can be used to quickly compute lower bounds
(Blind policy) and upper bounds (MDP, QMDP, FIB) offline.
Given these bounds, the idea behind Branch-and-Bound pruning is relatively simple: if a
given action a in a belief b has an upper bound UT (b, a) that is lower than another action as
lower bound LT (b, a), then we know that a is guaranteed to have a value Q (b, a)  Q (b, a).
Thus a is suboptimal in belief b. Hence that branch can be pruned and no belief reached
by taking action a in b will be considered.
3.2.1 RTBSS
The Real-Time Belief Space Search (RTBSS) algorithm uses a Branch-and-Bound approach
to compute the best action to take in the current belief (Paquet et al., 2005, 2006). Starting
674

fiOnline Planning Algorithms for POMDPs

1: Function Expand(b, d)
Inputs: b:
d:
Static: T :
L:
U:

2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:

The belief node we want to expand.
The depth of expansion under b.
An AND-OR tree representing the current search tree.
A lower bound on V  .
An upper bound on V  .

if d = 0 then
LT (b)  L(b)
else
Sort actions {a1 , a2 , . . . , a|A| } such that U (b, ai )  U (b, aj ) if i  j
i1
LT (b)  
while i  |A| and U (b, ai ) >
PLT (b) do
LT (b, ai )  RB (b, ai ) +  zZ Pr(z|b, ai )Expand( (b, ai , z), d  1)
LT (b)  max{LT (b), LT (b, ai )}
ii+1
end while
end if
return LT (b)

Algorithm 3.2: Expand subroutine of RTBSS.
from the current belief, it expands the AND-OR tree in a depth-first search fashion, up to
some pre-determined search depth D. The leaves of the tree are evaluated by using a lower
bound computed offline, which is propagated upwards such that a lower bound is maintained
for each node in the tree.
To limit the number of nodes explored, Branch-and-Bound pruning is used along the way
to prune actions that are known to be suboptimal, thus excluding unnecessary nodes under
these actions. To maximize pruning, RTBSS expands the actions in descending order of their
upper bound (first action expanded is the one with highest upper bound). By expanding
the actions in this order, one never expands an action that could have been pruned if actions
had been expanded in a different order. Intuitively, if an action has a higher upper bound
than the other actions, then it cannot be pruned by the other actions since their lower
bound will never exceed their upper bound. Another advantage of expanding actions in
descending order of their upper bound is that as soon as we find an action that can be
pruned, then we also know that all remaining actions can be pruned, since their upper
bounds are necessarily lower. The fact that RTBSS proceeds via a depth-first search also
increases the number of actions that can be pruned since the bounds on expanded actions
become more precise due to the search depth.
In terms of the framework in Algorithm 3.1, RTBSS requires the ChooseNextNodeToExpand subroutine to simply return the current belief bc . The UpdateAncestors function does not need to perform any operation since bc has no ancestor (root of the tree
T ). The Expand subroutine proceeds via depth-first search up to a fixed depth D, using
Branch-and-Bound pruning, as mentioned above. This subroutine is detailed in Algorithm
3.2. After this expansion is performed, PlanningTerminated evaluates to true and the
best action found is executed. At the end of each time step, the tree T is simply reinitialized
to contain the new current belief at the root node.
The efficiency of RTBSS depends largely on the precision of the lower and upper bounds
computed offline. When the bounds are tight, more pruning will be possible, and the search
will be more efficient. If the algorithm is unable to prune many actions, searching will
675

fiRoss, Pineau, Paquet, & Chaib-draa

be limited to short horizons in order to meet real-time constraints. Another drawback of
RTBSS is that it explores all observations equally. This is inefficient since the algorithm
could explore parts of the tree that have a small probability of occurring and thus have a
small effect on the value function. As a result, when the number of observations is large,
the algorithm is limited to exploring over a short horizon.
As a final note, since RTBSS explores all reacheable beliefs within depth D (except some
reached by suboptimal actions), then it can guarantee the same error bound as a D-step
lookahead (see Theorem 3.1). Therefore, the online search directly improves the precision of
the original (offline) value bounds by a factor  D . This aspect was confirmed empirically in
different domains where the RTBSS authors combined their online search with bounds given
by various offline algorithms. In some cases, their results showed a tremendous improvement
of the policy given by the offline algorithm (Paquet et al., 2006).
3.3 Monte Carlo Sampling
As mentioned above, expanding the search tree fully over a large set of observations is
infeasible except for shallow depths. In such cases, a better alternative may be to sample a
subset of observations at each expansion and only consider beliefs reached by these sampled
observations. This reduces the branching factor of the search and allows for deeper search
within a set planning time. This is the strategy employed by Monte Carlo algorithms.
3.3.1 McAllester and Singh
The approach presented by McAllester and Singh (1999) is an adaptation of the online MDP
algorithm presented by Kearns, Mansour, and Ng (1999). It consists of a depth-limited
search of the AND-OR tree up to a certain fixed horizon D where instead of exploring all
observations at each action choice, C observations are sampled from a generative model. The
probabilities Pr(z|b, a) are then approximated using the observed frequencies in the sample.
The advantage of such an approach is that sampling an observation from the distribution
Pr(z|b, a) can be achieved very efficiently in O(log |S| + log |Z|), while computing the exact
probabilities Pr(z|b, a) is in O(|S|2 ) for each observation z. Thus sampling can be useful to
alleviate the complexity of computing Pr(z|b, a), at the expense of a less precise estimate.
Nevertheless, a few samples is often sufficient to obtain a good estimate as the observations
that have the most effect on Q (b, a) (i.e. those which occur with high probability) are
more likely to be sampled. The authors also apply belief state factorization as in Boyen
and Koller (1998) to simplify the belief state calculations.
For the implementation of this algorithm, the Expand subroutine expands the tree up
to fixed depth D, using Monte Carlo sampling of observations, as mentioned above (see
Algorithm 3.3). At the end of each time step, the tree T is reinitialized to contain only the
new current belief at the root.
Kearns et al. (1999) derive bounds on the depth D and the number of samples C needed
to obtain an -optimal policy with high probability and show that the number of samples
required grows exponentially in the desired accuracy. In practice, the number of samples
required is infeasible given realistic online time constraints. However, performance in terms
of returns is usually good even with many fewer samples.
676

fiOnline Planning Algorithms for POMDPs

1: Function Expand(b, d)
Inputs: b:
d:
Static: T :
C:

2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:

The belief node we want to expand.
The depth of expansion under b.
An AND-OR tree representing the current search tree.
The number of observations to sample.

if d = 0 then
LT (b)  maxaA RB (b, a)
else
LT (b)  
for all a  A do
Sample Z = {z1 , z2 , . . . zC } from distribution Pr(z|b, a)
P
N (Z)
LT (b, a)  RB (b, a) +  zZ|Nz (Z)>0 zC Expand( (b, a, z), d  1)
LT (b)  max{LT (b), LT (b, a)}
end for
end if
return LT (b)

Algorithm 3.3: Expand subroutine of McAllester and Singhs Algorithm.

One inconvenience of this method is that no action pruning can be done since Monte
Carlo estimation is not guaranteed to correctly propagate the lower (and upper) bound
property up the tree. In their article, the authors simply approximate the value of the
fringe belief states by the immediate reward RB (b, a); this could be improved by using any
good estimate of V  computed offline. Note also that this approach may be difficult to
apply in domains where the number of actions |A| is large. Of course this may further
impact performance.
3.3.2 Rollout
Another similar online Monte Carlo approach is the Rollout algorithm (Bertsekas & Castanon, 1999). The algorithm requires an initial policy (possibly computed offline). At each
time step, it estimates the future expected value of each action, assuming the initial policy is followed at future time steps, and executes the action with highest estimated value.
These estimates are obtained by computing the average discounted return obtained over a
set of M sampled trajectories of depth D. These trajectories are generated by first taking
the action to be evaluated, and then following the initial policy in subsequent belief states,
assuming the observations are sampled from a generative model. Since this approach only
needs to consider different actions at the root belief node, the number of actions |A| only
influences the branching factor at the first level of the tree. Consequently, it is generally
more scalable than McAllester and Singhs approach. Bertsekas and Castanon (1999) also
show that with enough sampling, the resulting policy is guaranteed to perform at least as
well as the initial policy with high probability. However, it generally requires many sampled
trajectories to provide substantial improvement over the initial policy. Furthermore, the
initial policy has a significant impact on the performance of this approach. In particular, in
some cases it might be impossible to improve the return of the initial policy by just changing
the immediate action (e.g. if several steps need to be changed to reach a specific subgoal to
which higher rewards are associated). In those cases, the Rollout policy will never improve
over the initial policy.
677

fiRoss, Pineau, Paquet, & Chaib-draa

1: Function Expand(b, d)
Inputs: b: The belief node we want to expand.
d: The depth of expansion under b.
Static: T : An AND-OR tree representing the current search tree.
: A set of initial policies.
M : The number of trajectories of depth d to sample.

2: LT (b)  
3: for all a  A do
4: for all    do
5:
Q (b, a)  0
6:
for i = 1 to M do
7:
b  b
8:
a  a
9:
for j = 0 to d do
1 j
10:
Q (b, a)  Q (b, a) + M
 RB (b, a)
11:
z  SampleObservation(b, a)
12:
b   (b, a, z)
13:
a  (b)
14:
end for
15:
end for
16: end for
17: LT (b, a) = max Q (b, a)
18: end for

Algorithm 3.4: Expand subroutine of the Parallel Rollout Algorithm.
To address this issue relative to the initial policy, Chang, Givan, and Chong (2004)
introduced a modified version of the algorithm, called Parallel Rollout. In this case, the
algorithm starts with a set of initial policies. Then the algorithm proceeds as Rollout for
each of the initial policies in the set. The value considered for the immediate action is the
maximum over that set of initial policies, and the action with highest value is executed.
In this algorithm, the policy obtained is guaranteed to perform at least as well as the best
initial policy with high probability, given enough samples. Parallel Rollout can handle
domains with a large number of actions and observations, and will perform well when the
set of initial policies contain policies that are good in different regions of the belief space.
The Expand subroutine of the Parallel Rollout algorithm is presented in Algorithm 3.4.
The original Rollout algorithm by Bertsekas and Castanon (1999) is the same algorithm
in the special case where the set of initial policies  contains only one policy. The other
subroutines proceed as in McAllester and Singhs algorithm.
3.4 Heuristic Search
Instead of using Branch-and-Bound pruning or Monte Carlo sampling to reduce the branching factor of the search, heuristic search algorithms try to focus the search on the most relevant reachable beliefs by using heuristics to select the best fringe beliefs node to expand.
The most relevant reachable beliefs are the ones that would allow the search algorithm to
make good decisions as quickly as possible, i.e. by expanding as few nodes as possible.
There are three different online heuristic search algorithms for POMDPs that have been
proposed in the past: Satia and Lave (1973), BI-POMDP (Washington, 1997) and AEMS
(Ross & Chaib-draa, 2007). These algorithms all maintain both lower and upper bounds
on the value of each node in the tree (using Equations 19 - 22) and only differ in the
specific heuristic used to choose the next fringe node to expand in the AND/OR tree. We
678

fiOnline Planning Algorithms for POMDPs

first present the common subroutines for these algorithms, and then discuss their different
heuristics.
Recalling the general framework of Algorithm 3.1, three steps are interleaved several
times in heuristic search algorithms. First, the best fringe node to expand (according to
the heuristic) in the current search tree T is found. Then the tree is expanded under
this node (usually for only one level). Finally, ancestor nodes values are updated; their
values must be updated before we choose the next node to expand, since the heuristic
value usually depends on them. In general, heuristic search algorithms are slightly more
computationally expensive than standard depth- or breadth-first search algorithms, due to
the extra computations needed to select the best fringe node to expand, and the need to
update ancestors at each iteration. This was not required by the previous methods using
Branch-and-Bound pruning and/or Monte Carlo sampling. If the complexity of these extra
steps is too high, then the benefit of expanding only the most relevant nodes might be
outweighed by the lower number of nodes expanded (assuming a fixed planning time).
In heuristic search algorithms, a particular heuristic value is associated with every fringe
node in the tree. This value should indicate how important it is to expand this node in
order to improve the current solution. At each iteration of the algorithm, the goal is to find
the fringe node that maximizes this heuristic value among all fringe nodes. This can be
achieved efficiently by storing in each node of the tree a reference to the best fringe node
to expand within its subtree, as well as its associated heuristic value. In particular, the
root node always contains a reference to the best fringe node for the whole tree. When a
node is expanded, its ancestors are the only nodes in the tree where the best fringe node
reference, and corresponding heuristic value, need to be updated. These can be updated
efficiently by using the references and heuristic values stored in the lower nodes via a
dynamic programming algorithm, described formally in Equations 23 and 24. Here HT (b)
denotes the highest heuristic value among the fringe nodes in the subtree of b, bT (b) is a
reference to this fringe node, HT (b) is the basic heuristic value associated to fringe node b,
and HT (b, a) and HT (b, a, z) are factors that weigh this basic heuristic value at each level
of the tree T . For example, HT (b, a, z) could be Pr(z|b, a) in order to give higher weight to
(and hence favor) fringe nodes that are reached by the most likely observations.

HT (b)
if b  F(T )

HT (b) =

maxaA HT (b, a)HT (b, a) otherwise
(23)
HT (b, a) = maxzZ HT (b, a, z)HT ( (b, a, z))

b
if b  F(T )

bT (b) =
bT (b, aTb ) otherwise
T ))
bT (b, a) = bT ( (b, a, zb,a
(24)
T
ab = argmaxaA HT (b, a)HT (b, a)
T
zb,a
= argmaxzZ HT (b, a, z)HT ( (b, a, z))
This procedure finds the fringe node b  F(T ) that maximizes the overall heuristic value
QdT (b)
HT (bi , ai )HT (bi , ai , zi ), where bi , ai and zi represent the ith belief,
HT (bc , b) = HT (b) i=1
action and observation on the path from bc to b in T , and dT (b) is the depth of fringe
node b. Note that HT and bT are only updated in the ancestor nodes of the last expanded
node. By reusing previously computed values for the other nodes, we have a procedure
679

fiRoss, Pineau, Paquet, & Chaib-draa

1: Function Expand(b)
Inputs: b:
Static: bc :
T:
L:
U:

2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:

An OR-Node we want to expand.
The current belief state of the agent.
An AND-OR tree representing the current search tree.
A lower bound on V  .
An upper bound on V  .

for each a  A do
for each z  Z do
b0   (b, a, z)
UT (b0 )  U (b0 )
LT (b0 )  L(b0 )
HT (b0 )  HT (b0 )
bT (b0 )  b0
end for
P
LT (b, a)  RB (b, a) +  P zZ Pr(z|b, a)LT ( (b, a, z))
UT (b, a)  RB (b, a) +  zZ Pr(z|b, a)UT ( (b, a, z))

T  argmax
zb,a
zZ HT (b, a, z)HT ( (b, a, z))

T ))

T
HT (b, a) = HT (b, a, zb,a )HT ( (b, a, zb,a
T


bT (b, a)  bT ( (b, a, zb,a ))
end for
LT (b)  max{maxaA LT (b, a), LT (b)}
UT (b)  min{maxaA UT (b, a), UT (b)}

aT
b  argmaxaA HT (b, a)HT (b, a)
 (b, aT )
)H
HT (b)  HT (b, aT
b
T
b
bT (b)  bT (b, aT
b )

Algorithm 3.5: Expand : Expand subroutine for heuristic search algorithms.
that can find the best fringe node to expand in the tree in time linear in the depth of the
tree (versus exponential in the depth of the tree for the exhaustive search through all fringe
nodes). These updates are performed in both the Expand and the UpdateAncestors
subroutines, each of which is described in more detail below. After each iteration, the
ChooseNextNodeToExpand subroutine simply returns the reference to this best fringe
node stored in the root of the tree, i.e. bT (bc ).
The Expand subroutine used by heuristic search methods is presented in Algorithm 3.5.
It performs a one-step lookahead under the fringe node b. The main difference with respect
to previous methods in Sections 3.2 and 3.3 is that the heuristic value and best fringe node
to expand for these new nodes are computed at lines 7-8 and 12-14. The best leaf node
in bs subtree and its heuristic value are then computed according to Equations 23 and 24
(lines 18-20).
The UpdateAncestors function is presented in Algorithm 3.6. The goal of this function is to update the bounds of the ancestor nodes, and find the best fringe node to expand
next. Starting from a given OR-Node b0 , the function simply updates recursively the ancestor nodes of b0 in a bottom-up fashion, using Equations 19-22 to update the bounds and
Equations 23-24 to update the reference to the best fringe to expand and its heuristic value.
Notice that the UpdateAncestors function can reuse information already stored in the
node objects, such that it does not need to recompute  (b, a, z), Pr(z|b, a) and RB (b, a).
However it may need to recompute HT (b, a, z) and HT (b, a) according to the new bounds,
depending on how the heuristic is defined.
Due to the anytime nature of these heuristic search algorithms, the search usually keeps
going until an -optimal action is found for the current belief bc , or the available planning
680

fiOnline Planning Algorithms for POMDPs

1: Function UpdateAncestors(b0 )

2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:

Inputs: b0 : An OR-Node for which we want to update all its ancestors.
Static: bc : The current belief state of the agent.
T : An AND-OR tree representing the current search tree.
L: A lower bound on V  .
U : An upper bound on V  .
while b0 6= bc do
Set (b, a) so that action aPin belief b is parent node of belief node b0
LT (b, a)  RB (b, a) +  P zZ Pr(z|b, a)LT ( (b, a, z))
UT (b, a)  RB (b, a) +  zZ Pr(z|b, a)UT ( (b, a, z))

T  argmax
zb,a
zZ HT (b, a, z)HT ( (b, a, z))
T )H  ( (b, a, z T ))
HT (b, a)  HT (b, a, zb,a
T
b,a
T ))
bT (b, a)  bT ( (b, a, zb,a
LT (b)  maxa0 A LT (b, a0 )
UT (b)  maxa0 A UT (b, a0 )
0
0

aT
b  argmaxa0 A HT (b, a )HT (b, a )
 (b, aT )
)H
HT (b)  HT (b, aT
T
b
b
bT (b)  bT (b, aT
b )
b0  b
end while

Algorithm 3.6: UpdateAncestors : Updates the bounds of the ancestors of all ancestors
of an OR-Node
time is elapsed. An -optimal action is found whenever UT (bc )  LT (bc )   or LT (bc ) 
UT (bc , a0 ), a0 6= argmaxaA LT (bc , a) (i.e. all other actions are pruned, in which case the
optimal action has been found).
Now that we have covered the basic subroutines, we present the different heuristics
proposed by Satia and Lave (1973), Washington (1997) and Ross and Chaib-draa (2007).
We begin by introducing some useful notation.
Given any graph structure G, let us denote F(G) the set of all fringe nodes in G and
HG (b, b0 ) the set of all sequences of actions and observations that lead to belief node b0 from
belief node b in the search graph G. If we have a tree T , then HT (b, b0 ) will contain at most
0
0
a single sequence which we will denote hb,b
T . Now given a sequence h  HG (b, b ), we define
Pr(hz |b, ha ) the probability that we observe the whole sequence of observations hz in h, given
that we start in belief node b and perform the whole sequence of actions ha in h. Finally, we
define Pr(h|b, ) to be the probability that we follow the entire action/observation sequence
h if we start in belief b and behave according to policy . Formally, these probabilities are
computed as follows:
d(h)

Pr(hz |b, ha ) =

Y

Pr(hiz |bhi1 , hia ),

(25)

i=1

d(h)

Pr(h|b, ) =

Y

Pr(hiz |bhi1 , hia )(bhi1 , hia ),

(26)

i=1

where d(h) represents the depth of h (number of actions in the sequence h), hia denotes the
ith action in sequence h, hiz the ith observation in the sequence h, and bhi the belief state
obtained by taking the first i actions and observations of the sequence h from b. Note that
bh0 = b.
681

fiRoss, Pineau, Paquet, & Chaib-draa

3.4.1 Satia and Lave
The approach of Satia and Lave (1973) follows the heuristic search framework presented
above. The main feature of this approach is to explore, at each iteration, the fringe node b
in the current search tree T that maximizes the following term:
bc ,b

HT (bc , b) =  d(hT

)

c ,b
c ,b
Pr(hbT,z
|bc , hbT,a
)(UT (b)  LT (b)),

(27)

where b  F(T ) and bc is the root node of T . The intuition behind this heuristic is simple:
recalling the definition of V  , we note that the weight of the value V  (b) of a fringe node b
bc ,b
c ,b
c ,b
c ,b
is a sequence of optimal
), provided hbT,a
|bc , hbT,a
on V  (bc ) would be exactly  d(hT ) Pr(hbT,z
actions. The fringe nodes where this weight is high have the most effect on the estimate
of V  (bc ). Hence one should try to minimize the error at these nodes first. The term
UT (b)  LT (b) is included since it is an upper bound on the (unknown) error V  (b)  LT (b).
Thus this heuristic focuses the search in areas of the tree that most affect the value V  (bc )
and where the error is possibly large. This approach also uses Branch-and-Bound pruning,
such that a fringe node reached by an action that is dominated in some parent belief b is
never going to be expanded. Using the same notation as in Algorithms 3.5 and 3.6, this
heuristic can be implemented by defining HT (b), HT (b, a) and HT (b, a, z), as follows:
HT (b) = 
UT (b)  LT (b),
1 if UT (b, a) > LT (b),
HT (b, a) =
0 otherwise,
HT (b, a, z) =  Pr(z|b, a),

(28)

The condition UT (b, a) > LT (b) ensures that the global heuristic value HT (bc , b0 ) = 0 if
bc ,b0
is dominated (pruned). This guarantees that such fringe
some action in the sequence hT,a
nodes will never be expanded.
Satia and Laves heuristic focuses the search towards beliefs that are most likely to be
reached in the future, and where the error is large. This heuristic is likely to be efficient in
domains with a large number of observations, but only if the probability distribution over
observations is concentrated over only a few observations. The term UT (b)  LT (b) in the
heuristic also prevents the search from doing unnecessary computations in areas of the tree
where it already has a good estimate of the value function. This term is most efficient when
the bounds computed offline, U and L, are sufficiently informative. Similarly, node pruning
is only going to be efficient if U and L are sufficiently tight, otherwise few actions will be
pruned.
3.4.2 BI-POMDP
Washington (1997) proposed a slightly different approach inspired by the AO algorithm
(Nilsson, 1980), where the search is only conducted in the best solution graph. In the case
of online POMDPs, this corresponds to the subtree of all belief nodes that are reached by
sequences of actions maximizing the upper bound in their parent beliefs.
b
The set of fringe nodes in the best solution graph of G, which we denote F(G),
can be
b
defined formally as F(G) = {b  F(G)|h  HG (bc , b), Pr(h|b, G ) > 0}, where G (b, a) = 1
if a = argmaxa0 A UG (b, a0 ) and G (b, a) = 0 otherwise. The AO algorithm simply specifies
682

fiOnline Planning Algorithms for POMDPs

expanding any of these fringe nodes. Washington (1997) recommends exploring the fringe
node in Fb(G) (where G is the current acyclic search graph) that maximizes UG (b)  LG (b).
Washingtons heuristic can be implemented by defining HT (b), HT (b, a) and HT (b, a, z), as
follows:
HT (b) = 
UT (b)  LT (b),
1 if a = argmaxa0 A UT (b, a0 ),
HT (b, a) =
0 otherwise,
HT (b, a, z) = 1.

(29)

This heuristic tries to guide the search towards nodes that are reachable by promising
actions, especially when they have loose bounds on their values (possibly large error). One
nice property of this approach is that expanding fringe nodes in the best solution graph is
the only way to reduce the upper bound at the root node bc . This was not the case for
Satia and Laves heuristic. However, Washingtons heuristic does not take into account the
probability Pr(hz |b, ha ), nor the discount factor  d(h) , such that it may end up exploring
nodes that have a very small probability of being reached in the future, and thus have
little effect on the value of V  (bc ). Hence, it may not explore the most relevant nodes
for optimizing the decision at bc . This heuristic is appropriate when the upper bound U
computed offline is sufficiently informative, such that actions with highest upper bound
would also usually tend to have highest Q-value. In such cases, the algorithm will focus
its search on these actions and thus should find the optimal action more quickly then if it
explored all actions equally. On the other hand, because it does not consider the observation
probabilities, this approach may not scale well to large observation sets, as it will not be
able to focus its search towards the most relevant observations.
3.4.3 AEMS
Ross and Chaib-draa (2007) introduced a heuristic that combines the advantages of BIPOMDP, and Satia and Laves heuristic. It is based on a theoretical error analysis of tree
search in POMDPs, presented by Ross et al. (2008).
The core idea is to expand the tree such as to reduce the error on V  (bc ) as quickly as
possible. This is achieved by expanding the fringe node b that contributes the most to the
error on V  (bc ). The exact error contribution eT (bc , b) of fringe node b on bc in tree T is
defined by the following equation:
bc ,b

eT (bc , b) =  d(hT

)

Pr(hbTc ,b |bc ,   )(V  (b)  LT (b)).

(30)

This expression requires   and V  to be computed exactly. In practice, Ross and Chaibdraa (2007) suggest approximating the exact error (V  (b)  LT (b)) by (UT (b)  LT (b)),
as was done by Satia and Lave, and Washington. They also suggest approximating   by
some policy T , where T (b, a) represents the probability that action a is optimal in its
parent belief b, given its lower and upper bounds in tree T . In particular, Ross et al. (2008)
considered two possible approximations for   . The first one is based on a uniformity
assumption on the distribution of Q-values between the lower and upper bounds, which
yields:
683

fiRoss, Pineau, Paquet, & Chaib-draa

T (b, a) =

(

2

T (b,a)LT (b))
 (U
UT (b,a)LT (b,a)
0

if UT (b, a) > LT (b),
otherwise,

(31)

where  is a normalization constant such that the sum of the probabilities T (b, a) over all
actions equals 1.
The second is inspired by AO and BI-POMDP, and assumes that the action maximizing
the upper bound is in fact the optimal action:

1 if a = argmaxa0 A UT (b, a0 ),
(32)
T (b, a) =
0 otherwise.
Given the approximation T of   , the AEMS heuristic will explore the fringe node b
that maximizes:
bc ,b
)

HT (bc , b) =  d(hT

Pr(hbTc ,b |bc , T )(UT (b)  LT (b)).

(33)

This can be implemented by defining HT (b), HT (b, a) and HT (b, a, z) as follows:
HT (b) = UT (b)  LT (b),
HT (b, a) = T (b, a),
HT (b, a, z) =  Pr(z|b, a).

(34)

We refer to this heuristic as AEMS1 when T is defined as in Equation 31, and AEMS2
when it is defined as in Equation 32.2
Let us now examine how AEMS combines the advantages of both the Satia and Lave,
and BI-POMDP heuristics. First, AEMS encourages exploration of nodes with loose bounds
and possibly large error by considering the term UT (b)  LT (b) as in previous heuristics.
Moreover, as in Satia and Lave, it focuses the exploration towards belief states that are likely
to be encountered in the future. This is good for two reasons. As mentioned before, if a belief
state has a low probability of occurrence in the future, it has a limited effect on the value
V  (bc ) and thus it is not necessary to know its value precisely. Second, exploring the highly
probable belief states increases the chance that we will be able to reuse these computations
in the future. Hence, AEMS should be able to deal efficiently with large observation sets,
assuming the distribution over observations is concentrated over a few observations. Finally,
as in BI-POMDP, AEMS favors the exploration of fringe nodes reachable by actions that
seem more likely to be optimal (according to T ). This is useful to handle large action
sets, as it focuses the search on actions that look promising. If these promising actions
are not optimal, then this will quickly become apparent. This will work well if the best
actions have the highest probabilities in T . Furthermore, it is possible to define T such
that it automatically prunes dominated actions by ensuring that T (b, a) = 0 whenever
UT (b, a) < LT (b). In such cases, the heuristic will never choose to expand a fringe node
reached by a dominated action.
As a final note, Ross et al. (2008) determined sufficient conditions under which the
search algorithm using this heuristic is guaranteed to find an -optimal action within finite
time. This is stated in Theorem 3.2.
2. The AEMS2 heuristic was also used for a policy search algorithm by Hansen (1998).

684

fiOnline Planning Algorithms for POMDPs

Theorem 3.2. (Ross et al., 2008) Let  > 0 and bc the current belief. If for any tree T and
parent belief b in T where UT (b)  LT (b) > , T (b, a) > 0 for a = argmaxa0 A UT (b, a0 ),
then the AEMS algorithm is guaranteed to find an -optimal action for bc within finite time.
We observe from this theorem that it is possible to define many different policies T
under which the AEMS heuristic is guaranteed to converge. AEMS1 and AEMS2 both
satisfy this condition.
3.4.4 HSVI
A heuristic similar to AEMS2 was also used by Smith and Simmons (2004) for their offline
value iteration algorithm HSVI as a way to pick the next belief point at which to perform
-vector backups. The main difference is that HSVI proceeds via a greedy search that
descends the tree from the root node b0 , going down towards the action that maximizes the
upper bound and then the observation that maximizes Pr(z|b, a)(U ( (b, a, z))L( (b, a, z)))
at each level, until it reaches a belief b at depth d where  d (U (b)  L(b)) < . This
heuristic could be used in an online heuristic search algorithm by instead stopping the
greedy search process when it reaches a fringe node of the tree and then selecting this node
as the one to be expanded next. In such a setting, HSVIs heuristic would return a greedy
approximation of the AEMS2 heuristic, as it may not find the fringe node which actually
bc ,b
maximizes  d(hT ) Pr(hbTc ,b |bc , T )(UT (b)  LT (b)). We consider this online version of the
HSVI heuristic in our empirical study (Section 4). We refer to this extension as HSVI-BFS.
Note that the complexity of this greedy search is the same as finding the best fringe node
via the dynamic programming process that updates HT and bT in the UpdateAncestors
subroutine.
3.5 Alternatives to Tree Search
We now present two alternative online approaches that do not proceed via a lookahead
search in the belief MDP. In all online approaches presented so far, one problem is that no
learning is achieved over time, i.e. everytime the agent encounters the same belief, it has to
recompute its policy starting from the same initial upper and lower bounds computed offline.
The two online approaches presented next address this problem by presenting alternative
ways of updating the initial value functions computed offline so that the performance of
the agent improves over time as it stores updated values computed at each time step.
However, as is argued below and in the discussion (Section 5.2), these techniques lead to
other disadvantages in terms of memory consumption and/or time complexity.
3.5.1 RTDP-BEL
An alternative approach to searching in AND-OR graphs is the RTDP algorithm (Barto
et al., 1995) which has been adapted to solve POMDPs by Geffner and Bonet (1998). Their
algorithm, called RTDP-BEL, learns approximate values for the belief states visited by
successive trials in the environment. At each belief state visited, the agent evaluates all
possible actions by estimating the expected reward of taking action a in the current belief
685

fiRoss, Pineau, Paquet, & Chaib-draa

1: Function OnlinePOMDPSolver()
Static: bc : The current belief state of the agent.
V0 : Initial approximate value function (computed offline).
V : A hashtable of beliefs and their approximate value.
k: Discretization resolution.

2: Initialize bc to the initial belief state and V to an empty hashtable.
3: while not ExecutionTerminated() do
P
4: For all a  A: Evaluate Q(bc , a) = RB (b, a) +  zZ Pr(z|b, a)V (Discretize( (b, a, z), k))
5: a  argmaxaA Q(bc , a)
6: Execute best action a for bc
7: V (Discretize(bc , k))  Q(bc , a)
8: Perceive a new observation z
9: bc   (bc , a, z)
10: end while

Algorithm 3.7: RTDP-Bel Algorithm.
state b with an approximate Q-value equation:
X
Q(b, a) = RB (b, a) + 
Pr(z|b, a)V ( (b, a, z)),

(35)

zZ

where V (b) is the value learned for the belief b.
If the belief state b has no value in the table, then it is initialized to some heuristic value.
The authors suggest using the MDP approximation for the initial value of each belief state.
The agent then executes the action that returned the greatest Q(b, a) value. Afterwards,
the value V (b) in the table is updated with the Q(b, a) value of the best action. Finally,
the agent executes the chosen action and it makes the new observation, ending up in a new
belief state. This process is then repeated again in this new belief.
The RTDP-BEL algorithm learns a heuristic value for each belief state visited. To
maintain an estimated value for each belief state in memory, it needs to discretize the
belief state space to have a finite number of belief states. This also allows generalization of
the value function to unseen belief states. However, it might be difficult to find the best
discretization for a given problem. In practice, this algorithm needs substantial amounts
of memory (greater than 1GB in some cases) to store all the learned belief state values,
especially in POMDPs with large state spaces. The implementation of the RTDP-Bel
algorithm is presented in Algorithm 3.7.
The function Discretize(b, k) returns a discretized belief b0 where b0 (s) = round(kb(s))/k
for all states s  S, and V (b) looks up the value of belief b in a hashtable. If b is not present in
the hashtable, the value V0 (b) is returned by V . Supported by experimental data, Geffner
and Bonet (1998) suggest choosing k  [10, 100], as it usually produces the best results.
Notice that for a discretization resolution of k there are O((k + 1)|S| ) possible discretized
beliefs. This implies that the memory storage required to maintain V is exponential in |S|,
which becomes quickly intractable, even for mid-size problems. Furthermore, learning good
estimates for this exponentially large number of beliefs usually requires a very large number
of trials, which might be infeasible in practice. This technique can sometimes be applied
in large domains when a factorized representation is available. In such cases, the belief can
be maintained as a set of distributions (one for subset of conditionaly independent state
variables) and the discretization applied seperately to each distribution. This can greatly
reduce the possible number of discretized beliefs.
686

fiOnline Planning Algorithms for POMDPs

Algorithm
RTBSS
McAllester
Rollout
Satia and Lave
Washington
AEMS
HSVI-BFS
RTDP-Bel
SOVI

-optimal
yes
high probability
no
yes
acyclic graph
yes
yes
no
yes

Anytime
no
no
no
yes
yes
yes
yes
no
yes

Branch &
Bound
yes
no
no
yes
implicit
implicit
implicit
no
no

Monte
Carlo
no
yes
yes
no
no
no
no
no
no

Heuristic
no
no
no
yes
yes
yes
yes
no
no

Learning
no
no
no
no
no
no
no
yes
yes

Table 1: Properties of various online methods.

3.5.2 SOVI
A more recent online approach, called SOVI (Shani et al., 2005), extends HSVI (Smith &
Simmons, 2004, 2005) into an online value iteration algorithm. This approach maintains a
priority queue of the belief states encountered during the execution and proceeds by doing
-vector updates for the current belief state and the k belief states with highest priority at
each time step. The priority of a belief state is computed according to how much the value
function changed at successor belief states, since the last time it was updated. Its authors
also propose other improvements to the HSVI algorithm to improve scalability, such as a
more efficient -vector pruning technique, and avoiding to use linear programs to update and
evaluate the upper bound. The main drawback of this approach is that it is hardly applicable
in large environments with short real-time constraints, since it needs to perform a value
iteration update with -vectors online, and this can have very high complexity as the number
of -vectors representing the value function increases (i.e. O(k|S||A||Z|(|S| + |t1 |)) to
compute t ).
3.6 Summary of Online POMDP Algorithms
In summary, we see that most online POMDP approaches are based on lookahead search.
To improve scalability, different techniques are used: branch-and-bound pruning, search
heuristics, and Monte Carlo sampling. These techniques reduce the complexity from different angles. Branch-and-bound pruning lowers the complexity related to the action space
size. Monte Carlo sampling has been used to lower the complexity related to the observation space size, and could also potentially be used to reduce the complexity related to the
action space size (by sampling a subset of actions). Search heuristics lower the complexity
related to actions and observations by orienting the search towards the most relevant actions and observations. When appropriate, factored POMDP representations can be used
to reduce the complexity related to state. A summary of the different properties of each
online algorithm is presented in Table 1.
687

fiRoss, Pineau, Paquet, & Chaib-draa

4. Empirical Study
In this section, we compare several online approaches in two domains found in the POMDP
literature: Tag (Pineau et al., 2003) and RockSample (Smith & Simmons, 2004). We consider a modified version of RockSample, called FieldVisionRockSample (Ross & Chaib-draa,
2007), that has a higher observation space than the original RockSample. This environment
is introduced as a means to test and compare the different algorithms in environments with
large observation spaces.
4.1 Methodology
For each environment, we first compare the real-time performance of the different heuristics
presented in Section 3.4 by limiting their planning time to 1 second per action. All heuristics
were given the same lower and upper bounds such that their results would be comparable.
The objective here is to evaluate which search heuristic is most efficient in different types of
environments. To this end, we have implemented the different search heuristics (Satia and
Lave, BI-POMDP, HSVI-BFS and AEMS) into the same best-first search algorithm, such
that we can directly measure the efficiency of the heuristic itself. Results were also obtained
for different lower bounds (Blind and PBVI) to verify how this choice affects the heuristics
efficiency. Finally, we compare how online and offline times affect the performance of each
approach. Except where stated otherwise, all experiments were run on an Intel Xeon 2.4
Ghz with 4GB of RAM; processes were limited to 1GB of RAM.
4.1.1 Metrics to compare online approaches
We compare performance first and foremost in terms of average discounted return at execution time. However, what we really seek with online approaches is to guarantee better
solution quality than that provided by the original bounds. In other words, we seek to
reduce the error of the original bounds as much as possible. This suggests that a good
metric for the efficiency of online algorithms is to compare the improvement in terms of the
error bounds at the current belief before and after the online search. Hence, we define the
error bound reduction percentage to be:
UT (b)  LT (b)
,
(36)
U (b)  L(b)
where UT (b), LT (b), U (b) and L(b) are defined as in Section 3.2. The best online algorithm
should provide the highest error bound reduction percentage, given the same initial bounds
and real-time constraint.
Because the EBR metric does not necessarily reflect true error reduction, we also compare the return guarantees provided by each algorithm, i.e. the lower bounds on the expected
return provided by the computed policies for the current belief. Because improvement of
the lower bound compared to the initial lower bound computed offline is a direct indicator
of true error reduction, the best online algorithm should provide the greatest lower bound
improvement at the current belief, given the same initial bounds and real-time constraint.
Formally, we define the lower bound improvement to be:
EBR(b) = 1 

LBI(b) = LT (b)  L(b).
688

(37)

fiOnline Planning Algorithms for POMDPs

In our experiments, both the EBR and LBI metrics are evaluated at each time step for the
current belief. We are interested in seeing which approach provides the highest EBR and
LBI on average.
We also consider other metrics pertaining to complexity and efficiency. In particular,
we report the average number of belief nodes maintained in the search tree. Methods that
have lower complexity will generally be able to maintain bigger trees, but the results will
show that this does not always relate to higher error bound reduction and returns. We will
also measure the efficiency of reusing part of the search tree by recording the percentage of
belief nodes that were reused from one time step to the next.
4.2 Tag
Tag was initially introduced by Pineau et al. (2003). This environment has also been
used more recently in the work of several authors (Poupart & Boutilier, 2003; Vlassis &
Spaan, 2004; Pineau, 2004; Spaan & Vlassis, 2004; Smith & Simmons, 2004; Braziunas &
Boutilier, 2004; Spaan & Vlassis, 2005; Smith & Simmons, 2005). For this environment, an
approximate POMDP algorithm is necessary because of its large size (870 states, 5 actions
and 30 observations). The Tag environment consists of an agent that has to catch (Tag)
another agent while moving in a 29-cell grid domain. The reader is referred to the work of
Pineau et al. (2003) for a full description of the domain. Note that for all results presented
below, the belief state is represented in factored form. The domain is such that an exact
factorization is possible.
To obtain results in Tag, we run each algorithm in each starting configuration 5 times,
( i.e. 5 runs for each of the 841 different starting joint positions, excluding the 29 terminal
states ). The initial belief state is the same for all runs and consists of a uniform distribution
over the possible joint agent positions.
Table 2 compares the different heuristics by presenting 95% confidence intervals on the
average discounted return per run (Return), average error bound reduction percentage per
time step (EBR), average lower bound improvement per time step (LBI), average belief
nodes in the search tree per time step (Belief Nodes), the average percentage of belief nodes
reused per time step (Nodes Reused), the average online planning time used per time step
(Online Time). In all cases, we use the FIB upper bound and the Blind lower bound. Note
that the average online time is slightly lower than 1 second per step because algorithms
sometimes find -optimal solutions in less than a second.
We observe that the efficiency of HSVI-BFS, BI-POMDP and AEMS2 differs slightly
in this environment and that they outperform the three other heuristics: RTBSS, Satia
and Lave, and AEMS1. The difference can be explained by the fact that the latter three
methods do not restrict the search to the best solution graph. As a consequence, they
explore many irrelevant nodes, as shown by the lower error bound reduction percentage,
lower bound improvement, and nodes reused. This poor reuse percentage explains why
Satia and Lave, and AEMS1 were limited to a lower number of belief nodes in their search
tree, compared to the other methods which reached averages around 70K. The results of the
three other heuristics do not differ much here because the three heuristics only differ in the
way they choose the observations to explore in the search. Since only two observations are
possible after the first action and observation, and one of these observations leads directly
689

fiRoss, Pineau, Paquet, & Chaib-draa

Heuristic
RTBSS(5)
Satia and Lave
AEMS1
HSVI-BFS
BI-POMDP
AEMS2

Return
-10.31  0.22
-8.35  0.18
-6.73  0.15
-6.22  0.19
-6.22  0.15
-6.19  0.15

EBR (%)
22.3  0.4
22.9  0.2
49.0  0.3
75.7  0.4
76.2  0.5
76.3  0.5

LBI
3.03  0.07
2.47  0.04
3.92  0.03
7.69  0.06
7.81  0.06
7.81  0.06

Belief
Nodes
45066  701
36908  209
43693  314
64870  947
79508  1000
80250  1018

Nodes
Reused (%)
0
10.0  0.2
25.1  0.3
54.1  0.7
54.6  0.6
54.8  0.6

Online
Time (ms)
580  9
856  4
814 4
673  5
622  4
623  4

Table 2: Comparison of different search heuristics on the Tag environment using the Blind
policy as a lower bound.

EXIT

A

Figure 3: RockSample[7,8].
to a terminal belief state, the possibility that the heuristics differed significantly was very
limited. Due to this limitation of the Tag domain, we now compare these online algorithms
in a larger and more complex domain: RockSample.
4.3 RockSample
The RockSample problem was originally presented by Smith and Simmons (2004). In this
domain, an agent has to explore the environment and sample some rocks (see Figure 3),
similarly to what a real robot would do on the planet Mars. The agent receives rewards by
sampling rocks and by leaving the environment (at the extreme right of the environment).
A rock can have a scientific value or not, and the agent has to sample only good rocks.
We define RockSample[n, k] as an instance of the RockSample problem with an n  n
grid and k rocks. A state is characterized by k + 1 variables: XP , which defines the position
of the robot and can take values {(1, 1), (1, 2), . . . , (n, n)} and k variables, X1R through XkR ,
representing each rock, which can take values {Good, Bad}.
The agent can perform k + 5 actions: {N orth, South, East, W est, Sample, Check1 , . . . ,
Checkk }. The four motion actions are deterministic. The Sample action samples the
rock at the agents current location. Each Checki action returns a noisy observation from
{Good, Bad} for rock i.
The belief state is represented in factored form by the known position and a set of k
probabilities, namely the probability of each rock being good. Since the observation of a rock
690

fiOnline Planning Algorithms for POMDPs

Heuristic
Satia and Lave
AEMS1
RTBSS(2)
BI-POMDP
HSVI-BFS
AEMS2
AEMS1
Satia and Lave
RTBSS(2)
BI-POMDP
AEMS2
HSVI-BFS

Belief
Nodes
EBR (%)
LBI
Nodes
Reused (%)
Blind: Return:7.35, || = 1, Time:4s
7.35  0
3.64  0
00
509  0
8.92  0
10.30  0.08
9.50  0.11
0.90  0.03
579  2
5.31  0.03
10.30  0.15
9.65  0.02
1.00  0.04
439  0
00
18.43  0.14
33.3  0.5
4.33  0.06
2152  71
29.9  0.6
20.53  0.31
51.7  0.7
5.25  0.07
2582  72
36.5  0.5
20.75  0.15
52.4  0.6
5.30  0.06
3145  101
36.4  0.5
PBVI: Return:5.93, |B| = 64, || = 54, Time:2418s
17.10  0.28
26.1  0.4
1.39  0.03
1461  28
12.2  0.1
19.09  0.21
16.9  0.1
1.17  0.01
2311  25
13.5  0.1
19.45  0.30
22.4  0.3
1.37  0.04
426  1
00
21.36  0.22
49.5  0.2
2.73  0.02
2781  38
32.2  0.2
21.37  0.22
57.7  0.2
3.08  0.02
2910  46
38.2  0.2
21.46  0.22
56.3  0.2
3.03  0.02
2184  33
37.3  0.2
Return

Online
Time (ms)
900
916
886
953
885
859








0
1
2
2
5
6

954
965
540
892
826
826








2
1
7
2
3
2

Table 3: Comparison of different search heuristics in RockSample[7,8] environment, using
the Blind policy and PBVI as a lower bound.

state is independent of the other rock states (it only depends on the known robot position),
the complexity of computing Pr(z|b, a) and  (b, a, z) is greatly reduced. Effectively, the
computation of Pr(z|b, Checki ) reduces to: Pr(z|b, Checki ) = Pr(Accurate|XP , Checki ) 
Pr(XiR = z) + (1  Pr(Accurate|XP , Checki ))  (1  Pr(XiR = z)). The probability that
1+(Xp ,i)
, where (Xp , i) =
the sensor is accurate on rock i, Pr(Accurate|XP , Checki ) =
2
d(X
p ,i)/d0
2
, d(Xp , i) is the euclidean distance between position Xp and the position of rock i,
and d0 is a constant specifying the half efficiency distance. Pr(XiR = z) is obtained directly
from the probability (stored in b) that rock i is good. Similarly,  (b, a, z) can be computed
quite easily as the move actions deterministically affect variable XP , and a Checki action
only changes the probability associated to XiR according to the sensors accuracy.
To obtain our results in RockSample, we run each algorithm in each starting rock configuration 20 times (i.e. 20 runs for each of the 2k different joint rock states). The initial
belief state is the same for all these runs and consists of 0.5 that each rock is good, plus the
known initial robot position.
4.3.1 Real-Time Performance of Online Search
In Table 3, we present 95% confidence intervals on the mean of our metrics of interest, for
RockSample[7,8] (12545 states, 13 actions, 2 observations), with real-time contraints of 1
second per action. We compare performance using two different lower bounds, the Blind
policy and PBVI, and use QMDP for the upper bound in both cases. The performance of
the policy defined by each lower bound is shown in the comparison header. For RTBSS, the
notation RTBSS(k) indicates a k-step lookahead; we use the depth k that yields an average
online time closest to 1 second per action.
Return In terms of the return, we first observe that the AEMS2 and HSVI-BFS heuristics
obtain very similar results. Each of these obtains the highest return by a slight margin with
one of the lower bounds. BI-POMDP obtains a similar return when combined with the
691

fiRoss, Pineau, Paquet, & Chaib-draa

PBVI lower bound, but performs much worse with the Blind lower bound. The two other
heuristics, Satia and Lave, and AEMS1, perform considerably worse in terms of return with
either lower bound.
EBR and LBI In terms of error bound reduction and lower bound improvement, AEMS2
obtains the best results with both lower bounds. HSVI-BFS is a close second. This indicates that AEMS2 can more effectively reduce the true error than the other heuristics,
and therefore, guarantees better performance. While BI-POMDP tends to be less efficient
than AEMS2 and HSVI-BFS, it does significantly better than RTBSS, Satia and Lave, and
AEMS1, which only slightly improve the bounds in both case. Satia and Lave is unable
to increase the Blind lower bound, which explains why it obtains the same return as the
Blind policy. We also observe that the higher the error bound reduction and lower bound
improvement, the higher the average discounted return usually is. This confirms our intuition that guiding the search such as to minimize the error at the current belief bc is a good
strategy to obtain better return.
Nodes Reused In terms of the percentage of nodes reused, AEMS2 and HVSI-BFS
generally obtain the best scores. This allows these algorithms to maintain a higher number
of nodes in their trees, which could also partly explain why they outperform the other
heuristics in terms of return, error bound reduction and lower bound improvement. Note
that RTBSS does not reuse any node in the tree because the algorithm does not store the
tree in memory. As a consequence, the reuse percentage is always 0.
Online Time Finally, we also observe that AEMS2 requires less average online time per
action than the other algorithms to attain its performance. In general, a lower average
online time means the heuristic is efficient at finding -optimal actions in a small amount
of time. The running time for RTBSS is determined by the chosen depth, as it cannot stop
before completing the full lookahead search.
Summary Overall, we see that AEMS2 and HSVI-BFS obtain similar results. However
AEMS2 seems slightly better than HSVI-BFS, as it provides better performance guarantees
(lower error) within a shorter period of time. But the difference is not very significant. This
may be due to the small number of observations in this environment, in which case the two
heuristics expand the tree in very similar ways. In the next section, we explore a domain
with many more observations to evaluate the impact of this factor.
The lower performances of the three other heuristics can be explained by various reasons.
In the case of BI-POMDP, this is due to the fact that it does not take into account the
observation probabilities Pr(z|b, a) and discount factor  in the heuristic value. Hence
it tend to expand fringe nodes that did not affect significantly the value of the current
belief. As for Satia and Lave, its poor performance in the case of the Blind policy can be
explained by the fact that the fringe nodes that maximize this heuristic are always leaves
reached by a sequence of Move actions. Due to the deterministic nature of the Move actions
(Pr(z|b, a) = 1 for these actions, whereas Check actions have Pr(z|b, a) = 0.5 initially), the
heuristic value for fringe nodes reached by Move actions is much higher until the error is
reduced significantly. As a result, the algorithm never explores any nodes under the Check
actions, and the robot always follows the Blind policy (moving east, never checking or
sampling any rocks). This demonstrates the importance of restricting the choice of which
692

fiOnline Planning Algorithms for POMDPs

30

25

V(b0)

20

15

AEMS2
AEMS1
BIPOMDP
HSVIBFS
Satia

10

5 2
10

1

10

0

1

10

10

2

10

3

10

Time (s)

Figure 4: Evolution of the upper and lower bounds on RockSample[7,8].

leaves to explore to those reached by a sequence of actions maximizing the upper bound, as
done in AEMS2, HSVI-BFS and BI-POMDP. In the case of AEMS1, it probably behaves
less efficiently because the term it uses to estimate the probability that a certain action
is optimal is not a good approximation in this environment. Moreover, because AEMS1
does not restrict the exploration to the best solution graph, it probably also suffers, in part,
from the same problems as the Satia and Lave heuristic. RTBSS also did not perform very
well with the Blind lower bound. This is due to the short depth allowed to search the
tree, required to have a running time  1 second/action. This confirms that we can do
significantly better than an exhaustive search by having good heuristics to guide the search.
4.3.2 Long-Term Error Reduction of Online Heuristic Search
To compare the long term performance of the different heuristics, we let the algorithms run
in offline mode from the initial belief state of the environment, and log changes in the lower
and upper bound values of this initial belief state over 1000 seconds. Here, the initial lower
and upper bounds are provided by the Blind policy and QMDP respectively. We see from
Figure 4 that Satia and Lave, AEMS1 and BI-POMDP are not as efficient as HSVI-BFS
and AEMS2 at reducing the error on the bounds. One interesting thing to note is that
the upper bound tends to decrease slowly but continuously, whereas the lower bound often
increases in a stepwise manner. We believe this is due to the fact that the upper bound is
much tighter than the lower bound. We also observe that most of the error bound reduction
happens in the first few seconds of the search. This confirms that the nodes expanded earlier
in the tree have much more impact on the error of bc than those expanded very far in the
tree (e.g. after hundreds of seconds). This is an important result in support of using online
(as opposed to offline) methods.
693

fi22

22

20

20

Average Discounted Return

Average Discounted Return

Ross, Pineau, Paquet, & Chaib-draa

18
16
AEMS2
HSVIBFS
BIPOMDP

14
12
10
8
6 1
10

0

10

18
16

12
10
8
6 1
10

1

10

AEMS2 & Blind
AEMS2 & PBVI(8)
AEMS2 & PBVI(16)

14

Online Time (s)

0

10

1

10

Online Time (s)

Figure 5: Comparison of the return as a Figure 6: Comparison of the return as a
function of the online time in
function of the online time in
RockSample(10,10) for different
RockSample(10,10) for different
online methods.
offline lower bounds.

4.3.3 Influence of Offline and Online Time
We now compare how the performance of online approaches is influenced by the available
online and offline times. This allows us to verify if a particular method is better when the
available online time is shorter (or longer), or whether increasing the offline time could be
beneficial.
We consider the three approaches that have shown best overall performance so far (BIPOMDP, HSVI-BFS and AEMS2) and compare their average discounted return as a function of the online time constraint per action. Experiments were run in RockSample[10,10]
(102,401 states, 15 actions, 2 observations) for each of the following online time constraints:
0.1s, 0.2s, 0.5s, 1s, 2s, 5s and 10s. To vary the offline time, we used 3 different lower
bounds: Blind policy, PBVI with 8 belief points, and PBVI with 16 belief points, taking
respectively 15s, 82s, and 193s. The upper bound used is QMDP in all cases. These results
were obtained on an Intel Xeon 3.0 Ghz processor.
In Figure 5, we observe that AEMS2 fares significantly better than HSVI-BFS and
BI-POMDP for short time constraints. As the time constraint increases, AEMS2 and
HSVI-BFS performs similarly (no significant statistical difference). We also notice that
the performance of BI-POMDP stops improving after 1 second of planning time. This can
be explained by the fact that it does not take into account the observation probabilities
Pr(z|b, a), nor the discount factor. As the search tree grows bigger, more and more fringe
nodes have small probability of being reached in the future, such that it becomes more and
more important to take these probabilities into account in order to improve performance.
Otherwise, as we observe in the case of BI-POMDP, most expanded nodes do not affect the
quality of the solution found.
From Figure 6, we observe that increasing the offline time has a beneficial effect mostly
when we have very short real-time constraints. When more online planning time is available,
694

fiOnline Planning Algorithms for POMDPs

the difference between the performances of AEMS2 with the Blind lower bound, and AEMS2
with PBVI becomes insignificant. However, for online time constraints smaller than one
second, the difference in performance is very large. Intuitively, with very short real-time
constraints the algorithm does not have enough time to expand a lot of nodes, such that the
policy found relies much more on the bounds computed offline. On the other hand, with
longer time constraints, the algorithm has enough time to significantly improve the bounds
computed offline, and thus the policy found does not rely as much on the offline bounds.
4.4 FieldVisionRockSample
It seems from the results presented thus far that HSVI-BFS and AEMS2 have comparable
performance on standard domains. We note however that these environments have very
small observation sets (assuming observations with zero probability are removed). We
believe AEMS2 is especially well suited for domains with large observation spaces. However,
there are few such standard problems in the literature. We therefore consider a modified
version of the RockSample environment, called FieldVisionRockSample (Ross & Chaib-draa,
2007), which has an observation space size exponential in the number of rocks.
The FieldVisionRockSample (FVRS) problem differs from the RockSample problem only
in the way the robot is able to perceive the rocks in the environment. Recall that in
RockSample, the agent has to do a Check action on a specific rock to observe its state
through a noisy sensor. In FVRS, the robot observes the state of all rocks, through the
same noisy sensor, after any action is conducted in the environment. Consequently, this
eliminates the use of Check actions, and the remaining actions for the robot include only
the four move actions {North, East, South, West} and the Sample action. The robot can
perceive each rock as being either Good or Bad, thus the observation space size is 2k for
an instance of the problem with k rocks. As in RockSample, the efficiency of the sensor is
defined through the parameter  = 2d/d0 , where d is the distance of the rock and d0 is the
half efficiency distance. We assume the sensors observations are independent for each rock.
In FVRS, the partial observability of the environment is directly proportional to the
parameter d0 : as d0 increases, the sensor becomes more accurate and the uncertainty on
the state of the environment decreases. The value d0 defined for the different instances of
RockSample in the work of Smith and Simmons (2004) is too high for the FVRS problem
(especially in the bigger instances of RockSample), making it almost completely observable.
Consequently, we re-define the value d0 for the different instances of the FieldVisionRockSample according to the size of the grid (n). By considering the fact that
p in an n  n grid,
the largest possible distance between a rock and the robot is (n  1) (2), it seems reasonable that at this distance, the probability of observing the real state of the rock should
be close to 50%
p for the problem to remain partially observable. Consequently, we define
d0 = (n  1) (2)/4.
To obtain results for the FVRS domain, we run each algorithm in each starting rock
configurations 20 times (i.e. 20 runs for each of the 2k different joint rock states). The
initial belief state is the same for all runs and corresponds to a probability of 0.5 that each
rock is good, as well as the known initial position of the robot.
695

fiRoss, Pineau, Paquet, & Chaib-draa

Heuristic
RTBSS(2)
AEMS1
Satia and Lave
HSVI-BFS
AEMS2
BI-POMDP
RTBSS(1)
BI-POMDP
Satia and Lave
AEMS1
AEMS2
HSVI-BFS

Belief
Nodes
Return
EBR (%)
LBI
Nodes
Reused (%)
FVRS[5,5] [Blind: Return:8.15, || = 1, Time=170ms]
16.54  0.37
18.4  1.1
2.80  0.19
18499  102
00
16.88  0.36
17.1  1.1
2.35  0.16
8053  123
1.19  0.07
18.68  0.39
15.9  1.2
2.17  0.16
7965  118
0.88  0.06
20.27  0.44
23.8  1.4
2.64  0.14
4494  105
4.50  0.80
21.18  0.45
31.5  1.5
3.11  0.15
12301  440
3.93  0.22
22.75  0.47
31.1  1.2
3.30  0.17
12199  427
2.26  0.44
FVRS[5,7] [Blind: Return:8.15, || = 1, Time=761ms]
20.57  0.23
7.72  0.13
2.07  0.11
516  1
00
22.75  0.25
11.1  0.4
2.08  0.07
4457  61
0.37  0.11
22.79  0.25
11.1  0.4
2.05  0.08
3683  52
0.36  0.07
23.31  0.25
12.4  0.4
2.24  0.08
3856  55
1.36  0.13
23.39  0.25
13.3  0.4
2.35  0.08
4070  58
1.64  0.14
23.40  0.25
13.0  0.4
2.30  0.08
3573  52
1.69  0.27

Online
Time (ms)
3135  27
876  5
878  4
857  12
854  13
782  12
254
923
947
942
944
946








1
2
3
3
2
3

Table 4: Comparison of different search heuristics on different instances of the FieldVisionRockSample environment.

4.4.1 Real-Time Performance of Online Search
In Table 4, we present 95% confidence intervals on the mean for our metrics of interest. We
consider two instances of this environment, FVRS[5,5] (801 states, 5 actions, 32 observations) and FVRS[5,7] (3201 states, 5 actions, 128 observations). In both cases, we use the
QMDP upper bound and Blind lower bound, under real-time constraints of 1 second per
action.
Return In terms of return, we do not observe any clear winner. BI-POMDP performs surpringly well in FVRS[5,5] but significantly worse than AEMS2 and HSVI-BFS in FVRS[5,7].
On the other hand, AEMS2 does significantly better than HSVI-BFS in FVRS[5,5] but both
get very similar performances in FVRS[5,7]. Satia and Lave performs better in this environment than in RockSample. This is likely due to the fact that the transitions in belief
space are no longer deterministic (as was the case with the Move actions in RockSample).
In FVRS[5,5], we also observe that even when RTBSS is given 3 seconds per action to
perform a two-step lookahead, its performance is worse than any of the heuristic search
methods. This clearly shows that expanding all observations equally in the search is not
a good strategy, as many of these observations can have negligible impact for the current
decision.
EBR and LBI In terms of error bound reduction and lower bound improvement, we observe that AEMS2 performs much better than HSVI-BFS in FVRS[5,5], but not significantly
better in FVRS[5,7]. On the other hand, BI-POMDP obtains similar results to AEMS2 in
FVRS[5,5] but does significantly worse in terms of EBR and LBI than in FVRS[5,7]. This
suggests that AEMS2 is consistently effective at reducing the error, even in environments
with large branching factors.
Nodes Reused The percentage of belief nodes reused is much lower in FVRS due to the
much higher branching factor. We observe that HSVI-BFS has the best reuse percentage
696

fiOnline Planning Algorithms for POMDPs

26

35

24
30

22
20

16
14

25
AEMS2
AEMS1
BIPOMDP
HSVIBFS
Satia

V(b0)

V(b0)

18

20

AEMS2
AEMS1
BIPOMDP
HSVIBFS
Satia

15

12
10

10

8
6 2
10

1

10

0

1

10

10

2

10

5 1
10

3

10

Time (s)

0

10

1

10
Time (s)

2

10

3

10

Figure 7: Evolution of the upper and lower Figure 8: Evolution of the upper and lower
bounds on FieldVisionRockSambounds on FieldVisionRockSample[5,5].
ple[5,7].

in all environments, however not significantly higher than AEMS2. Both of these methods
reuse significantly larger portion of the tree than the other methods. This confirms that
these two methods are able to guide the search towards the most likely beliefs.
4.4.2 Long-Term Error Reduction of Online Heuristic Search
Overall, while Table 4 confirms the consistent performance of HSVI-BFS and AEMS2, the
difference with other heuristics is modest. Considering the complexity of this environment,
this may be due to the fact that the algorithms do not have enough time to expand a
significant number of nodes within 1 second. The long-term analysis of the bounds evolution
in Figures 7 and 8 confirms this. We observe in these figures that the lower bound converges
slightly more rapidly with AEMS2 than with other heuristics. The AEMS1 heuristic also
performs well in the long run on this problem, and seems to be the second best heuristic,
while Satia and Lave is not far behind. On the other hand, the HSVI-BFS heuristic is far
worse in this problem than in RockSample. This seems to be in part due to the fact that
this heuristic takes more time to find the next node to expand than the others, and thus
explores fewer belief states.

5. Discussion
The previous sections presented and evaluated several online POMDP algorithms. We now
discuss important issues that arise when applying online methods in practice, and summarize
some of their advantages and disadvantages. This should help researchers decide whether
online algorithms are a good approach for solving a given problem.
697

fiRoss, Pineau, Paquet, & Chaib-draa

5.1 Lower and Upper Bound Selection
Online algorithms can be combined with many valid lower and upper bounds. However,
there are some properties that these bounds should satisfy for the online search to perform efficiently in practice. One of the desired properties is that the lower and upper
bound functions
should
property states that b : L(b) 


P be monotone. The monotone
maxaA RB (b, a) +  PzZ Pr(z|b, a)L( (b, a, z))  for the lower bound and b : U (b) 
maxaA RB (b, a) +  zZ Pr(z|b, a)U ( (b, a, z)) for the upper bound. This property
guarantees that when a certain fringe node is expanded, its lower bound is non-decreasing
and its upper bound is non-increasing. This is sufficient to guarantee that the error bound
UT (b)  LT (b) on b is non-increasing after the expansion of b, such that the error bound
given by the algorithm on the value of the root belief state bc , cannot be worse than the
error bound defined by the initial bounds given. Note however that monotonicity is not
necessary for AEMS to converge to an -optimal solution, as shown in previous work (Ross
et al., 2008); boundedness is sufficient.
5.2 Improving the Bounds over Time
As we mentioned in our survey of online algorithms, one drawback of many online approaches is that they do not store improvements made to the offline bounds during the
online search, such that, if the same belief state is encountered again, the same computations need to be performed again, restarting from the same offline bounds. A trivial way
to improve this is to maintain a large hashtable (or database) of belief states for which we
have improved the lower and upper bounds in previous search, with their associated new
bounds. There are however many drawbacks in doing this. First every time we want to
evaluate the lower and upper bound of a fringe belief, a search through this hashtable needs
to be performed to check if we have better bounds available. This may require significant
time if the hashtable is large (e.g. millions of beliefs). Furthermore, experiments conducted
with RTDP-Bel in large domains, such as RockSample[7,8], have shown that such a process
usually runs out of memory (i.e. requires more than 1 GB) before good performance is
achieved and requires several thousands episodes before performing well (Paquet, 2006).
The authors of RTBSS have also tried combining their search algorithm with RTDPBel such as to preserve the improvements made by the search (Paquet, 2006). While this
combination usually performed better and learned faster than RTDP-Bel alone, it was found
that in most domains, a few thousand episodes are still required before any improvement
can be seen (in terms of return). Hence, such point updates of the offline bounds tend to
be useful in large domains only if the task to accomplish is repeated a very large number
of times.
A better strategy to improve the lower bound might be to save some time to perform
-vector updates for some of the beliefs expanded during the search, such that the offline
lower bound improves over time. Such updates have the advantage of improving the lower
bound over the whole belief space, instead of at a single belief state. However this can be
very time consuming, especially in large domains. Hence, if we need to act within very short
time constraints, such an approach is infeasible. However if several seconds of planning time
are available per action, then it might be advantageous to use some of this time to perform
-vector updates, rather than use all the available time to search through the tree. A good
698

fiOnline Planning Algorithms for POMDPs

idea here would be to perform -vector updates for a subset of the beliefs in the search tree,
where the lower bound most improves.
5.3 Factored POMDP Representations
The efficiency of online algorithms relies heavily on the ability to quickly compute  (b, a, z)
and Pr(z|b, a), as these must be computed for evey belief state in the search tree. Using
factored POMDP representations is an effective way to reduce the time complexity of computing these quantities. Since most environments with large state spaces are structured and
can be described by sets of features, obtaining factored representation of complex systems
should not be an issue in most cases. However, in domains with significant dependencies
between state features, it may be useful to use algorithms proposed by Boyen and Koller
(1998) and Poupart (2005) to find approximate factored representations where most features
are independent, with minimal degradation in the solution quality. While the upper and
lower bounds might not hold anymore if they are computed over the approximate factored
representation, usually it may still yield good results in practice.
5.4 Handling Graph Structure
As we have mentioned before, the general tree search algorithm used by online algorithms
will duplicate belief states whenever there are multiple paths leading to the same posterior
belief from the current belief bc . This greatly simplifies the complexity related to updating
the values of ancestor nodes, and it also reduces the complexity related to finding the
best fringe node to expand (using the technique in Section 3.4 which is only valid for
trees). The disadvantage of using a tree structure is that inevitably, some computations
will be redundant, as the algorithm will potentially expand the same subtree under every
duplicate belief. To avoid this, we could use the LAO algorithm proposed by Hansen and
Zilberstein (2001) as an extension of AO that can handle generic graph structure, including
cyclic graphs. After each expansion, it runs a value (or policy) iteration algorithm until
convergence among all ancestor nodes in order to update their values.
The heuristics we surveyed in Section 3.4 can be generalized to guide best-first search
algorithms that handle graph structure, like LAO . The first thing to notice is that, in
any graph, if a fringe node is reached by multiple paths, then its error contributes multiple
times to the error on the value of bc . Under this error contribution perspective, the heuristic
value of such a fringe node should be the sum of its heuristic values over all paths reaching
it. For instance, in the case of the AEMS heuristic, using the notation we have defined in
Section 3.4, the global heuristic value of a given fringe node b, on the current belief state
bc in any graph G, can be computed as follows:
HG (bc , b) = (U (b)  L(b))

X

 d(h) Pr(h|bc , G ).

(38)

hHG (bc ,b)

Notice that for cyclic graphs, there can be infinitely many paths in HG (bc , b). In such
case, we could use dynamic programming to estimate the heuristic value.
Because solving HG (bc , b) for all fringe nodes b in the graph G will require a lot of time
in practice, especially if there are many fringe nodes, we have not experimented with this
method in Section 4. However, it would be practical to use this heuristic if we could find an
699

fiRoss, Pineau, Paquet, & Chaib-draa

alternative way to determine the best fringe node without computing HG (bc , b) separately
for each fringe node b and performing an exhaustive search over all fringe nodes.
5.5 Online vs. Offline Time
One important aspect determining the efficiency and applicability of online algorithms is
the amount of time available during the execution for planning. This of course is often taskdependent. For real-time problems like robot navigation, this amount of time may be very
short, e.g. between 0.1 to 1 second per action. On the other hand for tasks like portfolio
management, where acting every second is not necessary, several minutes could easily be
taken to plan any stock buying/selling action. As we have seen from our experiments, the
shorter the available online planning time, the greater the importance of having a good
offline value function to start with. In such case, it is often necessary to reserve sufficient
time to compute a good offline policy. As more and more planning time is available online,
the influence of the offline value function becomes negligible, such that a very rough offline
value function is sufficient to obtain good performance. The best trade-off between online
and offline time often depends on how large the problem is. When the branching factor
(|A||Z|) is large and/or computing successor belief states takes a long time, then more online
time will be required to achieve a significant improvement over the offline value function.
However, for small problems, an online time of 0.1 second per action may be sufficient to
perform near-optimally even with a very rough offline value function.
5.6 Advantages and Disadvantages of Online Algorithms
We now discuss the advantages and disadvantages of online planning algorithms in general.
5.6.1 Advantages
 Most online algorithms can be combined with any offline solving algorithm, assuming
it provides a lower bound or an upper bound on V  , such as to improve the quality
of the policy found offline.
 Online algorithms require very little offline computation before being executable in an
environment, as they can perform well even using very loose bounds, which are quick
to compute.
 Online methods can exploit the knowledge of the current belief to focus computation
on the most relevant future beliefs for the current decision, such that they scale well
to large action and observation spaces.
 Anytime online methods are applicable in real-time environments, as they can be
stopped whenever planning time runs out, and still provide the best solution found
so far.
5.6.2 Disadvantages
 The branching factor depends on the number of actions and observations. Thus if
there are many observations and/or actions, it might be impossible to search deep
700

fiOnline Planning Algorithms for POMDPs

enough, to provide significant improvement of the offline policy. In such cases, sampling methods designed to reduce the branching factor could be useful. While we
cannot guarantee that the lower and upper bounds are still valid when sampling is
used, we can guarantee that they are valid with high probability, given that enough
samples are drawn.
 Most online algorithms do not store improvements made to the offline policy by the
online search, and so the algorithm has to plan again with the same bounds each time
the environment is restarted. If time is available, it could be advantageous to add
-vector updates for some belief states explored in the tree, so that the offline bounds
improve with time.

6. Conclusion
POMDPs provide a rich and elegant framework for planning in stochastic partially observable domains, however their time complexity has been a major issue preventing their
application to complex real-world systems. This paper thoroughly surveys the various existing online algorithms and the key techniques and approximations used to solve POMDPs
more efficiently. We empirically compare these online approaches in several POMDP domains under different metrics: average discounted return, average error bound reduction
and average lower bound improvement, and using different lower and upper bounds: PBVI,
Blind, FIB and QMDP.
From the empirical results, we observe that some of the heuristic search methods, namely
AEMS2 and HSVI-BFS, obtain very good performances, even in domains with large branching factors and large state spaces. These two methods are very similar and perform well
because they orient the search towards nodes that can improve the current approximate
value function as quickly as possible; i.e. the belief nodes that have largest error and are
most likely to be reached in the future by promising actions. However, in environments
with large branching factors, we may only have time to expand a few nodes at each turn.
Hence, it would be interesting to develop further approximations to reduce the branching
factor in such cases.
In conclusion, we believe that online approaches have an important role to play in
improving the scalability of POMDP solution methods. A good example is the succesful
applications of the RTBSS algorithm to the RobocupRescue simulation by Paquet et al.
(2005). This environment is very challenging as the state space is orders of magnitude
beyond the scope of current algorithms. Offline algorithms remain very important to obtain
tight lower and upper bounds on the value function. The interesting question is not whether
online or offline approaches are better, but how we can improve both kinds of approaches,
such that their synergy can be exploited to solve complex real-world problems.

Acknowledgments
This research was supported by the Natural Sciences and Engineering Council of Canada
and the Fonds Quebecois de la Recherche sur la Nature et les Technologies. We would also
like to thank the anonymous reviewers for their helpful comments and suggestions.
701

fiRoss, Pineau, Paquet, & Chaib-draa

References
Astrom, K. J. (1965). Optimal control of Markov decision processes with incomplete state
estimation. Journal of Mathematical Analysis and Applications, 10, 174205.
Barto, A. G., Bradtke, S. J., & Singhe, S. P. (1995). Learning to act using real-time dynamic
programming. Artificial Intelligence, 72 (1), 81138.
Bellman, R. (1957). Dynamic Programming. Princeton University Press, Princeton, NJ,
USA.
Bertsekas, D. P., & Castanon, D. A. (1999). Rollout algorithms for stochastic scheduling
problems. Journal of Heuristics, 5 (1), 89108.
Boyen, X., & Koller, D. (1998). Tractable inference for complex stochastic processes. In
In Proceedings of the Fourteenth Conference on Uncertainty in Artificial Intelligence
(UAI-98), pp. 3342.
Braziunas, D., & Boutilier, C. (2004). Stochastic local search for POMDP controllers. In The
Nineteenth National Conference on Artificial Intelligence (AAAI-04), pp. 690696.
Cassandra, A., Littman, M. L., & Zhang, N. L. (1997). Incremental pruning: a simple, fast,
exact method for partially observable Markov decision processes. In Proceedings of the
Thirteenth Conference on Uncertainty in Artificial Intelligence (UAI-97), pp. 5461.
Chang, H. S., Givan, R., & Chong, E. K. P. (2004). Parallel rollout for online solution
of partially observable Markov decision processes. Discrete Event Dynamic Systems,
14 (3), 309341.
Geffner, H., & Bonet, B. (1998). Solving large POMDPs using real time dynamic programming. In Proceedings of the Fall AAAI symposium on POMDPs, pp. 6168.
Hansen, E. A. (1998). Solving POMDPs by searching in policy space. In Fourteenth Conference on Uncertainty in Artificial Intelligence (UAI-98), pp. 211219.
Hansen, E. A., & Zilberstein, S. (2001). LAO * : A heuristic search algorithm that finds
solutions with loops. Artificial Intelligence, 129 (1-2), 3562.
Hauskrecht, M. (2000). Value-function approximations for partially observable Markov
decision processes. Journal of Artificial Intelligence Research, 13, 3394.
Kaelbling, L. P., Littman, M. L., & Cassandra, A. R. (1998). Planning and acting in
partially observable stochastic domains. Artificial Intelligence, 101, 99134.
Kearns, M. J., Mansour, Y., & Ng, A. Y. (1999). A sparse sampling algorithm for nearoptimal planning in large markov decision processes. In Proceedings of the Sixteenth
International Joint Conference on Artificial Intelligence (IJCAI-99), pp. 13241331.
Koenig, S. (2001). Agent-centered search. AI Magazine, 22 (4), 109131.
Littman, M. L. (1996). Algorithms for sequential decision making. Ph.D. thesis, Brown
University.
Littman, M. L., Cassandra, A. R., & Kaelbling, L. P. (1995). Learning policies for partially observable environments: scaling up. In Proceedings of the 12th International
Conference on Machine Learning (ICML-95), pp. 362370.
702

fiOnline Planning Algorithms for POMDPs

Lovejoy, W. S. (1991). Computationally feasible bounds for POMDPs. Operations Research,
39 (1), 162175.
Madani, O., Hanks, S., & Condon, A. (1999). On the undecidability of probabilistic planning
and infinite-horizon partially observable Markov decision problems. In Proceedings of
the Sixteenth National Conference on Artificial Intelligence. (AAAI-99), pp. 541548.
McAllester, D., & Singh, S. (1999). Approximate Planning for Factored POMDPs using Belief State Simplification. In Proceedings of the 15th Annual Conference on Uncertainty
in Artificial Intelligence (UAI-99), pp. 409416.
Monahan, G. E. (1982). A survey of partially observable Markov decision processes: theory,
models and algorithms. Management Science, 28 (1), 116.
Nilsson, N. (1980). Principles of Artificial Intelligence. Tioga Publishing.
Papadimitriou, C., & Tsitsiklis, J. N. (1987). The complexity of Markov decision processes.
Mathematics of Operations Research, 12 (3), 441450.
Paquet, S. (2006). Distributed Decision-Making and Task Coordination in Dynamic, Uncertain and Real-Time Multiagent Environments. Ph.D. thesis, Laval University.
Paquet, S., Chaib-draa, B., & Ross, S. (2006). Hybrid POMDP algorithms. In Proceedings
of The Workshop on Multi-Agent Sequential Decision Making in Uncertain Domains
(MSDM-06), pp. 133147.
Paquet, S., Tobin, L., & Chaib-draa, B. (2005). An online POMDP algorithm for complex
multiagent environments. In Proceedings of The fourth International Joint Conference
on Autonomous Agents and Multi Agent Systems (AAMAS-05), pp. 970977.
Pineau, J., Gordon, G., & Thrun, S. (2003). Point-based value iteration: an anytime algorithm for POMDPs. In Proceedings of the International Joint Conference on Artificial
Intelligence (IJCAI-03), pp. 10251032.
Pineau, J., Gordon, G., & Thrun, S. (2006). Anytime point-based approximations for large
POMDPs. Journal of Artificial Intelligence Research, 27, 335380.
Pineau, J. (2004). Tractable planning under uncertainty: exploiting structure. Ph.D. thesis,
Carnegie Mellon University.
Poupart, P. (2005). Exploiting structure to efficiently solve large scale partially observable
Markov decision processes. Ph.D. thesis, University of Toronto.
Poupart, P., & Boutilier, C. (2003). Bounded finite state controllers. In Advances in Neural
Information Processing Systems 16 (NIPS).
Puterman, M. L. (1994). Markov Decision Processes: Discrete Stochastic Dynamic Programming. John Wiley & Sons, Inc.
Ross, S., & Chaib-draa, B. (2007). Aems: An anytime online search algorithm for approximate policy refinement in large POMDPs. In Proceedings of the 20th International
Joint Conference on Artificial Intelligence (IJCAI-07), pp. 25922598.
Ross, S., Pineau, J., & Chaib-draa, B. (2008). Theoretical analysis of heuristic search
methods for online POMDPs. In Advances in Neural Information Processing Systems
20 (NIPS).
703

fiRoss, Pineau, Paquet, & Chaib-draa

Satia, J. K., & Lave, R. E. (1973). Markovian decision processes with probabilistic observation of states. Management Science, 20 (1), 113.
Shani, G., Brafman, R., & Shimony, S. (2005). Adaptation for changing stochastic environments through online POMDP policy learning. In Proceedings of the Workshop on
Reinforcement Learning in Non-Stationary Environments, ECML 2005, pp. 6170.
Smallwood, R. D., & Sondik, E. J. (1973). The optimal control of partially observable
Markov processes over a finite horizon. Operations Research, 21 (5), 10711088.
Smith, T., & Simmons, R. (2004). Heuristic search value iteration for POMDPs. In Proceedings of the 20th Conference on Uncertainty in Artificial Intelligence (UAI-04), pp.
520527.
Smith, T., & Simmons, R. (2005). Point-based POMDP algorithms: improved analysis and
implementation. In Proceedings of the 21th Conference on Uncertainty in Artificial
Intelligence (UAI-05), pp. 542547.
Sondik, E. J. (1971). The optimal control of partially observable Markov processes. Ph.D.
thesis, Stanford University.
Sondik, E. J. (1978). The optimal control of partially observable Markov processes over the
infinite horizon: Discounted costs. Operations Research, 26 (2), 282304.
Spaan, M. T. J., & Vlassis, N. (2004). A point-based POMDP algorithm for robot planning.
In In Proceedings of the IEEE International Conference on Robotics and Automation
(ICRA-04), pp. 23992404.
Spaan, M. T. J., & Vlassis, N. (2005). Perseus: randomized point-based value iteration for
POMDPs. Journal of Artificial Intelligence Research, 24, 195220.
Vlassis, N., & Spaan, M. T. J. (2004). A fast point-based algorithm for POMDPs. In
Benelearn 2004: Proceedings of the Annual Machine Learning Conference of Belgium
and the Netherlands, pp. 170176.
Washington, R. (1997). BI-POMDP: bounded, incremental partially observable Markov
model planning. In Proceedings of the 4th European Conference on Planning, pp.
440451.
Zhang, N. L., & Zhang, W. (2001). Speeding up the convergence of value iteration in partially observable Markov decision processes. Journal of Artificial Intelligence Research,
14, 2951.

704

fi