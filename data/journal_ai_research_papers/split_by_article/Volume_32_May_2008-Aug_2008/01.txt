Journal of Artificial Intelligence Research 32 (2008) 37-94

Submitted 08/07; published 05/08

Extended RDF as a Semantic Foundation of
Rule Markup Languages
Anastasia Analyti

analyti@ics.forth.gr

Institute of Computer Science, FORTH-ICS, Crete, Greece

Grigoris Antoniou

antoniou@ics.forth.gr

Institute of Computer Science, FORTH-ICS, Crete, Greece
Department of Computer Science, University of Crete, Greece

Carlos Viegas Damasio

cd@di.fct.unl.pt

Centro de Inteligencia Artificial, Universidade Nova de Lisboa,
Caparica, Portugal

Gerd Wagner

G.Wagner@tu-cottbus.de

Institute of Informatics, Brandenburg University
of Technology at Cottbus, Germany

Abstract
Ontologies and automated reasoning are the building blocks of the Semantic Web initiative. Derivation rules can be included in an ontology to define derived concepts, based on
base concepts. For example, rules allow to define the extension of a class or property, based
on a complex relation between the extensions of the same or other classes and properties.
On the other hand, the inclusion of negative information both in the form of negation-asfailure and explicit negative information is also needed to enable various forms of reasoning.
In this paper, we extend RDF graphs with weak and strong negation, as well as derivation
rules. The ERDF stable model semantics of the extended framework (Extended RDF) is
defined, extending RDF(S) semantics. A distinctive feature of our theory, which is based
on Partial Logic, is that both truth and falsity extensions of properties and classes are
considered, allowing for truth value gaps. Our framework supports both closed-world and
open-world reasoning through the explicit representation of the particular closed-world assumptions and the ERDF ontological categories of total properties and total classes.

1. Introduction
The idea of the Semantic Web is to describe the meaning of web data in a way suitable
for automated reasoning. This means that descriptive data (meta-data) in machine readable form are to be stored on the web and used for reasoning. Due to its distributed and
world-wide nature, the Web creates new problems for knowledge representation research.
Berners-Lee (1998) identifies the following fundamental theoretical problems: negation and
contradictions, open-world versus closed-world assumptions, and rule systems for the Semantic Web. For the time being, the first two issues have been circumvented by discarding
the facilities to introduce them, namely negation and closed-world assumptions. Though the
web ontology language OWL (McGuinness & van Harmelen, 2004), which is based on Description Logics (DLs) (Baader, Calvanese, McGuinness, Nardi, & Patel-Schneider, 2003),
includes a form of classical negation through class complements, this form is limited. This
c
2008
AI Access Foundation. All rights reserved.

fiAnalyti, Antoniou, Damasio, & Wagner

is because, to achieve decidability, classes are formed based on specific class constructors
and negation on properties is not fully considered. Rules constitute the next layer over the
ontology languages of the Semantic Web and, in contrast to DL, allow arbitrary interaction
of variables in the body of the rules. The widely recognized need of having rules in the Semantic Web, demonstrated by the Rule Markup Initiative1 , has restarted the discussion of
the fundamentals of closed-world reasoning and the appropriate mechanisms to implement
it in rule systems.
The RDF(S)2 recommendation (Klyne & Carroll, 2004; Hayes, 2004) provides the basic constructs for defining web ontologies and a solid ground to discuss the above issues.
RDF(S) is a special predicate logical language that is restricted to existentially quantified conjunctions of atomic formulas, involving binary predicates only. Due to its purpose,
RDF(S) has a number of special features that distinguish it from traditional logic languages:
1. It uses a special jargon, where the things of the universe of discourse are called resources, types are called classes, and binary predicates are called properties. Like
binary relations in set theory, properties have a domain and a range. Resources are
classified with the help of the property rdf :type (for stating that a resource is of type
c, where c is a class).
2. It distinguishes a special sort of resources, called literal values, which are denotations
of lexical representations of strings, numbers, dates, or other basic datatypes.
3. Properties are resources, that is, properties are also elements of the universe of discourse. Consequently, it is possible to state properties of properties, i.e., make statements about predicates.
4. All resources, except anonymous ones and literal values, are named with the help of
a globally unique reference schema, called Uniform Resource Identifier (URI)3 , that
has been developed for the Web.
5. RDF(S) comes with a non-standard model-theoretic semantics developed by Pat Hayes
on the basis of an idea of Christopher Menzel, which allows self-application without
violating the axiom of foundation. An example of this is the provable sentence stating
that rdfs:Class, the class of all classes, is an instance of itself.
However, RDF(S) does not support negation and rules. Wagner (1991) argues that a
database, as a knowledge representation system, needs two kinds of negation, namely weak
negation  (expressing negation-as-failure or non-truth) and strong negation  (expressing
explicit negative information or falsity) to be able to deal with partial information. In
a subsequent paper, Wagner (2003) makes also this point for the Semantic Web, as a
framework for knowledge representation in general. In the present paper, we make the
same argument for the Semantic Web language RDF and show how it can be extended
to accommodate the two negations of Partial Logic (Herre, Jaspars, & Wagner, 1999), as
well as derivation rules. We call the new language Extended RDF and denote it by ERDF.
1. http://www.ruleml.org/
2. RDF(S) stands for Resource Description Framework (Schema).
3. http://gbiv.com/protocols/uri/rfc/rfc3986.html

38

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

The model-theoretic semantics of ERDF, called ERDF stable model semantics, is developed
based on Partial Logic (Herre et al., 1999).
In Partial Logic, relating strong and weak negation at the interpretation level allows to
distinguish four categories of properties and classes. Partial properties are properties p that
may have truth-value gaps and truth-value clashes, that is p(x, y) is possibly neither true
nor false, or both true and false. Total properties are properties p that satisfy totalness,
that is p(x, y) is true or false (but possibly both). Coherent properties are properties p that
satisfy coherence, that is p(x, y) cannot be both true and false. Classical properties are total
and coherent properties. For classical properties p, the classical logic law applies: p(x, y) is
either true or false. Partial, total, coherent, and classical classes c are defined similarly, by
replacing p(x, y) by rdf :type(x, c).
Partial logic also allows to distinguish between properties (and classes) that are completely represented in a knowledge base and those that are not. The classification if a
property is completely represented or not is up to the owner of the knowledge base: the
owner must know for which properties there is complete information and for which there
is not. Clearly, in the case of a completely represented (closed ) property p, entailment of
p(x, y) allows to derive p(x, y), and the underlying completeness assumption has also
been called Closed-World Assumption (CWA) in the AI literature.
Such a completeness assumption for closing a partial property p by default may be
expressed in ERDF by means of the rule p(?x, ?y)  p(?x, ?y) and for a partial class
c, by means of the rule rdf :type(?x, c)  rdf :type(?x, c). These derivation rules are
called default closure rules. In the case of a total property p, default closure rules are
not applicable. This is because, some of the considered interpretations will satisfy p(x, y)
and the rest p(x, y)4 , preventing the preferential entailment of p(x, y). Thus, on total
properties, an Open-World Assumption (OWA) applies. Similarly to first-order-logic, in
order to infer negated statements about total properties, explicit negative information has
to be supplied, along with ordinary (positive) information.
As an example, consider an ERDF knowledge base KB that contains the facts:
interestedIn(Anastasia, SemanticWeb)

interestedIn(Grigoris, Robotics)

indicating that Anastasia is interested in the SemanticWeb area and Grigoris is interested
in the Robotics area. Then, the statement interestedIn(Anastasia, Robotics) is not satisfied
in the single intended model of KB . Thus, KB entails interestedIn(Anastasia, Robotics).
Assume now that the previous list of areas of interest is not complete for Anastasia or
Grigoris. Then, we should add to knowledge base KB the statement:
rdf :type(interestedIn, erdf :TotalProperty)
indicating that interestedIn is a total property. In this case, an open-world assumption is made for interestedIn and KB does not entail interestedIn(Anastasia, Robotics),
any longer. In particular, there is an intended model of the revised KB that satisfies
interestedIn(Anastasia, Robotics). Of course, if it is known that Anastasia is not interested
in Robotics then interestedIn(Anastasia, Robotics) should be added to KB .
Assume now that we add to KB the following facts:
4. On total properties p, the Law of Excluded Middle p(x, y)p(x, y) applies.

39

fiAnalyti, Antoniou, Damasio, & Wagner

hasCar (Anastasia, Suzuki )

hasCar (Grigoris, Volvo)

and assume that KB has complete knowledge on the property hasCar , as far as it concerns
elements in the Herbrand Universe of KB . Then, the default closure rule hasCar (?x , ?y) 
hasCar (?x , ?y) can be safely added to KB . As a result, hasCar (Anastasia, Volvo) is
satisfied in all intended models of KB . Thus, KB entails hasCar (Anastasia, Volvo).
The previous example shows the need for supporting both closed-world and open-world
reasoning in the same framework. Damasio et al. (2006) and Analyti et al. (2004) provide
further examples and arguments for this need. Unfortunately, classical logic and thus also
OWL support only open-world reasoning.
Specifically, in this paper:
1. We extend RDF graphs to ERDF graphs with the inclusion of strong negation, and
then to ERDF ontologies (or ERDF knowledge bases) with the inclusion of general
derivation rules. ERDF graphs allow to express existential positive and negative
information, whereas general derivation rules allow inferences based on formulas built
using the connectives , , , ,  and the quantifiers , .
2. We extend the vocabulary of RDF(S) with the terms erdf :TotalProperty and
erdf :TotalClass, representing the metaclasses of total properties and total classes, on
which the open-world assumption applies.
3. We extend RDFS interpretations to ERDF interpretations including both truth and
falsity extensions for properties and classes. Particularly, we consider only coherent
ERDF interpretations (imposing coherence on all properties). Thus, in this paper,
total properties and classes become synonymous to classical properties and classes.
4. We extend RDF graphs to ERDF formulas that are built from positive triples, using
the connectives , , , ,  and the quantifiers , . Then, we define ERDF
entailment between two ERDF formulas, extending RDFS entailment between RDF
graphs.
5. We define the ERDF models, the Herbrand interpretations, and the minimal Herbrand
models of an ERDF ontology. Since not all minimal Herbrand models of an ERDF
ontology are intended, we define the stable models of an ERDF ontology. The definition
of a stable model is based on the intuition that:
(a) assertions stating that a property p or class c is total should only be accepted, if
the ontology contains some direct support for them in the form of an acceptable
rule sequence, and
(b) assertions []p(s, o) and []rdf :type(o, c) should only be accepted, if (i) the ontology contains some direct support for them in the form of an acceptable rule
sequence, or (ii) property p and class c are total, respectively.
6. We show that stable model entailment on ERDF ontologies extends ERDF entailment
on ERDF graphs, and thus it also extends RDFS entailment on RDF graphs. Moreover, we show that if all properties are total, (boolean) Herbrand model reasoning and
stable model reasoning coincide. In this case, we make an open-world assumption for
all properties and classes.
40

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

A distinctive feature of the developed framework with respect to Partial Logic (Herre
et al., 1999) is that properties and classes are declared as total on a selective basis, by
extending RDF(S) with new built-in classes and providing support for the respective ontological categories. In contrast, in Partial Logic (Herre et al., 1999), the choice of partial or
total should be taken for the complete set of predicates. Thus, the approach presented here
is, in this respect, more flexible and general.
This work extends our conference paper (Analyti, Antoniou, Damasio, & Wagner, 2005)
by (i) considering the full RDFS model, (ii) providing a detailed characterization of the
properties of ERDF interpretations/models, Herbrand interpretations/models, and finally
ERDF stable models, (iii) discussing decidability issues, and (iv) providing formal proofs of
all lemmas and propositions.
The rest of the paper is organized as follows: In Section 2, we extend RDF graphs to
ERDF graphs and ERDF formulas. Section 3 defines ERDF interpretations and ERDF
entailment. We show that ERDF entailment extends RDFS entailment. In Section 4, we
define ERDF ontologies and the Herbrand models of an ERDF ontology. In Section 5, we
define the stable models of an ERDF ontology. Section 6 defines stable model entailment,
showing that it extends ERDF entailment. In Section 7, we provide a brief sketch of the
ERDF/XML syntax. Decidability issues for the ERDF stable model semantics are discussed
in Section 8. Section 9 shows that the developed ERDF model theory can be seen as a
Tarski-style model theory. Section 10 reviews related work and Section 11 concludes the
paper, including future work. The main definitions of RDF(S) semantics are reviewed in
Appendix A. Appendix B includes the proofs of the lemmas and propositions, presented in
the paper.

2. Extending RDF Graphs with Negative Information
In this section, we extend RDF graphs to ERDF graphs, by adding strong negation. Moreover, we extend RDF graphs to ERDF formulas, which are built from positive ERDF triples,
the connectives , , , , , and the quantifiers , .
According to RDF concepts (Klyne & Carroll, 2004; Hayes, 2004), URI references
are used as globally unique names for web resources. An RDF URI reference is a Unicode string that represents an absolute URI (with an optional fragment identifier). It
may be represented as a qualified name, that is a colon-separated two-part string consisting of a namespace prefix (an abbreviated name for a namespace URI) and a local
name. For example, given the namespace prefix ex defined to stand for the namespace URI http://www.example.org/, the qualified name ex:Riesling (which stands for
http://www.example.org/Riesling) is a URI reference.
A plain literal is a string s, where s is a sequence of Unicode characters, or a pair of
a string s and a language tag t, denoted by s@t. A typed literal is a pair of a string
s and a datatype URI reference d, denoted by sd. For example, 27xsd:integer is
a typed literal.
A (Web) vocabulary V is a set of URI references and/or literals (plain or typed). We
denote the set of all URI references by URI, the set of all plain literals by PL, the set of
all typed literals by T L, and the set of all literals by LIT . It holds: URI  LIT = .
41

fiAnalyti, Antoniou, Damasio, & Wagner

In our formalization, we consider a set Var of variable symbols, such that the sets Var ,
URI, LIT are pairwise disjoint. In the main text, variable symbols are explicitly indicated,
while in our examples, variable symbols are prefixed by a question mark symbol ?.
An RDF triple (Klyne & Carroll, 2004; Hayes, 2004) is a triple s p o., where s 
URI  Var , p  URI, and o  URI  LIT  Var , expressing that the subject s is related
with the object o through the property p. An RDF graph is a set of RDF triples. The
variable symbols appearing in an RDF graph are called blank nodes, and are, intuitively,
existentially quantified variables. In this paper, we denote an RDF triple s p o. by
p(s, o). Below we extend the notion of RDF triple to allow for both positive and negative
information.
Definition 2.1 (ERDF triple) Let V be a vocabulary. A positive ERDF triple over V
(also called ERDF sentence atom) is an expression of the form p(s, o), where s, o  V  Var
are called subject 5 and object, respectively, and p  V  URI is called predicate or property.
A negative ERDF triple over V is the strong negation p(s, o) of a positive ERDF triple
p(s, o) over V . An ERDF triple over V (also called ERDF sentence literal ) is a positive or
negative ERDF triple over V . 
For example, ex:likes(ex:Gerd , ex:Riesling) is a positive ERDF triple, expressing that
Gerd likes Riesling, and ex:likes(ex:Carlos, ex:Riesling) is a negative ERDF triple, expressing that Carlos dislikes Riesling. Note that an RDF triple is a positive ERDF
triple with the constraint that the subject of the triple is not a literal. For example,
ex:denotationOf (Grigoris, ex:Grigoris) is a valid ERDF triple but not a valid RDF triple.
Our choice of allowing literals appearing in the subject position is based on our intuition
that this case can naturally appear in knowledge representation (as in the previous example). Prudhommeaux & Seaborne (2008) and de Bruijn et al. (2005) also consider literals
in the subject position of RDF triples.
Based on the notion of ERDF triple, we define ERDF graphs and ERDF formulas, as
follows:
Definition 2.2 (ERDF graph) An ERDF graph G is a set of ERDF triples over some
vocabulary V . We denote the variables appearing in G by Var (G), and the set of URI
references and literals appearing in G by VG . 
Note that as an RDF graph is a set of RDF triples (Klyne & Carroll, 2004; Hayes, 2004),
an RDF graph is also an ERDF graph.
Definition 2.3 (ERDF formula) Let V be a vocabulary. We consider the logical factors
{, , , , , , }, where , , and  are called strong negation, weak negation, and
material implication, respectively. We denote by L(V ) the smallest set that contains the
positive ERDF triples over V and is closed with respect to the following conditions: if
F, G  L(V ) then {F, F, F G, F G, F  G, xF, xF }  L(V ), where x  Var .
An ERDF formula over V is an element of L(V ). We denote the set of variables appearing
5. Opposed to pure RDF (Klyne & Carroll, 2004), we allow literals in the subject position of an ERDF
triple.

42

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

in F by Var (F ), and the set of free variables6 appearing in F by FVar (F ). Moreover, we
denote the set of URI references and literals appearing in F by VF . 
For example, let:
F = ?x ?y (rdf :type(?x, ex:Person)  ex:hasChild (?y, ?x))  rdf :type(?z, ex:Person)
Then, F is an ERDF formula over the vocabulary V = {rdf :type, ex:Person, ex:hasChild }
with Var (F ) = {?x, ?y, ?z} and FVar (F ) = {?z}.
We will denote the sublanguages of L(V ) formed by means of a subset S of the logical
factors, by L(V |S). For example, L(V |{}) denotes the set of (positive and negative) ERDF
triples over V .

3. ERDF Interpretations
In this section, we extend RDF(S) semantics by allowing for partial properties and classes.
In particular, we define ERDF interpretations and satisfaction of an ERDF formula, based
on the notion of partial interpretation.
3.1 Partial Interpretations
We define a partial interpretation as an extension of a simple interpretation (Hayes, 2004),
where each property is associated not only with a truth extension but also with a falsity
extension allowing for partial properties. The notation P(S), where S is a set, denotes the
powerset of S.
Definition 3.1 (Partial interpretation) A partial interpretation I of a vocabulary V
consists of:
 A non-empty set of resources ResI , called the domain or universe of I.
 A set of properties P ropI .
 A vocabulary interpretation mapping IV 7 : V  URI  ResI  P ropI .
 A property-truth extension mapping PT I : P ropI  P(ResI  ResI ).
 A property-falsity extension mapping PF I : P ropI  P(ResI  ResI ).
 A mapping ILI : V  T L  ResI .
 A set of literal values LV I  ResI , which contains V  PL.

We define the mapping: I : V  ResI  P ropI , called denotation, such that:
 I(x) = IV (x), x  V  URI.
 I(x) = x,  x  V  PL.
 I(x) = ILI (x),  x  V  T L. 
6. Without loss of generality, we assume that a variable cannot have both free and bound occurrences in
F , and more than one bound occurrence.
7. In the symbol IV , V stands for Vocabulary.

43

fiAnalyti, Antoniou, Damasio, & Wagner

Note that the truth and falsity extensions of a property p according to a partial interpretation I, that is P TI (p) and P FI (p), are sets of pairs hsubject, objecti of resources. As
an example, let:
V = {ex:Carlos, ex:Grigoris, ex:Riesling, ex:likes, ex:denotationOf , Grigorisxsd:string}

and consider a structure I that consists of:
 A set of resources ResI = {C, G, R, l, d, Grigoris}.
 A set of properties P ropI = {l, d}.
 A vocabulary interpretation mapping IV : V  URI  ResI  P ropI such that:
IV (ex:Carlos) = C, IV (ex:Grigoris) = G, IV (ex:Riesling) = R, IV (ex:likes) = l, and
IV (ex:denotationOf ) = d.
 A property-truth extension mapping PT I : P ropI  P(ResI  ResI ) such that:
P TI (d) = {hGrigoris, Gi}.
 A property-falsity extension mapping PF I : P ropI  P(ResI  ResI ) such that:
P FI (l) = {hC, Ri}.
 A mapping ILI : V  T L  ResI such that: ILI (Grigorisxsd :string) = Grigoris.
 A set of literal values LV I = {Grigoris}.

It is easy to see that I is a partial interpretation of V , expressing that: (i) Grigoris
is the denotation of Grigoris and (ii) Carlos dislikes Riesling.
Definition 3.2 (Coherent partial interpretation) A partial interpretation I of a vocabulary V is coherent iff for all x  P ropI , PT I (x)  PF I (x) = . 
Coherent partial interpretations enforce the constraint that a pair of resources cannot
belong to both the truth and falsity extensions of a property (i.e., all properties are coherent). Intuitively, this means that an ERDF triple cannot be both true and false.
Continuing our previous example, note that I is a coherent partial interpretation.
Consider now a partial interpretation J which is exactly as I, except that it also holds:
P TJ (l) = {hC, Ri} (expressing that Carlos likes Riesling). Then, hC, Ri belongs to both
the truth and falsity extension of l (i.e., hC, Ri  P TJ (l)  P FJ (l)). Thus, J is not coherent.
To define satisfaction of an ERDF formula w.r.t. a partial interpretation, we need first
the following auxiliary definition.
Definition 3.3 (Composition of a partial interpretation and a valuation) Let I be
a partial interpretation of a vocabulary V and let v be a partial function v : Var  ResI
(called valuation). We define: (i) [I + v](x) = v(x), if x  Var , and (ii) [I + v](x) = I(x),
if x  V . 
Definition 3.4 (Satisfaction of an ERDF formula w.r.t. a partial interpretation
and a valuation) Let F, G be ERDF formulas and let I be a partial interpretation of a
vocabulary V . Additionally, let v be a mapping v : Var (F )  ResI .
 If F = p(s, o) then I, v |= F iff p  V  URI, s, o  V  Var , I(p)  P ropI , and
h[I + v](s), [I + v](o)i  PT I (I(p)).
44

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

 If F = p(s, o) then I, v |= F iff p  V  URI, s, o  V  Var , I(p)  P ropI , and
h[I + v](s), [I + v](o)i  PF I (I(p)).
 If F = G then I, v |= F iff VG  V and I, v 6|= G.
 If F = F1 F2 then I, v |= F iff I, v |= F1 and I, v |= F2 .
 If F = F1 F2 then I, v |= F iff I, v |= F1 or I, v |= F2 .
 If F = F1  F2 then8 I, v |= F iff I, v |= F1 F2 .
 If F = x G then I, v |= F iff there exists mapping u : Var (G)  ResI such that u(y) = v(y),
y  Var (G)  {x}, and I, u |= G.
 If F = x G then I, v |= F iff for all mappings u : Var (G)  ResI such that u(y) = v(y),
y  Var (G)  {x}, it holds I, u |= G.
 All other cases of ERDF formulas are treated by the following DeMorgan-style rewrite rules
expressing the falsification of compound ERDF formulas:
(F  G)  F  G, (F  G)  F  G, (F )  F, ( F )  F 9 ,
(x F )  x F, (x F )  x F, (F  G)  F G. 

Continuing our previous example, let v : {?x, ?y, ?z}  ResI such that v(?x) = C,
v(?y) = R, and v(?z) = G. It holds:
I, v |= ex:likes(?x, ?y)  ex:denotationOf (Grigorisxsd:string, ?z).
Definition 3.5 (Satisfaction of an ERDF formula w.r.t. a partial interpretation)
Let F be an ERDF formula and let I be a partial interpretation of a vocabulary V . We say
that I satisfies F , denoted by I |= F , iff for every mapping v : Var (F )  ResI , it holds
I, v |= F. 
Continuing our previous example, I |= ?x ex:likes(ex:Carlos, ?x).
Below we define ERDF graph satisfaction, extending satisfaction of an RDF graph
(Hayes, 2004) (see also Appendix A).
Definition 3.6 (Satisfaction of an ERDF graph w.r.t. a partial interpretation) Let
G be an ERDF graph and let I be a partial interpretation of a vocabulary V . Let v be a
mapping v : Var (G)  ResI . We define:
 I, v |=GRAPH G iff t  G, I, v |= t.
 I satisfies the ERDF graph G, denoted by I |=GRAPH G, iff there exists a mapping
v : Var (G)  ResI such that I, v |=GRAPH G. 
Intuitively, an ERDF graph G represents an existentially quantified conjunction of
ERDF triples. Specifically, let G = {t1 , ..., tn } be an ERDF graph, and let Var (G) =
{x1 , ..., xk }. Then, G represents the ERDF formula formula(G) = ?x1 , ..., ?xk t1  ...  tn .
This is shown in the following lemma.
8. Material implication is the logical relationship between any two ERDF formulas such that either the first
is non-true or the second is true.
9. This transformation expresses that if it is false that F does not hold then F holds.

45

fiAnalyti, Antoniou, Damasio, & Wagner

Lemma 3.1 Let G be an ERDF graph and let I be a partial interpretation of a vocabulary
V . It holds: I |=GRAPH G iff I |= formula(G).
Following the RDF terminology (Klyne & Carroll, 2004), the variables of an ERDF
graph are also called blank nodes and intuitively denote anonymous web resources. For
example, consider the ERDF graph:
G = {rdf :type(?x, ex:EuropeanCountry), rdf :type(?x, ex:EU member)}.
Then, G represents the ERDF formula formula(G) =
?x (rdf :type(?x, ex:EuropeanCountry)  rdf :type(?x, ex:EU member)),
expressing that there is a European country which is not a European Union member.
Notational Convention: Let G be an ERDF graph, let I be a partial interpretation of
a vocabulary V , and let v be a mapping v : Var (G)  ResI . Due to Lemma 3.1, we will
write (by an abuse of notation) I, v |= G and I |= G instead of I, v |=GRAPH G and
I |=GRAPH G, respectively.
3.2 ERDF Interpretations and Entailment
In this subsection, we define ERDF interpretations and entailment as an extension of RDFS
interpretations and entailment (Hayes, 2004). First, we define the vocabularies of RDF,
RDFS, and ERDF.
The vocabulary of RDF, VRDF , is a set of URI references in the rdf : namespace (Hayes,
2004), as shown in Table 1. The vocabulary of RDFS, VRDF S , is a set of URI references in
the rdfs: namespace (Hayes, 2004), as shown in Table 1. The vocabulary of ERDF , VERDF ,
is a set of URI references in the erdf : namespace. Specifically, the set of ERDF predefined
classes is CERDF = {erdf :TotalClass, erdf :TotalProperty}. We define VERDF = CERDF .
Intuitively, instances of the metaclass erdf :TotalClass are classes c that satisfy totalness,
meaning that each resource belongs to the truth or falsity extension of c. Similarly, instances
of the metaclass erdf :TotalProperty are properties p that satisfy totalness, meaning that
each pair of resources belongs to the truth or falsity extension of p.
We are now ready to define an ERDF interpretation over a vocabulary V as an extension
of an RDFS interpretation (Hayes, 2004) (see also Appendix A), where each property and
class is associated not only with a truth extension but also with a falsity extension, allowing
for both partial properties and partial classes. Additionally, an ERDF interpretation gives
special semantics to terms from the ERDF vocabulary.
Definition 3.7 (ERDF interpretation) An ERDF interpretation I of a vocabulary V
is a partial interpretation of V  VRDF  VRDF S  VERDF , extended by the new ontological
categories ClsI  ResI for classes, TCls I  ClsI for total classes, and TProp I  P ropI for
total properties, as well as the class-truth extension mapping CT I : ClsI  P(ResI ), and
the class-falsity extension mapping CF I : ClsI  P(ResI ), such that:
1. x  CT I (y) iff hx, yi  PT I (I(rdf :type)), and
x  CF I (y) iff hx, yi  PF I (I(rdf :type)).
46

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

VRDF
rdf :type
rdf :Property
rdf :XMLLiteral
rdf :nil
rdf :List
rdf :Statement
rdf :subject
rdf :predicate
rdf :object
rdf :first
rdf :rest
rdf :Seq
rdf :Bag
rdf :Alt
rdf : i, i  {1, 2, ...}
rdf :value

VRDF S
rdfs:domain
rdfs:range
rdfs:Resource
rdfs:Literal
rdfs:Datatype
rdfs:Class
rdfs:subClassOf
rdfs:subPropertyOf
rdfs:member
rdfs:Container
rdfs:ContainerMembershipProperty
rdfs:comment
rdfs:seeAlso
rdfs:isDefinedBy
rdfs:label

Table 1: The vocabulary of RDF and RDFS
2. The ontological categories are defined
P ropI = CT I (I(rdf :Property))
ResI = CT I (I(rdfs:Resource))
TCls I = CT I (I(erdf :TotalClass))

as follows:
ClsI = CT I (I(rdfs:Class))
LV I = CT I (I(rdfs:Literal))
TProp I = CT I (I(erdf :TotalProperty)).

3. If hx, yi  PT I (I(rdfs:domain)) and hz, wi  PT I (x) then z  CT I (y).
4. If hx, yi  PT I (I(rdfs:range)) and hz, wi  PT I (x) then w  CT I (y).
5. If x  ClsI then hx, I(rdfs:Resource)i  PT I (I(rdfs:subClassOf )).
6. If hx, yi  PT I (I(rdfs:subClassOf )) then x, y  ClsI , CT I (x)  CT I (y), and
CF I (y)  CF I (x).
7. PT I (I(rdfs:subClassOf )) is a reflexive and transitive relation on ClsI .
8. If hx, yi  PT I (I(rdfs:subPropertyOf )) then x, y  P ropI , PT I (x)  PT I (y), and
PF I (y)  PF I (x).
9. PT I (I(rdfs:subPropertyOf )) is a reflexive and transitive relation on P ropI .
10. If x  CT I (I(rdfs:Datatype)) then hx, I(rdfs:Literal)i  PT I (I(rdfs:subClassOf )).
11. If x  CT I (I(rdfs:ContainerMembershipProperty)) then
hx, I(rdfs:member)i  PT I (I(rdfs:subPropertyOf )).
12. If x  TCls I then CT I (x)  CF I (x) = ResI .
13. If x  TProp I then PT I (x)  PF I (x) = ResI  ResI .

47

fiAnalyti, Antoniou, Damasio, & Wagner

14. If srdf :XMLLiteral  V and s is a well-typed XML literal string, then
ILI (srdf :XMLLiteral ) is the XML value of s, and
ILI (srdf :XMLLiteral )  CT I (I(rdf :XMLLiteral )).
15. If srdf :XMLLiteral  V and s is an ill-typed XML literal string then
ILI (srdf :XMLLiteral )  ResI  LV I , and
ILI (srdf :XMLLiteral )  CF I (I(rdfs:Literal)).
16. I satisfies the RDF and RDFS axiomatic triples (Hayes, 2004), shown in Table 2 and Table 3
of Appendix A, respectively.
17. I satisfies the following triples, called ERDF axiomatic triples:
rdfs:subClassOf (erdf :TotalClass, rdfs:Class).
rdfs:subClassOf (erdf :TotalProperty, rdfs:Class).

Note that while RDFS intepretations (Hayes, 2004) imply a two-valued interpretation
of the instances of rdf :Property, this is no longer the case with ERDF interpretations.
Specifically, let I be an ERDF interpretation, let p  CTI (I (rdf :Property)), and let hx, yi 
ResI  ResI . It may be the case that neither hx, yi  P TI (p) nor hx, yi  P FI (p). That is
p(x, y) is neither true nor false.
Semantic conditions of ERDF interpretations may impose constraints to both the truth
and falsity extensions of properties and classes. Specifically, consider semantic condition 6 of
Definition 3.7 and assume that hx, yi  PT I (I(rdfs:subClassOf )). Then, I should not only
satisfy CT I (x)  CT I (y) (as an RDFS interpretation I does), but also CF I (y)  CF I (x).
The latter is true because if it is certain that a resource z does not belong to the truth
extension of class y then it is certain that z does not belong to the truth extension of class
x. Thus, the falsity extension of y is contained in the falsity extension of x. Similar is the
case for semantic condition 8. Semantic conditions 12 and 13 represent our definition of
total classes and total properties, respectively. Semantic condition 15 expresses that the
denotation of an ill-typed XML literal is not a literal value. Therefore (see semantic condition 2), it is certain that it is not contained in the truth extension of the class rdfs:Literal.
Thus, it is contained in the falsity extension of the class rdfs:Literal.
Let I be a coherent ERDF interpretation of a vocabulary V . Since I(rdf :type)  P ropI ,
it holds: x  ClsI , CT I (x)  CF I (x) = . Thus, all properties and classes of coherent
ERDF interpretations are coherent.
Convention: In the rest of the document, we consider only coherent ERDF interpretations.
This means that referring to an ERDF interpretation, we implicitly mean a coherent
one. Moreover, to improve the readability of our examples, we will ignore the example
namespace ex:.
According to RDFS semantics (Hayes, 2004), the only source of RDFS-inconsistency is
the appearance of an ill-typed XML literal l in the RDF graph, in combination with the
derivation of the RDF triple x rdf :type rdfs:Literal. by the RDF and RDFS entailment
rules, where x is a blank node allocated to l10 . Such a triple is called XML clash. To
10. In RDF(S), literals are not allowed in the subject position of RDF triples, whereas blank nodes are. For
this reason, before the RDF and RDFS entailment rules are applied on an RDF graph, each literal is
replaced by a unique blank node. This way inferences can be drawn on the literal value denoted by this
literal, without concern for the above restriction (Hayes, 2004).

48

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

understand this, note that from semantic condition 3 of Definition A.3 (RDF interpretation,
Appendix A), it follows that the denotation of an ill-typed XML literal cannot be a literal
value. Now, from semantic conditions 1 and 2 of Definition A.5 (RDFS interpretation,
Appendix A), it follows that the denotation of an ill-typed XML literal cannot be of type
rdfs:Literal. Therefore, the derivation of an XML clash from an RDF graph G through
the application of the RDF and RDFS entailment rules, indicates that there is no RDFS
interpretation that satisfies G.
An ERDF graph can be ERDF-inconsistent11 , not only due to the appearance of an
ill-typed XML literal in the ERDF graph (in combination with semantic condition 15 of
Definition 3.7), but also due to the additional semantic conditions for coherent ERDF
interpretations.
For example, let p, q, s, o  URI and let G = {p(s, o), rdfs:subPropertyOf (p, q), q(s, o)}.
Then, G is ERDF-inconsistent, since there is no (coherent) ERDF interpretation that satisfies G.
The following proposition shows that for total properties and total classes of (coherent)
ERDF interpretations, weak negation and strong negation coincide (boolean truth values).
Proposition 3.1 Let I be an ERDF interpretation of a vocabulary V and let V  = V 
VRDF  VRDF S  VERDF . Then,
1. For all p, s, o  V  such that I(p)  TProp I , it holds:
I |= p(s, o) iff I |= p(s, o) (equivalently, I |= p(s, o)  p(s, o)).
2. For all x, c  V  such that I(c)  TCls I , it holds:
I |= rdf :type(x, c) iff I |= rdf :type(x, c)
(equivalently, I |= rdf :type(x, c)  rdf :type(x, c)).
Below we define ERDF entailment between two ERDF formulas or ERDF graphs.
Definition 3.8 (ERDF entailment) Let F, F  be ERDF formulas or ERDF graphs. We
say that F ERDF-entails F  (F |=ERDF F  ) iff for every ERDF interpretation I, if I |= F
then I |= F  . 
For example, let:
F = ?x ?y (rdf :type(?x, Person)  hasFather (?x, ?y))  rdf :type(John, Person).
Additionally, let F  = ?y hasFather (John, ?y)  rdf :type(hasFather , rdf :Property).
Then F |=ERDF F  .
The following proposition shows that ERDF entailment extends RDFS entailment (Hayes,
2004) (see also Appendix A) from RDF graphs to ERDF formulas. In other words, ERDF
entailment is upward compatible with RDFS entailment.
Proposition 3.2 Let G, G be RDF graphs such that VG VERDF =  and VG VERDF = .
Then, G |=RDF S G iff G |=ERDF G .
It easily follows from Proposition 3.2 that an RDF graph is RDFS satisfiable iff it is
ERDF satisfiable. Thus, an RDF graph can be ERDF-inconsistent only due to an XML
clash.
11. Meaning that there is no (coherent) ERDF interpretation that satisfies the ERDF graph.

49

fiAnalyti, Antoniou, Damasio, & Wagner

4. ERDF Ontologies & Herbrand Interpretations
In this section, we define an ERDF ontology as a pair of an ERDF graph G and a set
P of ERDF rules. ERDF rules should be considered as derivation rules that allow us to
infer more ontological information based on the declarations in G. Moreover, we define the
Herbrand interpretations and the minimal Herbrand models of an ERDF ontology.
Definition 4.1 (ERDF rule, ERDF program) An ERDF rule r over a vocabulary V
is an expression of the form: G  F , where F  L(V )  {true} is called condition and
G  L(V |{})  {false} is called conclusion. We assume that no bound variable in F
appears free in G. We denote the set of variables and the set of free variables of r by Var (r)
and FVar (r)12 , respectively. Additionally, we write Cond(r) = F and Concl(r) = G.
An ERDF program P is a set of ERDF rules over some vocabulary V . We denote the set
of URI references and literals appearing in P by VP . 
Recall that L(V |{}) denotes the set of ERDF triples over V . Therefore, the conclusion
of an ERDF rule, unless it is false, it is either a positive ERDF triple p(s, o) or a negative
ERDF triple p(s, o).
For example, consider the derivation rule r:
allRelated (?P, ?Q)  ?p rdf :type(?p, ?P )  ?q (rdf :type(?q, ?Q)  related (?p, ?q)),

Then, r is an ERDF rule, indicating that between two classes P and Q, it holds allRelated (P,
Q) if for all instances p of the class P , there is an instance q of the class Q such that it
holds related (p, q). Note that Var (r) = {?P, ?Q, ?p, ?q} and FVar (r) = {?P, ?Q}.
When Cond(r) = true and Var (r) = {}, rule r is called ERDF fact. When Concl(r) =
false, rule r is called ERDF constraint. We assume that for every partial interpretation
I and every function v : Var  ResI , it holds I, v |= true, I |= true, I, v 6|= false, and
I 6|= false.
Intuitively, an ERDF ontology is the combination of (i) an ERDF graph G containing
(implicitly existentially quantified) positive and negative information, and (ii) an ERDF
program P containing derivation rules (whose free variables are implicitly universally quantified).
Definition 4.2 (ERDF ontology) An ERDF ontology (or ERDF knowledge base) is a
pair O = hG, P i, where G is an ERDF graph and P is an ERDF program. 
The following definition defines the models of an ERDF ontology.
Definition 4.3 (Satisfaction of an ERDF rule and an ERDF ontology) Let I be an
ERDF interpretation of a vocabulary V .
 We say that I satisfies an ERDF rule r, denoted by I |= r, iff for all mappings
v : Var (r)  ResI such that I, v |= Cond(r), it holds I, v |= Concl(r).
 We say that I satisfies an ERDF ontology O = hG, P i (also, I is a model of O),
denoted by I |= O, iff I |= G and I |= r,  r  P . 
12. FVar (r) = FVar (F )  FVar (G).

50

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

In this paper, existentially quantified variables in ERDF graphs are handled by skolemization, a syntactic transformation commonly used in automatic inference systems for removing existentially quantified variables.
Definition 4.4 (Skolemization of an ERDF graph) Let G be an ERDF graph. The
skolemization function of G is an 1:1 mapping skG : Var (G)  URI, where for each
x  Var (G), skG (x) is an artificial URI, denoted by G:x. The set skG (Var (G)) is called
the Skolem vocabulary of G.
The skolemization of G, denoted by sk(G), is the ground ERDF graph derived from G after
replacing each variable x  Var (G) by skG (x). 
Intuitively, the Skolem vocabulary of G (that is, skG (Var (G))) contains artificial URIs
giving arbitrary names to the anonymous entities whose existence was asserted by the
use of blank nodes in G.
For example, let: G = {rdf :type(?x, EuropeanCountry), rdf :type(?x, EU member)}.
Then,
sk(G) = {rdf :type(skG (?x), EuropeanCountry), rdf :type(skG (?x), EU member)}.

The following proposition expresses that the skolemization of an ERDF graph has the
same entailments as the original graph, provided that these do not contain URIs from the
skolemization vocabulary.
Proposition 4.1 Let G be an ERDF graph and let F be an ERDF formula such that
VF  skG (Var (G)) = . It holds: G |=ERDF F iff sk(G) |=ERDF F .
Below we define the vocabulary of an ERDF ontology O.
Definition 4.5 (Vocabulary of an ERDF ontology) Let O = hG, P i be an ERDF ontology. The vocabulary of O is defined as VO = Vsk(G)  VP  VRDF  VRDF S  VERDF .

Note that the vocabulary of an ontology O = hG, P i contains the skolemization vocabulary of G.
Let O = hG, P i be an ERDF ontology. We denote by ResH
O the union of VO and the set
of XML values of the well-typed XML literals in VO minus the well-typed XML literals.
The following definition defines the Herbrand interpretations and the Herbrand models
of an ERDF ontology.
Definition 4.6 (Herbrand interpretation, Herbrand model of an ERDF ontology)
Let O = hG, P i be an ERDF ontology and let I be an ERDF interpretation of VO . We say
that I is a Herbrand interpretation of O iff:
 ResI = ResH
O.
 IV (x) = x, for all x  VO  URI.
 ILI (x) = x, if x is a typed literal in VO other than a well-typed XML literal, and
ILI (x) is the XML value of x, if x is a well-typed XML literal in VO .
51

fiAnalyti, Antoniou, Damasio, & Wagner

We denote the set of Herbrand interpretations of O by I H (O).
A Herbrand interpretation I of O is a Herbrand model of O iff I |= hsk(G), P i. We denote
the set of Herbrand models of O by MH (O). 
Note that if I is a Herbrand interpretation of an ERDF ontology O then I(x) = x, for
each x  VO other than a well-typed XML literal.
It is easy to see that every Herbrand model of an ERDF ontology O is a model of
O. Moreover, note that every Herbrand interpretation of an ERDF ontology O is uniquely
identified by (i) its set of properties and (ii) its property-truth and property-falsity extension
mappings.
However, not all Herbrand models of an ERDF ontology O are desirable. For example,
let p, s, o  URI, let G = {p(s, o)}, and let O = hG, i. Then, there is a Herbrand model
I of O such that I |= p(o, s), whereas we want p(o, s) to be satisfied by all intended
models of O. This is because p is not a total property and p(o, s) cannot be derived from
O (negation-as-failure)13 .
Before we define the minimal Herbrand interpretations of an ERDF ontology O, we need
to define a partial ordering on the Herbrand interpretations of O.
Definition 4.7 (Herbrand interpretation ordering) Let O = hG, P i be an ERDF ontology. Let I, J  I H (O). We say that J extends I, denoted by I  J (or J  I), iff
P ropI  P ropJ , and for all p  P ropI , it holds PT I (p)  PT J (p) and PF I (p)  PF J (p).

It is easy to verify that the relation  is reflexive, transitive, and antisymmetric. Thus,
it is a partial ordering on I H (O).
The intuition behind Definition 4.7 is that by extending a Herbrand interpretation, we
extend both the truth and falsity extension for all properties, and thus (since rdf :type is a
property), for all classes.
The following proposition expresses that two Herbrand interpretations I, J of an ERDF
ontology O are incomparable, if the property-truth or property-falsity extension of a total
property p w.r.t. I and J are different.
Proposition 4.2 Let O = hG, P i be an ERDF ontology and let I, J  I H (O). Let p 
TProp I  TProp J . If PT I (p) 6= PT J (p) or PF I (p) 6= PF J (p) then I 6 J and J 6 I.
Definition 4.8 (Minimal Herbrand interpretations) Let O be an ERDF ontology and
let I  I H (O). We define minimal(I) = {I  I | 6 J  I : J =
6 I and J  I}. 
We define the minimal Herbrand models of O, as:
Mmin (O) = minimal(MH (O)).
However minimal Herbrand models do not give the intended semantics to all ERDF rules.
This is because ERDF rules are derivation and not implication rules. Derivation rules are
13. On the other hand, if p is a total property then p(o, s)p(o, s) should be satisfied by all intended models.
Therefore, in this case, there should be an intended model of O that satisfies p(o, s).

52

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

often identified with implications. But, in general, these are two different concepts. While
an implication is an expression of a logical formula language, a derivation rule is rather a
meta-logical expression. There are logics, which do not have an implication connective, but
which have a derivation rule concept. In standard logics (such as classical and intuitionistic
logic), there is a close relationship between a derivation rule (also called sequent) and the
corresponding implicational formula: they both have the same models. For non-monotonic
rules (e.g. with negation-as-failure), this is no longer the case: the intended models of such
a rule are, in general, not the same as the intended models of the corresponding implication.
This is easy to see with the help of an example. Consider the rule p  q whose model set,
according to the stable model semantics (Gelfond & Lifschitz, 1988, 1990; Herre & Wagner,
1997; Herre et al., 1999), is {{p}}, that is, it entails p. On the other hand, the model set
of the corresponding implication q  p, which is equivalent to the disjunction p  q, is
{{p}, {q}, {p, q}}; consequently, it does not entail p.
Similarly, let O = h, P i, where P = {p(s, o)  q(s, o)} and p, q, s, o  URI. Not
all minimal Herbrand models of O are intended. In particular, there is I  Mmin (O)
such that I |= q(s, o)  p(s, o), whereas we want q(s, o)  p(s, o) to be satisfied by all
intended models of O, as q is not a total property and q(s, o) cannot be derived by any rule
(negation-as-failure).
To define the intended (stable) models of an ERDF ontology, we need first to define
grounding of ERDF rules.
Definition 4.9 (Grounding of an ERDF program) Let V be a vocabulary and let r
be an ERDF rule. We denote by [r]V the set of rules that result from r if we replace each
variable x  FVar (r) by v(x), for all mappings v : FVar (r)  V .
Let P be an ERDF program. We define [P ]V =

S

rP [r]V .



Note that a rule variable can naturally appear in the subject position of an ERDF triple.
Since variables can be instantiated by a literal, a literal can naturally appear in the subject
position of an ERDF triple in the grounded version of an ERDF program. This case further
supports our choice of allowing literals in the subject position of an ERDF triple.

5. ERDF Stable Models
In this section, we define the intended models of an ERDF ontology O, called stable models
of O, based on minimal Herbrand interpretations. In particular, defining the stable models
of O, only the minimal interpretations from a set of Herbrand interpretations that satisfy
certain criteria are considered.
Below, we define the stable models of an ERDF ontology, based on the coherent stable
models14 of Partial Logic (Herre et al., 1999).
Definition 5.1 (ERDF stable model) Let O = hG, P i be an ERDF ontology and let
M  I H (O). We say that M is an (ERDF) stable model of O iff there is a chain of
Herbrand interpretations of O, I0  ...  Ik+1 such that Ik = Ik+1 = M and:
14. Note that these models on extended logic programs are equivalent (Herre et al., 1999) to Answer Sets of
answer set semantics (Gelfond & Lifschitz, 1990).

53

fiAnalyti, Antoniou, Damasio, & Wagner

1. I0  minimal({I  I H (O) | I |= sk(G)}).
2. For successor ordinals  with 0 <   k + 1:
I  minimal({I  I H (O) | I  I1 and I |= Concl(r), r  P[I1 ,M ] }), where
P[I1 ,M ] = {r  [P ]VO | I |= Cond(r), I  I H (O) s.t. I1  I  M }.
The set of stable models of O is denoted by Mst (O). 
Note that I0 is a minimal Herbrand interpretation of O = hG, P i that satisfies sk(G),
while Herbrand interpretations I1 , ..., Ik+1 correspond to a stratified sequence of rule applications, where all applied rules remain applicable throughout the generation of a stable
model M . In our words, a stable model is generated bottom-up by the iterative application
of the rules in the ERDF program P , starting from the information in the ERDF graph G.
Thus, ERDF stable model semantics, as a refinement of minimal model semantics, captures
the intuition that:
 Assertions rdf :type(p, erdf :TotalProperty) and rdf :type(c, erdf :TotalClass) should only
be accepted if the ontology contains some direct support for them in the form of an
acceptable rule sequence (that corresponds to a proof).
 Assertions p(s, o) and p(s, o) should only be accepted if the ontology contains some
direct support for them in the form of an acceptable rule sequence, or
rdf :type(p, erdf :TotalProperty) is accepted.
 Assertions rdf :type(o, c) and rdf :type(o, c) should only be accepted if the ontology
contains some direct support for them in the form of an acceptable rule sequence, or
rdf :type(c, erdf :TotalClass) is accepted.
Wine Selection Example: Consider a class Wine whose instances are wines, and a
property likes(X, Y ) indicating that person X likes object Y . Assume now that we want
to select wines for a dinner such that, for each guest, there is on the table exactly one wine
that he/she likes. Let the class Guest indicate the persons that will be invited to the dinner
and let the class SelectedWine indicate the wines chosen to be served. An ERDF program
P that describes this wine selection problem is the following (commas , in the body of
the rules indicate conjunction ):
id(?x, ?x)  rdf :type(?x, rdfs:Resource).
rdf :type(?y, SelectedWine)  rdf :type(?x, Guest), rdf :type(?y, Wine), likes(?x, ?y),
?z (rdf :type(?z, SelectedWine), id(?z, ?y)  likes(?x, ?z)).

Consider now the ERDF graph G, containing the factual information:
G = { rdf :type(Carlos, Guest), rdf :type(Gerd , Guest), rdf :type(Riesling, Wine),
rdf :type(Retsina, Wine), rdf :type(Chardonnay, Wine), likes(Gerd , Riesling),
likes(Gerd , Retsina), likes(Carlos, Chardonnay), likes(Carlos, Retsina) }.

Then, according to Definition 5.1, the ERDF ontology O = hG, P i has two stable models,
M1 and M2 , such that:
54

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

M1 |= rdf :type(Riesling, SelectedWine)  rdf :type(Chardonnay, SelectedWine) 
 rdf :type(Retsina, SelectedWine).
M2 |= rdf :type(Retsina, SelectedWine)   rdf :type(Riesling, SelectedWine) 
 rdf :type(Chardonnay, SelectedWine).

Note that, according to stable model M1 , the wines selected for the dinner are Riesling
and Chardonnay. This is because, (i) Gerd likes Riesling but does not like Chardonnay,
and (ii) Carlos likes Chardonnay but does not like Riesling.
According to stable model M2 , only Retsina is selected for the dinner. This is because,
both Gerd and Carlos like Retsina.
Stable model M1 is reached through the chain I0  M1  M1 , where I0 is the single
Herbrand interpretation in minimal({I  I H (O) | I |= sk(G)}). To verify this, note that:
P[I0 ,M1 ] = P[M1 ,M1 ] =
[id(?x, ?x)  rdf :type(?x, rdfs:Resource)]VO 
{rdf :type(Riesling, SelectedWine)  rdf :type(Gerd , Guest),
rdf :type(Riesling, Wine), likes(Gerd , Riesling),
?z (rdf :type(?z, SelectedWine), id(?z , Riesling)  likes(Gerd , ?z))} 
{rdf :type(Chardonnay, SelectedWine)  rdf :type(Carlos, Guest),
rdf :type(Chardonnay, Wine), likes(Carlos, Chardonnay),
?z (rdf :type(?z, SelectedWine), id(?z , Chardonnay)  likes(Carlos, ?z))}.

Similarly, stable model M2 is reached through the chain I0  M2  M2 . To verify this,
note that:
P[I0 ,M2 ] = P[M2 ,M2 ] =
[id(?x, ?x)  rdf :type(?x, rdfs:Resource)]VO 
{rdf :type(Retsina, SelectedWine)  rdf :type(Gerd , Guest),
rdf :type(Retsina, Wine), likes(Gerd , Retsina),
?z (rdf :type(?z, SelectedWine), id(?z, Retsina)  likes(Gerd , ?z))} 
{rdf :type(Retsina, SelectedWine)  rdf :type(Carlos, Guest),
rdf :type(Retsina, Wine), likes(Carlos, Retsina),
?z (rdf :type(?z, SelectedWine), id(?z, Retsina)  likes(Carlos, ?z))}.

Assume now that Retsina should not be one of the selected wines, because it does not
match with the food. To indicate this, we add to P the ERDF constraint:
false  rdf :type(Retsina, SelectedWine).
Then, M1 is the single model of the modified ontology.
It is easy to verify that if O is an ERDF ontology and O is exactly as O, but without
the ERDF constraints appearing in O, then Mst (O)  Mst (O ). In other words, the ERDF
constraints appearing in an ERDF ontology eliminate undesirable stable models.
Paper Assignment Example: Consider a class Paper whose instances are papers submitted to a conference, a class Reviewer whose instances are potential reviewers for the
55

fiAnalyti, Antoniou, Damasio, & Wagner

submitted papers, and a property conflict(R, P ) indicating that there is a conflict of interest between reviewer R and paper P . Assume now that we want to assign papers to
reviewers based on the following criteria: (i) a paper is assigned to at most one reviewer,
(ii) a reviewer is assigned at most one paper, and (iii) a paper is not assigned to a reviewer,
if there is a conflict of interest. The assignment of a paper P to a reviewer R is indicated
through the property assign(P, R). The ERDF triple allAssigned (Paper , Reviewer ) indicates that each paper has been assigned to one reviewer. An ERDF program P describing
the assignment of papers is the following:
id(?x, ?x)  true.
assign(?p, ?r)  rdf :type(?p, Paper ), rdf :type(?p , Paper ), assign(?p , ?r), id(?p, ?p ).
assign(?p, ?r)  rdf :type(?r, Reviewer ), rdf :type(?r , Reviewer ), assign(?p, ?r ), id(?r, ?r ).
assign(?p, ?r)  conflict(?r, ?p).
assign(?p, ?r)
 rdf :type(?r, Reviewer ), rdf :type(?p, Paper ),  assign(?p, ?r).
allAssigned (Paper , Reviewer )  ?p (rdf :type(?p, Paper ) 
?r (rdf :type(?r, Reviewer )  assign(?p, ?r))).

Consider now the ERDF graph G, containing the factual information:
G = { rdf :type(P 1, Paper ), rdf :type(P 2, Paper ), rdf :type(P 3, Paper ), rdf :type(R1, Reviewer ),
rdf :type(R2, Reviewer ), rdf :type(R3, Reviewer ), conflict(P 1, R3), conflict(P 2, R2),
conflict(P 3, R2) }.

Then, according to Definition 5.1, the ERDF ontology O = hG, P i has four stable
models, denoted by M1 , ..., M4 , such that:
M1
M2
M3
M4

|=
|=
|=
|=

assign(P 1, R1)  assign(P 2, R3)  allAssigned (Paper , Reviewer ),
assign(P 1, R1)  assign(P 3, R3)  allAssigned (Paper , Reviewer ),
assign(P 1, R2)  assign(P 2, R1)  assign(P 3, R3)  allAssigned (Paper , Reviewer ),
assign(P 1, R2)  assign(P 2, R3)  assign(P 3, R1)  allAssigned (Paper , Reviewer ).

We would like to note that, in contrast to the previous examples, given an ERDF
ontology O = hG, P i, it is possible that |minimal ({I  I H (O) | I |= sk(G)})| > 1, due
to the declaration of total properties and total classes. Specifically, the number of the
interpretations I0 in item 1 of Definition 5.1 is more than one iff G contains ERDF triples
of the form rdf :type(p, erdf :TotalProperty) or rdf :type(c, erdf :TotalClass). For example, let
O = hG, i, where:
G = {authorOf (John, book1 ), authorOf (Peter , book2 ), rdf :type(authorOf , erdf :TotalProperty)}.

Then, there are I0 , I0  minimal ({I  I H (O) | I |= sk(G)}) such that:
I0 |= authorOf (John, book2 ) and I0 |= authorOf (John, book2 ).
Note that both I0 and I0 are stable models of O. However, I0 satisfies authorOf (John, book2 ),
even though there is no evidence that John is an author of book2 .
The following proposition shows that a stable model of an ERDF ontology O is a Herbrand model of O.
56

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

Proposition 5.1 Let O = hG, P i be an ERDF ontology and let M  Mst (O). It holds
M  MH (O).
On the other hand, if all properties are total, a Herbrand model M of an ERDF ontology
O = hG, P i is a stable model of O15 . Obviously, this is a desirable result since, in this
case, an open-world assumption is made for all properties. Thus, there is no preferential
entailment of weak negation, for any of the properties. Of course, the term stable model
is not very descriptive, for this degenerative case.
Proposition 5.2 Let O = hG, P i be an ERDF ontology such that
rdfs:subClassOf (rdf :Property, erdf :TotalProperty)  G. Then, Mst (O) = MH (O).
A final note is that, similarly to stable models defined by Gelfond & Lifschitz (1988, 1990)
and Herre et al. (1999), ERDF stable models do not preserve Herbrand model satisfiability.
For example, let O = h, P i, where P = {p(s, o)  p(s, o)} and p, s, o  URI. Then,
Mst (O) = , whereas there is a Herbrand model of O that satisfies p(s, o).

6. ERDF Stable Model Entailment & Stable Answers
In this section, we define stable model entailment on ERDF ontologies, showing that it extends ERDF entailment on ERDF graphs. Moreover, we define the skeptical and credulous
answers of an ERDF formula (query) F w.r.t. an ERDF ontology O.
Definition 6.1 (Stable model entailment) Let O = hG, P i be an ERDF ontology and
let F be an ERDF formula or ERDF graph. We say that O entails F under the (ERDF)
stable model semantics, denoted by O |=st F iff for all M  Mst (O), M |= F . 
For example, let O = h, P i, where P = {p(s, o)  q(s, o)} and p, q, s, o  URI. Then,
O |=st q(s, o)  p(s, o).
Now, let G = {rdfs:subClassOf (rdf :Property, erdf :TotalProperty)} and let P be as in
the previous example. Then, hG, P i |=st q(s, o)  p(s, o), but hG, P i 6|=st q(s, o) and
hG, P i 6|=st p(s, o). Note that this is the desirable result, since now q is a total property
(and thus, an open-world assumption is made for q).
As another example, let p, s, o  URI, let G = {p(s, o)}, and let P = {p(?x, ?y) 
p(?x, ?y)}. Then, hG, P i |=st p(o, s)  p(o, s) (note that P contains a CWA on p).
Now, let G = {rdf :type(p, erdf :TotalProperty), p(s, o)} and let P be as in the previous
example. Then, hG, P i |=st ?x ?y (p(?x, ?y) p(?x, ?y)) (see Proposition 3.1), but
hG, P i 6|=st p(o, s) and hG, P i 6|=st p(o, s). Indeed, the CWA in P does not affect the
semantics of p, since p is a total property.
EU Membership Example: Consider the following ERDF program P , specifying some
rules for concluding that a country is not a member state of the European Union (EU).
(r1 )
(r2 )

rdf :type(?x, EUMember) 
rdf :type(?x, EUMember) 

rdf :type(?x, AmericanCountry).
rdf :type(?x, EuropeanCountry),
rdf :type(?x, EUMember).

15. Note that, in this case, M  minimal({I  I H (O) | I |= sk(G)}) and M  minimal({I  I H (O) | I 
M and I |= Concl(r),  r  P[M,M ] }).

57

fiAnalyti, Antoniou, Damasio, & Wagner

A rather incomplete ERDF ontology O = hG, P i is obtained by including the following
information in the ERDF graph G:
rdf :type(Russia, EUMember).
rdf :type(Austria, EUMember).
rdf :type(?x, EuropeanCountry).

rdf :type(Canada, AmericanCountry).
rdf :type(Italy, EuropeanCountry).
rdf :type(?x, EUMember).

Using stable model entailment on O, it can be concluded that Austria is a member of EU,
that Russia and Canada are not members of EU, and that it exists a European Country
which is not a member of EU. However, it is also concluded that Italy is not a member of EU, which is a wrong statement. This is because G does not contain complete
information of the European countries that are EU members (e.g., it does not contain
rdf :type(Italy, EUMember)). Thus, incorrect information is obtained by the closed-world
assumption expressed in rule r2 . In the case that rdf :type(EUMember, erdf :TotalClass)
is added to G (that is, an open-world assumption is made for the class EUMember) then
rdf :type(Italy, EUMember) and thus, rdf :type(Italy, EUMember) are no longer entailed.
This is because, there is a stable model of the extended ERDF ontology O that satisfies
rdf :type(Italy, EUMember). Moreover, if complete information for all European countries
that are members of EU is included in G then the stable model conclusions of O will also
be correct (the closed-world assumption will be correctly applied). Note that, in this case,
G will include the ERDF triple rdf :type(Italy, EUMember).
The following proposition follows directly from the fact that any stable model of an
ERDF ontology O is an ERDF interpretation.
Proposition 6.1 Let O = hG, P i be an ERDF ontology and let F, F  be ERDF formulas.
If O |=st F and F |=ERDF F  then O |=st F  .
For ERDF graphs G, G , it can be proved that hG, i |=st G iff G |=ERDF G (see
below). Now the question arises whether this result can be generalized by replacing the
ERDF graph G by any ERDF formula F . The following example shows that this is not
the case. Let G = {p(s, o)} and let F = p(o, s), where p, s, o  URI. Then hG, i |=st F ,
whereas G 6|=ERDF F . However, G can be replaced by any ERDF d-formula F , defined as
follows:
Definition 6.2 (ERDF d-formula) Let F be an ERDF formula. We say that F is an
ERDF d-formula iff (i) F is the disjunction of existentially quantified conjunctions of ERDF
triples, and (ii) FVar (F ) = . 
For example, let:
F = (?x rdf :type(?x , Vertex )  rdf :type(?x , Red )) 
(?x rdf :type(?x , Vertex )  rdf :type(?x , Blue)).
Then, F is an ERDF d-formula. It is easy to see that if G is an ERDF graph then formula(G)
is an ERDF d-formula.
58

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

Proposition 6.2 Let G be an ERDF graph and let F be an ERDF formula such that
VF  skG (Var (G)) = . It holds:
1. If F is an ERDF d-formula and hG, i |=st F then G |=ERDF F .
2. If G |=ERDF F then hG, i |=st F .
Let G be an ERDF graph and let F be an ERDF d-formula or an ERDF graph such
that VF  skG (Var (G)) = . A direct consequence of Proposition 6.2 is that:
hG, i |=st F iff G |=ERDF F .
The following proposition is a direct consequence of Proposition 3.2 and Proposition
6.2, and shows that stable model entailment extends RDFS entailment from RDF graphs
to ERDF ontologies.
Proposition 6.3 Let G, G be RDF graphs such that VG  VERDF = , VG  VERDF = ,
and VG  skG (Var (G)) = . It holds: G |=RDF S G iff hG, i |=st G .
Recall that the Skolem vocabulary of G (that is, skG (Var (G))) contains artificial URIs
giving arbitrary names to the anonymous entities whose existence was asserted by the
use of blank nodes in G. Thus, the condition VG  skG (Var (G)) =  in Proposition 6.3 is
actually trivial.
Definition 6.3 (ERDF query, ERDF stable answers) Let O = hG, P i be an ERDF
ontology. An (ERDF) query F is an ERDF formula. The (ERDF) stable answers of F
w.r.t. O are defined as follows:

if FVar (F ) =  and M  Mst (O) : M |= F
 yes
st
no
if FVar (F ) =  and M  Mst (O) : M 6|= F
Ans O (F ) =

{v : FVar (F )  VO | M  Mst (O), M |= v(F )}

if FVar (F ) 6= ,

where v(F ) is the formula F after replacing all the free variables x in F by v(x). 
For example, let p, q, c, s, o  URI, let G = {p(s, o), rdf :type(s, c), rdf :type(o, c)}, and
let P = {q(?x, ?y)  rdf :type(?x, c)  rdf :type(?y, c)  p(?x, ?y)}. Then, the stable
answers of F = q(?x, ?y) w.r.t. O = hG, P i are Ans st
O (F ) = {{?x = o, ?y = o}, {?x =
s, ?y = s}, {?x = o, ?y = s}}.
Let O = hG, P i, where q, s, o  URI, G = {rdf :type(p, erdf :TotalProperty), q(s, o)},
st
and P = {p(?x, ?y)  p(?x, ?y)}. Then, it holds Ans st
O (p(?x, ?y))= Ans O (p(?x, ?y)) =
st
Ans O (p(?x, ?y)) = . This is because, in contrast to the above example, p is a total
property. Thus, for all mappings v : {?x, ?y}  VO , there is a stable model M of O
such that M |= v(p(?x, ?y)  p(?x, ?y)), and another stable model M  of O such that
M  |= v(p(?x, ?y)  p(?x, ?y)).
Consider the ERDF ontology O of the paper assignment example, below Definition
st
5.1. Then, Ans st
O (assign(P 1, R2)) =yes and Ans O (assign(P 2, R1)) =no. Though
st
Ans O (assign(P 2, R1)) =no, that is assign(P 2, R1) is not satisfied by all stable models of O, there is a stable model (M3 ) that satisfies assign(P 2, R1). Indeed the answers of
the query assign(?x, ?y) w.r.t. the stable models M3 and M4 are of particular interest since
59

fiAnalyti, Antoniou, Damasio, & Wagner

both M3 and M4 satisfy allAssigned (Paper , Reviewer ), indicating that the desirable paper
assignment has been achieved.
The following definition defines the credulous stable answers of a query F w.r.t. an
ERDF ontology O, that is the answers of F w.r.t. the particular stable models of O.
Definition 6.4 (Credulous ERDF stable answers) Let O = hG, P i be an ERDF ontology. The credulous (ERDF) stable answers of a query F w.r.t. O are defined as follows:

 yes if FVar (F ) =  and M  Mst (O) : M |= F
st
no if FVar (F ) =  and M  Mst (O) : M 6|= F
c-Ans O (F ) =

{ans M (F ) 6=  | M  Mst (O)}
if FVar (F ) 6= ,

where ans M (F ) = {v : FVar (F )  VO | M |= v(F )}. 

Continuing with the paper assignment example, consider the query:
F = allAssigned (Paper , Reviewer ).
st
Then, although Ans st
O (F ) =no, it holds c-Ans O (F ) =yes, indicating that there is at
least one desirable assignment of the papers P 1, P 2, P 3 to reviewers R1, R2, R3.
Consider now the query F = allAssigned (Paper , Reviewer )  assign(?x , ?y). Then,

c-Ans st
O (F ) = {{{?x = P 1, ?y = R2}, {?x = P 2, ?y = R1}, {?x = P 3, ?y = R3}},
{{?x = P 1, ?y = R2}, {?x = P 2, ?y = R3}, {?x = P 3, ?y = R1}}},

indicating all possible desirable assignments of papers. Obviously, the credulous stable
answers of a query F can provide alternative solutions, which can be useful in a range of
applications, where alternative scenarios naturally appear.
Closing this section, we would like to indicate several differences of the ERDF stable
model semantics w.r.t. first-order logic (FOL). First, in our semantics a domain closure assumption is made. This is due to the fact that the domain of every Herbrand interpretation
of an ERDF ontology O is ResH
O , that is the union of the vocabulary of O (VO ) and the
set of XML values of the well-typed XML literals in VO minus the well-typed XML literals.
This implies that quantified variables always range in a closed domain. To understand the
implications of this assumption, consider the ERDF graph:
G = {rdf :type(x, c1) | x  {c1, c2}  V  },

where V  = (VRDF  {rdf : i | i  IN })  VRDF S  VERDF . Additionally, consider the ERDF
program:
P = { rdf :type(?x, c1)  rdf :type(?x, rdfs:ContainerMembershipProperty).
rdf :type(?x, c2)  true.}.

Let F = ?x rdf :type(?x, c2)  rdf :type(?x, c1). It holds that hG, P i |=st F . However,
G  P 6|=F OL F . This is because, there is a FOL model M of G  P with a domain D
and a variable assignment v:{?x}  D such that M, v |= rdf :type(?x, c2) and M, v 6|=
rdf :type(?x, c1).
Another difference is due to the fact that in the definition of the ERDF stable model
semantics, only minimal Herbrand interpretations are considered. Let
60

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

G = {teaches(Anne, CS301 ), teaches(Peter , CS505 ), rdf :type(CS505 , GradCourse)}.

Let F = ?x teaches(Peter , ?x)  rdf :type(?x, GradCourse). Then, hG, i |=st F .
However, G 6|=F OL F . This is because, there is a FOL model M of G with a domain D
and a variable assignment v:{?x}  D such that M, v |= teaches(Peter , ?x) and M, v 6|=
rdf :type(?x, GradCourse). In other words, FOL makes an open-world assumption for
teaches.
Consider now G = G  {rdf :type(teaches, erdf :TotalProperty)}. Then, similarly to
FOL, it holds O = hG , i 6|=st F . This is because now teaches is a total property. Thus,
there is a stable model M of O and a variable assignment v: {?x}  ResH
O such that
M, v |= teaches(Peter , ?x) and M, v 6|= rdf :type(?x, GradCourse). In other worlds, now an
open-world assumption is made for teaches, as in FOL. Thus, there might exist a course
taught by Peter , even if it is not explicitly indicated so in G .
This example also shows that, in contrast to FOL, stable model entailment is nonmonotonic.
Note that the previous ERDF graph G can also be seen as a Description Logic A-Box
A (Baader et al., 2003), where
A = {teaches(Anne, CS301), teaches(Peter , CS505), GradCourse(CS505)}
Consider a T-Box T = . Since Description Logics (DLs) are fragments of first-order
logic, it holds that L = hA, T i 6|=DL teaches.GradCourse(Peter ), meaning that L does not
satisfy that all courses taught by Peter are graduate courses. An interesting approach for
supporting non-monotonic conclusions in DLs is taken by Donini et al. (2002), where DLs of
minimal knowledge and negation as failure (MKNF-DLs) are defined, by extending DLs with
two modal operators K, A. Intuitively, K expresses minimal knowledge and A expresses
weak negation. It holds that L |=MKNF-DL Kteaches.KGradCourse(Peter ), expressing that all
courses known to be taught by Peter are known to be graduate courses. Note that this
conclusion is non-monotonic, and thus it cannot be derived by classical DLs. However,
compared to our theory, MKNF-DLs do not support rules and closed-world assumptions on
properties (i.e., p(?x, ?y)  p(?x, ?y)).

7. An XML-based Syntax for ERDF
A natural approach to define an XML syntax for ERDF is: (i) to follow the RDF/XML
syntax (Beckett, 2004), as much as possible, and (ii) to extend it in a suitable way, where
necessary. Following this approach, we briefly present here an XML syntax for ERDF.
Details are going to be given in a subsequent paper.
Classes and properties are defined with the help of the rdfs:Class and rdf:Property
elements of the RDF/XML syntax. Similarly, total classes and total properties are defined with the help of the erdf:TotalClass and erdf:TotalProperty elements of the
ERDF/XML syntax.
Example 7.1 The following ERDF/XML statements:
<rdf:Property rdf:about="#likes">
<rdfs:domain rdf:resource="#Person"/>
61

fiAnalyti, Antoniou, Damasio, & Wagner

</rdf:Property>
<erdf:TotalProperty rdf:about="#authorOf">
<rdfs:domain rdf:resource="#Person"/>
<rdfs:range rdf:resource="#Book"/>
</erdf:TotalProperty>

correspond to the ERDF graph:
G = { rdf :type(likes, rdf :Property), rdfs:domain(likes, Person),
rdf :type(authorOf , erdf :TotalProperty), rdfs:domain(authorOf , Person),
rdfs:range(authorOf , Book )}.

ERDF triples (and sets of ERDF triples sharing the same subject term) are encoded
by means of the erdf:Description element. Each description contains a non-empty list of
(possibly negated) property-value slots about the subject term.
 URI references, blank node identifiers, and variables that appear in the subject position
of an ERDF triple are expressed as values of the erdf:about attribute, using the
SPARQL syntax (Prudhommeaux & Seaborne, 2008) for blank node identifiers and
variables. On the other hand, literals that appear in the subject position of an ERDF
triple are expressed as the text content of the erdf:about subelement.
 URI references, blank node identifiers, and variables that appear in the object position of an ERDF triple are expressed as values of the attributes rdf:resource,
rdf:nodeID, and erdf:variable, respectively. On the other hand, literals that appear in the object position of an ERDF triple are expressed as the text content of the
corresponding property subelement.
Example 7.2 The following erdf:Description statements:
<erdf:Description erdf:about="#Gerd">
<ex:authorOf rdf:nodeID="x"/>
<ex:likes rdf:resource="#Chicken"/>
<ex:likes erdf:negationMode="Sneg" rdf:resource="#Pork"/>
</erdf:Description>
<erdf:Description>
<erdf:About rdf:datatype="&xsd;string">Grigoris</erdf:About>
<ex:denotationOf rdf:resource="#Grigoris"/>
</erdf:Description>

correspond to the ERDF graph:
G = { authorOf (Gerd , ?x ), likes(Gerd , Chicken), likes(Gerd , Pork ),
denotationOf (Grigorisxsd :string, Grigoris) }.

Now, in order to express ERDF rules with XML, we use the rule markup language R2ML
(REWERSE Rule Markup Language) (Wagner, Giurca, & Lukichev, 2006, 2005), which
is a general XML-based markup language for representing derivation rules and integrity
constraints. This is demonstrated in the following example:
62

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

Example 7.3 The following erdf:DerivationRule statement:
<r2ml:DerivationRule r2ml:ruleID="R1">
<r2ml:conditions>
<erdf:Description erdf:about="?x">
<rdf:type rdf:resource="#MainDish"/>
</erdf:Description>
<erdf:Description erdf:about="?y">
<rdf:type rdf:resource="#Guest"/>
<ex:likes erdf:variable="x"/>
</erdf:Description>
<r2ml:NegationAsFailure>
<r2ml:ExistentiallyQuantifiedFormula>
<r2ml:GenericVariable r2ml:name="z" r2ml:class="#Guest"/>
<erdf:Description erdf:about="?z">
<ex:likes erdf:negationMode="Sneg" erdf:variable="x"/>
</erdf:Description>
</r2ml:ExistentiallyQuantifiedFormula>
</r2ml:NegationAsFailure>
</r2ml:conditions>
<r2ml:conclusion>
<erdf:Description erdf:about="?x">
<rdf:type rdf:resource="#SelectedMainDish"/>
</erdf:Description>
</r2ml:conclusion>
</r2ml:DerivationRule>

expresses that a main dish is selected for dinner, if there is a guest who likes it and no guest
who dislikes it. Specifically, it corresponds to the ERDF rule:
rdf :type(?x, SelectedMainDish)  rdf :type(?x, MainDish), rdf :type(?y, Guest), likes(?y, ?x),
 (?z rdf :type(?z, Guest), likes(?z, ?x)).

8. Undecidability of the ERDF Stable Model Semantics
The main difficulty in the computation of the ERDF stable model semantics is the fact that
VRDF is infinite, and thus the vocabulary of any ERDF ontology O is also infinite (note
that {rdf : i | i  IN }  VRDF  VO ). Due to this fact, satisfiability and entailment under
the ERDF stable model semantics are in general undecidable.
The proof of undecidability exploits a reduction from the unbounded tiling problem. The
unbounded tiling problem consists in placing tiles on an infinite grid, satisfying a given set
of constraints on adjacent tiles. Specifically, the unbounded tiling problem is a structure
D = hT , H, V i, where T = {T1 , ..., Tn } is a finite set of tile types and H, V  T  T specify
which tiles can be adjacent horizontally and vertically, respectively. A solution to D is a
tiling, that is, a total function  : IN  IN  T such that: ( (i, j),  (i + 1, j))  H and
( (i, j),  (i, j + 1))  V , for all i, j  IN . The existence of a solution for a given unbounded
tiling problem is known to be undecidable (Berger, 1966).
Let D = hT , H, V i be an instance of the unbounded tiling problem, where T = {T1 , ..., Tn }.
We will construct an ERDF ontology OD = hG, P i and an ERDF formula FD such that D
has a solution iff OD does not entail FD under the ERDF stable model semantics.
63

fiAnalyti, Antoniou, Damasio, & Wagner

Consider (i) a class Tile whose instances are the tiles placed on the infinite grid, (ii) a
property right(x , y) indicating that tile y is right next to tile x, (iii) a property above(x , y)
indicating that tile y is exactly above tile x, (iv) a class HasRight whose instances are the
tiles for which there exists a tile right next to them, (v) a class HasAbove whose instances
are the tiles for which there exists a tile exactly above them, (vi) a property Type(x, T ),
indicating that the type of tile x is T , (vii) a property HConstraint(T, T  ), indicating that
(T, T  )  H, and (viii) a property VConstraint(T, T  ), indicating that (T, T  )  V .
Let G be the ERDF graph:
G=

{rdfs:subClassOf (rdfs:ContainerMembershipProperty, Tile),
rdfs:subClassOf (Tile, rdfs:ContainerMembershipProperty)} 
{HConstraint(T, T  ) | (T, T  )  H}  {VConstraint(T, T  ) | (T, T  )  V } .

Let P be the ERDF program, containing the following rules (and constraints):
(1)

Type(?x, T1 )  rdf :type(?x, Tile), Type(?x, T2 ), ..., Type(?x, Tn ).
Type(?x, Ti )  rdf :type(?x, Tile), Type(?x, T1 ), ..., Type(?x, Ti1 ),
Type(?x, Ti+1 ), ..., Type(?x, Tn ), for all i = 2, ..., n  1.
Type(?x, Tn )  rdf :type(?x, Tile), Type(?x, T1 ), ..., Type(?x, Tn1 ).

(2)

right(?x, ?y)
right(?x, ?y)




rdf :type(?x, Tile), rdf :type(?y, Tile), right(?x, ?y).
rdf :type(?x, Tile), rdf :type(?y, Tile), right(?x, ?y).

(3)

above(?x, ?y)
above(?x, ?y)




rdf :type(?x, Tile), rdf :type(?y, Tile), above(?x, ?y).
rdf :type(?x, Tile), rdf :type(?y, Tile), above(?x, ?y).

(4)

rdf :type(?x, HasRight)  right(?x, ?y).
rdf :type(?x, HasAbove)  above(?x, ?y).
false  rdf :type(?x, Tile), rdf :type(?x, HasRight).
false  rdf :type(?x, Tile), rdf :type(?x, HasAbove).
id (?x, ?x)  rdf :type(?x, rdfs:Resource).
false  right(?x, ?y), right(?x, ?y  ), id (?y, ?y  ).
false  above(?x, ?y), above(?x, ?y  ), id (?y, ?y  ).

(5)

false  right(?x, ?y), Type(?x, ?T ), Type(?y, ?T  ), HConstraint(?T, ?T  ).
false  above(?x, ?y), Type(?x, ?T ), Type(?y, ?T  ), VConstraint(?T, ?T  ).

Note that in all stable models of OD = hG, P i, the class Tile contains exactly the
(infinite in mumber) rdf : i terms, for i  IN . This is because, computing the stable models
of O, only the minimal models of sk(G) are considered (see Definition 5.1, Step 1). Thus,
each tile on the infinite grid is represented by an rdf : i term, for i  IN .
Intuitively, rule set (1) expresses that each tile should have exactly one associated type
in T . Rule set (2) expresses that two tiles are either horizontally adjacent on the grid or not
64

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

horizontally adjacent. Rule set (3) expresses that two tiles are either vertically adjacent on
the grid or not vertically adjacent. Rule set (4) expresses that each tile should have exactly
one tile right next to it and exactly one tile right above it. Rule set (5) expresses that the
types of horizontally and vertically adjacent tiles should respect the H and V relations of
D, respectively.
To finalize the reduction, we define:
FD = ?x, ?y, ?x , ?y  , ?x right(?x, ?y)  above(?y, ?y  )  right(?x , ?y  )  above(?x , ?x ) 
id (?x, ?x ).

Formula FD expresses that there is a tile x such that, starting from x, if we move:
one step right  one step up  one step left  one step down

then we will meet a tile x different than x.
Proposition 8.1 Let D be an instance of the unbounded tiling problem. It holds:
1. D has a solution iff OD  {false  FD } has a stable model.
2. D has a solution iff OD 6|=st FD .
Since the unbounded tiling problem is undecidable (Berger, 1966), it follows directly from
Proposition 8.1 that satisfiability and entailment under the ERDF stable model semantics
are in general undecidable.
The previous reduction shows that both problems remain undecidable for an ERDF ontology O = hG, P i, even if (i) the body of each rule in P has the form t1 , ..., tk , tk+1 , ..., tn ,
where ti is an ERDF triple and (ii) the terms erdf :TotalClass and erdf :TotalProperty do
not appear in O, that is, (VG  VP )  VERDF = . Note that since each constraint false  F
that appears in an ERDF ontology O can be replaced by the rule t  F , where t is an
RDF, RDFS, or ERDF axiomatic triple, the presence of constraints in O does not affect
decidability.
Future work concerns the identification of syntactic restrictions for an ERDF ontology
O such that ERDF stable model entailment is decidable.

9. ERDF Model Theory as Tarski-style Model Theory
Tarski-style model theory is not limited to classical first-order models, as employed in the
semantics of OWL. It allows various extensions, such as relaxing the bivalence assumption
(e.g., allowing for partial models) or allowing higher-order models. It is also compatible
with the idea of non-monotonic inference, simply by not considering all models of a rule as
being intended, but only those models that satisfy certain criteria. Thus, the stable model
semantics for normal and (generalized) extended logic programs (Gelfond & Lifschitz, 1988,
1990; Herre & Wagner, 1997; Herre et al., 1999) can be viewed as a Tarski-style modeltheoretic semantics for non-monotonic derivation rules.
A Tarski-style model theory is a triple hL, I, |=i such that:
 L is a set of formulas, called language,
65

fiAnalyti, Antoniou, Damasio, & Wagner

 I is a set of interpretations, and
 |= is a relation between interpretations and formulas, called model relation.
For each Tarski-style model theory hL, I, |=i, we can define:
 a notion of derivation rule G  F , where F  L is called condition and G  L is
called conclusion,
 a set of derivation rules DRL = {G  F | F, G  L},
 an extension of the model relation |= to include also pairs of interpretations and
derivation rules, and
 a standard model operator M(KB ) = {I  I | I |= X, X  KB }, where KB 
L  DRL is a set of formulas and/or derivation rules, called a knowledge base.
Notice that in this way we can define rules also for logics which do not contain an
implication connective. This shows that the concept of a rule is independent of the concept
of implication.
Typically, in knowledge representation theories, not all models of a knowledge base are
intended models. Except from the standard model operator M, there are also non-standard
model operators, which do not provide all models of a knowledge base, but only a special
subset that is supposed to capture its intended models according to some semantics.
A particularly important type of such an intended model semantics is obtained on the
basis of some information ordering , which allows to compare the information content of
two interpretations I1 , I2  I. Whenever I1  I2 , we say that I1 is less informative than
I2 . An information model theory hL, I, |=, i is a Tarski-style model theory, extended by
an information ordering .
For any information model theory, we can define a number of natural non-standard
model operators, such as the minimal model operator:
Mmin (KB ) = minimal (M(KB ))
and various refinements of it, like the stable generated models (Gelfond & Lifschitz, 1988,
1990; Herre & Wagner, 1997; Herre et al., 1999).
For any given model operator Mx : P(L  DRL )  P(I), knowledge base KB 
L  DRL , and F  L, we can define an entailment relation:
KB |=x F

iff I  Mx (KB ), I |= F

For non-standard model operators, like minimal and stable models, this entailment
relation is typically non-monotonic, in the sense that for an extension KB   KB it may
be the case that KB entails F , but KB  does not entail F .
Our (ERDF) stable model theory can be seen as a Tarski-style model theory, where
L = L(URI  LIT ), I is the set of ERDF interpretations over any vocabulary V 
URI  LIT , and the model relation |= is as defined in Definitions 3.5 and 4.3. In our
theory, the intended model operator (Mst ) assigns to each ERDF ontology a (possibly
empty) set of stable models (Definition 5.1).
66

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

10. Related Work
In this section, we briefly review extensions of web ontology languages with rules.
Ter Horst (2005b, 2004) generalizes RDF graphs to generalized RDF graphs, by allowing variables in the property position of RDF triples. Additionally, the author extends the
RDFS semantics with datatypes and part of the OWL vocabulary, defining the pD semantics, which extends the if-semantics of RDFS and is weaker than the iff-semantics of
D-entailment (Hayes, 2004) and OWL Full (Patel-Schneider, Hayes, & Horrocks, 2004). A
sound and complete set of entailment rules for pD entailment is also presented.
In a subsequent work, ter Horst (2005a) considers the extension of the previous framework with the inclusion of rules of the form if G then G , where G is an RDF graph without
blank nodes but possibly with variables and G is a generalized RDF graph, possibly with
both blank nodes and variables. Intuitively, rule variables are universally quantified in the
front of the rule (like the free variables of our rules) and blank nodes in the head of the rule
correspond to existentially quantified variables (this feature is not supported in our model).
Based on a set of rules R and a datatype map D, R-entailment16 is defined between two
generalized RDF graphs G and G (G |=R G ), and a set of sound and complete rules for
R-entailment is presented. To relate our work with that of ter Horst (2005a), we state the
following proposition:
Let D be a datatype map, containing only rdf :XMLLiteral , and let R be a set of rules of the form
if G then G  with the constraints: (i) all terms appearing in property position are URIs, (ii) if
G 6= {} then no blank node appears in G , and (iii) VR  (VpOWL  VERDF ) = , where VpOWL
denotes the part of the OWL vocabulary, included in the pD semantics. Let G, G be RDF graphs
such that (VG  VG )  (VpOWL  VERDF ) = . Then based on G and R, we can define, by a simple
transformation, an ERDF ontology O such that G |=R G iff O |=st G .

However, in this work, weak and strong negation are not considered. Thus, closed-world
reasoning is not supported. Additionally, in our theory, the condition of a rule is any ERDF
formula over a vocabulary V , (thus, involving any of the logical factors , , , , , ,
and ), and not just a conjunction of positive triples.
TRIPLE (Sintek & Decker, 2002) is a rule language for the Semantic Web that is
especially designed for querying and transforming RDF models (or contexts), supporting
RDF and a subset of OWL Lite. Its syntax is based on F-Logic (Kifer, Lausen, & Wu,
1995) and supports an important fragment of first-order logic. A triple is represented by
a statement of the form s[p  o] and sets of statements, sharing the same subject s, can
be aggregated using molecules of the form s[p1  o1 ; p2  o2 ; ....]. All variables must be
explicitly quantified, either existentially or universally. Arbitrary formulas can be used in
the body, while the head of the rules is restricted to atoms or conjunctions of molecules.
An interesting and relevant feature of TRIPLE is the use of models to collect sets of related
sentences. In particular, part of the semantics of the RDF(S) vocabulary is represented as
pre-defined rules (and not as semantic conditions on interpretations), which are grouped
together in a module. TRIPLE provides other features like path expressions, skolem model
terms, as well as model intersection and difference. Finally, it should be mentioned that
the queries and models are compiled into XSB Prolog. TRIPLE uses the Lloyd-Topor
transformations (Lloyd & Topor, 1984) to take care of the first-order connectives in the
16. The symbol D does not appear explicitly in the notation of R-entailement, for reasons of simplification.

67

fiAnalyti, Antoniou, Damasio, & Wagner

sentences and supports weak negation under the well-founded semantics (Gelder, Ross, &
Schlipf, 1991). Strong negation is not used.
Flora-2 (Yang, Kifer, & Zhao, 2003) is a rule-based object-oriented knowledge base system for reasoning with semantic information on the Web. It is based on F-logic (Kifer
et al., 1995) and supports metaprogramming, non-monotonic multiple inheritance, logical database updates, encapsulation, dynamic modules, and two kinds of weak negation.
Specifically, it supports Prolog negation and well-founded negation (Gelder et al., 1991),
through invocation of the corresponding operators \+ and tnot of the XSB system (Rao,
Sagonas, Swift, Warren, & Freire, 1997). The formal semantics for non-monotonic multiple inheritance is defined by Yang & Kifer (2003a). In addition, Flora-2 supports reification and anonymous resources (Yang & Kifer, 2003b). In particular, in Flora-2, reified
statements ${s(p  o)}$ are themselves objects. In contrast, in RDF(S), they are referred to by a URI or a blank node x, and are associated with the following RDF triples:
rdf :type(x, rdf :Statement), rdf :subject(x, s), rdf :predicate(x, p), and rdf :object(x, o). In
RDF(S) model theory (and thus, in our theory), no special semantics are given to reified
statements. In Flora-2, anonymous resources are handled through skolemization (similarly
to our theory).
Notation 3 (N3) (Berners-Lee, Connolly, Kagal, Scharf, & Hendler, 2008) provides a
more human readable syntax for RDF and also extends RDF by adding numerous predefined constructs (built-ins) for being able to express rules conveniently. Remarkably,
N3 contains a built-in (log:definitiveDocument) for making restricted completeness assumptions and another built-in (log:notIncludes) for expressing simple negation-as-failure
tests. The addition of these constructs was motivated by use cases. However, N3 does not
provide strong negation and closed-world reasoning is not fully supported. N3 is supported
by the CWM system17 , a forward engine especially designed for the Semantic Web, and
the Euler system18 , a backward engine relying on loop checking techniques to guarantee
termination.
Alferes et al. (2003) propose the paraconsistent well-founded semantics with explicit
negation (WFSXP )19 , as the appropriate semantics for reasoning with (possibly, contradictory) information in the Semantic Web. Supporting arguments include: (i) possible
reasoning, even in the presence of contradiction, (ii) program transformation into WFS,
and (iii) polynomial time inference procedures. No formal model theory has been explicitly
provided for the integrated logic.
DR-Prolog (Antoniou, Bikakis, & Wagner, 2004) and DR-DEVICE (Bassiliades, Antoniou, & Vlahavas, 2004) are two systems that integrate RDFS ontologies with rules (strict or
defeasible), that are partially ordered through a superiority relation, based on the semantics
of defeasible logic (Antoniou, Billington, Governatori, & Maher, 2001; Maher, 2002). Defeasible logic contains only one kind of negation (strong negation) in the object language20 and
allows to reason in the presence of contradiction and incomplete information. It supports
17. http://www.w3.org/2000/10/swap/doc/cwm.html.
18. http://www.agfa.com/w3c/euler/.
19. WFSXP (Alferes, Damasio, & Pereira, 1995) is an extension of the well-founded semantics with explicit
negation (WFSX) on extended logic programs (Pereira & Alferes, 1992) and, thus, also of the wellfounded semantics (WFS) on normal logic programs (Gelder et al., 1991).
20. However, in defeasible logic, negation-as-failure can be easily simulated by other language ingredients.

68

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

monotonic and non-monotonic rules, exceptions, default inheritance, and preferences. No
formal model theory has been explicitly provided for the integrated logic.
OWL-DL (McGuinness & van Harmelen, 2004) is an ontology representation language
for the Semantic Web, that is a syntactic variant of the SHOIN (D) description logic and
a decidable fragment of first-order logic (Horrocks & Patel-Schneider, 2003). However, the
need for extending the expressive power of OWL-DL with rules has initiated several studies,
including the SWRL (Semantic Web Rule Language) proposal (Horrocks, Patel-Schneider,
Boley, Tabet, Grosof, & Dean, 2004). Horrocks & Patel-Schneider (2004) show that this
extension is in general undecidable. AL-log (Donini, Lenzerini, Nardi, & Schaerf, 1998)
was one of the first efforts to integrate Description Logics with (safe) datalog rules, while
achieving decidability. It considers the basic description logic ALC and imposes the constraint that only concept DL-atoms are allowed to appear in the body of the rules, whereas
the heads of the rules are always non DL-atoms. Additionally, each variable appearing in
a concept DL atom in the body of a rule has also to appear in a non DL-atom in the body
or head of the rule. CARIN (Levy & Rousset, 1998) provides a framework for studying the
effects of combining the description logic ALCN R with (safe) datalog rules. In CARIN,
both concept and role DL-atoms are allowed in the body of the rules. It is shown that the
integration is decidable if rules are non-recursive, or certain combinations of constructors
are not allowed in the DL component, or rules are role-safe (imposing a constraint on the
variables of role DL atoms in the body of the rules)21 . Motik et al. (2004) show that the
integration of a SHIQ(D) knowledge base L with a disjunctive datalog program P is decidable, if P is DL-safe, that is, all variables in a rule occur in at least one non DL-atom in the
body of the rule. In this work, in contrast to AL-log and CARIN, no tableaux algorithm
is employed for query answering but L is translated to a disjunctive logic program DD(L)
which is combined with P for answering ground queries.
In this category of works, entailment on the DL, that has been extended with rules, is
based on first-order logic. This means that both the DL component and the logic program
are viewed as a set of first-order logic statements. Thus, negation-as-failure, closed-worldassumptions, and non-monotonic reasoning cannot be supported. In contrast, our work
supports both weak and strong negation, and allows closed-world and open-world reasoning
on a selective basis.
A different kind of integration is achieved by Eiter et al. (2004a). In this work, a
SHOIN (D) knowledge base L communicates with an extended logic program P (possibly
with weak and strong negation), only through DL-query atoms in the body of the rules. In
particular, the description logic component L is used for answering the augmented, with
input from the logic program, queries appearing in the (possibly weakly negated) DL-query
atoms, thus allowing flow of knowledge from P to L and vice-versa. The answer set semantics of hL, P i are defined, as a generalization of the answer set semantics (Gelfond
& Lifschitz, 1990) on ordinary extended logic programs. A similar kind of integration is
achieved by Eiter et al. (2004b). In this work, a SHOIN (D) knowledge base L communicates with a normal logic program P (possibly with weak negation), through DL-query
atoms in the body of the rules. The well-founded semantics of hL, P i are defined, as a
21. A rule is role-safe if at least one of the variables x, y of each role DL atom R(x, y) in the body of the
rule, appears in some body atom of a base predicate, where a base predicate is an ordinary predicate that
appears only in facts or in rule bodies.

69

fiAnalyti, Antoniou, Damasio, & Wagner

generalization of the well-founded semantics (Gelder et al., 1991) of ordinary normal logic
programs. Obviously, in both of these works, derived information concerns only non DLatoms (that can be possibly used as input to DL-query atoms). Thus, rule-based reasoning
is supported only for non DL-atoms. In contrast, in our work, properties and classes appearing in the ERDF graphs can freely appear in the heads and bodies of the rules, allowing
even the derivation of metalevel statements such as subclass and subproperty relationships,
property transitivity, property and class totalness.
Rosati (1999) defines the semantics of a disjunctive AL-log knowledge base, based on
the stable model semantics for disjunctive databases (Gelfond & Lifschitz, 1991), extending
AL-log (Donini et al., 1998). A disjunctive AL-log knowledge base is the integration of an
ALC knowledge base T with a (safe) disjunctive logic program P that allows concept and
role DL-atoms in the body of the rules (along with weak negation on non DL-atoms). The
safety condition enforces that each variable in the head of a rule should also appear in the
body of the rule. Additionally, all constants in P should be DL-individuals. Similarly to
our case, in defining the disjunctive AL-log semantics, only the grounded versions of the
rules are considered (by instantiating variables with DL individuals). However rule-based
reasoning is supported only for non DL-atoms, and DL-atoms in the body of the rules
mainly express constraints.
In a subsequent work, Rosati (2005) defines the r-hybrid knowledge bases. In r-hybrid
knowledge bases, DL-atoms are allowed in the head of the rules and the DL component
T is a SHOIN (D) knowledge base. Additionally, constants in P are not necessarily DLindividuals. However, a stronger safety condition is imposed, as each rule variable should
appear in a (positive) non DL-atom in the body of the rule. Additionally, weak negation is
allowed only for non DL-atoms and rule-based meta-reasoning is not supported. In general,
we can say that for non DL-atoms, a closed-world assumption is made, while DL-atoms
conform to the open-world assumption, as SHOIN (D) is a fragment of first-order logic.

11. Conclusions
In this paper, we have extended RDF graphs to ERDF graphs by allowing negative triples
for representing explicit negative information. Then, we proceeded by defining an ERDF
ontology as an ERDF graph complemented by a set of derivation rules with all connectives
 (weak negation),  (strong negation),  (material implication), , , ,  in the body
of a rule, and with strong negation  in the head of a rule. Moreover, we have extended
the RDF(S) vocabulary by adding the predefined vocabulary elements erdf :TotalProperty
and erdf :TotalClass, for representing the metaclasses of total properties and total classes,
on which the open-world assumption applies.
We have defined ERDF formulas, ERDF interpretations, and ERDF entailment on
ERDF formulas, showing that it conservatively extends RDFS entailment on RDF graphs.
We have developed the model-theoretic semantics of ERDF ontologies, called ERDF stable
model semantics, showing that stable model entailment extends ERDF entailment on ERDF
graphs, and thus it also extends RDFS entailment on RDF graphs. The ERDF stable model
semantics is based on Partial Logic and, in particular, on its generalized definition of stable
models (Herre & Wagner, 1997; Herre et al., 1999) (which extends answer set semantics
on extended logic programs). We have shown that classical (boolean) Herbrand model
70

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

reasoning is a special case of our semantics, when all properties are total. In this case,
similarly to classical logic, an open-world assumption is made for all properties and classes
and the two negations (weak and strong negation) collapse. Allowing (a) the totality of
properties and classes to be declared on a selective basis and (b) the explicit representation
of closed-world assumptions (as derivation rules) enables the combination of open-world
and closed-world reasoning in the same framework.
In particular, for a total property p, the open-world assumption applies, since each
considered Herbrand interpretation I, in the computation of ERDF stable models, satisfies
p(x, y)p(x, y), for each pair (x, y) of ontology vocabulary terms. For a closed property p,
a default closure rule of the form p(?x, ?y)  p(?x, ?y) is added, which allows to infer
the falsity of p(x, y), if there is no evidence that p(x, y) holds. However, this method only
works for partial properties. For a total property p, it may happen that there is a stable
model, where p(x, y) holds, even though there is no evidence for it (see the example in
Section 5, above Proposition 5.1). In fact, if p is a total property, the existence or not of
the corresponding default closure rule does not affect the ontology semantics.
The main advantages of ERDF are summarized as follows:
 It has a Tarski-style model theory, which is a desirable feature for logic languages for
the Semantic Web (Bry & Marchiori, 2005).
 It is based on Partial Logic (Herre et al., 1999), which is the simplest conservative
extension of classical logic that supports both weak and strong negation. Partial
logic also extends Answer Set Programming (ASP)22 (Gelfond & Lifschitz, 1990), by
allowing all logical factors , , , , , ,  in the body of a rule.
 It enables the combination of open-world (monotonic) and closed-world (non-monotonic)
reasoning, in the same framework.
 It extends RDFS ontologies with derivation rules and integrity constraints.
Satisfiability and entailment under the ERDF stable model semantics are in general undecidable. In a subsequent paper, we plan to identify syntactic restrictions for the ERDF
ontologies that guarantee decidability of reasoning and to elaborate on the ERDF computability and complexity issues.
In this work, we consider only coherent ERDF interpretations. However, due to the
Semantic Webs decentralized and distributed nature, contradictory information is frequent
(Schaffert, Bry, Besnard, Decker, Decker, Enguix, & Herzig, 2005). Though Partial Logic
allows for truth-value clashes, handling inconsistency in the Semantic Web is a topic that
deserves extended treatment, which is outside the scope of this paper. It is in our future
plans to consider general ERDF interpretations and extend the vocabulary of ERDF with
the terms erdf :CoherentProperty and erdf :CoherentClass, whose instances are properties
and classes that satisfy coherence. Thus, coherence will be decided on a per property and
22. ASP is a well-known and accepted knowledge representation formalism that allows (through credulous
reasoning) the definition of concepts ranging over a space of choices. This feature enables the compact
representation of search and optimization problems (Eiter, Ianni, Polleres, & Schindlauer, 2006).

71

fiAnalyti, Antoniou, Damasio, & Wagner

per class basis. Admitting incoherent models will only be interesting in combination with
a second preference criterion of minimal incoherence (Herre et al., 1999).
Our future work also concerns the support of datatypes, including XSD datatypes, and
the extension of the predefined ERDF vocabulary by adding other useful constructs, possibly
in accordance with the extensions of ter Horst (2005b). We also plan to formally define the
ERDF/XML syntax, briefly presented in Section 7. Moreover, we plan to implement an
ERDF inference engine.
Finally, we would like to mention that the success of the Semantic Web is impossible without support for modularity, encapsulation, information hiding, and access control.
Modularity mechanisms and syntactic restrictions for merging knowledge bases in the Semantic Web are explored by Damasio et al. (2006). However, in this work, knowledge bases
are expressed by extended logic programs. Our future plans include the extension of ERDF
with mechanisms allowing sharing of knowledge between different ERDF ontologies, along
the lines proposed by Damasio et al. (2006).

Acknowledgments
The authors would like to thank the reviewers for their valuable comments. This research
has been partially funded by the European Commission and by the Swiss Federal Office for Education and Science within the 6th Framework Programme project REWERSE
num. 506779 (www.rewerse.net).

Appendix A: RDF(S) Semantics
For self-containment, in this Appendix, we review the definitions of simple, RDF, and
RDFS interpretations, as well as the definitions of satisfaction of an RDF graph and RDFS
entailment. For details, see the W3C Recommendation of RDF semantics (Hayes, 2004).
Let URI denote the set of URI references, PL denote the set of plain literals, and T L
denote the set of typed literals, respectively. A vocabulary V is a subset of URI  PL  T L.
The vocabulary of RDF, VRDF , and the vocabulary of RDFS, VRDF S , are shown in Table
1 (Section 3).
Definition A.1 (Simple interpretation) A simple interpretation I of a vocabulary V
consists of:
 A non-empty set of resources ResI , called the domain or universe of I.
 A set of properties P ropI .
 A vocabulary interpretation mapping IV : V  URI  ResI  P ropI .
 A property extension mapping PT I : P ropI  P(ResI  ResI ).
 A mapping ILI : V  T L  ResI .
 A set of literal values LV I  ResI , which contains V  PL.

We define the mapping: I : V  ResI  P ropI such that:
 I(x) = IV (x), x  V  URI.
72

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

 I(x) = x,  x  V  PL.
 I(x) = ILI (x),  x  V  T L. 

Definition A.2 (Satisfaction of an RDF graph w.r.t. a simple interpretation) Let
G be an RDF graph and let I be a simple interpretation of a vocabulary V . Let v be a
mapping v : Var (G)  ResI . If x  Var (G), we define [I + v](x) = v(x). If x  V , we
define [I + v](x) = I(x). We define:
 I, v |= G iff  p(s, o)  G, it holds that: p  V, s, o  V  Var , I(p)  P ropI , and
h[I + v](s), [I + v](o)i  PT I (I(p)).
 I satisfies the RDF graph G, denoted by I |= G, iff there exists a mapping v :
Var (G)  ResI such that I, v |= G. 
rdf :type(rdf :type, rdf :Property)
rdf :type(rdf :subject, rdf :Property)
rdf :type(rdf :predicate, rdf :Property)
rdf :type(rdf :object, rdf :Property)
rdf :type(rdf :f irst, rdf :Property)
rdf :type(rdf :rest, rdf :Property)
rdf :type(rdf :value, rdf :Property)
rdf :type(rdf : i, rdf :Property), i  {1, 2, ...}
rdf :type(rdf :nil, rdf :List)

Table 2: The RDF axiomatic triples
Definition A.3 (RDF interpretation) An RDF interpretation I of a vocabulary V is a
simple interpretation of V  VRDF , which satisfies the following semantic conditions:
1. x  P ropI iff hx, I(rdf :Property)i  PT I (I(rdf :type)).
2. If srdf :XMLLiteral  V and s is a well-typed XML literal string, then
ILI (srdf :XMLLiteral ) is the XML value of s,
ILI (srdf :XMLLiteral )  LV I , and
hILI (srdf :XMLLiteral ), I(rdf :XMLLiteral )i  PT I (I(rdf :type)).
3. If srdf :XMLLiteral  V and s is an ill-typed XML literal string then
ILI (srdf :XMLLiteral )  ResI  LV I , and
hILI (srdf :XMLLiteral ), I(rdf :XMLLiteral )i 6 PT I (I(rdf :type)).
4. I satisfies the RDF axiomatic triples, shown in Table 2. 

Definition A.4 (RDF entailment) Let G, G be RDF graphs. We say that G RDFentails G (G |=RDF G ) iff for every RDF interpretation I, if I |= G then I |= G . 
Definition A.5 (RDFS interpretation) An RDFS interpretation I of a vocabulary V
is an RDF interpretation of V  VRDF  VRDF S , extended by the new ontological category
ClsI  ResI for classes, as well as the class extension mapping CT I : ClsI  P(ResI ),
such that:
73

fiAnalyti, Antoniou, Damasio, & Wagner

rdfs:domain(rdf :type, rdfs:Resource)
rdfs:domain(rdfs:domain, rdf :Property)
rdfs:domain(rdfs:range, rdf :Property)
rdfs:domain(rdfs:subPropertyOf , rdf :Property)
rdfs:domain(rdfs:subClassOf , rdfs:Class)
rdfs:domain(rdf :subject, rdf :Statement)
rdfs:domain(rdf :predicate, rdf :Statement)
rdfs:domain(rdf :object, rdf :Statement)
rdfs:domain(rdfs:member, rdfs:Resource)
rdfs:domain(rdf :f irst, rdf :List)
rdfs:domain(rdf :rest, rdf :List)
rdfs:domain(rdfs:seeAlso, rdfs:Resource)
rdfs:domain(rdfs:isDef inedBy, rdfs:Resource)
rdfs:domain(rdfs:comment, rdfs:Resource)
rdfs:domain(rdfs:label, rdfs:Resource)
rdfs:domain(rdfs:value, rdfs:Resource)
rdfs:range(rdf :type, rdfs:Class)
rdfs:range(rdfs:domain, rdfs:Class)
rdfs:range(rdfs:range, rdfs:Class)
rdfs:range(rdfs:subPropertyOf , rdf :Property)
rdfs:range(rdfs:subClassOf , rdfs:Class)
rdfs:range(rdf :subject, rdfs:Resource)
rdfs:range(rdf :predicate, rdfs:Resource)
rdfs:range(rdf :object, rdfs:Resource)
rdfs:range(rdfs:member, rdfs:Resource)
rdfs:range(rdf :f irst, rdfs:Resource)
rdfs:range(rdf :rest, rdf :List)
rdfs:range(rdfs:seeAlso, rdfs:Resource)
rdfs:range(rdfs:isDef inedBy, rdfs:Resource)
rdfs:range(rdfs:comment, rdfs:Literal)
rdfs:range(rdfs:label, rdfs:Literal)
rdfs:range(rdf :value, rdfs:Resource)
rdfs:subClassOf (rdf :Alt, rdfs:Container)
rdfs:subClassOf (rdf :Bag, rdfs:Container)
rdfs:subClassOf (rdf :Seq, rdfs:Container)
rdfs:subClassOf (rdfs:ContainerMembershipProperty, rdf :Property)
rdfs:subPropertyOf (rdfs:isDef inedBy, rdfs:seeAlso)
rdf :type(rdf :XMLLiteral , rdfs:Datatype)
rdfs:subClassOf (rdf :XMLLiteral , rdfs:Literal)
rdfs:subClassOf (rdfs:Datatype, rdfs:Class)
rdf :type(rdf : i, rdfs:ContainerMembershipProperty), i  {1, 2, ...}
rdfs:domain(rdf : i, rdfs:Resource), i  {1, 2, ...}
rdfs:range(rdf : i, rdfs:Resource), i  {1, 2, ...}

Table 3: The RDFS axiomatic triples

74

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

1. x  CT I (y) iff hx, yi  PT I (I(rdf :type)).
2. The ontological categories are defined as follows:
ClsI = CT I (I(rdfs:Class)),
ResI = CT I (I(rdfs:Resource)), and
LV I = CT I (I(rdfs:Literal)).
3. If hx, yi  PT I (I(rdfs:domain)) and hz, wi  PT I (x) then z  CT I (y).
4. If hx, yi  PT I (I(rdfs:range)) and hz, wi  PT I (x) then w  CT I (y).
5. If x  ClsI then hx, I(rdfs:Resource)i  PT I (I(rdfs:subClassOf )).
6. If hx, yi  PT I (I(rdfs:subClassOf )) then x, y  ClsI , CT I (x)  CT I (y).
7. PT I (I(rdfs:subClassOf )) is a reflexive and transitive relation on ClsI .
8. If hx, yi  PT I (I(rdfs:subPropertyOf )) then x, y  P ropI , PT I (x)  PT I (y).
9. PT I (I(rdfs:subPropertyOf )) is a reflexive and transitive relation on P ropI .
10. If x  CT I (I(rdfs:Datatype)) then hx, I(rdfs:Literal)i  PT I (I(rdfs:subClassOf )).
11. If x  CT I (I(rdfs:ContainerM embershipP roperty)) then
hx, I(rdfs:member)i  PT I (I(rdfs:subPropertyOf )).
12. I satisfies the RDFS axiomatic triples, shown in Table 3. 

Definition A.6 (RDFS entailment) Let G, G be RDF graphs. We say that G RDFSentails G (G |=RDF S G ) iff for every RDFS interpretation I, if I |= G then I |= G .


Appendix B: Proofs
In this Appendix, we prove the lemmas and propositions presented in the main paper. In
addition, we provide Lemma B.1, which is used in some of the proofs. To reduce the size of
the proofs, we have eliminated the namespace from the URIs in VRDF  VRDF S  VERDF .
Lemma B.1 Let F be an ERDF formula and let I be a partial interpretation of a
vocabulary V . Let u, u be mappings u, u : Var (F )  ResI such that u(x) = u (x),
x  FVar (F ). It holds: I, u |= F iff I, u |= F .
Proof: We prove the proposition by induction. Without loss of generality, we assume that
 appears only in front of positive ERDF triples. Otherwise we apply the transformation
rules of Definition 3.4, to get an equivalent formula that satisfies the assumption.
Let F = p(s, o). It holds: I, u |= F iff p  V , s, o  V  Var , I(p)  P ropI , and
h[I + u](s), [I + u](o)i  PT I (I(p)) iff p  V , s, o  V  Var , I(p)  P ropI , and h[I +
u ](s), [I + u ](o)i  PT I (I(p)) iff I, u |= p(s, o).
Let F = p(s, o). It holds: I, u |= F iff p  V , s, o  V  Var , I(p)  P ropI ,
and h[I + u](s), [I + u](o)i  PF I (I(p)) iff p  V , s, o  V  Var , I(p)  P ropI , and
h[I + u ](s), [I + u ](o)i  PF I (I(p)) iff I, u |= p(s, o).
Assumption: Assume that the lemma holds for the subformulas of F .
We will show that the lemma holds also for F .
Let F = G. It holds: I, u |= F iff I, u |= G iff VG  V and I, u 6|= G iff VG  V and
I, u 6|= G iff I, u |= G iff I, u |= F .
75

fiAnalyti, Antoniou, Damasio, & Wagner

Let F = F1 F2 . It holds: I, u |= F iff I, u |= F1 F2 iff I, u |= F1 and I, u |= F2 iff
I, u |= F1 and I, u |= F2 iff I, u |= F1 F2 iff I, u |= F .
Let F = x G. We will show that (i) if I, u |= F then I, u |= F and (ii) if I, u |= F
then I, u |= F .
(i) Let I, u |= F . Then, I, u |= xG. Thus, there exists a mapping u1 : Var (G)  ResI
s.t. u1 (y) = u(y), y  Var (G)  {x}, and I, u1 |= G. Let u2 be the mapping u2 :
Var (G)  ResI s.t. u2 (y) = u (y), y  Var (G)  {x}, and u2 (x) = u1 (x). Since u(z) =
u (z), z  FVar (F ) and x  FVar (G), it follows that u1 (z) = u2 (z), z  FVar (G).
Thus, I, u2 |= G. Therefore, there exists a mapping u2 : Var (G)  ResI s.t. u2 (y) = u (y),
y  Var (G)  {x}, and I, u2 |= G. Thus, I, u |= x G, which implies that I, u |= F .
(ii) We prove this statement similarly to (i) by exchanging u and u .
Let F = F1 F2 or F = F1  F2 or F = xG. We can prove, similarly to the above
cases, that I, u |= F iff I, u |= F . 
Lemma 3.1. Let G be an ERDF graph and let I be a partial interpretation of a vocabulary
V . It holds: I |=GRAPH G iff I |= formula(G).
Proof: Let G = {t1 , ..., tn } and F = formula(G).
) Assume that I |=GRAPH G, we will show that I |= F . Since I |=GRAPH G, it follows that
v : Var (G)  ResI such that I, v |= ti , i = 1, ..., n. Thus, v : Var (G)  ResI such
that I, v |= t1 ...tn . This implies that u : Var (G)  ResI such that I, u |= F . Since
FVar (F ) = , it follows from Lemma B.1 that u : Var (G)  ResI , it holds that I, u |= F .
Thus, I |= F .
) Assume that I |= F , we will show that I |=GRAPH G. Since I |= F , it follows that
v : Var (G)  ResI it holds that I, v |= F . Thus, v : Var (G)  ResI such that
I, v |= F . This implies that u : Var (G)  ResI such that I, u |= t1 ...tn . Thus,
u : Var (G)  ResI such that I, u |= ti , i = 1, ..., n. Therefore, I |=GRAPH G. 
Proposition 3.1. Let I be an ERDF interpretation of a vocabulary V and let V  =
V  VRDF  VRDF S  VERDF . Then,
1. For all p, s, o  V  such that I(p)  TProp I , it holds:
I |= p(s, o) iff I |= p(s, o) (equivalently, I |= p(s, o)  p(s, o)).
2. For all x, c  V  such that I(c)  TCls I , it holds:
I |= rdf :type(x, c) iff I |= rdf :type(x, c)
(equivalently, I |= rdf :type(x, c)  rdf :type(x, c)).
Proof:
1) It holds: I |= p(s, o) iff I 6|= p(s, o) iff hI(s), I(o)i 6 PT I (p) iff (since p  TProp I )
hI(s), I(o)i  PF I (p) iff I |= p(s, o). Therefore, I |= p(s, o) iff I |= p(s, o).
We will also show that I |= p(s, o)  p(s, o). It holds I |= p(s, o) or I |= p(s, o). This
implies that I |= p(s, o) or I |= p(s, o), and thus, I |= p(s, o)  p(s, o).
2) The proof is similar to the proof of 1) after replacing p(s, o) by type(x, c) and TProp I by
TCls I . 
Proposition 3.2. Let G, G be RDF graphs such that VG  VERDF =  and VG  VERDF =
. Then, G |=RDF S G iff G |=ERDF G .
76

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

Proof:
) Let G |=ERDF G . We will show that G |=RDF S G . In particular, let I be an RDFS
interpretation of a vocabulary V s.t. I |= G, we will show that I |= G .
Since I |= G, it holds that v : Var (G)  ResI s.t. I, v |= G. Our goal is to construct
an ERDF interpretation J of V s.t. J |= G. We consider an 1-1 mapping res : VERDF  R,
where R is a set disjoint from ResI . Additionally, let V  = V  VRDF  VRDF S  VERDF .
Based on I and the mapping res, we construct a partial interpretation J of V as follows:
 ResJ = ResI  res(VERDF ).
 JV (x) = IV (x), x  (V   VERDF )  URI and JV (x) = res(x), x  VERDF .
 We define the mapping: ILJ : V   T L  ResJ such that: ILJ (x) = ILI (x).
 We define the mapping: J : V   ResJ such that:
 J(x) = JV (x), x  V   URI.
 J(x) = x,  x  V   PL.
 J(x) = ILJ (x),  x  V   T L.
 We define the mapping PT J : ResJ  P(ResJ  ResJ ) as follows:
(PT1) if x, y, z  ResI and hx, yi  PT I (z) then hx, yi  PT J (z).
(PT2) hres(TotalClass), J(Class)i  PT J (J(subClassOf )).
(PT3) hres(TotalProperty), J(Property)i  PT J (J(subClassOf )).
Starting from the derivations of (PT1), (PT2), and (PT3), the following rules are
applied recursively, until a fixpoint is reached:
(PT4) if hx, yi  PT J (J(domain)) and hz, wi  PT J (x) then
hz, yi  PT J (J(type)).
(PT5) if hx, yi  PT J (J(range)) and hz, wi  PT J (x) then
hw, yi  PT J (J(type)).
(PT6) if hx, J(Class)i  PT J (J(type)) then
hx, J(Resource)i  PT J (J(subClassOf )).
(PT7) if hx, yi  PT J (J(subClassOf )) then hx, J(Class)i  PT J (J(type)).
(PT8) if hx, yi  PT J (J(subClassOf )) then hy, J(Class)i  PT J (J(type)).
(PT9) if hx, yi  PT J (J(subClassOf )) and hz, xi  PT J (J(type)) then
hz, yi  PT J (J(type)).
(PT10) if hx, J(Class)i  PT J (J(type)) then hx, xi  PT J (J(subClassOf )).
(PT11) if hx, yi  PT J (J(subClassOf )) and hy, zi  PT J (J(subClassOf )) then
hx, zi  PT J (J(subClassOf )).
(PT12) if hx, yi  PT J (J(subPropertyOf )) then hx, J(Property)i  PT J (J(type)).
(PT13) if hx, yi  PT J (J(subPropertyOf )) then hy, J(Property)i  PT J (J(type)).
(PT14) if hx, yi  PT J (J(subPropertyOf )) and hz, wi  PT J (x) then
hz, wi  PT J (y).
77

fiAnalyti, Antoniou, Damasio, & Wagner

(PT15) if hx, J(Property)i  PT J (J(type)) then hx, xi  PT J (J(subPropertyOf )).
(PT16) if hx, yi  PT J (J(subPropertyOf )) and hy, zi  PT J (J(subPropertyOf ))
then hx, zi  PT J (J(subPropertyOf )).
(PT17) if hx, J(Datatype)i  PT J (J(type)) then
hx, J(Literal)i  PT J (J(subClassOf )).
(PT18) if hx, J(ContainerM embershipP roperty)i  PT J (J(type)) then
hx, J(member)i  PT J (J(subPropertyOf )).
After reaching fixpoint, nothing else is contained in PT J (x), x  ResJ .
 P ropJ = {x  ResJ | hx, J(Property)}  PT J (J(type))}.
 The mapping PT J : P ropJ  P(ResJ  ResJ ) is defined as follows:
PT J (x) = PT J (x), x  P ropJ .
 LV J = {x  ResJ | hx, J(Literal)i  PT J (J(type))}.
 The mapping PF J : P ropJ  P(ResJ  ResJ ) is defined as follows:
(PF1) if srdf :XMLLiteral  V is an ill-typed XML-Literal then
hILJ (srdf :XMLLiteral ), J(Literal)i  PF J (J(type)).
(PF2) if hJ(TotalClass), J(TotalClass)i  PT J (J(type)) then
x  ResJ  {J(TotalClass)}, hx, J(TotalClass)i  PF J (J(type)).
(PF3) if hJ(TotalProperty), J(TotalProperty)i  PT J (J(type)) then
x, y  ResJ , hx, yi  PF J (J(TotalProperty)).
Starting from the derivations of (PF1), (PF2), and (PF3), the following rules are
applied recursively, until a fixpoint is reached:
(PF4) if hx, yi  PT J (J(subClassOf )) and hz, yi  PF J (J(type)) then
hz, xi  PF J (type).
(PF5) if hx, yi  PT J (J(subPropertyOf )) and hz, wi  PF J (y) then
hz, wi  PF J (x).
After reaching fixpoint, nothing else is contained in PF J (x), x  P ropJ .
Before we continue, we prove the following lemma:
Lemma: For all x, y, x  ResJ , hx, yi  PT J (z) iff hx, yi  PT J (z).
Proof :
) if hx, yi  PT J (z), then from the definition of PT J , it follows immediately that
hx, yi  PT J (z).
) Let hx, yi  PT J (z). Then, from the definition of PT J , it follows that it holds (i)
z  P ropI or (ii) w  ResJ , s.t. hw, zi  PT J (J(subPropertyOf )).
(i) Assume that z  P ropI . Then, hz, I(Property)i  PT I (I(type)). This implies that
hz, J(Property)i  PT I (J(type)). From (PT1), it now follows that hz, J(v)i  PT J (J(type)).
Therefore, z  P ropJ . From the definition of PT J , it now follows that hx, yi  PT J (z).
78

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

(ii) Assume that w  ResJ s.t. hw, zi  PT J (J(subPropertyOf )). Then, from (PT13),
it follows that hz, J(Property)i  PT J (J(type)). Therefore, z  P ropJ . From the definition
of PT J , it now follows that hx, yi  PT J (z).
End of Lemma
Though not mentioned explicitly, the above Lemma is used throughout the rest of the
proof.
To show that J is a partial interpretation of V  , it is enough to show that V  PL  LV J .
Let x  V   PL. Then, x  LV I . Thus, hx, I(Literal)i  PT I (I(type)). Due to (PT1),
this implies that hx, J(Literal)i  PT J (J(type)). Thus, x  LV J .
Now, we extend J with the ontological categories:
ClsJ = {x  ResJ | hx, J(Class)i  PT J (J(type))},
TCls J = {x  ResJ | hx, J(TotalClass)i  PT J (J(type))}, and
TProp J = {x  ResJ | hx, J(TotalProperty)i  PT J (J(type))}.
We define CT J , CF J : ClsJ  P(ResJ ) as follows:
x  CT J (y) iff hx, yi  PT J (J(type)), and
x  CF J (y) iff hx, yi  PF J (J(type)).
We will now show that J is an ERDF interpretation of V . Specifically, we will show that
J satisfies the semantic conditions of Definition 3.7 (ERDF interpretation) and Definition
3.2 (Coherent ERDF interpretation).
First, we will show that J satisfies semantic condition 2 of Definition 3.7. We will start
by proving that ResJ = CT J (J(Resource)). Obviously,
CT J (J(Resource))  ResJ . Thus, it is enough to prove that ResJ  CT J (J(Resource)).
Let x  ResJ . Then, we distinguish the following cases:
Case 1) x  ResI . Since I is an RDFS interpretation, it holds that hx, I(Resource)i 
PT I (I(type)). Thus, it holds hx, J(Resource)i  PT J (J(type)), which implies that x 
CT J (J(Resource)).
Case 2) x  res(VERDF ). From the definition of PT J , it follows that
hx, J(Resource)i  PT J (J(type)). Thus, hx, J(Resource)i  PT J (J(type)), which implies
that x  CT J (J(Resource)).
Thus, ResJ = CT J (J(Resource)).
Additionally, it is easy to see that it holds P ropJ = CT J (J(Property)), ClsJ =
CT J (J(Class)), LV J = CT J (J(Literal)), TCls J = CT J (J(TotalClass)), and
TProp J = CT J (J(TotalProperty)).
We will now show that J satisfies semantic condition 3 of Definition 3.7. Let hx, yi 
PT J (J(domain)) and hz, wi  PT J (x). Then, from (PT4) and the definition of CT J , it
follows that z  CT J (y).
We will now show that J satisfies semantic condition 4 of Definition 3.7. Let hx, yi 
PT J (J(range)) and hz, wi  PT J (x). Then, from (PT5) and the definition of CT J , it
follows that w  CT J (y).
We will now show that J satisfies semantic condition 5 of Definition 3.7. Let x 
ClsJ . Thus, it holds: hx, J(Class)i  PT J (J(type)). From (PT6), it now follows that
hx, J(Resource)i  PT J (J(subClassOf )).
79

fiAnalyti, Antoniou, Damasio, & Wagner

We will now show that J satisfies semantic condition 6 of Definition 3.7. Let hx, yi 
PT J (J(subClassOf )). Then, from (PT7), (PT8), and the definition of CT J , it follows that
x, y  ClsJ .
Let hx, yi  PT J (J(subClassOf )). We will show that CT J (x)  CT J (y). In particular,
let z  CT J (x). Then, from (PT9) and the definition of CT J , it follows that z  CT J (y).
Let hx, yi  PT J (J(subClassOf )). We will show that CF J (y)  CF J (x). In particular,
let z  CF J (y). Then, from (PF4) and the definition of CF J , it follows that z  CF J (x).
In a similar manner, we can prove that J also satisfies the semantic conditions 7, 8, 9,
10, and 11 of Definition 3.7.
To continue the rest of the proof, we need to make a few observations.
Consider the mapping h : ResJ  ResI , which is defined as follows:

if x  ResI
 x
I(Class)
if x = res(TotalClass)
h(x) =

I(Property) if x = res(TotalProperty)

Observation 1: If hx, yi  PT J (z) and y  res(VERDF ) then x = y.
Observation 2: If x  res(VERDF ) and x  P ropJ then PT J (x) = .
Observation 3: If hx, yi  PT J (z) then hh(x), h(y)i  PT I (h(z)).
Observation 4: If x, y, z  ResI and hx, yi  PT J (z) then hx, yi  PT I (z)23 .
The proof of these observations is made by induction. It is easy to see that all observations
hold for the derivations of (PT1), (PT2), and (PT3). Assume now that the observations
hold for the derivations obtained at a step k of the application of the fixpoint operator for
PT J . Then, the observations also hold for the derivations obtained at step k + 1.
We will now show that J satisfies semantic condition 12 of Definition 3.7. Let x 
TCls J . Thus, hx, J(TotalClass)i  PT J (J(type)). From Observation 1, it follows that x =
J(TotalClass). From (PF2), it now follows that CT J (J(TotalClass))CF J (J(TotalClass)) =
ResJ . Thus, CT J (x)  CF J (x) = ResJ .
We will now show that J satisfies semantic condition 13 of Definition 3.7. Let x 
TProp J . Thus, hx, J(TotalProperty)i  PT J (J(type)). From Observation 1, it follows
that x = J(TotalProperty). From (PF3), it now follows that PT J (J(TotalProperty)) 
PF J (J(TotalProperty)) = ResJ  ResJ . Thus, PT J (x)  PF J (x) = ResJ  ResJ .
We will now show that J satisfies semantic condition 14 of Definition 3.7.
Let srdf :XMLLiteral be a well-typed XML-Literal in V then ILJ (srdf :XMLLiteral )
= ILI (srdf :XMLLiteral ) is the XML value of s. Additionally, since I is an RDFS
interpretation of V , it holds: hILI (srdf :XMLLiteral ), I(XMLLiteral )i  PT I (I(type)).
Therefore, from (PT1), it follows that hILJ (srdf :XMLLiteral ), J(XMLLiteral )i 
PT J (J(type)).
We will now show that J satisfies semantic condition 15 of Definition 3.7. Let
srdf :XMLLiteral  V s.t. s is not a well-typed XML literal string. Assume now
that ILJ (srdf :XMLLiteral )  LV J . Then, hILJ (srdf :XMLLiteral ), J(Literal)i 
PT J (J(type)). From Observation 4, it follows that hILJ (srdf :XMLLiteral ), J(Literal)i
 PT I (J(type)). Therefore, it follows that hILI (srdf :XMLLiteral ), I(Literal)i 
23. Note that Observation 3 implies Observation 4.

80

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

PT I (I(type)). Thus, ILI (srdf :XMLLiteral )  LV I , which is impossible since I is an
RDFS interpretation of V . Therefore, ILJ (srdf :XMLLiteral )  ResJ  LV J .
Additionally, from (PF1), it follows that hILJ (srdf :XMLLiteral ), J(Literal)i 
PF J (J(type)).
J also satisfies semantic condition 16 of Definition 3.7, due to (PT1). Finally, J satisfies
semantic condition 17, due to (PT2) and (PT3).
Thus, J is an ERDF interpretation of V .
Now, we will show that J is a coherent ERDF interpretation (Definition 3.2). Assume
that this is not the case. Thus, there is z  P ropJ s.t. PT J (z)  PF J (z) 6= . Assume that
hx, yi  PT J (z)  PF J (z), for such a z. We distinguish the following cases:
Case 1) z  res(VERDF ). Then, from Observation 2, it follows that PT J (z) = , which
is a contradiction.
Case 2) y  res(VERDF ) and z  ResI . Then, it holds:
(i) hz, res(TotalProperty)i  PT J (J(subPropertyOf )), or
(ii) hz, J(type)i  PT J (J(subPropertyOf )) and hx, yi  PF J (J(type)).
Now, from Observation 1 and since z  ResI , (i) is impossible. Thus, hz, J(type)i 
PT J (J(subPropertyOf )) and hx, yi  PF J (J(type)). This implies that
y = res(TotalClass). From Observation 1, it follows that x = res(TotalClass), which is
impossible since, due to (PF2), hres(TotalClass), res(TotalClass)i 6 PF J (J(type)).
Case 3) x  res(VERDF ) and y, z  ResI . Then, it holds:
(i) hz, res(TotalProperty)i  PT J (J(subPropertyOf )), or
(ii) hz, J(type)i  PT J (J(subPropertyOf )) and hx, yi  PF J (J(type)).
Now, from Observation 1 and since z  ResI , (i) is impossible. Thus, hz, J(type)i 
PT J (J(subPropertyOf )) and hx, yi  PF J (J(type)). This implies that
y = res(TotalClass), which is impossible, since y  ResI .
Case 4) x, y, z  ResI . Then, x = ILJ (s), where s is an ill-typed XML-Literal in
V , hz, J(type)i  PT J (J(subPropertyOf )) and hy, J(Literal)i  PT J (J(subClassOf )).
Since hx, yi  PT J (z), it follows that hx, yi  PT J (J(type)). Since hy, J(Literal)i 
PT J (J(subClassOf )), it follows that hx, J(Literal)i  PT J (J(type)). From Observation 4,
it follows that hILJ (s), J(Literal)i  PT I (J(type)). Therefore,
hILI (s), I(Literal)i  PT I (I(type)). But this implies that ILI (s)  LV I , which is impossible since I is an RDFS interpretation of V .
Since all cases lead to contradiction, it follows that:
z  P ropJ , PT J (z)  PF J (z) = .
We will now show that J, v |= G. Let p(s, o)  G. Since I, v |= G, it holds that
p  V  , s, o  V   Var . Note that, due to (PT1), it holds P ropI  P ropJ . Since
p 6 VERDF , it holds J(p) = I(p)  P ropI  P ropJ . Since s, o 6 VERDF , it holds that
[I + v](s) = [J + v](s) and [I + v](o) = [J + v](o). Since I, v |= G, it holds h[I + v](s), [I +
v](o)i  PT I (I(p)). Thus, h[J + v](s), [J + v](o)i  PT I (J(p)). From (PT1), it follows
that h[J + v](s), [J + v](o)i  PT J (J(p)). Thus, J, v |= G, which implies that J |= G.
Since J is an ERDF interpretation and G |=ERDF G , it follows that J |= G . Thus,
there is u : Var (G )  ResJ = ResI  res(VERDF ) s.t. J, u |= G . We define a mapping
u : Var (G )  ResI as follows:
81

fiAnalyti, Antoniou, Damasio, & Wagner


if u(x)  ResI
 u(x)
I(Class)
if u(x) = res(TotalClass)
u (x) =

I(Property) if u(x) = res(TotalProperty)

We will show that I, u |= G . Let p(s, o)  G . Since J |= G and VG  VERDF = ,
it follows that p  V  VRDF  VRDF S , s, o  V  VRDF  VRDF S  Var , and J(p) 
P ropJ . Thus, hJ(p), J(type)i  PT J (J(Property)), which implies (since p 6 VERDF ) that
hI(p), I(type)i  PT J (I(Property). Due to Observation 4, it follows that hI(p), I(type)i 
PT I (I(Property). Thus, I(p)  P ropI . Additionally, it holds: h[J + u](s), [J + u](o)i 
PT J (J(p)). We want to show that h[I + u ](s), [I + u ](o)i  PT I (I(p)).
Case 1) It holds: (i) if s  Var (G ) then u(s) 6 res(VERDF ) and (ii) if o  Var (G ) then
u(o) 6 res(VERDF ).
Then, [J + u](s) = [J + u ](s) = [I + u ](s)  ResI , [J + u](o) = [J + u ](o) = [I +
u ](o)  ResI , and J(p) = I(p)  ResI . Thus, h[J + u](s), [J + u](o)i  PT J (J(p)) implies
that h[I + u ](s), [I + u ](o)i  PT J (I(p)). From Observation 4, the latter implies that
h[I + u ](s), [I + u ](o)i  PT I (I(p)).
Case 2) It holds: (i) s  Var (G ) and u(s)  res(VERDF ) and (ii) if o  Var (G ) then
u(o) 6 res(VERDF ).
Assume that u(s) = res(TotalClass), [J + u](o) = y, and J(p) = z. Then y, z  ResI .
Additionally, I(p) = J(p) = z and [I + u ](o) = [J + u](o) = y. Thus, h[I + u ](s), [I +
u ](o)i = hI(Class), yi. It holds hres(TotalClass), yi  PT J (z). Due to Observation 3, it
holds hI(Class), yi  PT I (z). Thus, h[I + u ](s), [I + u ](o)i = hI(Class), yi  PT I (z) =
PT I (I(p)).
Similarly, if u(s) = res(TotalProperty), we prove that h[I+u ](s), [I+u ](o)i  PT I (I(p)).
Case 3) It holds: o  Var (G ) and u(o)  res(VERDF ). Then, Observation 1, it
follows that s  Var (G ) and u(s) = u(o). Assume that u(o) = res(TotalClass), and
J(p) = z. Then, z  ResI and I(p) = J(p) = z. Additionally, h[I + u ](s), [I + u ](o)i =
hI(Class), I(Class)i. It holds hres(TotalClass), res(TotalClass)i  PT J (z). Due to Observation 3, it follows that hI(Class), I(v)i  PT I (z). Thus, h[I + u ](s), [I + u ](o)i =
hI(Class), I(Class)i  PT I (z) = PT I (I(p)).
Similarly, if u(o) = res(TotalProperty), we prove that h[I+u ](s), [I+u ](o)i  PT I (I(p)).
As in all cases, it holds h[I + u ](s), [I + u ](o)i = PT I (I(p)), it follows that I, u |= G ,
which implies that I |= G .
) Let G |=RDF S G . We will show that G |=ERDF G . Let I be an ERDF interpretation
of a vocabulary V , such that I |= G. Thus, there is u : Var (G)  ResI s.t. I, u |= G. We
will show that I |= G .
We define V  = V  VRDF  VRDF S  VERDF . Based on I, we construct an RDFS interpretation J of V  such that: ResJ = ResI , P ropJ = P ropI , LV J = LV I , ClsJ =
ClsI , JV (x) = IV (x), x  V   URI, PT J (x) = PT I (x), x  P ropJ , ILJ (x) =
ILI (x), x  V   T L, CT J (x) = CT I (x), x  ClsJ .
We will now show that J is indeed an RDFS interpretation of V  .
First, we will show that J satisfies semantic condition 1 of Definition A.3 (Appendix
A, RDF interpretation). It holds: x  P ropJ iff x  P ropI iff x  CT I (I(Property)) iff
hx, I(Property)i  PT I (I(type)) iff hx, J(Property)i  PT J (J(type)).
82

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

We will now show that J satisfies semantic condition 2 of Definition A.3.
Let srdf :XMLLiteral  V such that s is a well-typed XML literal string. Then, it
follows from the definition of J and the fact that I is an ERDF interpretation of V
that ILJ (srdf :XMLLiteral ) is the XML value of s, and ILJ (srdf :XMLLiteral ) 
CT J (J(XMLLiteral )). We will show that ILJ (srdf :XMLLiteral )  LV J . Since I is
an ERDF interpretation, ILI (srdf :XMLLiteral )  CT I (I(XMLLiteral )). Additionally,
hI(XMLLiteral ), I(Literal)i  PT I (I(subClassOf )). Therefore, ILI (srdf :XMLLiteral ) 
CT I (I(Literal)), and thus, ILI (srdf :XMLLiteral )  LV I . The last statement implies
that ILJ (srdf :XMLLiteral )  LV J .
We will now show that J satisfies semantic condition 3 of Definition A.3.
Let srdf :XMLLiteral  V such that s is an ill-typed XML literal string. Then, it
follows from the definition of J and the fact that I is an ERDF interpretation of V that
ILJ (srdf :XMLLiteral )  ResJ  LV J . We will show that
hILJ (srdf :XMLLiteral ), J(XMLLiteral )i 6 PT J (J(type)). Assume that
hILJ (srdf :XMLLiteral ), J(XMLLiteral )i  PT J (J(type)). Then,
hILI (srdf :XMLLiteral ), I(XMLLiteral )i  PT I (I(type)). Thus,
ILI (srdf :XMLLiteral )  CT I (I(XMLLiteral )). Since it holds
hI(XMLLiteral ), I(Literal)i  PT I (I(subClassOf )), it follows that
ILI (srdf :XMLLiteral )  CT I (I(Literal)). Thus, ILI (srdf :XMLLiteral )  LV I ,
which is impossible since I is an ERDF interpretation of V . Therefore,
hILJ (srdf :XMLLiteral ), J(XMLLiteral )i 6 PT J (J(type)).
It is easy to see that J satisfies semantic condition 4 of Definition A.3 and all the
semantic conditions of Definition A.5 (Appendix A, RDFS Interpretation). Therefore, J is
an RDFS interpretation of V  .
We will now show that J, u |= G. Let p(s, o)  G. Since I |= G, it holds that p  V  ,
s, o  V   Var , and J(p) = I(p)  P ropI = P ropJ . It holds: h[J + u](s), [J + u](o)i 
PT J (J(p)) iff h[I + u](s)), [I + u](o)i  P ropI (I(p)), which is true, since I, u |= G. Thus,
J, u |= G, which implies that J |= G. Since G |=RDF S G , it follows that J |= G . Thus,
there is v : Var (G )  ResJ s.t. J, v |= G .
We will now show that I |= G . Let p(s, o)  G . Since J, v |= G , it holds that p  V  ,
s, o  V   Var , and I(p) = J(p)  P ropJ = P ropI . It holds: h[I + v](s), [I + v](o)i 
PT I (I(p)) iff h[J + v](s), [J + v](o)i  PT J (J(p)), which is true, since J, v |= G . Thus,
I, v |= G , which implies that I |= G . 
Proposition 4.1. Let G be an ERDF graph and let F be an ERDF formula such that
VF  skG (Var (G)) = . It holds: G |=ERDF F iff sk(G) |=ERDF F .
Proof:
) Let G |=ERDF F . We will show that sk(G) |=ERDF F . Let I be an ERDF interpretation
over a vocabulary V s.t. I |= sk(G). We will show that I |= G. We define V  = V  VRDF 
VRDF S  VERDF . Additionally, we define a total function u : Var (G)  ResI s.t. u(x) =
IV (skG (x)), x  Var (G). Moreover, we define a total function u : V   Var (G)  V  s.t.
u (x) = skG (x), if x  Var (G) and u (x) = x, otherwise.
Let p(s, o)  G. Then, p  V  , s, o  V  Var , and I(p)  P ropI . It holds: h[I+u](s), [I+
u](o)i  PT I (I(p)) iff hI(u (s)), I(u (o))i  PT I (I(p)), which is true, since p(u (s), u (o)) 
sk(G) and I |= sk(G). Thus, I, u |= p(s, o).
83

fiAnalyti, Antoniou, Damasio, & Wagner

Let p(s, o)  G. Then, p  V  , s, o  V   Var , and I(p)  P ropI . It holds:
h[I + u](s), [I + u](o)i  PF I (I(p)) iff hI(u (s)), I(u (o))i  PF I (I(p)), which is true, since
p(u (s), u (o))  sk(G) and I |= sk(G). Thus, I, u |= p(s, o).
Therefore, I |= G. Since G |=ERDF F , it follows that I |= F .
) Let sk(G) |=ERDF F . We will show that G |=ERDF F . Let I be an ERDF interpretation
of a vocabulary V such that I |= G. We will show that I |= F . Since I |= G, there is a total
function u : Var (G)  ResI s.t. I, u |= G. We define V  = V VRDF VRDF S VRDF S . We
construct an ERDF interpretation J of V skG (Var (G)) as follows: ResJ = ResI , P ropJ =
P ropI , LV J = LV I , ClsJ = ClsI . We define JV : (V   skG (Var (G)))  URI  ResJ ,
1
as follows: JV (x) = IV (x), x  V   URI and JV (x) = u(skG
(x)), x  skG (Var (G)).
Moreover, PT J (x) = PT I (x), x  P ropJ , PF J (x) = PF I (x), x  P ropJ , ILJ (x) =
ILI (x), x  V   T L, CT J (x) = CT I (x), x  ClsJ , and CF J (x) = CF I (x), x  ClsJ .
Since I is an ERDF interpretation of V , it is easy to see that J is indeed an ERDF interpretation of V  skG (Var (G)). We will show that J |= sk(G). First, we define a total func1
tion g : V   skG (Var (G))  V   Var (G) as follows: g(x) = skG
(x), x  skG (Var (G))
and g(x) = x, otherwise. Let p(s, o)  sk(G). Since I |= G, it follows that p  V  ,
s, o  V   Var , and J(p) = I(p)  P ropI = P ropJ . It holds J(s) = [I + u](g(s)),
J(o) = [I + u](g(o)), and J(p) = I(p). Therefore, it holds: hJ(s), J(o)i  PT J (J(p)) iff
h[I + u](g(s)), [I + u](g(o))i  PT I (I(p)), which holds since p(g(s), g(o))  G and I, u |= G.
Let v : {}  ResJ . It follows that J, v |= p(s, o). Let p(s, o)  sk(G). We can show that
J, v |= p(s, o), in a similar manner. Therefore, J |= sk(G).
Since sk(G) |=ERDF F , it follows that J |= F . We will show that I |= F . We define
V = V  VRDF  VRDF S  VERDF . Note that ResJ = ResI .


Lemma: For every mapping u : Var (F )  ResJ , it holds J, u |= F iff I, u |= F .
Proof: We will prove the Lemma by induction. Without loss of generality, we assume that
 appears only in front of positive ERDF triples. Otherwise we apply the transformation
rules of Definition 3.4, to get an equivalent formula that satisfies the assumption.
Let F = p(s, o). Assume that J, u |= F . Since VF  skG (Var (G)) = , it follows that
p  V  , s, o  V   Var , and J(p) = I(p)  P ropI = P ropJ . Since h[J + u](s), [J + u](o)i 
PT J (J(p)), it follows that h[I + u](s), [I + u](o)i  PT I (I(p)). Therefore, I, u |= F .
Assume that I, u |= F . It follows that p  V  , s, o  V  Var , and J(p) = I(p)  P ropI =
P ropJ . Since h[I + u](s), [I + u](o)i  PT I (I(p)), it follows that h[J + u](s), [J + u](o)i 
PT J (J(p)). Therefore, J, u |= F .
Let F = p(s, o). Similarly, we prove that J, u |= F iff I, u |= F .
Assumption: Assume that the lemma holds for the subformulas of F .
We will show that the lemma holds also for F .
Let F = G. It holds: I, u |= F iff VG  V  and I, u 6|= G iff VG  V  and J, u 6|= G iff
J, u |= F .
Let F = F1 F2 . It holds: I, u |= F iff I, u |= F1 and I, u |= F2 iff J, u |= F1 and
J, u |= F2 iff J, u |= F .
84

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

Let F = x G. It holds: I, u |= F iff I, u |= x G iff there is v : Var (G)  ResI
s.t. v(y) = u(y), y  Var (G)  {x} and I, v |= G iff there is v : Var (G)  ResJ s.t.
v(y) = u(y), y  Var (G)  {x} and J, v |= G iff J, u |= x G iff J, u |= F .
Let F = F1 F2 or F = F1  F2 or F = xG. We can prove, similarly to the above
cases, that I, u |= F iff J, u |= F .
End of lemma
Since J |= F , it follows that for every mapping u : Var (F )  ResJ ,
J, u |= F .
Therefore, it follows from Lemma and the fact that ResJ = ResI that for every mapping
u : Var (F )  ResI , I, u |= F . Thus, I |= F . 
Proposition 4.2. Let O = hG, P i be an ERDF ontology and let I, J  I H (O). Let
p  TProp I  TProp J . If PT I (p) 6= PT J (p) or PF I (p) 6= PF J (p) then I 6 J and J 6 I.
Proof: Assume PT I (p) 6= PT J (p). Now, assume I  J. Then, PT I (p)  PT J (p)
and PF I (p)  PF J (p). Since I, J  I H (O) and p  TProp I  TProp J , it holds that
H
PF I (p) = ResH
O  PT I (p) and PF J (p) = ResO  PT J (p). Thus, PF I (p)  PF J (p), which
is a contradiction. Thus, I 6 J. Similarly, we can prove that J 6 I.
Assume now that PF I (p) 6= PF J (p). Then, we can prove that I 6 J and J 6 I, in a
similar manner. 
Proposition 5.1. Let O = hG, P i be an ERDF ontology and let M  Mst (O). It holds
M  MH (O).
Proof: Let M  Mst (O). Obviously, M  I H (O) and M |= sk(G). We will show that
M |= r, r  P . Let r  P . Let v be a mapping v : Var (r)  ResH
O s.t. M, v |= Cond(r).
It is enough to show that M, v |= Concl(r).
For any mapping u : X  ResH (O), where X  Var , we define the mapping u : X 
VO as follows:

u(x) if u(x) is not the xml value of a well-typed XML literal in VO
u (x) =
t
if u(x) is the xml value of a well-typed XML literal t in VO




Let x  VO , we define xu = x. Let x  X, we define xu = u (x). Let F  L(VO ) 

{true, f alse} such that FVar (F )  X, we define F u to be the formula that results from F

after replacing each free variable of F by u (x). It is easy to see that it holds: Concl(r)v 

Concl(r)v  [r]VO  [P ]VO .
Lemma: Let F be an ERDF formula over VO and let u be a mapping u : Var (F )  ResH
O.

It holds: M, u |= F iff M, u |= F u .
Proof: We prove the lemma by induction. Without loss of generality, we assume that 
appears only in front of positive ERDF triples. Otherwise we apply the transformation
rules of Definition 3.4, to get an equivalent formula that satisfies the assumption.
Let F = p(s, o). It holds: M, u |= F iff M, u |= p(s, o) iff h[M + u](s), [M + u](o)i 



PT M (M (p)) iff h[M + u](su ), [M + u](ou )i  PT M (M (p)) iff M, u |= p(s, o)u .
Let F = p(s, o). It holds: M, u |= F iff M, u |= p(s, o) iff h[M + u](s), [M + u](o)i 



PF M (M (p)) iff h[M + u](su ), [M + u](ou )i  PF M (M (p)) iff M, u |= (p(s, o))u .
Assumption: Assume that the lemma holds for the subformulas of F .
We will show that the lemma holds also for F .
85

fiAnalyti, Antoniou, Damasio, & Wagner



Let F = G. It holds: M, u |= F iff M, u |= G iff M, u 6|= G iff M, u 6|= Gu iff


M, u |= Gu iff M, u |= F u .
Let F = F1 F2 . It holds: M, u |= F iff M, u |= F1 F2 iff M, u |= F1 and M, u |= F2 iff




M, u |= F1u and M, u |= F2u iff M, u |= (F1 F2 )u iff M, u |= F u .
Let F = xG. It holds: M, u |= F iff there exists a mapping u1 : Var (G)  ResH
O s.t.
u1 (y) = u(y), y  Var (G)  {x} s.t. M, u1 |= G iff there exists a mapping u1 : Var (G) 
u1 iff there exists a mapping
ResH
O s.t. u1 (y) = u(y), y  Var (G)  {x} s.t. M, u1 |= G

u1 : Var (G)  ResH
u1 |= (xG)u1 iff (since
O s.t. u1 (y) = u(y), y  Var(G)  {x} s.t. M,

u1 (y) = u (y), y  FVar (xG)) M, u |= (xG)u iff M, u |= F u .
Let F = F1 F2 or F = F1  F2 or F = xG. We can prove, similarly to the above

cases, that M, u |= F iff M, u |= F u .
End of Lemma
First assume that Cond(r) 6= true. Then, Cond(r)  L(VO ) and thus, Cond(r) is an ERDF

formula over VO . Since M, v |= Cond(r), it follows from Lemma that M, v |= Cond(r)v .


Now since FVar (Cond(r)v ) = , it follows from Lemma B.1 that M |= Cond(r)v . Since

M  Mst (O), it follows that M |= Concl(r)v . Thus, Concl(r) 6= f alse and Concl(r) 

L(VO |{}). Now since FVar (Concl(r)v ) = , it follows from lemma B.1 that M, v |=

Concl(r)v . Since Concl(r) is an ERDF formula over VO , it follows from Lemma that
M, v |= Concl(r).

Assume now that Cond(r) = true. Then, M |= Cond(r)v . Since M  Mst (O), it

follows that M |= Concl(r)v . Therefore, Concl(r) 6= f alse, and we can prove as above
that M, v |= Concl(r).
Therefore, M |= r, r  P . 
Proposition 5.2. Let O = hG, P i be an ERDF ontology, such that
rdfs:subClassOf (rdf :Property, erdf :TotalProperty)  G. Then, Mst (O) = MH (O).
Proof: From Proposition 5.1, it follows that Mst (O)  MH (O). We will show that
MH (O)  Mst (O). Let M  MH (O). It follows that M |= sk(G). We will show that
M  minimal({I  I H (O) | I |= sk(G)}).
Let J  I H (O) s.t. J |= sk(G) and J  M . We will show that J = M . Since J  M ,
it follows that P ropJ  P ropM and for all p  P ropJ , it holds PT J (p)  PT M (p) and
PF J (p)  PF M (p). Let p  P ropJ . Since J |= sk(G), it follows that P ropJ  TProp J .
Thus, p  TProp J . Assume that PT J (p) 6= PT M (p). Then, there is hx, yi  PT M (p)
s.t. hx, yi 6 PT J (p). Then, hx, yi  PF J (p). Thus, hx, yi  PF M (p), which is impossible,
since hx, yi  PT M (p). Thus, PT J (p) = PT M (p). Similarly, we can prove that PF J (p) =
PF M (p). Therefore, for all p  P ropJ , it holds PT J (p) = PT M (p) and PF J (p) = PF M (p).
We will now show that P ropJ = P ropM . It holds P ropJ ={x  ResH
O | hx, Propertyi 
PT J (type)} = {x  ResH
|
hx,
Propertyi

PT
(type)}
=P
rop
.
Based
on these results,
I
M
O
the fact that J, M  I H (O), it follows that J = M . Therefore, M  minimal({I 
I H (O) | I |= sk(G)}).
We will now show that M  minimal({I  I H (O) | I  M and I |= Concl(r), for
all r  P[M,M ] }). Since M  MH (O) it follows that M  {I  I H (O) | I  M and
I |= Concl(r), for all r  P[M,M ] }. Let J  {I  I H (O) | I  M and I |= Concl(r),
for all r  P[M,M ] } and J  M . Since J  M , it follows that P ropM  P ropJ , and
for all p  P ropM , it holds PT M (p)  PT J (p) and PF M (p)  PF J (p). Since J  M ,
86

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

it follows that P ropJ  P ropM , and for all p  P ropJ , it holds PT J (p)  PT M (p) and
PF J (p)  PF M (p). Therefore, it follows that P ropM = P ropJ , and for all p  P ropM ,
it holds PT M (p) = PT J (p) and PF M (p) = PF J (p). Based on this result, the fact that
J, M  I H (O), it follows that J = M .
Thus, M  minimal({I  I H (O) | I  M and I |= Concl(r), for all r  P[M,M ] }).
Since M satisfies the conditions of Definition 5.1 (Stable Model), it follows that M 
st
M (O). Thus, it holds MH (O)  Mst (O).
Therefore, MH (O) = Mst (O). 
Proposition 6.2. Let G be an ERDF graph and let F be an ERDF formula such that
VF  skG (Var (G)) = . It holds:
1. If F is an ERDF d-formula and hG, i |=st F then G |=ERDF F .
2. If G |=ERDF F then hG, i |=st F .
Proof:
1) Let hG, i |=st F . We will show that sk(G) |=ERDF F . Let I be an ERDF interpretation
of a vocabulary V s.t. I |= sk(G). We will show that I |= F . We define V  = V  VRDF 
VRDF S  VERDF .
Let O = hG, i. Based on I, we construct a partial interpretation J of VO as follows:
 ResJ = ResH
O.
 JV (x) = x, for all x  VO  URI.
 We define the mapping: ILJ : VO  T L  ResJ such that:
ILJ (x) = x, if x is a typed literal in VO other than a well-typed XML literal, and
ILI (x) is the XML value of x, if x is a well-typed XML literal in VO .
 We define the mapping: J : VO  ResJ such that:
 J(x) = JV (x), x  VO  URI.
 J(x) = x,  x  VO  PL.
 J(x) = ILJ (x),  x  VO  T L.
 P ropJ = {x  ResJ | x  VO , J(x ) = x and I(x )  P ropI }.
 The mapping PT J : P ropJ  P(ResJ  ResJ ) is defined as follows:
x, y, z  VO , it holds:
hJ(x), J(y)i  PT J (J(z)) iff hI(x), I(y)i  PT I (I(z)).
 We define the mapping PF J : P ropJ  P(ResJ  ResJ ) as follows:
x, y, z  VO , it holds:
hJ(x), J(y)i  PF J (J(z)) iff hI(x), I(y)i  PF I (I(z)).
 LV J = {x  ResJ | hx, J(Literal)i  PT J (J(type))}.
87

fiAnalyti, Antoniou, Damasio, & Wagner

To show that J is a partial interpretation, it is enough to show that VO  PL  LV J .
Let x  VO  PL. Then, x  LV I . Thus, hx, I(Literal)i  PT I (I(type)). This implies that
hx, J(Literal)i  PT J (J(type)). Thus, x  LV J .
Now, we extend J with the ontological categories:
ClsJ = {x  ResJ | hx, J(Class)i  PT J (J(type))},
TCls J = {x  ResJ | hx, J(TotalClass)i  PT J (J(type))}, and
TProp J = {x  ResJ | hx, J(TotalProperty)i  PT J (J(type))}.
We define the mappings CT J , CF J : ClsJ  P(ResJ ) as follows:
x  CT J (y) iff hx, yi  PT J (J(type)), and
x  CF J (y) iff hx, yi  PF J (J(type)).
We will now show that J is an ERDF interpretation of VO . First, we will show that
J satisfies semantic condition 2 of Definition 3.7 (ERDF Interpretation), in a number of
steps:
Step 1: Here, we prove that ResJ = CT J (J(Resource)). Obviously, CT J (J(Resource))
 ResJ . We will show that ResJ  CT J (J(Resource)). Let x  ResJ . Then, there is
x  VO such that J(x ) = x. We want to show that hJ(x ), J(Resource)i  PT J (J(type)).
It holds: hJ(x ), J(Resource)i  PT J (J(type)) iff hI(x ), I(Resource)i  PT I (I(type)),
which is true, since I is an ERDF interpretation that satisfies sk(G) and I(x )  ResI .
Thus, x = J(x )  CT J (J(ResourceResource)).
Therefore, ResJ = CT J (J(Resource)).
Step 2: Here, we prove that P ropJ = CT J (J(Property)). We will show that P ropJ 
CT J (J(Property)). Let x  P ropJ . Then, there is x  VO such that J(x ) = x and
I(x )  P ropI . We want to show that hJ(x ), J(Property)i  PT J (J(type)). It holds:
hJ(x ), J(Property)i  PT J (J(type)) iff hI(x ), I(Property)i  PT I (I(type)),
which is true, since I(x )  P ropI . Thus, x = J(x )  CT J (J(Property)).
Therefore, P ropJ  CT J (J(Property)).
We will now show that CT J (J(Property))  P ropJ . Let x  CT J (J(Property)). Then,
x  VO such that J(x ) = x. It holds hJ(x ), J(Property)i  PT J (J(type)), which implies
that hI(x ), I(Property)i  PT I (I(type)). Thus, I(x )  P ropI and x  P ropJ .
Therefore, CT J (J(Property))  P ropJ .
Step 3: By definition, it holds ClsJ = CT J (J(Class)), LV J = CT J (J(Literal)), TCls J =
CT J (J(TotalClass)) and TProp J = CT J (J(TotalProperty)).
We will now show that J satisfies semantic condition 3 of Definition 3.7 (ERDF Interpretation). Let hx, yi  PT J (J(domain)) and hz, wi  PT J (x). We will show
that z  CT J (y). There are x , y   VO such that J(x ) = x, J(y  ) = y. Thus,
hJ(x ), J(y  )i  PT J (J(domain)). Additionally, there are z  , w  VO such that J(z  ) =
z, J(w ) = w. Thus, hJ(z  ), J(w )i  PT J (J(x )). Then, hI(x ), I(y  )i  PT I (I(domain))
and hI(z  ), I(w )i  PT I (I(x )). Since I is an ERDF interpretation, hI(z  ), I(y  )i 
PT I (I(type)). Thus, hJ(z  ), J(y  )i  PT J (J(type)) and z  CT J (y).
In a similar manner, we can prove that J also satisfies the rest of the semantic conditions
of Definition 3.7. Thus, J is an ERDF interpretation of VO .
Moreover, we will show that J is a coherent ERDF interpretation (Definition 3.2).
Assume that this is not the case. Thus, there is z  P ropJ s.t. PT J (z)  PF J (z) 6= .
Thus, there are x, y  ResJ s.t. hx, yi  PT J (z)  PF J (z), for such a z. Then, there are
88

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

x , y  , z   VO s.t. J(x ) = x, J(y  ) = y, and J(z  ) = z. It holds: hJ(x ), J(y  )i  PT J (J(z  ))
and hJ(x ), J(y  )i  PF J (J(z  )). Thus, hI(x ), I(y  )i  PT I (I(z  )) and hI(x ), I(y  )i 
PF I (I(z  )). But this is impossible, since I is a (coherent) ERDF interpretation. Therefore,
J is also a coherent ERDF interpretation.
Thus, J  I H (O).
We will now show that J |= sk(G). Let p(s, o)  sk(G). It holds p, s, o  VO . Since
I |= sk(G), it holds I(p)  P ropI . Thus, hI(p), I(Property)i  PT I (I(type)), which implies
that hJ(p), J(Property)i  PT J (J(type)). From this, it follows that J(p)  P ropJ . It
holds: hJ(s), J(o)i  PT J (J(p)) iff hI(s), I(o)i  PT I (I(p)). The last statement is true
since I |= sk(G). Let u : {}  ResH
O . Then, J, u |= p(s, o). Let p(s, o)  sk(G). We can
show that J, u |= p(s, o), in a similar manner. Thus, J |= sk(G).
Now, from Definition 5.1 (Stable Model) and the fact that J |= sk(G), it follows that
K  Mst (O) s.t. K  J. From this and the fact that O |=st F , it follows that K |= F .
Since F is an ERDF d-formula, it holds that
F = (?x1 , ..., ?xk1 F1 )  ...  (?x1 , ..., ?xkn Fn ),
where Fi = t1  ...  tmi and tj , for j = 1, ..., mi , is an ERDF triple. Thus, there is an
i  {1, ..., n} and u : Var (Fi )  ResH
O s.t. K, u |= Fi .
We will show that J, u |= Fi .
Let p(s, o)  {t1 , ..., tmi }. Since K is an ERDF interpretation of VO , K, u |= Fi , and
P ropK  P ropJ , it follows that p  VO , s, o  VO  Var , and J(p) = K(p)  P ropK 
P ropJ . Additionally, h[K +u](s), [K +u](o)i  PT K (p). Since h[J +u](s), [J +u](o)i = h[K +
u](s), [K + u](o)i and PT K (p)  PT J (p), it follows that h[J + u](s), [J + u](o)i  PT J (p).
Thus, J, u |= p(s, o).
Let p(s, o)  {t1 , ..., tmi }. Since K is an ERDF interpretation of VO , K, u |= Fi , and
P ropK  P ropJ , it follows that p  VO , s, o  VO  Var , and J(p) = K(p)  P ropK 
P ropJ . Additionally, h[K +u](s), [K +u](o)i  PF K (p). Since h[J +u](s), [J +u](o)i = h[K +
u](s), [K + u](o)i and PF K (p)  PF J (p), it follows that h[J + u](s), [J + u](o)i  PF J (p).
Thus, J, u |= p(s, o).
We now define a total function u : VFi  Var (Fi )  VO , as follows:

u(x) if x  Var (Fi ) and




u(x) is not the xml value of a well-typed XML literal in VO

t
if x  Var (Fi ) and
u (x) =


u(x) is the xml value of a well-typed XML literal t in VO



x
otherwise

Moreover, we define a total function u : Var (Fi )  ResI s.t. u (x) = I(u (x)).
We will show that I, u |= Fi .
Let p(s, o)  {t1 , ..., tmi }. Then, p  VFi and s, o  VFi  Var . Since J, u |= Fi , it follows
that VFi  VO . Therefore, VFi  Vsk(G)  VRDF  VRDF S  VERDF  V  . Thus, p  V  and
s, o  V   Var .
We will now show that I(p)  P ropI . It holds:
hI(p), I(Property)i  PT I (I(type)) iff
hJ(p), J(Property)i  PT J (J(type)), which holds since J, u |= Fi .
89

fiAnalyti, Antoniou, Damasio, & Wagner

We want to show that h[I +v  ](s), [I +v  ](o)i  PT I (I(p)). Note that x  VFi , it holds:
[I + u ](x) = I(u (x)) = I(x) and J(u (x)) = [J + u](x) = J(x). Moreover, x  Var (Fi ),
it holds: [I + u ](x) = I(u (x)) and J(u (x)) = [J + u](x) (recall the definition of J(.)).
Therefore, it holds:
h[I + u ](s), [I + u ](o)i  PT I (I(p)) iff
hI(u (s)), I(u (o))i  PT I (I(p)) iff
hJ(u (s)), J(u (o))i  PT J (J(p)) iff
h[J + u](s), [J + u](o)i  PT J (J(p)), which is true since J, u |= Fi . Thus, I, u |= p(s, o).
Let p(s, o)  {t1 , ..., tmi }. We can show that I, u |= p(s, o), in a similar manner.
Thus, I, u |= Fi , which implies that I, u |=  ?x1 , ..., ?xki Fi . Thus, I, u |= F . Now, it
follows from Lemma B.1 that I |= F .
Thus, sk(G) |=ERDF F . Now, it follows from Proposition 4.1 that G |=ERDF F .
2) Let G |=ERDF F . It follows from Proposition 4.1 that sk(G) |=ERDF F . We will show
that hG, i |=st F . In particular, let O = hG, i and let I  Mst (O). Note that I is an
ERDF interpretation of VO , such that I |= sk(G). Since sk(G) |=ERDF F , it follows that
I |= F . 
Proposition 8.1 Let D be an instance of the unbounded tiling problem. It holds:
1. D has a solution iff OD  {false  FD } has a stable model.
2. D has a solution iff OD 6|=st FD .
Proof:
1) This statement follows easily from statement 2).
2) ) Let  be a solution to D. Since IN  IN is denumerable, there exists a bijective
function  : IN  IN  IN . Consider now a Herbrand interpretation I of OD such that:
1. CTI (Tile) = CTI (HasRight) = CTI (HasAbove) = {rdf : i | i  IN } and
CFI (T ile) = CFI (HasRight) = CFI (HasAbove) = .
2. P TI (id ) = {hx, xi | x  VO } and P FI (id ) = .
3. P TI (HConstraint) = H and P FI (HConstraint) = .
4. P TI (VConstraint) = V and P FI (VConstraint) = .
5. P TI (Type) = {hrdf : (i, j),  (i, j)i | i, j  IN } and P FI (Type) = .
6. P TI (right) = {hrdf : (i, j), rdf : (i + 1, j)i | i, j  IN } and
P FI (right) = {hrdf : i, rdf : ji | i, j  IN and hrdf : i, rdf : ji 6 P TI (right)}.
7. P TI (above) = {hrdf : (i, j), rdf : (i, j + 1)i | i, j  IN } and
P FI (above) = {hrdf : i, rdf : ji | i, j  IN and hrdf : i, rdf : ji 6 P TI (above)}.

It is easy to see that I is a stable model of OD and I 6|= FD . Thus, OD 6|=st FD .
) Let D = hT , H, V i, where T = {T1 , ..., Tn }. Assume that OD 6|=st FD and let I be a
stable model of OD = hG, P i such that I 6|= FD . Obviously, CTI (Tile) = {rdf : i | i  IN }.
Due to rule sets (2)-(4) of P and since OD 6|=st FD , it holds that starting from tile rdf : 0
90

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

and placing tiles according to P TI (right) and P TI (above) relations, a grid is formed. We
define (i, j) = k, for i, j, k  IN , iff the tile rdf : k has been placed on the hi, ji position
of the previous grid. Note that  is a total function. Due to rule set (1) of P , each tile is
assigned a unique type in T = {T1 , ..., Tn }. Due to rule set (5) of P , this type assignment
satisfies the horizontal and vertical adjacency constraints of D. Thus, a solution of D is
 : IN  IN  T , where  (i, j) = T iff hrdf : (i, j), T i  P TI (T ype). Since  is a total
function and, for all k  IN , tile rdf : k is assigned a unique type in T , it follows that  is a
total function.

References
Alferes, J. J., Damasio, C. V., & Pereira, L. M. (1995). A Logic Programming System
for Non-monotonic Reasoning. Special Issue of the Journal of Automated Reasoning,
14 (1), 93147.
Alferes, J. J., Damasio, C. V., & Pereira, L. M. (2003). Semantic Web Logic Programming Tools. In International Workshop on Principles and Practice of Semantic Web
Reasoning (PPSWR03), pp. 1632.
Analyti, A., Antoniou, G., Damasio, C. V., & Wagner, G. (2004). Negation and Negative
Information in the W3C Resource Description Framework. Annals of Mathematics,
Computing & Teleinformatics (AMCT), 1 (2), 2534.
Analyti, A., Antoniou, G., Damasio, C. V., & Wagner, G. (2005). Stable Model Theory for
Extended RDF Ontologies. In 4th International Semantic Web Conference (ISWC2005), pp. 2136.
Antoniou, G., Bikakis, A., & Wagner, G. (2004). A System for Nonmonotonic Rules on the
Web. In 3rd International Workshop on Rules and Rule Markup Languages for the
Semantic Web (RULEML03), pp. 2336.
Antoniou, G., Billington, D., Governatori, G., & Maher, M. J. (2001). Representation
Results for Defeasible Logic. ACM Transactions on Computational Logic (TOCL),
2 (2), 255287.
Baader, F., Calvanese, D., McGuinness, D. L., Nardi, D., & Patel-Schneider, P. F. (Eds.).
(2003). The Description Logic Handbook: Theory, Implementation, and Applications.
Cambridge University Press.
Bassiliades, N., Antoniou, G., & Vlahavas, I. P. (2004). DR-DEVICE: A Defeasible Logic
System for the Semantic Web. In 2nd International Workshop on Principles and
Practice of Semantic Web Reasoning (PPSWR04), pp. 134148.
Beckett, D. (2004). RDF/XML Syntax Specification (Revised). W3C Recommendation.
Available at http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/.
Berger, R. (1966). The Undecidability of the Dominoe Problem. Memoirs of the American
Mathematical Society, 66, 172.
Berners-Lee, T. (1998). Design Issues - Architectual and Philosophical Points. Personal
notes. Available at http://www.w3.org/DesignIssues.
91

fiAnalyti, Antoniou, Damasio, & Wagner

Berners-Lee, T., Connolly, D., Kagal, L., Scharf, Y., & Hendler, J. (2008). N3Logic: A
Logical Framework For the World Wide Web. to be published by Theory and Practice
of Logic Programming (TPLP), Special Issue on Logic Programming and the Web.
Bry, F., & Marchiori, M. (2005). Ten Theses on Logic Languages for the Semantic Web. In
3rd International Workshop on Principles and Practice of Semantic Web Reasoning
(PPSWR-2005), pp. 4249.
Damasio, C. V., Analyti, A., Antoniou, G., & Wagner, G. (2006). Supporting Open and
Closed World Reasoning on the Web. In 4th Workshop on Principles and Practice of
Semantic Web Reasoning (PPSWR-2006), pp. 149163.
de Bruijn, J., Franconi, E., & Tessaris, S. (2005). Logical Reconstruction of Normative RDF.
In OWL: Experiences and Directions Workshop (OWLED-2005), Galway, Ireland.
Donini, F. M., Lenzerini, M., Nardi, D., & Schaerf, A. (1998). AL-log: Integrating Datalog
and Description Logics. Journal of Intelligent Information Systems, 10 (3), 227252.
Donini, F. M., Nardi, D., & Rosati, R. (2002). Description Logics of Minimal Knowledge
and Negation as Failure. ACM Transactions on Computational Logic, 3 (2), 177225.
Eiter, T., Lukasiewicz, T., Schindlauer, R., & Tompits, H. (2004a). Combining Answer Set
Programming with Description Logics for the Semantic Web. In 9th International
Conference on Principles of Knowledge Representation and Reasoning (KR04), pp.
141151.
Eiter, T., Lukasiewicz, T., Schindlauer, R., & Tompits, H. (2004b). Well-Founded Semantics
for Description Logic Programs in the Semantic Web. In 3rd International Workshop
on Rules and Rule Markup Languages for the Semantic Web (RuleML04), pp. 8197.
Eiter, T., Ianni, G., Polleres, A., & Schindlauer, R. (2006). Answer Set Programming for the
Semantic Web. Tutorial co-located with the 3d European Semantic Web Conference
(ESWC-2006).
Gelder, A. V., Ross, K. A., & Schlipf, J. S. (1991). The Well-Founded Semantics for General
Logic Programs. Journal of the ACM, 38 (3), 620650.
Gelfond, M., & Lifschitz, V. (1988). The Stable Model Semantics for Logic Programming.
In Kowalski, R., & Bowen, K. A. (Eds.), 5th International Conference on Logic Programming, pp. 10701080. MIT Press.
Gelfond, M., & Lifschitz, V. (1990). Logic programs with Classical Negation. In Warren,
& Szeredi (Eds.), 7th International Conference on Logic Programming, pp. 579597.
MIT Press.
Gelfond, M., & Lifschitz, V. (1991). Classical Negation in Logic programs and Disjunctive
Databases. New Generation Computing, 9, 365385.
Hayes, P. (2004). RDF Semantics. W3C Recommendation. Available at http://www.w3.
org/TR/2004/REC-rdf-mt-20040210/.
Herre, H., Jaspars, J., & Wagner, G. (1999). Partial Logics with Two Kinds of Negation
as a Foundation of Knowledge-Based Reasoning. In Gabbay, D. M., & Wansing, H.
(Eds.), What Is Negation? Kluwer Academic Publishers.
92

fiExtended RDF as a Semantic Foundation of Rule Markup Languages

Herre, H., & Wagner, G. (1997). Stable Models are Generated by a Stable Chain. Journal
of Logic Programming, 30 (2), 165177.
Horrocks, I., & Patel-Schneider, P. F. (2003). Reducing OWL Entailment to Description
Logic Satisfiability. In 2nd International Semantic Web Conference (ISWC-2003),
pp. 1729.
Horrocks, I., & Patel-Schneider, P. F. (2004). A Proposal for an OWL Rules Language. In
13th International Conference on World Wide Web (WWW04), pp. 723731. ACM
Press.
Horrocks, I., Patel-Schneider, P. F., Boley, H., Tabet, S., Grosof, B., & Dean, M.
(2004). SWRL: A semantic web rule language combining OWL and RuleML.
W3C Member Submission. Available at http://www.w3.org/Submission/2004/
SUBM-SWRL-20040521/.
Kifer, M., Lausen, G., & Wu, J. (1995). Logical Foundations of Object-Oriented and FrameBased Languages. Journal of the ACM, 42 (4), 741843.
Klyne, G., & Carroll, J. J. (2004). Resource Description Framework (RDF): Concepts
and Abstract Syntax. W3C Recommendation. Available at http://www.w3.org/TR/
2004/REC-rdf-concepts-20040210/.
Levy, A. Y., & Rousset, M. (1998). Combining Horn Rules and Description Logics in
CARIN. Artificial Intelligence, 104 (1-2), 165209.
Lloyd, J. W., & Topor, R. W. (1984). Making Prolog more Expressive. Journal of Logic
Programming, 1 (3), 225240.
Maher, M. J. (2002). A Model-Theoretic Semantics for Defeasible Logic. In ICLP 2002
Workshop on Paraconsistent Computational Logic (PCL-2002), pp. 255287.
McGuinness, D. L., & van Harmelen, F. (2004).
OWL Web Ontology Language
Overview. W3C Recommendation. Available at http://www.w3.org/TR/2004/
REC-owl-features-20040210/.
Motik, B., Sattler, U., & Studer, R. (2004). Query Answering for OWL-DL with Rules. In
3rd International Semantic Web Conference (ISWC-2004), pp. 549563.
Patel-Schneider, P. F., Hayes, P., & Horrocks, I. (2004). OWL Web Ontology Language
Semantics and Abstract Syntax. W3C Recommendation. Available at http://www.
w3.org/TR/2004/REC-owl-semantics-20040210/.
Pereira, L. M., & Alferes, J. J. (1992). Well-Founded Semantics for Logic Programs with
Explicit Negation. In Neumann, B. (Ed.), European Conference on Artificial Intelligence, pp. 102106. John Wiley & Sons.
Prudhommeaux, E., & Seaborne, A. (2008). SPARQL Query Language for RDF. W3C
Recommendation. Available at http://www.w3.org/TR/rdf-sparql-query/.
Rao, P., Sagonas, K. F., Swift, T., Warren, D. S., & Freire, J. (1997). XSB: A System for
Efficiently Computing WFS. In Proceedings of 4th International Conference on Logic
Programming and Nonmonotonic Reasoning (LPNMR97), pp. 10701080.
93

fiAnalyti, Antoniou, Damasio, & Wagner

Rosati, R. (1999). Towards Expressive KR Systems Integrating Datalog and Description
Logics: Preliminary Report. In Proc. of the 1999 Description Logic Workshop (DL99),
pp. 160164.
Rosati, R. (2005). On the Decidability and Complexity of Integrating Ontologies and Rules.
Journal of Web Semantics, 3, 6173.
Schaffert, S., Bry, F., Besnard, P., Decker, H., Decker, S., Enguix, C. F., & Herzig, A.
(2005). Paraconsistent Reasoning for the Semantic Web. In Workshop on Uncertainty
Reasoning for the Semantic Web, co-located with ISWC-2005, pp. 104105.
Sintek, M., & Decker, S. (2002). TRIPLE - A Query, Inference, and Transformation Language for the Semantic Web. In 1st International Semantic Web Conference (ISWC2002), pp. 364378. Springer-Verlag.
ter Horst, H. J. (2004). Extending the RDFS Entailment Lemma. In 3rd International
Semantic Web Conference (ISWC-2004), pp. 7791.
ter Horst, H. J. (2005a). Combining RDF and Part of OWL with Rules: Semantics, Decidability, Complexity. In 4th International Semantic Web Conference (ISWC-2005),
pp. 668684.
ter Horst, H. J. (2005b). Completeness, Decidability and Complexity of Entailment for
RDF Schema and a Semantic Extension Involving the OWL Vocabulary. Journal of
Web Semantics, 3 (2-3), 79115.
Wagner, G. (1991). A Database Needs Two Kinds of Negation. In 3rd Symposium on
Mathematical Fundamentals of Database and Knowledge Base Systems (MFDBS91),
pp. 357371. Springer-Verlag.
Wagner, G. (2003). Web Rules Need Two Kinds of Negation. In 1st International Workshop on Principles and Practice of Semantic Web Reasoning (PPSWR03), pp. 3350.
Springer-Verlag.
Wagner, G., Giurca, A., & Lukichev, S. (2005). A General Markup Framework for Integrity
and Derivation Rules. In Dagstuhl Seminar Proceedings: Principles and Practices of
Semantic Web Reasoning.
Wagner, G., Giurca, A., & Lukichev, S. (2006). A Usable Interchange Format for Rich
Syntax Rules Integrating OCL, RuleML and SWRL. In Workshop on Reasoning on
the Web (RoW-2006), co-located with WWW-2006).
Yang, G., & Kifer, M. (2003a). Inheritance and Rules in Object-Oriented Semantic Web
Languages. In 2nd International Workshop on Rules and Rule Markup Languages for
the Semantic Web (RULEML03), pp. 95110.
Yang, G., & Kifer, M. (2003b). Reasoning about Anonymous Resources and Meta Statements on the Semantic Web. Journal on Data Semantics, 1, 6997.
Yang, G., Kifer, M., & Zhao, C. (2003). Flora-2: A Rule-Based Knowledge Representation
and Inference Infrastructure for the Semantic Web. In 2nd International Conference
on Ontologies, DataBases, and Applications of Semantics for Large Scale Information
Systems (ODBASE03), pp. 671688.

94

fi