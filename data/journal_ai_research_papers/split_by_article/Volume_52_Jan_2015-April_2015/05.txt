Journal of Artificial Intelligence Research 52 (2015) 287-329

Submitted 10/14; published 02/15

Revision by History
Paolo Liberatore

liberato@dis.uniroma1.it

Sapienza University of Rome, DIAG
Via Ariosto 25, 00185 Rome, Italy

Abstract
This article proposes a solution to the problem of obtaining plausibility information,
which is necessary to perform belief revision: given a sequence of revisions, together with
their results, derive a possible initial order that has generated them; this is different from
the usual assumption of starting from an all-equal initial order and modifying it by a sequence of revisions. Four semantics for iterated revision are considered: natural, restrained,
lexicographic and reinforcement. For each, a necessary and sufficient condition to the existence of an order generating a given history of revisions and results is proved. Complexity
is proved coNP complete in all cases but one (reinforcement revision with unbounded sequence length).

1. Introduction
Many belief revision operators are based on some sort of plausibility order (Spohn, 1988;
Boutilier, 1996; Nayak, 1994; Williams, 1994; Areces & Becher, 2001; Zhang, 2004; Benferhat, Kaci, Le Berre, & Williams, 2004; Hild & Spohn, 2008; Ferme & Hansson, 2011).
Whenever revising can be done in two or more different ways, the result is the disjunction of
either all of them (Alchourron & Makinson, 1982; Fagin, Ullman, & Vardi, 1983; Winslett,
1988) or the most plausible ones only according to the order (Gardenfors, 1988; Katsuno
& Mendelzon, 1991; Peppas, 2008; Nebel, 1992; Ferme & Hansson, 2011). Fewer disjuncts
imply more formulae; therefore, the more discriminating the order, the more informative
the result. A fine-grained order is central to the usefulness of the revised knowledge base.
Iterated revision provides itself a way for obtaining a plausibility order. Even starting
from an all-equal plausibility order (the least discriminating one), each revision changes it by
making some possibilities more plausible than others (Spohn, 1988; Boutilier, 1996; Nayak,
1994; Williams, 1994; Booth & Meyer, 2006; Jin & Thielscher, 2007). A sequence of revisions
produces an order that, depending on the revising formulae, is more or less informative. In
some cases, this is a solution to the problem of obtaining a plausibility order: by a sequence
of previous revisions (Konieczny & Pino Perez, 2000; Baltag, Gierasimczuk, & Smets, 2011).
However, even a long history of revisions may not produce a fine discrimination. In a limit
case, after revising by a, a, a, a, etc., the final order only discriminates models of a from
models of a.
Is there any other way to obtain an initial plausibility order? One possibility is to derive
it from knowledge of the previous results (this can also be done for merging, Liberatore,
2014b, 2014a). In other words, not only the previous revising formulae are given, but also
the results they produced. If K0 is the initial knowledge base and P1 the first revising
formula, the result is another knowledge base K1 , which can be further revised by P2 . In
this article, all Ki s and Pi s are assumed known up to a certain point:
c
2015
AI Access Foundation. All rights reserved.

fiLiberatore

P

P

P

P

1
2
3
n
K0 
K1 
K2 
K3 . . . Kn1 
Kn

Such a sequence of consistent formulae [K0 , P1 , K1 , . . . , Pn , Kn ] is called a revision sequence. It gives information about the initial plausibility order over models, like the following example shows.
Example 1 Let [K0 , P1 , K1 ] be the revision sequence where:
K0 = a
P1 = a
K1 = a  b  c
This specific K1 = a  b  c is not the only possible result of revising K0 = a by
P1 = a. While for example a  b  c was also possible, a  b  c is the actual revision
result. This means that the model {a, b, c} was considered more plausible than {a, b, c},
another model of P1 . This information can be useful in subsequent revisions.
A revision sequence may be seen as a form of training: the first n revisions are manually performed by human operators, the following others are done automatically using the initial plausibility order obtained from the training. Technically, from the revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] containing the revising formulae and their resulting
knowledge bases up to Kn , one derives an initial plausibility order, which is revised by
P1 , . . . , Pn , Pn+1 , Pn+2 , . . . to obtain Kn+1 , Kn+2 , . . . A similar mechanism has been studied
by Nittka and Booth (2008); a comparison with their approach is in the conclusions.
Example 2 As a part of a research project, PhD student Polyxena is tasked with automating the incorporation of new data in a database, a process so far manually performed by the
database maintainers, a specialized group of people. She soon realizes that the information
to be incorporated may be disjunctive, so that revisions may be done in multiple ways. Introducing data in the form either a or b when both a and b are in the database requires
erasing either a, b or both. Studying the relevant literature on the topic, she finds out that
such choices require plausibility information. Since the previous revisions were performed by
the database maintainers, they possess this information. She therefore asks them about the
rank of the models, getting answers ranging from what do you mean? to I rank Brazilian
redhead models at the top, but Swiss models are not bad. After spending half an hour trying
to explain to them the concepts of plausibility, consistency, propositional models (and how
they differ from fashion models) and ranking, she gives up.
When she is about to leave the room, one of the maintainers suggests to her to have
a look at the logs, since these files record everything that happened to the database. She
does, and indeed all previous revisions are stored in the logs: both the new information
and how the database maintainers incorporated it. The problem now shifts from eliciting
a rank from the database maintainers, which proved difficult, to determining it from the
previous history of revisions. She finds out that the sequence of revisions and results is
natural-compatible (Definition 4) but not compatible with the other revisions. This means
288

fiRevision by History

that not only an initial plausibility order can be calculated using Lemma 2, but also that the
people who performed the previous revisions had (unknowingly) adopted a policy of minimal
plausibility change.
Apart from the remarks of the operators, admittedly surreal for comedic purposes, the
example shows a not-so-uncommon scenario: a process performed by hand is to be automated, and eliciting information from the people who have performed it so far is difficult.
First, this information may have never been expressed in an explicit form; second, it may
be hard to formalize for people lacking a background in formal logic.
In the case of belief revision, the information needed to perform the subsequent revisions
is the initial order of the models. However, eliciting an order is not as easy as it may seem, as
shown by research on the similar concept of preference (Sandholm & Conen, 2010; Carson &
Louviere, 2011), not to mention the experimental results in cognitive psychology (Tversky
& Kahneman, 1983): after being given some background information, the majority of the
participants in a test reckoned Linda is a bank teller and is active in the feminist movement
to be more likely than Linda is a bank teller, while probability theory forbids a  b to be
more likely than a.
Furthermore, providing plausibility information is an additional work for the people who
have manually performed the process so far. Instead, as Example 1 shows, some information
may be derived from the previous history of revisions.
Another example is in data synchronization: the SyncML protocol (OMA, 2002) allows
synchronizing data (phonebook, calendar notes, etc.) between a mobile phone and a computer, but conflicts may arise; an implementation may then ask the user what to do, or
take a decision (like phone always wins) which may however be later manually reversed
by the user. Either way, the result tells how the conflict should have been solved. Again,
both the revising formula and the resulting knowledge base are given, and can be used to
derive information about the unknown plausibility order.
As Example 1 shows,
from the knowledge of a revision sequence
[K0 , P1 , K1 , P2 , K2 , . . . , Pn , Kn ] some information about the initial plausibility of models
can be derived. Such an information depends on the revision semantics, and some sequences
are not generated at all by some semantics.
Example 3 Let [K0 , P1 , K1 , P2 , K2 , P3 , K3 ] be the revision sequence defined as follows.
K0 = a
P1 = b
K1 = a  b
P2 = c
K2 = a  b  c
P3 = a
K3 = a
It will be shown that there exists an initial order of the models that generates this sequence
using the natural revision semantics. By contrast, no order generates it with the restrained
and lexicographic semantics.
289

fiLiberatore

The technical results provided by this article are: first, equivalent formulations for the
problem of establishing the existence of an order generating a revision sequence using the
natural, lexicographical, restrained and reinforcement revision; second, how an initial order
can be built if one exists; third, a complexity characterization.
Since the number of models is exponential in the number of variables, there exists an
order over models such that . . .  is a quantification over a data structure that may be
exponential in size. As a result, brute-force search takes double exponential time. The
equivalent formulations avoid this high computational cost by recasting the problem in
terms of polynomial-size data structures.
The problem of establishing the existence of an initial order generating a given sequence
is coNP-complete in all cases but one (reinforcement revision with unbounded sequence
length), therefore showing that the problem can be expressed as the validity of a QBF.
This proves that the problem can be recast in a form that does not contain the existential
quantification over the initial order.

2. Preliminaries
Belief revision as considered in this article is on propositional formulae built on a finite
alphabet of variables. A truth evaluation over such an alphabet is called a model: a function
from the variables to either true or false. Following a common terminology of propositional
logic, if a model satisfies a formula then it is a model of the formula, and the formula
has that model. The set of models of a formula F is denoted Mod(F ). A QBF is a
propositional formula where the variables are quantified, either universally (like in a.a 
b), existentially (like in ab.a  b) or both (like in ab.a  b). When all variables are
universally quantified the formula is a QBF .
A revision sequence represents the evolution of beliefs over time, including both the
revising formulae and their results.
Definition 1 A revision sequence is an odd sequence of consistent propositional formulae
[K0 , P1 , K1 , . . . , Pn , Kn ] over a finite set of variables.
The semantics for belief revision considered in this article work on an ordering of the
models, representing their relative plausibility, which is modified when new information
arrives. Such orderings can be defined as follows.
Definition 2 A total preorder C is a partition of the models into a finite sequence of classes
[C(0), C(1), C(2), . . . , C(m)] with C(0) 6= .
Intuitively, such a partition represents a way to compare models: I and J compare the
same if they are in the same class, I compares greater than J if it is in a class of higher
index. The use of partitions instead of the usual notation I  J simplifies definitions and
proofs. Since classes can be empty (except the first), several partitions may represent the
same way of comparing models. This is not a problem as total preorders are never checked
for equality in this article.
A total preorder can be depicted as a shelf, as in Figure 1. The bottom drawer C(0)
contains the most plausible models. These represent the situations currently believed possible: C(0) = Mod(K0 ). Revising C by P1 changes it into a new preorder CP1 that takes into
290

fiRevision by History

account the new information. The class CP1 (0) contains the models that are now considered
the most plausible; therefore, CP1 (0) = Mod(K1 ).

C(7)
C(6)
C(5)
C(4)
C(3)
C(2)
C(1)
C(0)

Figure 1: The graphical representation of a total preorder C
Such a partition formalizes the plausibility of models: models of C(i) are more plausible
than models of C(i + 1). The lower the class, the more plausible the model; for this reason,
a total preorder is often seen as representing implausibility rather than plausibility. It is
inverse of an ordinal conditional function (Spohn, 1988): (I) = n if and only if I  C(n).
The study of two of the semantics considered in this article involves the prefixes and
the maxsets of a sequence. Sequences are denoted using brackets [. . .]. Given a sequence of
formulae [P1 , . . . , Pn ], its h-prefix is the sequence containing only its first h  1 formulae in
the sequence. The maxset of a sequence extends the concept of maximal consistent subsets
from sets to sequences.

maxset([P1 , . . . , Pn ]) = maxset(; [P1 , . . . , Pn ])


 maxset([Q1 , . . . , Qi , P1 ]; [P2 , . . . , Pn ])


if Q1      Qi  P1 is consistent
maxset([Q1 , . . . , Qi ]; [P1 , P2 , . . . , Pn ]) =

maxset([Q1 , . . . , Qi , true], [P2 , . . . , Pn ])



otherwise
maxset([Q1 , . . . , Qn ]; ) = [Q1 , . . . , Qn ]
A sequence of formulae used in a context where a propositional formula is expected
implicitly represents the conjunctions of its formulae. For example, a  [b, c, c  d] means
a  (b  c  (c  d)). According to this notation, Q1      Qi  P1 is inconsistent if and only
if [Q1 , . . . , Qi ] |= P1 . As a result, [Q1 , . . . , Qi , true] can be replaced by [Q1 , . . . , Qi , P1 ] in
the definition of a maxset.
By definition of prefixes and maxsets, they commute: the h-prefix of the maxset of a
sequence is the same as the maxset of the h-prefix of the same sequence. As a result, if P is
the h-th element of the sequence S then P  maxset(S) if and only if P maxset(prefixh (S))
is consistent.
The maxset is often written maxset(P1 , . . . , Pn ) as a shorthand of maxset([P1 , . . . , Pn ]).
A number of properties of maxsets are now shown. All proofs are in the appendix.
291

fiLiberatore

Lemma 1 If F is consistent and F |= maxset(P1 , . . . , Pn ), then maxset(P1 , . . . , Pn ) 
{Pi | 1  i  n and F |= Pi }.
Lemma 2 If F is consistent and F |= maxset(P1 , . . . , Pn ), every consistent subset of
{P1 , . . . , Pn } that contains all formulae entailed by F is equivalent to maxset(P1 , . . . , Pn ).
In this article, a sequence of formulae where some of them are replaced by true is called
a subsequence. This is similar to the usual definition, with the difference that formulae
maintain their position in the sequence.
Lemma 3 If F is consistent then F 6|= maxset(P1 , . . . , Pn ) if and only if there exists a
subsequence R of [P1 , . . . , Pn ] such that:
1. R is consistent;
2. if F |= Pi then Pi  R;
3. for some i, Pi 6 R and Pi  prefixi (R) is consistent.
The conditions in the lemma are all of existential type: there exists R, there exists
a model for R, either F 6|= Pi or Pi  R and Pi  prefixi (R) is consistent. This proves
that checking F 6|= maxset(P1 , . . . , Pn ) can be expressed as the validity of a QBF, and is
therefore in NP.
Corollary 1 If F is consistent, checking F 6|= maxset(P1 , . . . , Pn ) is in NP.
The lemma avoids constructing the maxset one formula at time by replacing the test
of satisfiability of Pi  prefixi (maxset(P1 , . . . , Pn )) with F |= Pi , which is the same if F is
consistent and entails the maxset. This way, the sequence of satisfiability checks required
to build the maxset are parallelized, that is, turned into a number of validity checks that
can be performed in parallel.
In order to check F  maxset(P1 , . . . , Pn ), one first checks whether F |=
maxset(P1 , . . . , Pn ), and then maxset(P1 , . . . , Pn ) |= F . Assuming that the first condition
is true, the second can be shown in coNP.
Theorem 1 If F is consistent, checking F  maxset(P1 , . . . , Pn ) is in coNP.
In this article, only revisions satisfying the AGM postulate 4 are considered: K  P 
K  P if K  P is consistent. Also, all formulae Pi and Ki in the sequences are assumed
consistent. When checking a sequence for being generated by some total preorder, Ki1 Pi
is consistent if and only if Ki  Ki1 Pi . In particular, if the sequence is generated by some
total preorder and Ki1 Pi is consistent then by the AGM postulate Ki1 Pi is equivalent
to Ki ; conversely, if Ki  Ki1  Pi is consistent then the consistency of Ki implies that of
Ki1  Pi . This property is important because it allows replacing a satisfiability test with
an unsatisfiability test.
292

fiRevision by History



P

P

-

Figure 2: Natural revision

3. Natural Revision
Natural revision (Boutilier, 1996) modifies a total preorder of plausibility of models C in
light of a new piece of information P into a new total preorder CP that is as close as possible
to the original one. In the new preorder P has to be true in all most plausible models, these
of CP (0). A minimal change of C ensuring this is setting CP (0) to be the minimal models
of P according to C, leaving the rest of the preorder unaltered.
Definition 3 The natural revision of the total preorder C by formula P is defined as the
total preorder CP that follows, where i is the minimal index such that C(i)  Mod(P ) 6= :
(

CP (j) =

C(i)  Mod(P ) if j = 0
C(j  1)\CP (0) otherwise

For example, CP (0) = C(i)  Mod(P ), while CP (1) = C(1  1)\CP (0) = C(0)\CP (0).
Graphically, the change that P produces to the preorder in natural revision can be depicted
as cutting out the lowest models of P and placing them below the others, as shown in
Figure 2.
If CP1 ,...,Pi is the result of revising C by P1 , then P2 , etc. using natural revision, then
Mod(Ki ) = CP1 ,...,Pi (0) in the revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ].
Example 4 Let C = [C(0), C(1)] be the total preorder such that:

C(0) = Mod(a)
C(1) = Mod(a)
Revising it by P1 = b, P2 = c and P3 = a using natural revision generates the revision
sequence in Example 3. Indeed, revising C by P1 = b makes the minimal models of P1 to
form the new class zero. Since C(0)  Mod(P ) 6= , the index i in the definition of natural
revision is zero. The resulting preorder is therefore:
293

fiLiberatore

CP1 (0) = C(0)  Mod(P1 ) = Mod(a  b)
CP1 (1) = C(0)\CP1 (0) = Mod(a  b)
CP1 (2) = C(1)\CP1 (0) = Mod(a)
Since Mod(K1 ) = CP1 (0), it follows that K1  a  b. A similar change happens when
revising by P2 = c, since CP (0)  Mod(P2 ) 6= , which implies i = 0.
CP1 P2 (0) = Mod(a  b  c)
CP1 P2 (1) = Mod(a  b  c)
CP1 P2 (2) = Mod(a  b)
CP1 P2 (3) = Mod(a)
Again, Mod(K2 ) = CP1 P2 (0), which implies K2  a  b  c. The minimal models of
P3 = a are the entire class CP1 P2 (3). Therefore, i = 3 and the preorder becomes:
CP1 P2 P3 (0) = Mod(a)
CP1 P2 P3 (1) = Mod(a  b  c)
CP1 P2 P3 (2) = Mod(a  b  c)
CP1 P2 P3 (3) = Mod(a  b)
This proves that K3  a. The revision sequence coincides with that of Example 3.
Looking at this example in the other direction, it shows that the revision sequence [a, b, a 
b, c, a  b  c, a, a] is generated by natural revision from some preorder. It will be proved
that this is not the case for restrained and lexicographic revisions.
The aim of this article is to establish whether a sequence is generated by some preorder,
and finding it. Unfortunately, a direct search in the space of total preorders is unfeasible:
the number of models is exponential in the number of the variables, and the number of
total preorders is therefore a double exponential. Fortunately, for natural revision this
difficulty can be overcome thanks to a necessary and sufficient condition for a sequence to
be generated by some total preorder. A number of lemmas are needed to prove it. The first
shows that the revising by a formula does not alter the relative order of models that are
not in the resulting knowledge base.
Lemma 4 If CP (0)  Mod(F ) =  then CP compares the models of F as C does, where CP
is the natural revision of the total preorder C with formula P .
This result can be iterated over a number of revising formulae: if the resulting knowledge
bases Ki are all inconsistent with a formula F , the relative order of models of F is not
changed. The result of a final revision by F can therefore be calculated from the original
ordering, in this case. The following lemma is formulated over a fragment of a revision
sequence because this is how it is later applied.
294

fiRevision by History

Lemma 5 Let [Kj , Pj+1 , . . . , Pi , Ki ] be a revision sequence generated by natural revision
from a total preorder C. If Kj  Pi is consistent while none of Kj+1  Pi , . . . , Ki1  Pi is,
then CPj+1 ,...,Pi (0) = Mod(Kj  Pi ).
This lemma is similar to a result by Boutilier (1996, Thm. 17), but lifts the assumption
that all conjunctions Kj  Pj+1 , . . . , Ki2  Pi1 are consistent. It shows that if Pi is
consistent with a previous Kj , then natural revision by Pi produces a result that can be
determined from Kj only, independent of the initial preorder. The following lemma covers
the other case, where Pi is inconsistent with all previous Kj .
Lemma 6 If the revision sequence [K0 , P1 , K1 , . . . , Pi , Ki ] is generated by natural revision
from the total preorder C and Pi is inconsistent with each of K0 , . . . , Ki1 , then the models
of Ki are the minimal models of Pi according to C.
The last two lemmas prove that, for natural revision, Ki is equivalent to Kj  Pi for
the maximal j for which this conjunction is consistent if one exists, otherwise is determined
from the initial preorder. The first is a necessary condition for the existence of a total
preorder generating the sequence.
Definition 4 A revision sequence [K0 , P1 , . . . , Pn , Kn ] is natural-compatible if, for every
i  {1, . . . , n}, it holds:
1. Ki |= Pi ;
2. if j is the maximal index such that j < i and Kj  Pi is consistent (if any), then
Ki  Kj  Pi .
If a sequence is natural-compatible then it is generated by natural revision from some
initial total preorder.
Theorem 2 If [K0 , P1 , K1 , . . . , Pn , Kn ] is natural-compatible then it is generated by natural
revision from the initial preorder C = [C(0), . . . , C(n + 1)].


 Mod(Ki )

if i  n and l < i . Kl  Pi |= 

otherwise, if i  n
C(i) =

 S{Mod(K ) | l < j . K  P 6|= } if i = n + 1
j
j
l
Natural-compatibility is not only a sufficient condition for a sequence being generated
by natural revision from some initial preorder. The following theorem proves that it is also
necessary. Therefore, it characterizes exactly the revision sequences that natural revision
generates.
Theorem 3 A revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] is generated by natural revision
from some initial total preorder if and only if it is natural-compatible.
The following example illustrates natural compatibility and its application to natural
revision.
295

fiLiberatore

Example 5 The revision sequence in the previous example is natural-compatible. The first
condition of natural compatibility is satisfied: K1 = a  b implies P1 = b; K2 = a  b  c
implies P2 = c; and K3 = a implies P3 = a.
The last preceding formula Kj consistent with P1 = b is K0 = a, and indeed K1 =
K0  P1 = a  b. The last preceding formula Kj consistent with P2 = c is K1 = a  b, and
indeed K2 = K1  P2 = a  b  c. Finally, P3 = a is consistent with none of K0 , K1 , K2 .
Therefore, the second condition of natural compatibility places no constraint on it.
Theorem 2 not only proves that the revision sequence is generated by natural revision
from some preorder, but it also provides one: C(0) = Mod(a), C(1) = Mod(a). This was
indeed the preorder used in the previous example to generate the sequence.
Natural compatibility can be rewritten as a number of satisfiability and unsatisfiability
tests. In particular, that j is the maximal index having the property can be written as:
Kj  Pi is consistent and Kh  Pi is not, for j < h < i. This way, no satisfiability check is
dependent on another, so the problem can be solved with two parallel calls to an NP oracle,
one positive and one negative. The assumption that formulae in revision sequences are all
consistent allows rewriting the first.
Lemma 7 Checking the existence of a total preorder C generating a revision sequence
[K0 , P1 , K1 , . . . , Pn , Kn ] using natural revision is in coNP.
The problem is also hard for coNP. Therefore, it is coNP complete.
Theorem 4 The problem of establishing the existence of a preorder generating a revision
sequence using natural revision is coNP complete.

4. Restrained Revision
Restrained revision (Booth & Meyer, 2006) has in common to natural revision that when
revising a total preorder C by a formula P , the minimal models of P becomes the new class
zero. In addition, every other class is split in two according to satisfaction of P : the models
of P go in the lower class, the others in the higher.
Equivalently, every class i is refined (Papini, 2001) into classes 2i and 2i + 1, where the
first class contains the models of class i satisfying P and the second the models of class i
not satisfying P ; then, natural revision is applied.
Definition 5 The restrained revision of the total preorder C by formula P is defined as the
total preorder CP that follows, where i is the minimal index such that C(i)  Mod(P ) 6= 
and / denotes quotient (integer division, truncated):


 C(i)  Mod(P )

CP (j) =

if j = 0
(C((j  1)/2)\CP (0))  Mod(P ) if j > 0 odd

 (C((j  1)/2)\C (0))\Mod(P )
otherwise
P

For example,
CP (0) = C(i)  Mod(P ),
CP (1) = (C((1  1)/2)\CP (0)) 
Mod(P ) = (C(0)\CP (0))  Mod(P ) and CP (2) = (C((2  1)/2)\CP (0))\Mod(P ) =
(C(0)\CP (0))\Mod(P ) since (2  1)/2 = 1/2 = 0 using integer division.
296

fiRevision by History

-

P



-

-

Figure 3: Restrained revision
A graphical example of the application of restrained revision to a total preorder is in
Figure 3.
The revision sequence in Example 3 is not generated by any preorder using restrained
revision. This will be proved using a necessary and sufficient condition to the existence of a
preorder generating the sequence. For now, just to illustrate how restrained revision works,
the preorder shown for natural revision is used.
Example 6 Let C be the following total preorder:
C(0) = Mod(a)
C(1) = Mod(a)
Restrained revision by P1 = b, P2 = c and P3 = a generates a revision sequence
different than that in Example 3. Since K0 = Mod(C(0)), it follows K0  a. Revising C
by P1 = b makes the minimal models of P1 to be the new class zero and splits every other
class by b/b. The resulting total preorder after removing the empty classes is therefore:
CP1 (0) = Mod(a  b)
CP1 (1) = Mod(a  b)
CP1 (2) = Mod(a  b)
CP1 (3) = Mod(a  b)
Since Mod(K1 ) = CP1 (0), it follows that K1  a  b. A similar change happens when
revising by P2 = c:
297

fiLiberatore

CP1 P2 (0) = Mod(a  b  c)
CP1 P2 (1) = Mod(a  b  c)
CP1 P2 (2) = Mod(a  b  c)
CP1 P2 (3) = Mod(a  b  c)
CP1 P2 (4) = Mod(a  b  c)
CP1 P2 (5) = Mod(a  b  c)
CP1 P2 (6) = Mod(a  b  c)
CP1 P2 (7) = Mod(a  b  c)
Again, Mod(K2 ) = CP1 P2 (0), which implies K2  a  b  c. The minimal models of
P3 = a are the whole class CP1 P2 (4). The preorder therefore becomes:
CP1 P2 P3 (0) = Mod(a  b  c)
CP1 P2 P3 (1) = Mod(a  b  c)
CP1 P2 P3 (2) = Mod(a  b  c)
CP1 P2 P3 (3) = Mod(a  b  c)
CP1 P2 P3 (4) = Mod(a  b  c)
CP1 P2 P3 (5) = Mod(a  b  c)
CP1 P2 P3 (6) = Mod(a  b  c)
CP1 P2 P3 (7) = Mod(a  b  c)
As a result, K3  a  b  c. This revision sequence coincides with that of Example 3
up to P3 but K3 is different, as K3 = a in the previous example. It will be shown that no
preorder generates that sequence using restrained revision.
The following property is similar to Lemma 5 of natural revision, with the difference
that a maxset is introduces to account for the class split.
Lemma 8 Let [Kj , Pj+1 , . . . , Pi , Ki ] be a revision sequence generated by restrained revision
from the initial total preorder C. If Kj  Pi is consistent while none of Kj+1  Pi , . . . ,
Ki1  Pi is, then CPj+1 ,...,Pi (0) = Mod(maxset(Kj  Pi , Pj+1 , . . . , Pi1 )).
This result is the first half of a necessary and sufficient condition for a sequence being
generated by restrained revision from some preorder, which involves the following definition.
Definition 6 A revision sequence [K0 , P1 , K1 . . . , Pn , Kn ] is restrained-compatible if, for
every i  {1, . . . , n}, it holds:
1. Ki |= Pi ;
2. Ki  maxset(Kj  Pi , Pj+1 , . . . , Pii ) if j is the maximal index such that j < i and
Kj  Pi is consistent, if any;
298

fiRevision by History

3. either Ki |= Pl or Ki |= Pl for every l < i if no such j exists.
As a side remark, the condition that either Ki |= Pl or Ki |= Pl in the third point of
the definition refers to all indexes l < i, including the ones for which Kl is consistent with
a previous Kj .
If a revision sequence is restrained-compatible it is generated by restrained revision from
some initial preorder. The following lemma specifies which one that is.
Lemma 9 If [K0 , P1 , K1 , . . . , Pn , Kn ] is restrained-compatible then it is generated by restrained revision from the total preorder C = [C(0), . . . , C(n + 1)], where:


 Mod(Ki )

C(i) =

if i  n and l < i . Pi  Kl |= 
otherwise, if i  n

 S{Mod(K ) | l < j P  K 6|= } if i = n + 1
j
j
l


The results proved so far can be collected into an equivalent formulation of the existence
of a preorder generating a sequence.
Theorem 5 A revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] is generated by restrained revision
from some initial total preorder if and only if it is restrained-compatible.
The sequence in Example 3 can be shown not to be restrained-compatible. Therefore,
not only it is not generated by restrained revision from the preorder that worked for natural
revision, it is not generated from any other.
Example 7 The revision sequence [K0 , P1 , K1 , P2 , K2 , P3 , K3 ] with K0 = a, P1 = b, K1 =
a  b, P2 = c, K2 = a  b  c, P3 = a, K3 = a is not restrained-compatible (this is
the sequence of Example 3). Indeed, P3 = a is inconsistent with each of K0 , K1 and K2 ,
yet K3 = a entails neither P1 = b nor P1 = b, thereby violating the third condition of
restrained compatibility.
The definition of restrained compatibility involves consistency and entailment checks.
The following lemma rewrites it in a form that can be shown to use only inconsistencies.
Lemma 10 A revision sequence [K0 , P1 , K1 . . . , Pn , Kn ] is restrained-compatible if and only
if, for every index i:
1. Ki |= Pi ;
2. for every 0  j < i, either Kj  Pi is inconsistent or Ki |= Kl  Pi for some j < l < i
or Ki  maxset(Kj  Pi , Pj+1 , . . . , Pi1 );
3. for every 0  j < i, Ki |= Pj , Ki |= Pj , or Ki |= Kl  Pi for some 0  l < i.
Since checking equivalence of a consistent formula and a maxset is a problem in coNP
by Theorem 1, it can be expressed as a universally quantified formula. As a result, all
quantifiers in the conditions of the lemma are universal, and the whole problem is in coNP.
Hardness for the same class is easy to prove.
Theorem 6 Establishing the existence of a total preorder generating a restrained revision
sequence is coNP-complete.
299

fiLiberatore

5. Intermezzo: Multiple Preorders
The same revision sequence may be generated by more than one total preorder. Examples
exist even with two variables only, such as the sequence [K0 , P1 , K1 , P2 , K2 ] with K0 = ab,
P1 = a  b, K1 = a  b, P2 = a  b and K2 = a  b.
ab

ab

a  b  a  b  a  b
According to Lemma 9, the sequence is generated by restrained revision from the initial
preorder C = [C(0), C(1), C(2), C(3)].
C(0) = Mod(a  b)
C(1) = Mod(a  b)
C(2) = Mod(a  b)
C(3) = Mod(a  b)
However, this is not the only preorder generating the sequence. Classes C(1) and C(2)
can be swapped, still leading to the same result.
C(0) = Mod(a  b)
C(1) = Mod(a  b)
C(2) = Mod(a  b)
C(4) = Mod(a  b)
Intuitively, revising by a single-model formula has always a single possible outcome:
the formula itself. As a result, even if Mod(K1 ) is now contained in a class greater than
Mod(K2 ), still the minimal models of P1 are Mod(K1 ).
In a way, this is expected: when revision can only be performed in a single possible
way, the initial preorder is irrelevant. This intuition holds for all considered revisions, and
is confirmed by further simplifying the preorder: indeed, apart from C(0), the other classes
can be shuffled in every possible way, or even merged:
C(0) = Mod(a  b)
C(1) = Mod(a  b)  Mod(a  b)  Mod(a  b)
This kind of preorder works whenever each Pi has a single model, but not in general.
Even restricting to the Pi s such that Pi  Kj |=  for all j < i, if l < i then Pi  Kl is
guaranteed to be inconsistent, but Pl  Ki is not. In other words, Mod(Ki ) cannot always
be swapped or merged with Mod(Kl ).
When more than one preorder is possible, a sensible principle is to choose the least discriminating one. Such a preorder would compare I different from J only if strictly necessary
to obtain the revision sequence. In other words, it does not carry plausibility information
that does not follow from the revision sequence. Such a minimization is similar in spirit
300

fiRevision by History

to the way rational closure in conditional logic is the most rationally rooted consequence
relation (Lehmann & Magidor, 1992; Booth & Nittka, 2008). The last preorder shown
obeys this principle, but the question of whether a least discriminating preorder exists for
all revision sequences and all considered revision semantics is an open problem.
A different possible solution is to proceed by refutation:
if a sequence
[K0 , P1 , K2 , . . . , Pn , Kn ] is generated by a revision from some preorder but
[K0 , P1 , K2 , . . . , Pn , Kn , Pn+1 , Kn+1 ] is not, then Kn+1 might be considered true
after revising by Pn+1 .
As correctly pointed out by one of the reviewers, a revision sequence may even be
generated by different revisions from different initial preorder, adding a second dimension
to the problem: not only the preorder, but also the semantics of revision has to be chosen.
The sequence shown in this example is one of this kind: it is generated by all four revision
semantics considered in this article from every initial preorder C with C(0) = Mod(a  b).

6. Lexicographic Revision
In a seminal work on iterated revision, Spohn (1988) defined a tentative semantics based
on the principle that newer formulae are more plausible than older ones at all levels of
plausibility: even the most unlikely models of P are to be preferred over the most likely
of P . In spite of some apparent drawbacks pointed out by its author, this semantics was
later recognized as a principled way to perform iterated revision (Nayak, 1994; Darwiche &
Pearl, 1997; Booth & Meyer, 2006; Jin & Thielscher, 2007; Konieczny & Pino Perez, 2000).
Like the other revisions used in this article, lexicographic revision works on a total
preorder of plausibility of models C. In particular, revision by P changes it by moving all
models of P to classes of index lower than the others.
Definition 7 The lexicographic revision of a total preorder C by a formula P is defined
as the following total preorder, where i and j are respectively the indexes of the lowest and
highest classes containing models of P :
(

CP (k) =

C(k + i)  Mod(P )
if k  j  i
C(k  j + i  1)\Mod(P ) otherwise

The new class zero is CP (0) = C(0 + i)  Mod(P ); as expected, it comprises the minimal
models of P , since C(i) is the lowest class containing models of P . The class CP (j  i) =
C(j  i + i)  Mod(P ) = C(j)  Mod(P ) contains the highest-class models of P , since by
assumption these are in C(j). The models of C(0) that satisfy P , if any, are moved to
class CP (j  i + 1) = C(j  i + 1  j + i  1)\Mod(P ) = C(0)\Mod(P ). The index is
j  i + 1 because the lower classes CP (0), . . . , CP (j  i) contain the models of P coming
from C(i), . . . , C(j).
Figure 4 shows how a total preorder C is changed by a formula P using lexicographic
revision.
Graphically, lexicographic revision cuts out the models of P from their classes and
wedges them under the shelf. This way, every model of P belongs to a lower class than all
models of P . At the same time, the relative position of two models of P is not changed,
and the same holds for every two models of P .
301

fiLiberatore

P


-

P

Figure 4: Lexicographic revision
Example 8 It will be shown that the sequence in Example 3 is not generated by lexicographic
revision from any total preorder. Meanwhile, to illustrate the definition of lexicographic
revision the preorder used in the example for natural revision is revised by P1 = b, P2 = c
and P3 = a.
C(0) = Mod(a)
C(1) = Mod(a)
Revising C by P1 = b using lexicographic revision removes all models of P1 from their
classes and creates new classes for them at the bottom:
CP1 (0) = Mod(a  b)
CP1 (1) = Mod(a  b)
CP1 (2) = Mod(a  b)
CP1 (3) = Mod(a  b)
As a result, K1 = a  b. Revising by P2 = c has a similar effect:
CP1 P2 (0) = Mod(a  b  c)
CP1 P2 (1) = Mod(a  b  c)
CP1 P2 (2) = Mod(a  b  c)
CP1 P2 (3) = Mod(a  b  c)
CP1 P2 (4) = Mod(a  b  c)
302

fiRevision by History

CP1 P2 (5) = Mod(a  b  c)
CP1 P2 (6) = Mod(a  b  c)
CP1 P2 (7) = Mod(a  b  c)

This preorder produces K2 = a  b  c. Finally, revising by P3 = a and removing the
empty classes makes the classes 1, 3, 5, 7 to become the new classes 0, 1, 2, 3.
CP1 P2 P3 (0) = Mod(a  b  c)
CP1 P2 P3 (1) = Mod(a  b  c)
CP1 P2 P3 (2) = Mod(a  b  c)
CP1 P2 P3 (3) = Mod(a  b  c)
CP1 P2 P3 (4) = Mod(a  b  c)
CP1 P2 P3 (5) = Mod(a  b  c)
CP1 P2 P3 (6) = Mod(a  b  c)
CP1 P2 P3 (7) = Mod(a  b  c)

Since K3 = a  b  c is not equivalent to a, the revision sequence in Example 3 is
not generated by lexicographic revision from the initial preorder C. It will be shown that no
preorder at all generates that sequence using lexicographic revision.
For every preorder C and consistent formula P , the revised preorder CP using lexicographic revision has three properties:
1. CP (0) is the set of minimal models of P in the preorder C;
2. there exists an index h such

S

i=0,...,h CP (i)

= Mod(P );

3. if two models both satisfy P or both falsify it, CP compares them as C does.
Lexicographic revision can be recast in terms of the maxsets of the reversed sequence.
Booth and Nittka (2008) proved the following property; more precisely, what they proved
implies the following property because an arbitrary preorder [C(0), . . . , C(n)] is obtained
by revising the ordering with all models in class zero with a sequence of formulae having
C(n), . . . , C(0) as their sets of models.
Property 1 If [K0 , P1 , . . . , Kn , Pn ] is a revision sequence generated by lexicographic revision from the total preorder C, then Mod(Ki ) is the set of minimal models of
maxset(Pi , . . . , P1 ) according to C.
This property has the following consequences:
1. all models of Ki are in the same class of C;
303

fiLiberatore

2. all other models of maxset(Pi , . . . , P1 ) are in greater classes.
Two further properties follow. First, if Ki Kj is consistent then all models in Mod(Ki )
Mod(Kj ) are in the same class of C. Indeed, since Ki  Kj is consistent, it has a model
I; since all models of Ki are in the same class of I, and the same for Kj , all models of
these two formulae are in the same class. Second, if Kj has some models in common with
Ki  maxset(Pi , . . . , P1 ), then all its models are in the same class of C, greater than that
of the models of Ki .
This allows shifting from a total preorder among models to a total preorder among
formulae Ki . Since this is a preorder over the formulae Ki , which are the results of the
revision process, it is called a result preorder.
Definition 8 A result preorder for the revision sequence [K0 , P1 , . . . , Pn , Kn ] is a total
preorder among its formulae Ki such that:
1. if Ki  Kj is consistent then Ki and Kj are in the same class;
2. if Ki  Kj  maxset(Pi , . . . , P1 ) is consistent then Ki is in a lower class than Kj .
The advantage of result preorders is that they can be built from the revision sequence,
as it will be shown. Before, it is proved that the existence of a result preorder is the
same as the existence of an initial total preorder over models generating the sequence by
lexicographic revision. Since two preorders are involved (one among models, one among
formulae), a distinction is made between preorder among models C and preorder among
formulae R; result preorders are of the second kind.
Lemma 11 If a revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] is generated by lexicographic
revision from the total preorder among models C then it has the result preorder R defined
by:
R(i) = {Ki | Mod(Ki )  C(i)}
The converse also holds: from a result preorder for a revision sequence one can derive a
preorder among models that generates the sequence using lexicographic revision.
Lemma 12 If R is a result preorder for a revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] such
that Ki |= maxset(Pi , . . . , P1 ) for every i, then lexicographic revision from the following
total preorder C among models generates the revision sequence, where z is the index of the
greatest class of R:
( S

C(h) =

{Mod(Ki ) | Ki  R(h)} if h  z
{I | I 6 K1      Kn }
if h = z + 1

The two lemmas together imply the following corollary.
Corollary 2 A revision sequence [K0 , P1 , . . . , Pn , Kn ] is generated by lexicographic revision
from some initial preorder among models if and only if a result preorder for the sequence
exists and Ki |= maxset(Pi , . . . , P1 ) for every i.
304

fiRevision by History

The condition of existence of a result preorder is already simpler than that of existence
of an initial total preorder over models, since the number of formulae Ki is linear in the size
of the revision sequence while the number of models may be exponential. The existence of
a result preorder can be further recast in terms of a condition over the revision sequence.
Definition 9 A revision sequence [K0 , P1 , . . . , Kn , Pn ] is lexicographic compatible if Ki |=
maxset(Pi , . . . , P1 ) for every i and the relations ' and < defined as follows do not form
cycles containing some < links:
 Ki ' Kj if and only if Ki  Kj is consistent;
 Ki < Kj if and only if Ki  Kj  maxset(Pi , . . . , P1 ) is consistent.
The rationale of the definition is that Ki ' Kj is the same as Ki and Kj being in the
same class of R, and Ki < Kj is the same as Ki being in a lower class. This intuition is
confirmed by the following lemma.
Lemma 13 A revision sequence is generated by lexicographic revision from some total preorder if and only if it is lexicographic compatible.
This result can be applied to the running example.
Example 9 The revision sequence presented in Example 3 is not lexicographic compatible.
Indeed, maxset(P3 , P2 , P1 ) = maxset(a, c, b) = a  c  b, which is not entailed by K3 =
a. As a result, the revision sequence is not generated by lexicographic revision from any
preorder.
Given a revision sequence, one can determine the consistency of Ki  Kj and Ki  Kj 
maxset(Pi , . . . , P1 ) for every pair of formulae Ki and Kj . The problem of non-existence of
a preorder generating the sequence is then turned into that of existence of cycles, which is
computationally easy (polynomial in the size of the revision sequence). The hard part is
checking consistency. Since the problem is polynomial if an NP oracle is available (which
turns all consistency checks into constant-time operations), the problem is in p2 . However,
it can be proved to be even computationally easier than that.
Lemma 14 A revision sequence [K0 , P1 , K1 . . . , Pn , Kn ] is not lexicographic compatible if
and only if either Ki 6|= maxset(Pi , . . . , P1 ) for some i or consistent sets R1 , . . . , Rn exist
such that:
1. {Pj | 1  j  i and Ki |= Pj }  Ri for every i; and
2. there exists a cycle Ki1 , . . . , Kim = Ki1 such that either Kij Kij+1 or Kij Kij+1 Ri
is consistent for all ij  {i1 , . . . , im1 }, and the second is consistent for at least one
such index.
The advantage of this reformulation of lexicographic incompatibility is that all entailment tests it contains can be reformulated in terms of consistency. This means that incompatibility is in NP. Therefore, compatibility is in coNP. It can also be shown hard for the
same class.
Theorem 7 The problem of checking the existence of a total preorder generating a revision
sequence using lexicographic revision is coNP-complete.
305

fiLiberatore

P


P

Figure 5: Reinforcement revision

7. Reinforcement Revision
Reinforcement revision (Jin & Thielscher, 2007) takes as input not only a total preorder
to revise C and a revising formula P , but also a parameter m that encodes the degree of
belief in P (more precisely, m is the degree of disbelief in P ). For the sake of simplicity,
the restriction to the the case m = 1 is analyzed.
Definition 10 The reinforcement revision of the total preorder C by formula P and parameter m = 1 is the following total preorder CP , where i is the minimal index such that
C(i)  Mod(P ) 6= .
(

CP (j) =

C(i)  Mod(P )
if j = 0
C(j  1)\Mod(P )  C(j + i)  Mod(P ) if j > 0

The general definition has j  m instead of j  1; in this article, m is always 1. The two
cases can be merged into the single one CP (j) = C(j  1)\Mod(P )  C(j + i)  Mod(P ) for
all j  0 by assuming that C(1) = . For example, CP (0) = C(1)\Mod(P )  C(i) 
Mod(P ) = C(i)  Mod(P ), while CP (1) = C(0)\Mod(P )  C(i + 1)  Mod(P ).
A graphical example of a revision is in Figure 5.
The behavior of this revision is shown on the preorder and formulae of Example 3.
Example 10 Revising the preorder C = [C(0), C(1)] where C(0) = Mod(a) and C(1) =
Mod(a) by P1 = b using reinforcement revision has the effect of increasing the class of
every model of P1 by one; the models of P1 do not decrease of class since some of them
are already in class zero, which means that i = 0 in the definition of CP .
CP1 (0) = Mod(a  b)
CP1 (1) = Mod((a  b)  (a  b))
CP1 (2) = Mod(a  b)

306

fiRevision by History

The same happens when revising by P2 = c: every class is the union of the original class
conjoined with c and of the previous class conjoined with c:
CP1 P2 (0) = Mod(a  b  c)
CP1 P2 (1) = Mod((a  b  c)  (a  b  c)  (a  b  c))
CP1 P2 (2) = Mod((a  b  c)  (a  b  c)  (a  b  c))
CP1 P2 (3) = Mod(a  b  c)
The minimal class containing models of P3 = a is CP1 P2 (1). Therefore, models of a
are decreased of one class. Models of P3 = a are increased of one class, as usual:
CP1 P2 P3 (0) = Mod((a  b  c))
CP1 P2 P3 (1) = Mod((a  b  c)  (a  b  c)  (a  b  c))
CP1 P2 P3 (2) = Mod((a  b  c)  (a  b  c)  (a  b  c))
CP1 P2 P3 (3) = Mod(a  b  c)
As a result, K3 = a  b  c.
As for the other revision semantics, every Ki is assumed consistent; the case of inconsistent Ki is degenerated, as no preorder produces such a knowledge base.
Given a fixed revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] generated by reinforcement revision from the initial total preorder C, the lowest class index of the models of Pi in the
ordering CP1 ,...,Pi is denoted DC (i). Formally:
DC (i) = min{j | CP1 ,...,Pi1 (j)  Mod(Pi ) 6= }
Revising by Pi shifts down all models of Pi of DC (i) classes and raises all other models
of one class. As a result, DC (1), . . . , DC (n) tell how a model is moved up or down at every
step, allowing to determine how a model is moved between step i and step j.
Definition 11 The movement of I from i to j according to DC in the revision sequence
[K0 , P1 , K1 , . . . , Pn , Kn ] is MDC (I, i, j) where:
 MDC (I, i, i) = 0;
 MDC (I, i, i + 1) = DC (i + 1) if I |= Pi+1 and MDC (I, i, i + 1) = 1 otherwise;
 if j > i then MDC (I, i, j) =

P

l=i,...,j1 MDC (I, l, l

+ 1);

 if j < i then MDC (I, i, j) = MDC (I, j, i).
Since DC (i) is the minimal class of models of Pi at step i  1 according to an initial preorder, MDC (I, i, j) is the change of classes between i and j when using the same
preorder. The initial preorder C affects the definition of MDC (I, i, j) only indirectly, via
the sequence DC = [DC (1), . . . , DC (n)]. As a result, MV (I, i, j) can be defined from an
arbitrary sequence of n numbers V = [V (1), . . . , V (n)].
307

fiLiberatore

Lemma 15 For every sequence of n numbers V = [V (1), . . . , V (n)], it holds MV (I, i, j) =
MV (I, i, h) + MV (I, h, j) for every three indexes i, j and h.
This lemma holds even if h is not between i and j.
Since MDC (I, i, j) has been defined so that it is the change of class of model I from step
i to step j, in the particular case where I |= Ki it is the class of I at step j, since that at
step i is zero.
Lemma 16 If a revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] is generated by reinforcement revision from the total preorder C and DC = [DC (1), . . . , DC (n)] with DC (i) =
min{j | CP1 ,...,Pi1 (j)  Mod(Pi ) 6= } and I |= Ki then, for every j:
 MDC (I, i, j) = 0 if I |= Kj ;
 MDC (I, i, j) > 0 otherwise.
This lemma can be reversed, in the sense that a sequence of values having this property
allows to determine a preorder generating the sequence.
Definition 12 A sequence of nonnegative integer values V = [V (1), . . . , V (n)] is a reinforcement mover of the revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] if, for every i and j, if
I |= Ki then:
 MV (I, i, j) = 0 if I |= Kj ;
 MV (I, i, j) > 0 otherwise.
The previous lemma can therefore be recast as: if a sequence is generated by reinforcement revision from the total preorder C, then it has a reinforcement mover: DC . The
converse also holds: from a reinforcement mover one can determine a total preorder generating the revision sequence.
Lemma 17 If V = [V (1), . . . , V (n)] is a reinforcement mover for the revision sequence
[K0 , P1 , K1 , . . . , Pn , Kn ], the following initial preorder C = [C(0), . . . , C(V (1) +    + V (n +
1))] generates the revision sequence by reinforcement revision and DC = V .
(

C(j) =

{I | I |= Ki and MV (I, i, 0) = j} if j < V (1) + . . . + V (n) + 1
{I | i . I 6|= Ki }
if j = V (1) + . . . + V (n) + 1

In contrast to the condition of compatibility for the other revision semantics, this one
does not explicitly require Ki |= Pi . It is however implied: if I 6|= Pi then MV (I, i  1, i) = 1
by the definition of movement (Definition 11) and if I |= Ki then MV (I, i, j)  0 for every j
by definition of reinforcement mover (Definition 12). But in the particular case of j = i  1
this is MV (I, i, j) = MV (I, i, i  1) = MV (I, i  1, i) = 1, which is not greater than or
equal to zero. Therefore, no reinforcement mover exists if Ki 6|= Pi .
This lemma allows checking the existence of a preorder generating the sequence by
guessing V (1), . . . , V (n) and then checking the class of every model I that satisfies at least
a Ki . However, membership to the polynomial hierarchy follows only if all such values V (i)
are representable in polynomial space, which is only possible if their values are bounded by
some exponential in the size of the sequence.
308

fiRevision by History

Lemma 18 If reinforcement revision generates a revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ]
from some total preorder, then it also generates the same sequence from a preorder in which
the minimal initial class of models of P1 is 0 or 1.
This lemma proves that if a sequence is generated by some preorder is also generated by
a preorder C such that DC (1) is either 0 or 1. In particular, if K0  P1 is consistent then
DC (1) = 0, otherwise DC (1) = 1. This is the base case of a recursive proof giving a bound
on the size of the other DC (i). Intuitively, this is done by lowering all models of Pi of the
same number of classes in the initial preorder; after revising by Pi they will moved together
so that their minimal ones are in class zero, resulting in the same ordering as obtained from
the original one. This lowering cannot however be so large that some of these models enter
class zero at a previous step j if they do not satisfy Kj .
Lemma 19 If reinforcement revision generates the sequence [K0 , P1 , K1 , . . . , Pn , Kn ] from
a total preorder, it is also generates the same sequence from a total preorder C such that
DC (i + 1)  DC (1) + . . . + DC (i) + i + 1.
This lemma can be seen as the inductive part of a proof, where the previous one was
the base case. They lead to the following conclusion.
Lemma 20 Reinforcement revision generates the revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ]
from a total preorder if and only if it generates the same sequence from a total preorder such
that each DC (i) is bounded by 2i  1.
The values of DC (1), . . . , DC (n) are bounded by an exponential in the value of n, which
is also a lower bound on the size of the sequence [K0 , P1 , . . . , Pn , Kn ]. Therefore, each DC (i)
can be represented in space polynomial in the size of the sequence.
Theorem 8 Establishing the existence of a total preorder generating the revision sequence
[K0 , P1 , . . . , Pn , Kn ] by reinforcement revision is in p2 , and is in coNP if n is a constant.
For the case of constant-length sequences, hardness is easy to prove.
Theorem 9 Checking the existence of a preorder generating a reinforcement revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] is coNP-complete, if n is a constant.

8. Conclusions
Belief revision employs plausibility orders to revise a knowledge base, but how to obtain
such orders has largely been neglected. The solution proposed and studied in this article
is to assume knowledge of previous revisions, reversing them to obtain the initial order,
which can be then used in further revisions. This method is similar to deriving the order
from hypothetical revisions like K  P |= Q, K  R |= T , etc., which assumes knowledge of
what would happen if the revising formula is P , if it is R, etc. In the approach considered
in this article the results of iteratively incorporating a series of new formulae are given, like
in nested counterfactuals (Eiter & Gottlob, 1996). Booth and Nittka (2008) considered the
problem of deriving facts holding at some time points from partial information expressed
309

fiLiberatore

in terms of positive and negative conditions (i.e., some formulae hold and some others
do not hold at certain time points), and this is done by constructing an initial ordering.
Their study focuses on lexicographic revision only, but allows for partial knowledge of both
revisions and results, and includes the choice of an initial ordering among the possible ones.
Rather than entailment information like K P R |= Q, in this article the history of revisions
and resulting knowledge bases is assumed fully known. These could be the actual results of
manually performed changes, and may already be available.
The analysis has shown simple equivalent conditions to the existence of an ordering generating a given series of revisions and results for natural (Boutilier, 1996), restrained (Booth
& Meyer, 2006), lexicographic (Spohn, 1988; Nayak, 1994) and reinforcement revisions (Jin
& Thielscher, 2007). The conditions allow to construct such an initial ordering if one exists.
Using these equivalent conditions, the complexity of establishing the existence of orderings generating a sequence has been established for the considered semantics. Surprisingly,
they turned out to be relatively simple: coNP complete in all cases but one (reinforcement
revision with unbounded sequence length). This is the same as checking propositional entailment, which means that checking generability does not increase complexity over that of
the base language of propositional logic.
As shown in Section 5, the same revision sequence may be generated by more than one
ordering. This leads to the question of whether one of them may be considered the most
natural for the sequence. If for example I is less than J in an ordering but not in another,
the second may be seen as more cautious, and in the end more rational: the sequence can
be generated without assuming that I represents a more plausible world than J, so there
is no reason to draw such a conclusion. The question of whether a single least informative
ordering exists for every sequence, in each of the considered revision semantics, is an open
problem.
Still open is the comparison of generable sequences in the various revisions: as shown
by the running example, a sequence that is generated by natural revision is generated by
no ordering with the restrained and lexicographic revision. Is there any sequence with the
opposite property? If not, natural revision may be seen as more suited at explaining why a
revision sequence has been generated. On the other hand, it may also give less information
about the initial ordering used to generate them; this is the case if the orderings generating
the same sequence are more numerous than in the other semantics.
The four semantics for iterated belief revisions are not the only ones defined in the literature (Williams, 1994; Darwiche & Pearl, 1997; Areces & Becher, 2001; Benferhat et al.,
2004; Konieczny & Pino Perez, 2000; Zhang, 2004); a recent survey counted at least twenty
seven revision-related operators (Rott, 2009). Natural and lexicographic semantics are regarded as extreme forms of revision satisfying the Darwiche-Pearl postulates (Darwiche &
Pearl, 1997), where minimal and maximal hearing is respectively given to the new information. Restrained and reinforcement revision can be considered to be in the middle, as they
also obey some other conditions (Booth & Meyer, 2006; Jin & Thielscher, 2007). The four
considered semantics therefore constitute a reasonable spectrum of possibilities, but others
exist.
Some require additional information (like the strength of every revision, Spohn, 1988;
Williams, 1994; Benferhat et al., 2004), others are families of revisions rather than single
ones (Darwiche & Pearl, 1997; Zhang, 2004). These, in particular, open an interesting
310

fiRevision by History

line of research: whether a revision sequence can be generated by some ordering and some
revision semantics satisfying a given set of conditions, like the Darwiche and Pearl (1997)
postulates. In other words, both the ordering and the semantics are the solution of the
problem, while the given is only the revision sequence.
The assumption of reliability strictly increasing with time also gives other directions to
study. Indeed, this principle has been realized as not true in general (Peppas, 2008) and
iterated revision recognized as a form of prioritized merging (Delgrande, Dubois, & Lang,
2006). In this perspective, giving preference to the last formula is just a particular case.
It is a case of interest, yet searching for the initial plausibility order is also possible in the
general case.
Yet another open problem is how to combine the approach in this article with results
about how people actually perform revision. Indeed, it has been experimentally proved
that human revision suffers from a number of biases (Tversky & Kahneman, 1983; See,
Morrison, Rothman, & Soll, 2011; Wang, Zhang, & Johnson, 2000), such as the anchoring
or order effect, the excessive preference of knowledge acquired early. These studies show
that revision performed by people is not fully rational, contrary to what belief revision
formal semantics attempt to be. Such psychological, extra-logical biases should be kept
into account when working on sequences of manually-performed revisions.
8.1 Acknowledgements
The author thanks the anonymous referees for their useful suggestions on the previous
versions of this article.

Appendix A. Proofs
The following sections contain the proofs of all lemmas and theorems in the article.
A.1 Preliminaries: Proofs
Lemma 1 If F is consistent and F |= maxset(P1 , . . . , Pn ), then maxset(P1 , . . . , Pn ) 
{Pi | 1  i  n and F |= Pi }.
Proof. Since F |= maxset(P1 , . . . , Pn ) then F implies every Pi that is in the maxset.
The only possibility for the claim not to hold is that F also implies some Pi not in the
maxset. Since every element of maxset(P1 , . . . , Pn ) is implied by F , also every element
of prefixi (maxset(P1 , . . . , Pn )) is. Since F also entails Pi , every model of F satisfies both
prefixi (maxset(P1 , . . . , Pn )) and Pi . The consistency of Pi  prefixi (maxset(P1 , . . . , Pn ))
contradicts the assumption that Pi is not in the maxset.
Lemma 2 If F is consistent and F |= maxset(P1 , . . . , Pn ), every consistent subset of
{P1 , . . . , Pn } that contains all formulae entailed by F is equivalent to maxset(P1 , . . . , Pn ).
Proof. By Lemma 1, since F is consistent and F |= maxset(P1 , . . . , Pn ) then
maxset(P1 , . . . , Pn )  {Pi | 1  i  n and F |= Pi }. This proves that maxset(P1 , . . . , Pn )
contains all formulae entailed by F .
Let R be a consistent proper superset of
311

fiLiberatore

maxset(P1 , . . . , Pn ). Let Pi be the lowest-index formula that is in R but not in
maxset(P1 , . . . , Pn ). Since this is the lowest index, R and maxset(P1 , . . . , Pn ) have the
same formulae among {P1 , . . . , Pi1 }. Since R is consistent, its intersection with this set
is consistent as well. Since R also contains Pi , it follows that prefixi (P1 , . . . , Pn )  {Pi } is
consistent, contradicting the assumption that Pi is not in maxset(P1 , . . . , Pn ).
Lemma 3 If F is consistent then F 6|= maxset(P1 , . . . , Pn ) if and only if there exists a
subsequence R of [P1 , . . . , Pn ] such that:
1. R is consistent;
2. if F |= Pi then Pi  R;
3. for some i, Pi 6 R and Pi  prefixi (R) is consistent.
Proof. Two cases are considered: first, F entails the maxset; second, F does not. In the
first, no such R is proved to exists; in the second, one such R is shown.
If F |= maxset(P1 , . . . , Pn ), then F implies all elements of the maxset. As a result,
the second condition can only be true if R contains all formulae in the maxset. If R also
contains some formulae not in the maxset, since a formula not in the maxset is inconsistent
with the maxset, then R is inconsistent. As a result, R can be consistent only if it coincides
with the maxset. This contradicts the third point, showing that for every R, if the first and
the second conditions are true the third is false.
If F 6|= maxset(P1 , . . . , Pn ), the three conditions are satisfied by R containing precisely
the formulae Pi entailed by F . This choice meets the first condition because F is consistent
and the second by construction. The third condition is now proved to hold as well.
Since F does not entail the maxset then F does not entail some formulae in the maxset.
Let i be the least index of a formula in maxset(P1 , . . . , Pn ) that is not entailed by F . By
construction, every formula Pj in the maxset is in R if j < i. It can be shown that the
converse also holds. To the contrary, let j < i be the lowest index of a formula in R that is
not in the maxset.
The assumptions that i and j are the least indexes on which R and the maxset differ (in
a way or the other) imply prefixj (R) = prefixj (maxset(P1 , . . . , Pn )). Since by assumption
Pj is not in the maxset, it is inconsistent with prefixj (maxset(P1 , . . . , Pn )). As a result, it is
also inconsistent with prefixj (R). Since Pj  R, that implies the inconsistency of R, which
was proved consistent.
This contradiction proves that R and the maxset are not only equal up to some index
j < i, but up to i. In other words, prefixi (R) = prefixi (maxset(P1 , . . . , Pn )).
By assumption Pi is a formula in the maxset that is not in R. Being in the maxset
means that Pi  prefixi (maxset(P1 , . . . , Pn )) is consistent. As it has just been proved, the
latter is equivalent to Pi  prefixi (R). This concludes the proof of the third condition.
Theorem 1 If F is consistent, checking F  maxset(P1 , . . . , Pn ) is in coNP.
Proof. F  maxset(P1 , . . . , Pn ) holds if F |= maxset(P1 , . . . , Pn ) and maxset(P1 , . . . , Pn ) |=
F . If the first condition is true, by Lemma 1 the maxset comprises exactly the formulae
312

fiRevision by History

entailed by F . Therefore, the converse maxset(P1 , . . . , Pn ) 6|= F can only happen if there
exists a model I satisfying all formulae Pi entailed by F but not F itself. In other words:
F  maxset(P1 , . . . , Pn )
iff F |= maxset(P1 , . . . , Pn ) and maxset(P1 , . . . , Pn ) |= F
iff F |= maxset(P1 , . . . , Pn ) and (I . I 6|= F and i(F |= Pi  I |= Pi ))
iff F |= maxset(P1 , . . . , Pn ) and (I . I 6|= F and i(F 6|= Pi or I |= Pi ))
iff F |= maxset(P1 , . . . , Pn ) and I . I |= F or i(F |= Pi and I 6|= Pi ))

Lemma 3 reformulates the converse of the first condition F |= maxset(P1 , . . . , Pn ) using
only existential quantifiers (the second point is equivalent to either F 6|= Pi or Pi  R).
As a result, the first condition can be expressed using only universal quantifiers. The only
existential quantifier in the second condition is that over i, which can be replaced by a
disjunction. Since all quantifiers are universal, the problem is in coNP.
A.2 Natural Revision: Proofs
Lemma 4 If CP (0)  Mod(F ) =  then CP compares the models of F as C does, where CP
is the natural revision of the total preorder C with formula P .
Proof. Let I and J be two models of F , m and l their classes. Since these are models of F and
CP (0)  Mod(F ) = , they do not belong to CP (0). As a result, CP (m + 1) = C(m)\CP (0)
contains I and CP (l + 1) = C(l)\CP (0) contains J. This proves that revising C by F
increases the classes of I and J by one each. Therefore, I is greater or equal than J
according to CP if and only if it is according to C.
Lemma 5 Let [Kj , Pj+1 , . . . , Pi , Ki ] be a revision sequence generated by natural revision
from a total preorder C. If Kj  Pi is consistent while none of Kj+1  Pi , . . . , Ki1  Pi is,
then CPj+1 ,...,Pi (0) = Mod(Kj  Pi ).
Proof. By Lemma 4, CPj+1 ,...,Pi1 compares models of Pi in the same way C does. As a
result, Mod(Ki ) are the minimal models of Pi in C. Since C(0) = Mod(Kj ) and Kj  Pi is
consistent, these minimal models are C(0)  Mod(Pi ) = Mod(Kj  Pi ).
Lemma 6 If the revision sequence [K0 , P1 , K1 , . . . , Pi , Ki ] is generated by natural revision
from the total preorder C and Pi is inconsistent with each of K0 , . . . , Ki1 , then the models
of Ki are the minimal models of Pi according to C.
Proof. By Lemma 4, revising C by P1 , . . . , Pi1 does not affect the order between the
models of Pi . As a result, the minimal models of Pi according to CP1 ,...,Pi1 are the minimal
models of Pi according to C.
313

fiLiberatore

Theorem 2 If [K0 , P1 , K1 , . . . , Pn , Kn ] is natural-compatible then it is generated by natural
revision from the initial preorder C = [C(0), . . . , C(n + 1)].


 Mod(Ki )

C(i) =

if i  n and l < i . Kl  Pi |= 
otherwise, if i  n

 S{Mod(K ) | l < j . K  P 6|= } if i = n + 1
j
j
l


Proof. Since no formula has index lower than zero, C(0) is equal to Mod(K0 ) and is therefore
not empty. The classes of C contain all models because C(n + 1) comprises every model
not in C(0), . . . , C(n). To prove that C is a total preorder, it is to be proved that the sets
C(i) are disjoint. A model is in C(i) with i  n only if it is in Mod(Ki ). Therefore, it is
also a model of Pi . Since Pi is inconsistent with each of K0 , . . . , Ki1 , the model is not in
any of C(0), . . . , C(i  1). The class C(n + 1) contains exactly the models that are not in
C(0)      C(n). This proves that C is a total preorder.
The formulae Ki are generated in different ways depending on whether Kj  Pi is consistent for some j < i:
 if such an index j exists, then by the assumption of natural compatibility Ki  Kj Pi
for the maximal such j; by Lemma 5, this is exactly the result of revising C by
P1 , . . . , Pi .
 otherwise, Pi is inconsistent with each of K0 , . . . , Ki1 ; by Lemma 6, Mod(Ki )
are the minimal models of Pi in the initial preorder C. Since Pi is inconsistent with K0 , . . . , Ki1 , then: first, since C(0), . . . , C(i  1) are subsets of
Mod(K0 ), . . . , Mod(Ki1 ), these classes do not contain models of Pi ; second, C(i)
is not empty but equal to Mod(Ki ). As a result, the minimal models of Pi are exactly
Mod(Ki ).

Theorem 3 A revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] is generated by natural revision
from some initial total preorder if and only if it is natural-compatible.
Proof. The previous theorem shows that every natural-compatible sequence is generated
by natural revision from some total preorder. The converse is now proved: if a sequence is
not natural-compatible then it is not generated by natural revision from any preorder.
Since Mod(Ki ) = CP1 ,...,Pi1 ,Pi (0) = CP1 ,...,Pi1 (l)  Mod(Pi ) for some l, it holds
Mod(Ki )  Mod(Pi ), which is the same as Ki |= Pi . Therefore, if Ki 6|= Pi no preorder can
generate the revision sequence. Otherwise, natural-compatibility is violated if, for some j
and i:
1. Kj  Pi is consistent;
2. formulae Kj+1  Pi , . . . , Ki1  Pi are inconsistent;
3. Kj  Pi is not equivalent to Ki .
314

fiRevision by History

By Lemma 5, the first two points imply that revising Cj by Pj+1 , . . . , Pi generates a
formula equivalent to Kj  Pi , contradicting the third point. This proves that a revision
sequence that is not natural-compatible is not generated by natural revision from any preorder.
Lemma 7 Checking the existence of a total preorder C generating a revision sequence
[K0 , P1 , K1 , . . . , Pn , Kn ] using natural revision is in coNP.
Proof. According to Theorem 3, such a preorder C exists if and only if, for every i 
{1, . . . , n}, it holds that Ki |= Pi and, if j is the maximal index such that j < i and Kj  Pi
is consistent (if any), then Ki  Kj  Pi . The first part, Ki |= Pi for all i, can be verified
by a linear number of independent unsatisfiability tests.
The second part can be rewritten as: if Kj  Pi is consistent and Kh  Pi is inconsistent
for every h between j and i, then Ki  Kj  Pi . Rewriting implication as disjunction, for
every j = 0, . . . , i  1:
1. either K0 Pi is inconsistent or Kh Pi is consistent for some 0 < h < i or Ki  K0 Pi ;
and
2. either K1 Pi is inconsistent or Kh Pi is consistent for some 1 < h < i, or Ki  K1 Pi ;
and
3. . . . ;
4. either Ki1  Pi is inconsistent or Ki  K0  Pi .
These are the conditions for index i. They have to hold for every i  {1, . . . , n}. Since
the formulae Ki are consistent, the conditions can be simplified: if Kj Pi is consistent, then
either Kh  Pi is consistent for j < h < i or Ki  Kj  Pi ; in the latter case, Ki  Kh  Pi
for one such index h (the last). Therefore, the condition can be recast as:
Kj  Pi |=  or Ki  Kj+1  Pi or . . . Ki  Ki1  Pi or Ki  Kj  Pi
This condition can be checked with a number of independent unsatisfiability tests, and
is therefore in coNP.
Theorem 4 The problem of establishing the existence of a preorder generating a revision
sequence using natural revision is coNP complete.
Proof. Membership is proved in the previous lemma. Hardness is proved by reduction from
the problem of checking whether a formula G is unsatisfiable. The instance is [K0 , P1 , K2 ]
with K0 = a, K1 = P1 = a  G, where a is a new variable, not in G. If G is satisfiable,
then K0  P1 is consistent; therefore, it should be equivalent to K1 . Instead, it is a  G. If
G is unsatisfiable, then K1 = P1 = a is inconsistent with K0 . By Theorem 3, a preorder
generating the sequence using natural revision exists.

315

fiLiberatore

A.3 Restrained Revision: Proofs
Lemma 8 Let [Kj , Pj+1 , . . . , Pi , Ki ] be a revision sequence generated by restrained revision
from the initial total preorder C. If Kj  Pi is consistent while none of Kj+1  Pi , . . . ,
Ki1  Pi is, then CPj+1 ,...,Pi (0) = Mod(maxset(Kj  Pi , Pj+1 , . . . , Pi1 )).
Proof. Proof is by induction on i  j. When j = i + 1 the claim CPi (0) = Mod(maxset(Kj 
Pi )) holds because Kj  Pi is consistent by assumption.
The inductive claim is that CPj+1 ,...,Pi2 ,Pi1 ,Pi (0)
=
Mod(maxset(Kj 
Pi , Pj+1 , . . . , Pi2 , Pi1 )), the inductive assumption is the same without Pi1 :
CPj+1 ,...,Pi2 ,Pi (0) = Mod(maxset(Kj  Pi , Pj+1 , . . . , Pi2 ))
By definition, CPj+1 ,...,Pi2 ,Pi (0) is CPj+1 ,...,Pi2 (k)  Mod(Pi ) where k is the minimal
integer making this intersection non-empty. As a result, CPj+1 ,...,Pi2 (l)  Mod(Pi ) =  for
all indexes l such that 0  l < k. Revising the preorder by Pi1 changes the classes of:
 the models of Ki1 , which become class zero;
 the models of the same class, which are split according to whether they satisfy Pi1 .
Since no model of Ki1 satisfies Pi by assumption, CPj+1 ,...,Pi2 ,Pi1 (0)  Mod(Pi ) = 
holds. None of the classes of CPj+1 ,...,Pi2 of index 0  l < k intersect Mod(Pi ); therefore,
neither do the ones resulting from splitting them. As a result, the minimal-index class
intersecting Mod(Pi ) is one of the two resulting from splitting CPj+1 ,...,Pi2 (k), which are:
CPj+1 ,...,Pi2 (k)  Mod(Pi1 )
CPj+1 ,...,Pi2 (k)\Mod(Pi1 )
If the first intersects Mod(Pi ), this is Mod(Ki ); otherwise, Mod(Ki ) is the second. In
formulae:
(

Mod(Ki ) =

CPj+1 ,...,Pi2 (k)  Mod(Pi1 )  Mod(Pi ) if not empty
(CPj+1 ,...,Pi2 (k)\Mod(Pi1 ))  Mod(Pi ) otherwise

By the properties of set operators, this equation can be rewritten as:
(

Mod(Ki ) =

CPj+1 ,...,Pi2 (k)  Mod(Pi )  Mod(Pi1 ) if not empty
(CPj+1 ,...,Pi2 (k)  Mod(Pi ))\Mod(Pi1 ) otherwise

By the way k was defined, CPj+1 ,...,Pi2 (k)  Mod(Pi ) is equal to CPj+1 ,...,Pi2 ,Pi (0). The
latter is by the inductive assumption Mod(maxset(Kj  Pi , Pj+1 , . . . , Pi2 )). Intersecting
this set with Mod(Pi1 ) if the result is not empty, and subtracting Mod(Pi1 ) otherwise
is the same as adding Pi1 to the end of the sequence, by the definition of maxset of a
sequence. Since Mod(Ki ) = CPj+1 ,...,Pi2 ,Pi1 ,Pi (0), this proves the inductive claim that this
set is equal to Mod(maxset(Kj  Pi , Pj+1 , . . . , Pi2 , Pi1 )).

316

fiRevision by History

Lemma 9 If [K0 , P1 , K1 , . . . , Pn , Kn ] is restrained-compatible then it is generated by restrained revision from the total preorder C = [C(0), . . . , C(n + 1)], where:


 Mod(Ki )

C(i) =

if i  n and l < i . Pi  Kl |= 
otherwise, if i  n

 S{Mod(K ) | l < j P  K 6|= } if i = n + 1
j
j
l


Proof. No formula has index less than zero; therefore, C(0) = Mod(K0 ), which is not empty
because all formulae in the sequences are consistent by assumption. Since C(n + 1) contains
all models not in C(0)      C(n), the union of the classes include all models, and no model
in C(n+1) is also in another classes. In order to prove that C is a partition, it is shown that
no model of C(i) is also in C(l) with l < i  n. If I  C(i) with i  n then I  Mod(Ki )
with Pi  Kl inconsistent for all l < i. Since Ki |= Pi , also Ki  Kl is inconsistent. This
proves that a model I cannot be in C(i) and also in C(l) with l < i.
The previous lemma shows that, regardless of the initial total preorder, if a revision
sequence is generated by restrained revision then Ki  maxset(Kj  Pi , Pj+1 , . . . , Pii ) if
j is the maximal index such that j < i and Kj  Pi is consistent, if any. Since restrained
compatibility ensures that this condition holds, all Ki for which such a j exists are obtained
by revision regardless of C.
Remains to show that C generates Ki even if Pi  Kl is inconsistent for all l < i. The
models of Pi are in C(i) = Mod(Ki ) and classes of greater index. Indeed, if a model of
Pi were in C(l) with l < k then Pi  Kl would be consistent. Revising C by Pl , with
l = 1, . . . , i  1, changes the preorder in two ways:
1. the models of Kl are moved to class zero;
2. all other classes are split according to satisfaction of Pl .
Since Pi  Kl is inconsistent, no model of Pi is moved to class zero. As a result, the
relative position of the models of Pi is only modified by the second change, the splitting of
the classes. This could break the class Mod(Ki ) in two, but not in this case. Indeed, since
either Ki |= Pl or Ki |= Pl , either all models of Ki satisfy Pl or all falsify Pl . In other
words, the change may alter the comparison of two models of Pi , but does not if they are
both in Mod(Ki ).
Two claims are therefore proved: that the models of Pi are in C(i) = Mod(Ki ) and
greater classes; and that after the first i  1 revisions the minimal models of Pi are still
Mod(Ki ). This proves that the result of the i-th revision is Ki .
Theorem 5 A revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] is generated by restrained revision
from some initial total preorder if and only if it is restrained-compatible.
Proof. The previous lemma shows that every restrained-compatible revision sequence is
generated by a certain initial preorder. Remains therefore to prove the converse: if a
revision sequence is not restrained-compatible then it is generated by no initial preorder.
Lemma 8 proves that every sequence generated by restrained revision satisfies the condition that Ki  maxset(Pi  Kj , Pj+1 , . . . , Pi1 ) where j is the maximal j < i such that
317

fiLiberatore

Pi  Kj is consistent. That Ki |= Pi holds is a consequence of Mod(Ki ) being the set of minimal models satisfying Pi . Remains therefore to prove the necessity of the third condition
of restrained compatibility: if Pi is consistent with all Kj with j < k then either Ki |= Pl
or Ki |= Pl for every l < i.
To the contrary, let l < i be such that Ki 6|= Pl and Ki 6|= Pl . These two conditions
imply that Mod(Ki ) contains some models of Pl and some models of Pl . Even if the
models of Ki are in the same class after l  1 revisions, the l-th one separates the ones
satisfying Pl from the ones satisfying Pl . These may end in two consecutive classes, or in
the new class zero and in another class, but either way the models of Ki are placed in two
separate classes. Since constrained revision never merges classes, these models are still in
separate classes after the i  1-th revision. As a result, revising by Pi can only select a part
of Mod(Ki ) and not all of it.
Lemma 10 A revision sequence [K0 , P1 , K1 . . . , Pn , Kn ] is restrained-compatible if and only
if, for every index i:
1. Ki |= Pi ;
2. for every 0  j < i, either Kj  Pi is inconsistent or Ki |= Kl  Pi for some j < l < i
or Ki  maxset(Kj  Pi , Pj+1 , . . . , Pi1 );
3. for every 0  j < i, Ki |= Pj , Ki |= Pj , or Ki |= Kl  Pi for some 0  l < i.
Proof. The three conditions of restrained compatibility can be rewritten as follows, for
every index i.
1. Ki |= Pi ;
2. for every j such that 0  j < i, either Kj  Pi is inconsistent or Kl  Pi is consistent
for some j < l < i or Ki  maxset(Kj  Pi , Pj+1 , . . . , Pi1 );
3. for every j such that 0  j < i, either Ki |= Pj or Ki |= Pj or Kl  Pi is consistent
for some 0  l < i.
Both the second and the third point include Kl  Pi is consistent for some h  l < i:
in the first, h = j + 1; in the second, h = 0. In the particular conditions of the lemma,
these two conditions will be shown to be equivalent:
1. Kl  Pi is satisfiable for some l such that h  l < i;
2. Ki |= Kl  Pi for some l such that h  l < i.
It is proved that: first, if the sequence is restrained-compatible then Condition 1 implies
Condition 2; second, if the three conditions of the lemma are true then Condition 2 implies
Condition 1.
Condition 1 is that Kl  Pi is consistent for some h  l < i. Either l is the maximal
index with this property or some other index between h and i is. Let g be such a maximal
index. By restrained compatibility, Ki  maxset(Kg  Pi , Pi1 , . . . , Pg+1 ). The maxset of a
318

fiRevision by History

sequence implies its first element, if consistent. Since this is the case, Ki |= Kg  Pi . This
means that Condition 2 holds for index g.
Condition 2 is that Ki |= Kh  Pi for some h  l < i. Since Ki is consistent, Kh  Pi is
consistent as well, proving Condition 1 for the same index l.
Theorem 6 Establishing the existence of a total preorder generating a restrained revision
sequence is coNP-complete.
Proof. Membership follows from the previous lemma. Its conditions can be all reformulated
as entailments (like Ki |= Pi ), inconsistencies (like that of Kj  Pi ) and equivalences with
maxsets (Ki  maxset(Kj  Pi , Pj+1 , . . . , Pi1 )). All these problems are in coNP, and can
therefore be rewritten as universal quantified formulae. The whole problem is a combination
of these; by renaming all variables and taking out the quantifiers, a single universally
quantified formula results. Since QBF is in coNP, the problem is in coNP.
Hardness is proved by reduction from the problem of propositional unsatisfiability. Given
a formula F , the associated revision sequence is [a, b  F, a  b], where a and b are fresh
variables, not occurring in F . If F is unsatisfiable then b  F is equivalent to b, and the
sequence [a, b, a  b] is generated by the preorder C = [C(0), C(1)] with C(0) = Mod(a) and
C(1) = Mod(a). If F is satisfiable then a  (b  F ) is satisfiable but is not equivalent to
a  b, which makes the sequence not generated by restrained revision from any preorder.
The sequence is therefore generated by restrained revision from some preorder if and only
if F is unsatisfiable.
A.4 Lexicographic Revision: Proofs
Lemma 11 If a revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] is generated by lexicographic
revision from the total preorder among models C then it has the result preorder R defined
by:
R(i) = {Ki | Mod(Ki )  C(i)}
Proof. R is a total preorder because: first, R(0) is not empty because C(0) = Mod(K0 ),
which implies Mod(K0 )  C(0) and K0  R(0); second, no formula is in two classes of
R because C is a partition. Third, every Ki is in a class of R because of Property 1:
since Mod(Ki ) is a set of minimal models of C, all its models are in the same class C(j);
therefore, Ki  R(j). Remains to prove that this preorder satisfies the two conditions for
being a result preorder for the sequence.
If Ki and Kj are consistent with each other, they have a common model I. Let h be
its class. By construction, since I |= Ki then Ki  R(h). The same holds for Kj , since
I |= Kj . As a result, Kj  R(h).
Let Ki and Kj be such that Ki Kj maxset(Pi , . . . , P1 ) is consistent. By assumption,
the sequence is generated by lexicographic revision from C. As a result, the models of Ki are
exactly the minimal models of maxset(Pi , . . . , P1 ) according to C. Let h be the class of such
models. By construction of R, it holds Ki  R(h). All models of Ki  maxset(Pi , . . . , P1 )
belong to a greater class l > h. Since Ki  Kj  maxset(Pi , . . . , P1 ) is consistent, Kj has
319

fiLiberatore

some models in C(l). Since all models of Kj are in the same class, it follows Mod(Kj )  C(l),
which implies Kj  R(l). Since l > h, the claim is proved.
Lemma 12 If R is a result preorder for a revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] such
that Ki |= maxset(Pi , . . . , P1 ) for every i, then lexicographic revision from the following
total preorder C among models generates the revision sequence, where z is the index of the
greatest class of R:
( S

C(h) =

{Mod(Ki ) | Ki  R(h)} if h  z
{I | I 6 K1      Kn }
if h = z + 1

Proof. C is proved to be a total preorder. First, C(0) is not empty since R(0) is not empty.
Second, no model belongs to more than one class: if I is in both C(h) and C(l) then by
definition there exists Ki  R(h) and Kj  R(l) that are both satisfied by I; this implies
that Ki  Kj is consistent; since R is a result preorder for the sequence, it follows that l = h.
Models of C(z + 1) are exactly the ones not contained in the other classes.
Remains to be proved that lexicographic revision generates the revision sequence from
C: revising C by P1 , . . . , Pi generates Ki . Since Ki |= maxset(Pi , . . . , P1 ) by assumption,
all models of Ki are also models of maxset(Pi , . . . , P1 ). Remains to be proved that they are
the minimal ones: all other models are in greater classes. Let h be the class of the models
of Ki , and I be a model of Ki  maxset(Pi , . . . , P1 ). If I does not satisfy any other Kj
then I  R(z + 1), and z + 1 > h since z is the greatest index of the classes of R. If I
satisfies Kj then it satisfies Ki  Kj  maxset(Pi , . . . , P1 ), which is therefore satisfiable.
Since R is a result preorder for the sequence, Kj is in a class R(l) with l > h. This implies
that I  C(l). This proves that every model of maxset(Pi , . . . , P1 ) that is not in Mod(Ki )
is in a class greater than h.
Lemma 13 A revision sequence is generated by lexicographic revision from some total preorder if and only if it is lexicographic compatible.
Proof. If the revision sequence is generated by some total preorder then Ki |=
maxset(Pi , . . . , P1 ) holds for every i. Furthermore, a result preorder R for it exists by
Lemma 11. From it, define the relations ' and < as: Ki ' Kj if and only if Ki and Kj are
in the same class R(h); Ki < Kj if Ki  R(h), Kj  R(l) and h < l. Since R is a revision
preorder for the sequence, if Ki  Kj is consistent then Ki and Kj are in the same class,
which implies Ki ' Kj . In the same way, if Ki  Kj  maxset(Pi , . . . , P1 ) is consistent
then Ki is in a lower class than Kj , implying Ki < Kj . A cycle containing < is impossible
because Ki < Kj means that the class of Ki is lower than the class of Kj .
This does not prove lexicographic compatibility, which requires Ki ' Kj and Ki < Kj to
be respectively equivalent to the consistency of Ki  Kj and Ki  Ki  maxset(Pi , . . . , P1 ),
not merely implied by them. However, by removing from these relations all pairs Ki and
Kj not satisfying the respective condition makes these relations weaker. Therefore, no new
cycle is created.
To prove the other direction, assume that Ki |= maxset(Pi , . . . , P1 ) for every i and
that ' and < are two relations defined from the sequence as specified in the definition
320

fiRevision by History

of lexicographic compatibility. A result preorder for the sequence is shown. Together with
Ki |= maxset(Pi , . . . , P1 ), this implies that the revision sequence is generated by some initial
preorder by Lemma 12.
From ' and <, a relation  is defined: Ki  Kj if either Ki ' Kj or Ki < Kj . This
relation is not necessarily transitive, but has a number of other properties:
1. if Ki ' Kj then Ki  Kj and Kj  Ki ; indeed, Ki ' Kj holds only if Ki  Kj is
consistent, which implies that Kj  Ki is consistent; therefore, Kj ' Ki , which implies
Kj  Ki ;
2. if Ki < Kj then Ki  Kj and Kj 6 Ki ; to the converse, if Kj  Ki , then either
Kj ' Ki or Kj < Ki ; in both cases, this is a cycle of ' and < containing one < link,
which contradicts the assumption that no such cycle exists;
3.  is reflexive; indeed, all formulae Ki are consistent by assumption; therefore, Ki  Ki
is consistent, which implies Ki ' Ki and Ki  Ki ;
4.  is Suzumura consistent (Suzumura, 1976): it does not form cycles Ki1 , . . . , Kim =
Ki1 such that Kij  Kij+1 for all j and for some j also Kij+1 6 Kij ; this is proved
below.
Properties 1 and 2 mean that ' and < are the equivalence and strict part of , respectively. Indeed, Ki  Kj holds only if either Ki ' Kj or Ki < Kj ; the former implies
Kj  Ki , the latter Kj 6 Ki . Property 4 is a consequence of this fact and of the assumption
of nonexistence of cycles of ' and < containing at least one link <.
Since  is reflexive (Property 3) and Suzumura consistent (Property 4), by the Suzumura
extension theorem (Suzumura, 1976) a total preorder R extending  exists. Extending
means that both the equivalence and strict parts of  are preserved in R. Since these have
been proved to be ' and <, the total preorder R has Ki and Kj in the same class if Ki ' Kj
and Ki in a lower class if Ki < Kj .
If Ki  Kj is consistent then Ki ' Kj , which implies that Ki and Kj are in the same
class of R. If Ki  Kj  maxset(Pi , . . . , P1 ) is consistent then Ki < Kj , which implies that
the class of Ki in R is less than the class of Kj . This proves that R is a result preorder for
the revision sequence.
Lemma 14 A revision sequence [K0 , P1 , K1 . . . , Pn , Kn ] is not lexicographic compatible if
and only if either Ki 6|= maxset(Pi , . . . , P1 ) for some i or consistent sets R1 , . . . , Rn exist
such that:
1. {Pj | 1  j  i and Ki |= Pj }  Ri for every i; and
2. there exists a cycle Ki1 , . . . , Kim = Ki1 such that either Kij Kij+1 or Kij Kij+1 Ri
is consistent for all ij  {i1 , . . . , im1 }, and the second is consistent for at least one
such index.
Proof.
A revision sequence is lexicographic compatible if and only if Ki |=
maxset(Pi , . . . , P1 ) for all i and there is no cycle as specified by the definition. Inverting
321

fiLiberatore

this condition, a sequence is not lexicographic compatible if either Ki 6|= maxset(Pi , . . . , P1 )
or a cycle exists. As a result, one can check whether Ki 6|= maxset(Pi , . . . , P1 ) for some i; if
this is true, no further check is needed: the sequence is not lexicographic compatible. The
presence of cycles is irrelevant in this case. The other case is that Ki |= maxset(Pi , . . . , P1 )
for all i, and then the sequence is not lexicographic compatible if and only if it contains
cycles.
The point is that the condition for the presence of cycles can be written under the
assumption that Ki |= maxset(Pi , . . . , P1 ), since this is the only case where this condition
matters. By Lemma 2, the only consistent subset of {P1 , . . . , Pi } containing all formulae entailed by Ki is maxset(Pi , . . . , P1 ). This means that Ri can be used in place of
maxset(Pi , . . . , P1 ), since the only Ri satisfying the first condition in the statement of the
lemma is maxset(Pi , . . . , P1 ).
Theorem 7 The problem of checking the existence of a total preorder generating a revision
sequence using lexicographic revision is coNP-complete.
Proof. Membership follows from the previous lemma: the sequence is not generated by
lexicographic revision from any preorder if and only if it is not lexicographic compatible,
which in turns can be checked by existential quantifiers only:
1. Ki 6|= maxset(Pi , . . . , P1 );
2. there exists Ri ;
3. Ri is consistent;
4. either Ki 6|= Pj or Pj  Ri ;
5. there exists a cycle Ki1 , . . . , Kim = Ki1 ;
6. Kij  Kij+1 is consistent;
7. Kij  Kij+1  Ri is consistent.
The first condition can be expressed in terms of existential quantifiers only as shown by
Lemma 3. The same holds for the other conditions as well. As a result, incompatibility is
in NP, which means that the existence of preorder generating the sequence is in coNP.
Hardness is proved by reduction from propositional unsatisfiability. A formula F is
satisfiable if and only if [K0 , P1 , K1 ] is generated by no preorder, where K0 = a, P1 = a and
K1 = a  F and a is a new variable not contained in F . Indeed, if F is unsatisfiable, then
K1 = a, and the sequence is generated by the preorder C = [C(0), C(1)] with C(0) = Mod(a)
and C(1) = Mod(a). If F is satisfiable, then K1 has some models that do not satisfy P1 :
the ones of F . As a result, K1 6|= P1 , and the sequence is not generated by any preorder.

322

fiRevision by History

A.5 Reinforcement Revision: Proofs
Lemma 15 For every sequence of n numbers V = [V (1), . . . , V (n)], it holds MV (I, i, j) =
MV (I, i, h) + MV (I, h, j) for every three indexes i, j and h.
Proof. If i < j then MV (I, i, j) is the sum of MV (I, l, l+1) for i < l  j. Otherwise, it is the
sum of MV (I, l, l + 1) = MV (I, l + 1, l). Also MV (I, i, h) and MV (I, h, j) can be expressed
in the same way. If h is between i and j the result follows immediately. Otherwise, if i < j
and h > j then MV (I, i, h) includes MV (I, l, l + 1) for l > j, but then MV (I, h, j) includes
MV (I, l + 1, l) = MV (I, l, l + 1), which subtracts the same amount from the sum. The
case h < i is similar.
Lemma 16 If a revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] is generated by reinforcement revision from the total preorder C and DC = [DC (1), . . . , DC (n)] with DC (i) =
min{j | CP1 ,...,Pi1 (j)  Mod(Pi ) 6= } and I |= Ki then, for every j:
 MDC (I, i, j) = 0 if I |= Kj ;
 MDC (I, i, j) > 0 otherwise.
Proof. If a model I is in CP1 ...Pi1 (c) then it is in CP1 ...Pi (c  DC (i)) if I |= Pi and in
CP1 ...Pi1 (c + 1) otherwise. As a result, MDC (I, i, i + 1) is the difference between the class
of I in the preorder at step i + 1 and the preorder at step i. Since MDC (I, i, j) is the sum
of these amounts from index i to index j, it is the difference between the class of I at step
j and i. If I |= Ki then its class at step i is zero. As a result, MDC (I, i, j) is the class of I
at step j. This is zero if I |= Kj and greater otherwise.
Lemma 17 If V = [V (1), . . . , V (n)] is a reinforcement mover for the revision sequence
[K0 , P1 , K1 , . . . , Pn , Kn ], the following initial preorder C = [C(0), . . . , C(V (1) +    + V (n +
1))] generates the revision sequence by reinforcement revision and DC = V .
(

C(j) =

{I | I |= Ki and MV (I, i, 0) = j} if j < V (1) + . . . + V (n) + 1
{I | i . I 6|= Ki }
if j = V (1) + . . . + V (n) + 1

Proof. Since K0 is consistent, it has at least a model I. Since I |= K0 and MV (I, 0, 0) = 0
by definition, it follows I  C(0), proving that C(0) is not empty. Every model is in some
class because if I |= Ki then I is in C(MV (I, i, 0)), otherwise it is in C(V (1) + . . . + V (n) +
1). To prove that C is a total preorder, remains to prove that no model belongs to two
classes. If I |= Ki and I |= Kj then MV (I, j, i) = 0 because V is a reinforcement mover;
therefore, MV (I, i, 0) = 0 + MV (I, i, 0) = MV (I, j, i) + MV (I, i, 0) = MV (I, j, 0). A model
of C(V (1) + . . . + V (n) + 1) does not satisfy any Ki ; therefore, it cannot be in any other
class C(j). This proves that C is a total preorder.
The longest part of the proof is to show that reinforcement revision generates the
sequence from C. Inductively, it is assumed that DC (1) = V (1), DC (2) = V (2), . . . ,
DC (i) = V (i), where DC (l) = min{j | CP1 ,...,Pl1 (j)  Mod(Pl ) 6= }. It is then proved that
323

fiLiberatore

all models of Ki are in CP1 ,...,Pi (0) and all other models are in classes of greater index of
the same total preorder. Furthermore, the minimal class of models of Pi+1 in that preorder
is V (i + 1), proving that DC (i + 1) = V (i + 1), which allows to iterate the proof.
The base case is with i = 0: what is to be proved is that Mod(K0 ) = C(0) and DC (1) =
V (1). By construction of C, a model I is in C(0) if MV (I, i, 0) = 0 and I |= Ki for some i;
both hold for i = 0. Vice versa, if I  C(0) then I |= Ki and MV (I, i, 0) = 0 for some i. If
I 6|= K0 , the definition of reinforced mover with j = 0 implies that MV (I, i, 0) > 0, which
in turn implies I 6 C(0), a contradiction.
In order to prove that DC (1) = V (1), let I be a model of P1 . By construction of C, if
I |= K1 then I is in C(V (1)). If I 6|= K1 two cases are possible. In the first, I 6|= Kj for every
j. This implies that I  C(V (1) + . . . + V (n) + 1), and V (1) + . . . + V (n) + 1 > V (1). In the
second case, I |= Kj for some other j. By definition of reinforcement mover, MV (I, j, 1) > 0.
The class of C containing I has index MV (I, j, 0) = MV (I, j, 1)+MV (I, 1, 0) = MV (I, j, 1)+
V (1), the last step being a consequence of I |= Pi . Since MV (I, j, 1) > 0, it follows that
this amount is greater than V (1). This proves that V (1) is the index of the minimal class
of models of P1 in C: DC (1) = V (1). This concludes the base case.
It is now assumed that DC (1) = V (1), . . . , DC (i) = V (i), and is proved that CP1 ...Pi
has the class zero equal to Mod(Ki ) and the minimal models of Pi+1 in class V (i + 1), which
proves that DC (i + 1) = V (i + 1). By induction, this proves that the sequence is generated
by reinforcement revision from the total preorder C.
Let I be a model of Ki . By construction, I  C(MV (I, i, 0)). The first i revisions
increase the class of I by MDC (I, 0, i). Since DC (1), . . . , DC (i) are equal to V (1), . . . , V (i)
by the inductive assumption, this is the same as MV (I, 0, i). By definition of MV , it
holds MV (I, i, 0) = MV (I, 0, i). As a result, MV (I, i, 0) + MDC (I, 0, i) = MV (I, i, 0) 
MV (I, i, 0) = 0: the model I is in CP1 ...Pi (0).
If I is not a model of Ki , then it may be a model of some other Kj or not. In the second
case, it is in C(V (1) +    + V (n) + 1). The first i steps reduce its class number by at most
DC (1) + . . . + DC (i), leading to V (1) +    + V (n) + 1 + DC (1) + . . . + DC (i). Since the
first i values of V and DC coincide, this is V (1) +    + V (n) + 1  V (1)      V (i) =
1 + V (i + 1) +    + V (n), which is greater than zero.
If I is a model of some Kj then I  C(MV (I, j, 0)) by the definition of C. Its class at step
i is therefore MV (I, j, 0)+MDC (I, 0, i). Since DC (1), . . . , DC (i) coincide with V (1), . . . , V (i)
by the induction hypothesis, the second term is equal to MV (I, 0, i). The sum is therefore
equal to MV (I, j, 0) + MV (I, 0, i) = MV (I, j, 0)  MV (I, i, 0) = MV (I, j, i) + MV (I, i, 0) 
MV (I, i, 0) = MV (I, j, i). By the definition of reinforced mover with i and j reversed, since
I |= Kj and I 6|= Ki then MV (I, j, i) > 0. This proves that the class of I in the order
CP1 ...Pi has index larger than zero.
The last step of the proof is to show that the models of Pi+1 are in classes of index
V (i + 1) and greater according to the ordering at step i, which is CP1 ...Pi . Let I be a model
of Pi+1 . If it does not satisfy any Kj then it is in C(V (1)+  +V (n)+1). At step i its class
is at least V (1) +    + V (n) + 1  DC (1)      DC (i), since DC (j) is the maximal decrease
of classes at step j. Since DC (1), . . . , DC (i) coincide with V (1),    , V (i) by the induction
assumption, this is equal to V (1)+  +V (n)+1V (1)  V (i) = V (i+1)+  +V (n)+1,
which is larger than V (i + 1).
324

fiRevision by History

If I satisfies some Kj , possibly with j = i + 1, then I  C(MV (I, j, 0)) by the definition
of C. At step i, its class index is MV (I, j, 0) + MDC (I, 0, i). Since DC (1), . . . , DC (i) are
assumed equal to V (1), . . . , V (i), the second term is equal to MV (I, 0, i) and the sum to
MV (I, j, 0) + MV (I, 0, i) = MV (I, j, i). Since I |= Pi+1 , MV (I, i, i + 1) = V (i + 1) by the
definition of MV (Definition 11 with V in place of DC ). The definition of reinforced mover
ensures that MV (I, j, i + 1) = MV (I, j, i) + MV (I, i, i + 1) = MV (I, j, i)  V (i + 1) is equal
to 0 if I |= Ki+1 and greater otherwise. Since Ki+1 has some models, the minimal value
of MV (I, j, i)  V (i + 1) is zero, proving that the minimal value of MV (I, j, i) is V (i + 1).
This proves that DC (i + 1) = V (i + 1).
Lemma 18 If reinforcement revision generates a revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ]
from some total preorder, then it also generates the same sequence from a preorder in which
the minimal initial class of models of P1 is 0 or 1.
Proof. If K0  P1 is consistent then P1 has models in K0 , which is class zero.
Otherwise, let the class indexes of models of P1 be k1 < k2 < k3 < . . . Revision by P1
decreases all these numbers by k1 , making them k1  k1 = 0, k2  k1 , k3  k1 , etc.
From the given initial preorder, a new one can be generated by reducing each model of
P1 of k1  1 classes. This new initial preorder generates the same revision sequence. The
models that do not satisfy P1 are not changed of initial class, and after revising by P1 are
still moved up one class.
The models of P1 are in classes k1  (k1  1), k2  (k1  1), k3  (k1  1), etc. of the
new preorder. Since k1 is the minimal index of models of P1 , none of these indexes is zero.
Therefore, no model of P1 enters K0 .
The minimal class of models of P1 in the new initial preorder is 1, proving that DC (1) =
1. This implies that revising by P1 decreases the class of the models of P1 by one. As a
result, the indexes of these classes are k1  (k1  1)  1, k2  (k1  1)  1, k3  (k1  1)  1,
etc. and these coincide with k1  k1 = 0, k2  k1 , k3  k1 , etc. These are the same classes
obtained revising the original preorder by P1 . The models that do not satisfy P1 are in
the same initial class and are still moved up one class. This proves that the ordering after
revising by P1 is the same as before. Therefore, from this point on the revision sequences
are identical.
Lemma 19 If reinforcement revision generates the sequence [K0 , P1 , K1 , . . . , Pn , Kn ] from
a total preorder, it is also generates the same sequence from a total preorder C such that
DC (i + 1)  DC (1) + . . . + DC (i) + i + 1.
Proof. The claim is proved in two cases separately: Pi+1 has some models that satisfy some
Kj with j < i, or it does not.
Case 1: some models of Pi+1 satisfy Kj with j < i. Such models are in class zero at
step j. Therefore, they are at most in class i  j at step i. This proves that Pi+1 has some
models in class i  j, so the minimal class of its models is i  j or less: DC (i + 1)  i  j,
which is less that DC (1) + . . . + DC (i) + i + 1 because i  j < i + 1.
Case 2: no model of Pi+1 is in any Kj with j < i. Let C(l) be the minimal initial class
of the models of Pi+1 . If l > DC (1) + . . . + DC (i), then all models of Pi+1 can be decreased
325

fiLiberatore

of l  (DC (1) + . . . + DC (i))  1 classes without affecting the generated sequence. Models of
class l move to class l(l(DC (1)+. . .+DC (i)1)) = DC (1)+. . .+DC (i)+1. The maximal
class such a model may reach at step i is DC (1) + . . . + DC (i) + 1 + i, since each step may at
most increase the class of a model of one. Therefore, DC (i+1)  DC (1)+. . .+DC (i)+i+1.
What remains to be proved is that this change does not affect the revision results.
Regarding the steps before i + 1, since the models of Pi+1 are in the initial class DC (1) +
. . . + DC (i) + 1 or greater, while the models of K1 are in the initial class DC (1), the minimal
class of models of P1 is still DC (1) and the result of revision is still K1 . Since DC (1) is the
same as before, a similar line of reasoning can be applied to the models of K2 and to DC (2),
then to K3 and so on until Ki , proving that neither K1 , . . . , Ki nor DC (1), . . . , DC (i) are
affected by the change. Since DC (1), . . . , DC (i) tell how the models are moved, at step i
the models of Pi+1 are in the same classes as before the change. The models of Pi+1 are
lowered of DC (i + 1) classes. Since the change has not altered their relative initial positions,
it does not modify their relative positions at step i. The preorder at step i + 1 is therefore
the same as before.
Lemma 20 Reinforcement revision generates the revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ]
from a total preorder if and only if it generates the same sequence from a total preorder such
that each DC (i) is bounded by 2i  1.
Proof. It has been proved that if DC (1) is not 1, the preorder can be modified to make it
so.
Since DC (i + 1) is bounded by DC (1) + . . . + DC (i) + i + 1, assuming the claim for
DC (1), . . . , DC (i) leads to DC (i + 1)  (21  1) +    + (2i  1) + i + 1, which is the same
as DC (i + 1)  (20 + 21 +    + 2i )  20  1  i + i + 1 = 21 +    + 2i , which is 2i+1  1.
Theorem 8 Establishing the existence of a total preorder generating the revision sequence
[K0 , P1 , . . . , Pn , Kn ] by reinforcement revision is in p2 , and is in coNP if n is a constant.
Proof. By the above lemma, a revision sequence is generated by a preorder if and only
if it is generated by a preorder for which DC (i) is between 0 and 2i  1. As a result, the
problem can be solved by guessing a reinforcement mover V = [V (1), . . . , V (n)] for the
sequence, where each V (i) is between 0 and 2i  1, since this implies not only the existence
of a total preorder C generating the sequence but also that DC (i) = V (i) for all indexes.
If n is a constant the guessing can be replaced by a disjunction. Checking whether V is
a reinforcement mover amount to check whether, for all I, i and j, it holds that I |= Ki
implies MV (I, i, j) = 0 if I |= Kj and MV (I, i, j) > 0 otherwise. Calculating MV (I, i, j)
can be done in polynomial time since the only checks it requires are in the form j > i and
I |= Pl . Therefore, this verification is in coNP, and the whole problem in p2 because of the
guessing of V .
Theorem 9 Checking the existence of a preorder generating a reinforcement revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] is coNP-complete, if n is a constant.
326

fiRevision by History

Proof. Membership is proved by the previous theorem. Hardness can be proved from the
problem of propositional unsatisfiability. Given a formula F , its corresponding revision
sequence is [K0 , P1 , K1 ] with K0 = a  F , P1 = b and K1 = a  b, where a and b are
fresh variables not occurring in F . In this sequence, K0 = a  F is consistent with P1 = b.
Therefore, K1 = a  b should be equivalent to their conjunction (a  F )  b. If F is
unsatisfiable this is the case. Otherwise, the model of F extended by assigning a to false
and b to false is a model of K0  P1 that is not a model of K1 . This proves that the sequence
is generated by some preorder if and only if F is unsatisfiable.

References
Alchourron, C., & Makinson, D. (1982). On the logic of theory change: Contraction functions
and their associated revision functions. Theoria, 48 (1), 1437.
Areces, C., & Becher, V. (2001). Iterable AGM functions. In Rott, H., & Williams, M.A. (Eds.), Frontiers in Belief Revision, Applied Logic Series, pp. 261277. Kluwer
Academic Publisher.
Baltag, A., Gierasimczuk, N., & Smets, S. (2011). Belief revision as a truth-tracking process.
In Proceedings of the Thirteenth Conference on Theoretical Aspects of Rationality and
Knowledge (TARK 2011), pp. 187190.
Benferhat, S., Kaci, S., Le Berre, D., & Williams, M.-A. (2004). Weakening conflicting
information for iterated revision and knowledge integration. Artificial Intelligence,
153, 339371.
Booth, R., & Meyer, T. (2006). Admissible and restrained revision. Journal of Artificial
Intelligence Research, 26, 127151.
Booth, R., & Nittka, A. (2008). Reconstructing an agents epistemic state from observations
about its beliefs and non-beliefs. Journal of Logic and Computation, 18, 755782.
Boutilier, C. (1996). Iterated revision and minimal change of conditional beliefs. Journal
of Philosophical Logic, 23, 263305.
Carson, R., & Louviere, J. (2011). A common nomenclature for stated preference elicitation
approaches. Environmental and Resource Economics, 49 (4), 539559.
Darwiche, A., & Pearl, J. (1997). On the logic of iterated belief revision. Artificial Intelligence Journal, 89 (12), 129.
Delgrande, J., Dubois, D., & Lang, J. (2006). Iterated revision as prioritized merging. In
Proceedings, Tenth International Conference on Principles of Knowledge Representation and Reasoning, KR-2006, pp. 210220.
Eiter, T., & Gottlob, G. (1996). The complexity of nested counterfactuals and iterated
knowledge base revisions. Journal of Computer and System Sciences, 53 (3), 497512.
Fagin, R., Ullman, J. D., & Vardi, M. Y. (1983). On the semantics of updates in databases.
In Proceedings of the Second ACM SIGACT SIGMOD Symposium on Principles of
Database Systems (PODS83), pp. 352365.
327

fiLiberatore

Ferme, E., & Hansson, S. (2011). AGM 25 years - Twenty-five years of research in belief
change. Journal of Philosophical Logic, 40 (2), 295331.
Gardenfors, P. (1988). Knowledge in Flux: Modeling the Dynamics of Epistemic States.
Bradford Books, MIT Press, Cambridge, MA.
Hild, M., & Spohn, W. (2008). The measurement of ranks and the laws of iterated contraction. Artificial Intelligence, 172 (10), 11951218.
Jin, Y., & Thielscher, M. (2007). Iterated belief revision, revised. Artificial Intelligence
Journal, 171 (1), 118.
Katsuno, H., & Mendelzon, A. O. (1991). Propositional knowledge base revision and minimal change. Artificial Intelligence, 52, 263294.
Konieczny, S., & Pino Perez, R. (2000). A framework for iterated revision. Journal of
Applied Non-Classical Logics, 10, 339367.
Lehmann, D., & Magidor, M. (1992). What does a conditional knowledge base entail?
Artificial Intelligence, 55, 160.
Liberatore, P. (2014a). Belief revision by examples.
(CoRR), abs/1409.5340.

Computing Research Repository

Liberatore, P. (2014b). Belief revision by reliability assessment. Manuscript.
Nayak, A. (1994). Iterated belief change based on epistemic entrenchment. Erkenntnis, 41,
353390.
Nebel, B. (1992). Syntax-Based Approaches to Belief Revision, pp. 5288. Cambridge
University Press.
Nittka, A., & Booth, R. (2008). A method for reasoning about other agents beliefs from
observations. In Logic and the foundation of game and decision theory, Vol. 3 of Texts
in logic and games, pp. 153182.
Papini, O. (2001). Iterated revision operations stemming from the history of an agents
observations. In Frontiers in belief revision, Vol. 22 of Applied Logic Series, pp. 279
301. Springer.
Peppas, P. (2008). Belief revision, pp. 317359. Elsevier.
Rott, H. (2009). Shifting priorities: Simple representations for twenty-seven iterated theory change operators. In Towards Mathematical Philosophy, Vol. 28, pp. 269296.
Springer.
Sandholm, T., & Conen, W. (2010). Preference elicitation in combinatorial auctions. US
Patent 7,742,971.
See, K., Morrison, W., Rothman, N., & Soll, J. (2011). The detrimental effects of power
on confidence, advice taking, and accuracy. Organizational Behavior and Human
Decision Processes, 116 (2), 272285.
Spohn, W. (1988). Ordinal conditional functions: A dynamic theory of epistemic states. In
Causation in Decision, Belief Change, and Statistics, pp. 105134. Kluwer Academics.
Suzumura, K. (1976). Remarks on the theory of collective choice. Economica, New Series,
43, 381390.
328

fiRevision by History

SyncML (2002). SyncML sync protocol, version 1.1.
Tversky, A., & Kahneman, D. (1983). Extensional versus intuitive reasoning: the conjunction fallacy in probability judgment. Psychological review, 90 (4), 293315.
Wang, H., Zhang, J., & Johnson, T. R. (2000). Human belief revision and order effect. In
Proceedings of the 22th Annual Conference of the Cognitive Science Society.
Williams, M. (1994). Transmutations of knowledge systems. In Proceedings of the Fourth International Conference on the Principles of Knowledge Representation and Reasoning
(KR94), pp. 619629.
Winslett, M. (1988). Reasoning about actions using a possible models approach. In Proceedings of the Seventh National Conference on Artificial Intelligence (AAAI88), pp.
8993.
Zhang, D. (2004). Properties of iterated multiple belief revision. In Proceedings of the Seventh International Conference on Logic Programming and Nonmonotonic Reasoning
(LPNMR 2004), pp. 314325.

329

fi