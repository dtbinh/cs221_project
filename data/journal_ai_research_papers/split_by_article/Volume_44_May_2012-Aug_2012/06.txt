Journal of Artificial Intelligence Research 44 (2012) 633-708

Submitted 11/11; published 08/12

The Logical Difference for the
Lightweight Description Logic EL
Boris Konev
Michel Ludwig

konev@liverpool.ac.uk
michel.ludwig@liverpool.ac.uk

Department of Computer Science
University of Liverpool, UK

Dirk Walther

dirk.walther@upm.es

Departamento Inteligencia Artificial, Facultad de Informatica
Universidad Politecnica de Madrid, Spain

Frank Wolter

wolter@liverpool.ac.uk

Department of Computer Science
University of Liverpool, UK

Abstract
We study a logic-based approach to versioning of ontologies. Under this view, ontologies
provide answers to queries about some vocabulary of interest. The difference between
two versions of an ontology is given by the set of queries that receive different answers.
We investigate this approach for terminologies given in the description logic EL extended
with role inclusions and domain and range restrictions for three distinct types of queries:
subsumption, instance, and conjunctive queries. In all three cases, we present polynomialtime algorithms that decide whether two terminologies give the same answers to queries
over a given vocabulary and compute a succinct representation of the difference if it is nonempty. We present an implementation, CEX2, of the developed algorithms for subsumption
and instance queries and apply it to distinct versions of Snomed CT and the NCI ontology.

1. Introduction
Terminologies are lightweight ontologies that are used to provide a common vocabulary
for a domain of interest together with descriptions of the meaning of terms built from the
vocabulary and relationships between them. They are being used in areas such as medical
informatics, bio-informatics, and the semantic web to capture domain semantics and promote interoperability. Terminologies are often large and complex. For example, the widely
used medical terminology Snomed CT (Systematized Nomenclature of Medicine Clinical
Terms) contains more than 300 000 term definitions (IHTSDO, 2008). Another example is
the National Cancer Institute ontology (NCI) consisting of more than 60 000 axioms (Golbeck, Fragaso, Hartel, Hendler, Oberhaler, & Parsia, 2003). Engineering, maintaining, and
using such terminologies is a complex and laborious task, which is practically unfeasible
without appropriate tool support. In this article, we focus on a principled logic-based
approach to support for terminology versioning.
Dealing with multiple versions of the same information unit is nothing new in computing, and version control is a well established computer technology. Although modern version
control systems provide a range of operations including support for collaborative development, branching, merging, etc., these operations extend and rely on the basic operations of
c
2012
AI Access Foundation. All rights reserved.

fiKonev, Ludwig, Walther, & Wolter

detecting and representing the differences between versions. In this paper, we focus on this
basic problem of versioning.
The need for versioning support is recognised by the ontology research community and
ontology users, and a large number of approaches and tools have been developed. In our
review of currently existing support for ontology versioning, we distinguish three approaches
and describe them according to the difference between ontologies they compute:
1. versioning based on syntactic difference (syntactic diff);
2. versioning based on structural difference (structural diff);
3. versioning based on logical difference (logical diff).
The syntactic diff underlies most existing version control systems used in software development (Conradi & Westfechtel, 1998) (such as, for example, RCS, CVS, SCCS). It works
with text files and represents the difference between versions as blocks of text present in one
version but not another, ignoring any meta-information about the document. As observed
already in the work of Noy and Musen (2002), ontology versioning cannot rely on a purely
syntactic diff operation since many syntactic differences (e.g., the order of ontology axioms)
do not affect the semantics of ontologies. Therefore, ontology versioning based on syntactic
difference is essentially limited to comparing rather informal change logs (Oliver, Shahar,
Shortliffe, & Musen, 1999).
The structural diff extends the syntactic diff by taking into account information about
the structure of ontologies. It has been suggested for dealing with structured and hierarchical documents such as UML diagrams, database schemas, or XML documents (see, e.g.,
Ohst, Welle, & Kelter, 2003, and references within). For ontologies, the main characteristic
of the structural diff is that it regards them as structured objects, such as an is-a taxonomy (Noy & Musen, 2002), a set of RDF triplets (Klein, Fensel, Kiryakov, & Ognyanov,
2002) or a set of class defining axioms (Redmond, Smith, Drummond, & Tudorache, 2008;
Jimenez-Ruiz, Cuenca Grau, Horrocks, & Llavori, 2011). Changes to ontologies are mostly
described in terms of structural operations, for example, adding or deleting a class, extending a class, renaming slots, moving a class from one place in the hierarchy to another,
adding or deleting an axiom, class renaming, etc.; sometimes basic logical properties of
ontologies, e.g., the equivalence of different structural forms of concepts, are also taken into
account (Palma, Haase, Corcho, & Gomez-Perez, 2009; Jimenez-Ruiz et al., 2011). Ontology versioning based on structural diff of some form is available in most current ontology
editors and ontology management systems either natively or through plugins (Noy & Musen,
2002; Klein et al., 2002; Jimenez-Ruiz et al., 2011).
Though very helpful, the structural diff still has the deficiency of having no unambiguous semantic foundation and being syntax dependent. Moreover, it is tailored towards
applications of ontologies which are based on the induced concept hierarchy (or some mild
extension of it), but does not capture modern applications such as ontology based data access (OBDA) (Poggi, Lembo, Calvanese, Giacomo, Lenzerini, & Rosati, 2008; Lutz, Toman,
& Wolter, 2009) in which ontologies are used to provide a user-oriented view of the data
634

fiThe Logical Difference for the Lightweight Description Logic EL

and make it accessible via queries formulated solely in the language of the ontology without
any knowledge of the actual structure of the data.1
The logical diff has only been recently introduced (Konev, Walther, & Wolter, 2008;
Kontchakov, Wolter, & Zakharyaschev, 2010) and completely abstracts from the representation of the ontology. Here, an ontology is regarded as a set of axioms formulated in a logical
language with a formal and unambiguous semantics. Under this view, ontologies provide
answers to queries about some vocabulary of interest. Typical queries include subsumption
queries between concepts and, if the ontology is used to access instance data, instance and
conjunctive queries. The logical diff is motivated by this view. If two versions of an ontology
give the same answers to a class of queries relevant to an application domain, they may be
deemed to have no difference regardless of their syntactic or structural form; and queries
producing different answers from the versions may be considered as a characterisation of
the difference itself. In this way one can, for example, define exactly the differences visible
when querying instance data or exactly the differences expressed by subsumptions between
concepts.
To make this approach work in practice, at least two problems have to be addressed:
 For most ontology languages and classes of queries the computational complexity of
even detecting if two ontology versions differ over a certain vocabulary is at least
one exponential harder than ontology classification and is sometimes undecidable;
and even if the computational complexity does not increase, searching for differences
between ontologies within a certain vocabulary requires techniques that are very different from those used for standard reasoning (Lutz, Walther, & Wolter, 2007; Lutz
& Wolter, 2010; Cuenca Grau, Horrocks, Kazakov, & Sattler, 2008).
 If the set of queries producing different answers from the two versions is not empty,
it is typically infinite and, therefore, cannot be presented to the user as such. Thus,
techniques to succinctly characterise its elements and present them to the user are
required.
The aim of this paper is to provide first steps toward solutions to these problems for
terminologies (aka classical TBoxes) given in the description logic ELHr that extends the
description logic EL underlying the OWL 2 EL profile with role inclusions and domain and
range restrictions (Baader, Brandt, & Lutz, 2008). Our main contributions are as follows:
1. It has been argued that syntax-dependence should be regarded as an advantage rather than a deficiency
in the context of versioning (Goncalves, Parsia, & Sattler, 2011; Jimenez-Ruiz et al., 2011). For example, Jimenez-Ruiz et al. argue that logical equivalence between ontologies can be too permissive: even if
O  O0  the strongest assumption from a semantic point of view  conflicts may still exist. This might
result from the presence of incompatible annotations (statements that act as comments and do not carry
logical meaning), or a mismatch in modelling styles; for example, O may be written in a simple language
such as the OWL 2 EL profile and contain  = (A v B u C), while O0 may contain  = (B t C v A).
Even though   , the explicit use of negation and disjunction means that O0 is outside the EL profile.
We agree with Jimenez-Ruiz et al. and Goncalves et al. that there are various applications in which a
structural rather than logical difference is appropriate. Even a syntactic diff has applications in ontology
versioning. In practice, we see logic-based approaches as complementary to structural approaches. An
interesting analysis of NCI versions taking into account both structural and logical differences is given
in the work of Goncalves et al.

635

fiKonev, Ludwig, Walther, & Wolter

 for subsumption, instance, and conjunctive queries, we present polynomial-time algorithms
that decide whether two ELHr -terminologies give different answers to some query from the
respective class of queries over a given signature of concept and role names (note that we
use the terms signature and vocabulary synonymously).
 Besides of a polynomial-time decision procedure detecting differences, we also develop a
succinct presentation of the (typically infinite) difference. This presentation can be computed in polynomial time as well.
 We present two different types of polynomial-time algorithms for deciding the existence
of logical differences between terminologies and for computing a succinct representation
of it: the first type of algorithms is conceptually more transparent as it keeps the two
input terminologies separate and reduces (a substantial part of) the difference problem to
an instance checking problem for an ABox. Such algorithms are, however, not sufficiently
efficient on very large inputs. For example, substantial performance problems occur when
computing the differences between versions of Snomed CT on their joint signature since
the constructed ABox is typically of quadratic size in the input terminologies. The second
variant of algorithms, which is based on dynamic programming, is more efficient in practice.
It is developed in detail for acyclic ELHr -terminologies.
 We present an implementation, CEX2, that is based on the second type of algorithms and
computes a succinct representation of the difference between acyclic ELHr -terminologies
for the concept and instance query case. In addition, a prototype implementation of the
ABox-based algorithm is used to estimate its efficiency.
 As an important tool in our investigation, we present description logics, ELran and
ELran,u,u , that capture as subsumption differences the instance and query difference between ELHr -terminologies. This result is presented for general ELHr -TBoxes and can,
therefore, be exploited in future work on versioning for general ELHr -TBoxes.
 We present experiments using CEX2 that illustrate the efficiency of the algorithms and
potential applications to terminologies such as Snomed CT and NCI. A plugin for Protege
is discussed. CEX2 extends the functionality of the first version of CEX (Konev, Walther, &
Wolter, 2008) and of the OwlDiff plugin (Kremen, Smd, & Kouba, 2011), which implements
the algorithms developed by Konev, Walther, and Wolter. Based on Snomed CT, we also
investigate the performance of the ABox-based algorithms in practice.
This paper is based on, and extends the work of Konev, Walther, and Wolter (2008).
To improve readability, a number of proofs have been deferred to an appendix.

2. Preliminaries
Let NC , NR , and NI be countably infinite and mutually disjoint sets of concept names, role
names, and individual names. EL-concepts C are built according to the rule
C :=

A

|

>

| C uD

|

r.C,

where A  NC , r  NR , and C, D range over EL-concepts. The set of ELHr -inclusions
consists of
 concept inclusions C v D, ran(r) v D and ran(r) u C v D,
636

fiThe Logical Difference for the Lightweight Description Logic EL

 concept equations C  D, and
 role inclusions r v s,
where C and D are EL-concepts and r, s  NR . An ELHr -TBox T is a finite set of ELHr inclusions. Inclusions of the form ran(r) v D and ran(r)uC v D are also referred to as range
restrictions, and inclusions of the form r.> v D are referred to as domain restrictions.
An ELHr -TBox is called an ELHr -terminology if all its concept inclusions and equations
are of the form
 A v C and A  C,
 ran(r) v C, and
 r.> v C,
where A  NC and r  NR , C is an EL-concept such that C 6= >, C 6= > u >, etc., and no
concept name occurs more than once on the left-hand side. Note that, in concept inclusions
of the form r.> v C, the concept r.> is often denoted dom(r). A terminology is acyclic
(or unfoldable) if the process of exhaustively substituting definitions in place of the defined
concept names terminates. For example, if a terminology contains a concept inclusion
Mother v hasMother.Mother
it is not acyclic. Formally, consider the relation T between concept names by setting
A T B if there exists an ELHr -inclusion of the form A  C or A v C in T such that B
occurs in C. A terminology T is acyclic if the transitive closure +
T of T is irreflexive.
In description logic, instance data are represented by ABox assertions of the form >(a),
A(a) and r(a, b), where a, b  NI , A  NC , and r  NR . An ABox A is a non-empty finite
set of ABox-assertions. A is said to be a singleton ABox if it contains exactly one ABox
assertion. By obj(A) we denote the set of individual names in A. A knowledge base K (KB)
is a pair (T , A) consisting of a TBox T and an ABox A. Assertions of the form C(a) and
r(a, b), where a, b  NI , C an EL-concept, and r  NR , are called instance assertions. Note
that instance assertions of the form C(a) with C not a concept name nor C = > do not
occur in ABoxes.
The semantics of ELHr is given by interpretations I = (I , I ), where the domain I
is a non-empty set, and I is a function mapping each concept name A to a subset AI of
I , each role name r to a binary relation rI  I  I , and each individual name a to an
element aI  I . The extension C I of a concept C is defined by induction as follows:
>I
(C u D)I
(r.C)I
ran(r)I

:=
:=
:=
:=

I
C I  DI
{d  I | e  C I : (d, e)  rI }
{d  I | e : (e, d)  rI }

I satisfies
 a concept inclusion C v D, in symbols I |= C v D, if C I  DI ;
637

fiKonev, Ludwig, Walther, & Wolter

 a concept equation C  D, in symbols I |= C  D, if C I = DI ;
 a role inclusion r v s, in symbols I |= r v s, if rI  sI ;
 an assertion C(a), in symbols I |= C(a), if aI  C I ,
 an assertion r(a, b), in symbols I |= r(a, b), if (aI , bI )  rI .
We say that an interpretation I is a model of a TBox T (ABox A) if I |=  for all   T
(  A). An ELHr -inclusion  follows from a TBox T if every model of T is a model of
, in symbols T |= . |=  is used to denote that  follows from the empty TBox and we
sometimes write r vT s for T |= r v s. An instance assertion  follows from a KB (T , A)
if every individual name that occurs in  also occurs in obj(A) and every model of (T , A) is
a model of , in symbols (T , A) |= . The most important ways of querying ELHr -TBoxes
and KBs are
 subsumption: check whether T |= , for an ELHr -inclusion  and TBox T ,
 instance checking: check whether (T , A) |= , for an instance assertion  and KB
(T , A), and
 conjunctive query answering.
To define the latter, call a first-order formula q(~x) a conjunctive query if it is of the form
~y (~x, ~y ), where  is a conjunction of expressions A(t), A  NC , and r(t1 , t2 ), r  NR , with
t, t1 , t2 drawn from NI and the sequences of variables ~x and ~y . Let ~x = x1 , . . . , xk . Let I be
an interpretation and  be a mapping from ~x  ~y into I . Set (a) = aI for all a  obj(A).
We say that a vector ~a = a1 , . . . , ak is a -match of q(~x) and I if  satisfies the following
conditions:
 (t)  AI for every conjunct A(t) of ;
 ((t1 ), (t2 ))  rI for every conjunct r(t1 , t2 ) of ;
 (xi ) = aIi for 1  i  k.
We set I |= q[~a] if, and only if, there exists a  such that ~a is a -match of q(~x) and I. Let
(T , A) be a KB. Then a sequence ~a of members of obj(A) is a certain answer to q(~x) of a
KB (T , A), in symbols (T , A) |= q(~a), if I |= q[~a], for every model I of (T , A).
All three types of querying ELHr -TBoxes have been studied extensively. The complexity
of subsumption and instance checking is in PTime (Baader et al., 2008). The combined
complexity of answering Boolean conjunctive queries (i.e., deciding whether (T , A) |= q for
a conjunctive query q without free variables) is coNP-complete (Rosati, 2007) and its data
complexity is in PTime (Rosati, 2007). Information on reasoners for subsumption checking
for ELHr can be found in the work of Delaitre and Kazakov (2009), Kazakov, Krotzsch,
and Simancik (2011), and Mendez and Suntisrivaraporn (2009). Lutz et al. (2009) present
an approach to efficient conjunctive query answering for ELHr .
638

fiThe Logical Difference for the Lightweight Description Logic EL

2.1 Normal Form
It is often convenient to consider normalised ELHr -terminologies. Let T be an ELHr terminology and A a concept name. Call A
 primitive in T if A  NC \ ({A  NC | A  C  T }  {A  NC | A v C  T });
 pseudo-primitive in T if A  NC \ {A  NC | A  C  T }.
Note that concept names that do not occur in T are primitive and pseudo-primitive in T .
Call a concept name A non-conjunctive in T if it is pseudo-primitive in T or there exists
a concept of the form r.C such that A  r.C  T . Otherwise, A is called conjunctive
in T . Thus, A is conjunctive in T if, and only if, there exists a concept name B such that
A  B  T or there exist C1 , . . . , Cn , n  2, such that A  C1 u    u Cn  T . Let X be a
finite set d
of concepts. We say that a concept F is a conjunction of concepts in X if F is of
the form DX D. Any D  X is then called a conjunct of F and, if D is a concept name,
then it is called an atomic conjunct of F . We sometimes write D  F instead of D  X.
An ELHr -terminology T is normalised if it consists of ELHr -inclusions of the following
form:
 A  r.B, or A  F , where A, B are concept names and F is a non-empty conjunction
of concept names such that every conjunct B 0 of F is non-conjunctive in T ;
 E v r.B, E v r.>, or E v F , where B is a concept name, E is either a concept
name, or is of the form s.>, or ran(s), and F is a non-empty conjunction of concept
names such that every conjunct B 0 of F is non-conjunctive in T .
As the following lemma shows, any ELHr -terminology can be normalised yielding a
model conservative extension of the original terminology.
Lemma 1. For every ELHr -terminology T , one can construct in polynomial time a normalised terminology T 0 of polynomial size in |T | such that sig(T )  sig(T 0 ), T 0 |= T , and
for every model I of T there exists a model J of T 0 such that I = J and X I = X J for
every X  sig(T ). Moreover, T 0 is acyclic if T is acyclic.
Normalised terminologies in the sense defined above are a minor modification of normalised terminologies as defined by Baader (2003). The straightforward extension of the
proof given by Baader is provided in the appendix.
2.2 Canonical Model
We define a canonical model, IK , for ELHr -knowledge bases K. IK can be constructed in
polynomial time and gives the same answers to instance queries as K; i.e., IK |=  if, and
only if, K |= , for any instance assertion . The construction is similar to the canonical
model introduced by Lutz et al. (2009).
Let sub(T ) denote the set of all subconcepts of concepts used in T , rol(T ) the set of all
role names occurring in T . Take fresh individual names xran(r),D for every r  rol(T ) and
D  sub(T ) and set
NIaux := {xran(r),D | r  rol(T ) and D  sub(T )}.
639

fiKonev, Ludwig, Walther, & Wolter

Now define the generating interpretation WK of a KB K = (T , A) as follows:
W K
AW K
r WK

aWK

:= obj(A)  NIaux ;
:= {a  obj(A) | K |= A(a)}  {xran(r),D  NIaux | T |= ran(r) u D v A};
:= {(a, b)  obj(A)  obj(A) | s(a, b)  A and T |= s v r} 
{(a, xran(s),D )  obj(A)  NIaux | K |= s.D(a) and T |= s v r} 
{(xran(s),D , xran(s0 ),D0 )  NIaux  NIaux | T |= ran(s) u D v s0 .D0 , T |= s0 v r};
:= a, for all a  obj(A).

A path in WK is a finite sequence d0 r1 d1    rn dn , n  0, where d0  obj(A) and, for all i < n,
WK
(di , di+1 )  ri+1
. We use paths(WK ) to denote the set of all paths in WK . If p  paths(WK ),
then tail(p) denotes the last element dn in p.
The canonical model IK of a knowledge base K is the restriction of WK to all domain
elements d such that there is a path in WK with tail d. The following result summarises
the main properties of IK .
Theorem 2. Let K = (T , A) be an ELHr -KB. Then
1. IK is a model of K;
2. IK can be computed in polynomial time in the size of K;
3. for all xran(s),D  IK and all a  obj(A), if C is an EL-concept or C = ran(r), then
 K |= C(a) if, and only if, aIK  C IK .
 T |= ran(s) u D v C if, and only if, xran(s),D  C IK .
The proof of Theorem 2 is given in the appendix. It follows from Point 3 that IK gives
the same answers to instance queries as K itself.

3. Logical Difference
In this section, we introduce three notions of logical difference between TBoxes and the
derived notion of -inseparability. Intuitively, the logical difference between two TBoxes T1
and T2 should be the set of all relevant formulas  such that T1 |=  and T2 6|=  or vice
versa. Of course, which formulas  are relevant depends on the application domain. In many
applications only subsumptions between concepts are relevant, but if TBoxes are employed
to access instance data, then answers to instance or even conjunctive queries can be relevant
as well. In addition, in applications of large-scale terminologies such as Snomed CT and
NCI typically only a very small subset of the vocabulary of the terminology is relevant.
Thus, a meaningful notion of logical difference should take into account only those formulas
that are given in a certain signature of interest, where a signature  is a subset of NC  NR .
Given a concept, role, concept inclusion, TBox, ABox, or query E, we denote by sig(E)
the signature of E, that is, the set of concept and role names occurring in it. We call E a
-concept, -concept inclusion, -TBox, -ABox, or -query, respectively, if sig(E)  .
Similarly, an EL -concept C is an EL-concept such that sig(C)   and an ELHr -inclusion
 is an ELHr -inclusion such that sig()  .
The first notion of logical difference we introduce corresponds to applications in which
only subsumptions are relevant.
640

fiThe Logical Difference for the Lightweight Description Logic EL

Definition 3 (-concept difference). The -concept difference between ELHr -TBoxes T1
and T2 is the set cDiff  (T1 , T2 ) of all ELHr -inclusions  such that T1 |=  and T2 6|= .
We say that T1 and T2 are -concept inseparable, in symbols T1 C
 T2 , if cDiff  (T1 , T2 ) =
cDiff  (T2 , T1 ) = .
-concept inseparability between T1 and T2 means that T1 can be replaced by T2 in
any application that is only concerned with ELHr -inclusions.2 As the following example
shows, however, -concept inseparable terminologies can give different answers for the same
instance query and data.
Example 4. Let T1 = {ran(r) v A1 , ran(s) v A2 , B  A1 u A2 }, T2 = ,  = {r, s, B}.
One can show that T1 and T2 are -concept inseparable. However, for the -ABox A =
{r(a, c), s(b, c)} we have (T1 , A) |= B(c) but (T2 , A) 6|= B(c).
To take into account the differences between TBoxes that are relevant if TBoxes are
used to access instance data, we consider the -instance difference.
Definition 5 (-instance difference). The -instance difference between TBoxes T1 and T2
is the set iDiff  (T1 , T2 ) of pairs of the form (A, ), where A is a -ABox and  a -instance
assertion such that (T1 , A) |=  and (T2 , A) 6|= . We say that T1 and T2 are -instance
inseparable, in symbols T1 i T2 , if iDiff  (T1 , T2 ) = iDiff  (T2 , T1 ) = .
In contrast to ELHr , it has been shown by Lutz and Wolter (2010) that for EL-TBoxes
there is no difference between -concept inseparability and -instance inseparability. In
this paper we extend this result to ELHr -TBoxes without range restrictions (the proof is
given after Corollary 37):
Theorem 6. Let T1 and T2 be ELHr -TBoxes without range restrictions and  a signature.
i
Then T1 C
 T2 if, and only if, T1  T2 .
Sometimes, instance queries are not sufficiently expressive, and conjunctive queries are
employed. In that case, the following notion of difference is appropriate.
Definition 7 (-query-difference). The -query difference between TBoxes T1 and T2 is
the set qDiff  (T1 , T2 ) of pairs of the form (A, q(~a)), where A is a -ABox, q(~x) a conjunctive query, and ~a a tuple of individual names in A such that (T1 , A) |= q(~a) and
(T2 , A) 6|= q(~a). We say that T1 and T2 are -query inseparable, in symbols T1 q T , if
qDiff  (T1 , T2 ) = qDiff  (T2 , T1 ) = .
As observed by Lutz and Wolter (2010) already, even for EL -instance inseparability
does not imply -query inseparability. The following is a simple example.
Example 8. Let T1 = {A v r.B}, T2 = ,  = {A, B}. Then T1 and T2 are -instance
inseparable, but they are not -query inseparable. Consider the -ABox A = {A(a)} and
the -query q = x.B(x). Then (T1 , A) |= q but (T2 , A) 6|= q.
2. We refer the reader to the conclusion of this paper for a brief discussion of this claim.

641

fiKonev, Ludwig, Walther, & Wolter

It is shown by Lutz and Wolter (2010) that Example 8 is essentially the only situation
in which there is a difference between -instance inseparability and -query inseparability
in EL: the two notions become equivalent for EL if the universal role is admitted in instance
queries (e.g., in Example 8, the conjunctive query x.B(x) corresponds to the instance query
u.B(a) for the universal role u). In contrast, for ELHr there are more subtle differences
between the instance and the query case.
Example 9. Let T1 = {A v s.>, s v r1 , s v r2 }, T2 = {A v r1 .> u r2 .>},  =
{A, r1 , r2 }. Then T1 and T2 are -concept and -instance inseparable, but they are not
-query inseparable. To show the latter, let A = {A(a)} and let q = x(r1 (a, x)  r2 (a, x)).
Then (T1 , A) |= q but (T2 , A) 6|= q.
We have seen that -concept inseparability does not imply -instance inseparability
and that -instance inseparability does not imply -query inseparability. The converse
implications, however, hold:
Lemma 10. For all ELHr -TBoxes T1 and T2 and all signatures :
T1 q T2



T1 i T2



T1 C
 T2 .

Proof. The first implication follows from the observation that every instance query can be
regarded as a conjunctive query. For the second implication, note first that if s v r 
cDiff  (T1 , T2 ), then ({s(a, b)}, r(a, b))  iDiff  (T1 , T2 ). Now let C v D  cDiff  (T1 , T2 ).
One can construct a -ABox AC with individual a such that for all EL-concepts D0 :
(T , AC ) |= D0 (a) if, and only if, T |= C v D0 (cf. Lemma 36). Thus (AC , D(a)) 
iDiff  (T1 , T2 ).
Having introduced three notions of difference between ELHr -TBoxes, we now investigate two problems: (i) how to detect whether there is any difference between two ELHr terminologies and, if so, (ii) how to represent the differences.
In what follows we assume that the fresh symbols used in the normalised form of terminologies do not occur in the signature  for which we compute the difference between
terminologies. Then we obtain the following lemma as a direct corollary of Lemma 1.
Lemma 11. For any ELHr -terminologies T1 , T2 and their normalised forms T10 , T20 as
defined in Lemma 1, we have that the following hold:
 cDiff  (T1 , T2 ) = cDiff  (T10 , T20 );
 iDiff  (T1 , T2 ) = iDiff  (T10 , T20 );
 qDiff  (T1 , T2 ) = qDiff  (T10 , T20 ).
From now on, unless stated otherwise, we consider normalised terminologies only.
642

fiThe Logical Difference for the Lightweight Description Logic EL

4. The Case of EL-Terminologies
Before investigating the logical difference for ELHr -terminologies, we illustrate the main
ideas behind the proofs by considering the -concept difference for EL-terminologies. An
EL-terminology is an ELHr -terminology consisting of EL-inclusions only, that is, concept
inclusions of the form A v C and concept equations of the form A  C. We start with the
observation that even for acyclic EL-terminologies there are T1 and T2 in which cDiff  (T1 , T2 )
contains inclusions of at least exponential size only. Thus, when searching for witness
inclusions in cDiff  (T1 , T2 ), one has to deal with the case in which all witness inclusions
have at least exponential size.
Example 12. Consider
T1 = {A0 v B0 , A1  Bn }  {Bi+1  r.Bi u s.Bi | 0  i < n}
T2 = {A1 v F0 }  {Fi v r.Fi+1 u s.Fi+1 | 0  i < n}
and  = {A0 , A1 , r, s}. Then a concept inclusion in cDiff  (T1 , T2 ) of minimal size is given
by Cn v A1 , where
C0 = A0 and Ci+1 = r.Ci u s.Ci , for i  0.
Clearly, Cn is of exponential size. Note, however, that if we use structure sharing and define
the size of Cn as the number of its subconcepts, then Cn is only of polynomial size.
We now derive basic properties of EL-terminologies using a sequent calculus.
4.1 Proof System for EL
We derive basic properties of EL from the Gentzen-style sequent calculus presented by Hofmann (2005); see Figure 1. The calculus operates on sequents of the form C v D, where
C, D are EL-concepts; here the symbol v is treated as a syntactic separator. A derivation
(or, equivalently, a proof ) of a sequent C v D is a finite rooted tree whose nodes are labelled
with sequents, whose root is labelled with C v D, whose leaves are labelled with axioms
(instances of Ax or AxTop) and whose internal nodes are labelled with the result of an
application of one of the inference rules to the labels of their children. The length of a
derivation is the number of rule applications in the derivation.
Example 13. Let T = {A  B1 uB2 , F v B1 }. A derivation D of the sequent r.(F uB2 ) v
r.A is shown below. The root of the derivation D is labelled with r.(F u B2 ) v r.A and
the two leaves with B1 v B1 and B2 v B2 , respectively.
(Ax)

B1 v B1
(PDefL)
(Ax)
F v B1
B2 v B2
(AndL1)
(AndL2)
F u B2 v B1
F u B2 v B2
(AndR)
F u B2 v B1 u B2
(DefR)
F u B2 v A
(Ex)
r.(F u B2 ) v r.A
643

fiKonev, Ludwig, Walther, & Wolter

CvC

(Ax)

Cv>

(AxTop)

CvE
(AndL1)
C uD vE

CvE CvD
(AndR)
C vDuE
CA v D
(DefL)
AvD

CvD
(Ex)
r.C v r.D

D v CA
(DefR)
DvA

CA v D
(PDefL)
AvD

DvE
(AndL2)
C uD vE

where A  CA  T

where A v CA  T

Figure 1: Gentzen-style proof system for EL-terminologies.
Notice that the basic calculus of Hofmann (2005) considers EL without the constant >
and for terminologies without concept inclusions. To take care of >, we have added the
rule (AxTop), and (PDefL) is the rule representing inclusions of the form A v C. Cutelimination, completeness, and correctness can now be shown in a straightforward extension
of the proof given by Hofmann.
For a terminology T and concepts C, D, we write T ` C v D if, and only if, there exists
a proof of C v D in the calculus of Figure 1.
Theorem 14 (Hofmann). For all EL-terminologies T and concepts C, D, it holds that
T |= C v D if, and only if, T ` C v D.
We apply this calculus to derive a description of the syntactic form of concepts C such
that T |= C v D, where D is non-conjunctive in T .
Lemma 15. Let T be a normalised EL-terminology, r a role name, A a concept name and
D an EL-concept.
1. Assume
T |=

l

Ai u

1in

l

rj .Cj v A,

1jm

where A is pseudo-primitive in T , Ai are concept names for 1  i  n, Cj are ELconcepts for 1  j  m, and m, n  0. Then there exists Ai , 1  i  n, such that
T |= Ai v A.
2. Assume now
T |=

l
1in

l

Ai u

rj .Cj v r.D,

1jm

where Ai are concept names for 1  i  n, Cj are EL-concepts for 1  j  m, and
m, n  0. Then
 there exists Ai , 1  i  n, such that T |= Ai v r.D or
 there exists rj , 1  j  m, such that rj = r and T |= Cj v D.
644

fiThe Logical Difference for the Lightweight Description Logic EL

d
d
Proof. We use Theorem 14. First, we prove Point 1. Let C = 1in Ai u 1jm rj .Cj
and assume T |= C v A, where A is pseudo-primitive in T . Let D be a proof of C v A.
Note that, since A is pseudo-primitive in T (and a concept name), by inspecting the form
of the conclusions of the inference rules, one can see that the root of the derivation D can
only have been derived by either Ax, AndL1, AndL2, DefL, or PDefL. We now show
that there exists Ai , 1  i  n, such that T |= Ai v A by induction on n + m, i.e. the
number of conjuncts in C. It is easy to see that n + m  1 as T 6|= > v A by definition of
terminologies T .
The base case of n + m = 1 is trivial: the root of D can only have been derived by one
of Ax, DefL, or PDefL; so, we can conclude that C = A1 ; i.e. n = 1, m = 0, and we set
Ai = A1 .
Assume n + m > 1. Then the root of D can only have been derived by either AndL1
or AndL2. In both cases, the premise used in the application of either inference rule is
a sequent C 0 v A such that either C = C 0 u D or C = D u C 0 for an EL-concept D.
Thus, C 0 contains less conjuncts than C (but still at least one). We can also conclude that
T |= C 0 v A holds by Theorem 14. By applying the induction hypothesis, there hence
exists a concept name Ai which is a conjunct of C 0 such that T |= Ai v A. Finally, we still
note that Ai is also a conjunct of C.
d
d
We now prove Point 2. Let C = 1in Ai u 1jm rj .Cj and assume T |= C v r.D.
Let D be a proof of C v r.D. Note that due to the form of the right-hand side of the sequent
C v r.D, the rule used to derive the root of D can only have been one of Ax, AndL1,
AndL2, DefL, PDefL, or Ex. We now prove that either there exists Ai , 1  i  n, such
that T |= Ai v r.D, or there exists rj , 1  j  m, with rj = r and T |= Cj v D by
induction on n + m again. Similarly to above, we have n + m  1.
If n + m = 1, the rule used to derive the root of D can only have been one of Ax, DefL,
PDefL, or Ex. We have two subcases:
 the root of D was derived with DefL or PDefL: then n = 1, m = 0 and C = A1 ; i.e.
T |= Ai v r.D for Ai = A1 .
 the root of D was derived with Ax or Ex: then n = 0, m = 1, C = r1 .C1 , and
r1 = r. If C1 = D, then obviously T |= C1 v D holds. Otherwise, the rule Ex was
used to derive the root of D and T ` C1 v D holds, which implies that T |= C1 v D.
Thus, in any case, rj = r and T |= Cj v D holds for j = 1.
The case n+m > 1 can be proved by induction analogously to the proof of Point 1 above.
We apply Lemma 15 to elements of cDiff  (T1 , T2 ).
Theorem 16 (Primitive witness for EL). Let T1 and T2 be EL-terminologies and  a
signature. If   cDiff  (T1 , T2 ), then either C v A or A v D is a member of cDiff  (T1 , T2 ),
where A  sig() is a concept name and C, D are EL-concepts occurring in .
Proof. Let  = C v D  cDiff  (T1 , T2 ). The proof is by induction on the construction of
D. We have D 6= > as T2 |= C v >. If D = D1 u D2 , then one of C v Di , i = 1, 2, is in
cDiff  (T1 , T2 ) and we can apply the induction hypothesis. If D = r.D1 then, by Lemma 15,
645

fiKonev, Ludwig, Walther, & Wolter

either (i) there exists a conjunct A of C, A a concept name, such that T1 |= A v D, or (ii)
there exists a conjunct r.C1 of C with T1 |= C1 v D1 .
In case (i) it follows that T2 6|= A v D as otherwise T2 |= C v D and C v D 6
cDiff  (T1 , T2 ) due to |= C v A. Hence, A v D  cDiff  (T1 , T2 ).
Finally, for case (ii) we obtain T2 6|= C1 v D1 as otherwise |= C v r.C1 , T2 |= r.C1 v D
and C v D 6 cDiff  (T1 , T2 ) again. Thus, C1 v D1  cDiff  (T1 , T2 ) and we can apply the
induction hypothesis.
By Theorem 16, every inclusion C v D in the -concept difference of T1 and T2 contains a basic witness inclusion that has a concept name either on the right-hand side or
the left-hand side. We define
 the set of left-hand -concept difference witnesses, cWtnlhs
 (T1 , T2 ), as the set of all
A    NC such that there exists a concept D with A v D  cDiff  (T1 , T2 ) and
 the set of right-hand -concept difference witnesses, cWtnrhs
 (T1 , T2 ), as the set of all
A    NC such that there exists a concept C with C v A  cDiff  (T1 , T2 ).
rhs
We regard the concept names in cWtnlhs
 (T1 , T2 ) and cWtn (T1 , T2 ) as a succinct and, in a
certain sense, complete representation of the -concept difference between T1 and T2 and
define the set of all -concept difference witnesses as
rhs
cWtn (T1 , T2 ) = (cWtnlhs
 (T1 , T2 ), cWtn (T1 , T2 )).

In what follows, we first present a polytime algorithm computing cWtnrhs
 (T1 , T2 ). A polytime algorithm computing cWtnlhs
(T
,
T
)
has
already
been
given
by
Lutz
and Wolter (2010)
1 2

(for EL-TBoxes). We briefly present it since an extension will be developed when we consider ELHr -terminologies. Both algorithms together decide -concept inseparability since,
by Theorem 16, T1 and T2 are -concept inseparable if, and only if, cWtn (T1 , T2 ) =
cWtn (T2 , T1 ) = (, ).
4.2 Computing cWtnrhs
 (T1 , T2 )
Let A   and assume we want to decide whether A  cWtnrhs
 (T1 , T2 ). Thus, we want to
decide whether there exists a -concept C such that T1 |= C v A and T2 6|= C v A. Our
general strategy is as follows. Let
noimplyT2 , (A) = {C | T2 6|= C v A, C an EL -concept}.
We aim at an algorithm that checks whether noimplyT2 , (A) contains some C with T1 |=
C v A. For two sets C and D of concepts we call C a cover of D if C  D and for all
D  D there exists a C  C such that |= C v D. Thus, C  noimplyT2 , (A) is a cover
of noimplyT2 , (A) if for all D  noimplyT2 , (A) there exists a C  C such that |= C v D.
Note that if C is a cover of noimplyT2 , (A), then there exists some -concept C such that
C v A  cDiff  (T1 , T2 ) if, and only if, there exists some C  C such that T1 |= C v A.
Thus we have reduced the original problem to the construction of an appropriate cover C
and deciding the subsumption problem T1 |= C v A, for C  C. Unfortunately, in general,
no finite cover exists. The following example illustrates the situation.
646

fiThe Logical Difference for the Lightweight Description Logic EL

Example 17. (1) Let  = {A, B, r} and T2 = . Then noimplyT2 , (A) contains all concepts that do not have A as an atomic conjunct. Clearly, noimplyT2 , (A) contains no
finite cover.
(2) Let 0 = {A, B, r} and T20 = {A  r.A}. Then noimplyT20 ,0 (A) contains all
0 \ {A}-concepts and contains no finite cover.
(3) Let 00 = {A, B1 , B2 } and T200 = {A  B1 u B2 }. Then {B1 , B2 } is a cover of
noimplyT200 ,00 (A).
As a consequence, instead of directly constructing a cover of noimplyT2 , (A), we first
construct transparent and small covers of
noimplyT2 , (A)  {C | depth(C)  n},
for all n  0, where depth(C) is the role-depth of C; i.e., the number of nestings of existential
restrictions in C.3 Those covers are denoted noimplynT2 , (A), n  0, and are singleton
sets if A is non-conjunctive in T2 and finite sets containing at most k concepts if A 
B1 u  uBk  T2 . Based on this sequence, we present two distinct algorithms for computing
cWtnrhs
 (T1 , T2 ):
1. we encode the infinite sequence noimplynT2 , (A), n  0, into a polynomial-size ABox
AT2 , . In this way we obtain a reduction of the original problem to an instance
checking problem for the knowledge base (T1 , AT2 , ). In a certain sense, the ABox
AT2 , encodes a (in general infinite) cover of noimplyT2 , (A).
2. we employ the terminology T1 in a dynamic programming approach to decide which
concepts in noimplynT2 , (A) are relevant for deciding whether A  cWtnrhs
 (T1 , T2 ).
Although less transparent, for large terminologies the latter approach is considerably
more efficient. We develop it for acyclic terminologies.
For an EL-terminology T , a concept name A and a signature , set
pre
T (A) = {B   | T |= B v A}.
The finite covers noimplynT2 , (A), n  0, are defined in Figure 2. For n = 0, the
set noimplynT2 , (A) consists of concepts without role names. We distinguish between conjunctive and non-conjunctive A. Note that if A is non-conjunctive, then noimplynT2 , (A)
is a singleton set. Example 17 (3) shows that this is not always the case for conjunctive A. For n + 1, we distinguish between pseudo-primitive concept names, conjunctive
concept names, and those that have a definition of the form A  r.C. Again, for nonn
conjunctive A, noimplyn+1
T2 , (A) is a singleton set. Note that the concepts all are covers of
{C | depth(C)  n, C an EL -concept}, for all n  0. We illustrate the definitions using
the EL-terminologies from Example 17.
Example 18. (1) Let  = {A, B, r} and T2 = . Then A and B are non-conjunctive in T2
and noimply0T2 , (A) = {B} and noimply0T2 , (B) = {A}. A and B are also pseudo-primitive
in T2 , and so noimply1T2 , (A) = {B u r.(A u B)} and noimply1T2 , (B) = {A u r.(A u B)}.
3. More precisely depth(A) = 0, depth(C1 u C2 ) = max{depth(C1 ), depth(C2 )}, and depth(r.D) =
depth(D) + 1.

647

fiKonev, Ludwig, Walther, & Wolter

Set, inductively,
all0 =

l

A0

l

and alln+1
=


A0 

A0 u

A0 

l

s.alln .

s

Define noimply0T2 , (A) as follows:
 if A is non-conjunctive in T2 , then
l

noimply0T2 , (A) = {

A0 };

A0 \pre
T (A)
2

 if A is conjunctive and A  F  T2 , then
[

noimply0T2 , (A) =

noimply0T2 , (B);

BF

and define, inductively, noimplyn+1
T2 , (A) by
 if A is pseudo-primitive in T2 , then
l

noimplyn+1
T2 , (A) = {

A0 u

A0 (\pre
T (A))

l

s.alln }.

s

2

 If A is conjunctive and A  F  T2 , then
noimplyn+1
T2 , (A) =

[

noimplyn+1
T2 , (B).

BF

 If A  r.B  T2 , then
n+1
noimplyn+1
T2 , (A) = {C,T2 }, where
n+1
=(
C,T
2

l

A0 u

A0 (\pre
T2 (A))

l

l

s.alln u

r.E).

r
Enoimplyn
T

r6=s

2 ,

(B)

Figure 2: Definition of noimplynT2 , (A)

(2) Let 0 = {A, B, r} and T20 = {A  r.A}. Then A and B are non-conjunctive in T20
and noimply0T 0 ,0 (A) = {B} and noimply0T 0 ,0 (B) = {A}. B is pseudo-primitive in T20 and so
2

2

noimply1T2 , (B) = {A u r.(A u B)}. A  r.A  T20 and so noimplyT20 ,0 (A) = {B u r.B}.
T200

(3) Let 00 = {A, B1 , B2 } and T200 = {A  B1 u B2 }. B1 and B2 are non-conjunctive in
and so noimply0T 00 ,00 (B1 ) = {B2 } and noimply0T 00 ,00 (B2 ) = {B1 }. A is conjunctive in T200
2

2

648

fiThe Logical Difference for the Lightweight Description Logic EL

and, by definition, noimply0T 00 ,00 (A) = {B1 , B2 }. Since  does not contain any role names,
2

we have noimply0T 00 ,00 (X) = noimplynT 00 ,00 (X), for all X  {A, B1 , B2 } and n > 0.
2

2

The following lemma shows the correctness of the definition of noimplynT2 , (A).
Lemma 19. Let T2 be a normalised EL-terminology,  be a signature, and A  NC . Then
noimplynT2 , (A) is a cover of noimplyT2 , (A)  {C | depth(C)  n}. Namely, for all n  0,
C1. T2 6|= C v A, for all C  noimplynT2 , (A).
C2. For all EL -concepts D with n = depth(D), if T2 6|= D v A, then |= C v D for some
C  noimplynT2 , (A).
S
In particular, n0 noimplynT2 , (A) is a cover of noimplyT2 , (A).
Proof.d C1. Assume first that A is pseudo-primitive in T2 . Then noimplynT2 , (A) consists of
C = A0 (\pre (A)) A0 u F , where F is a (possibly empty) conjunction of concepts of the
T2

form s.Fi . By Lemma 15, T2 6|= C v A because the only atomic conjuncts of C are in
 \ pre
T2 (A).
We now prove C1 for concept names A which are not pseudo-primitive
in T2 . The proof
d
is by induction on n. For n = 0 and A  r.B  T2 , assume T2 |= A0 (\pre (A)) A0 v A.
T2

As A  r.B  T2 , we have by Lemma 15 that there must exist A0   \ pre
T2 (A) with
0

T2 |= A v A. But this contradicts the definition of the
S set preT2 (A)). For n = 0 and A
conjunctive with A  F  T2 , let C  noimplynT2 , (A) = BF noimplynT2 , (B). There hence
exists an atomic conjunct B of F such that C  noimplynT2 , (B). As T2 is normalised, B is
non-conjunctive, i.e. property C1 has already been proved above for B. Thus, T2 6|= C v B,
which implies that T2 6|= C v A as otherwise T2 |= C v B would hold.
For the induction step, assume C1 has been proved for n  0.
be the only element of noimplyn+1
Let A  r.B  T2 and let CTn+1
T2 , (A). Assume
2 ,
n+1
T2 |= CT2 , v A. By Lemma 15 there are two possibilities:
d
 T2 |= A0 (\pre (A)) A0 v r.B. Similarly to above, the claim follows from Lemma 15
T2

and the fact that A  r.B  T2 .
 r   and there exists E  noimplynT2 , (B) such that T2 |= E v B. This is excluded
by the induction hypothesis.
We have derived a contradiction. The case A  F  T2 , A conjunctive in T2 , is considered
analogously to the case n = 0.
C2. Let n = 0 and assume first that A is non-conjunctive. Let D be a -concept
with depth(D)d = 0 and T2 6|= D v A. Then all conjuncts of D are in  \ pre
T2 (A) and
we obtain |= A0 \pre (A) A0 v D. Now assume A is conjunctive in T2 and A  F  T2 .
T2

Let D be a -concept with depth(D) = 0 and T2 6|= D v A. Then T2 6|= D v B, for some
conjunct B of F . By induction, |= C v D for the (unique as B must be non-conjunctive)
C  noimply0T2 , (B), and therefore |= C v D for some C  noimply0T2 , (A).
For the induction step, assume that C2 has been shown for n. Let D be a -concept
with T2 6|= D v A and depth(D) = n + 1.
649

fiKonev, Ludwig, Walther, & Wolter

(a) Let A be pseudo-primitive in T2 . Then the atomicdconjuncts of D aredincluded in
n
0
 \ pre
A0 \pre (A) A u s s.all .
T2 (A). Now |= C v D follows immediately for C =
T2

(b) Let A  r.B  T2 . Let CTn+1
be the only element of noimplyn+1
T2 , (A) and assume
2 ,
D=

l

l

Eu

EQ0
n+1
Then Q0   \ pre
T2 (A). Hence, |= CT2 , v
We distinguish two cases:

s.D0 .

(s,D0 )Q1

d

EQ0

E. Now consider a conjunct s.D0 of D.

 if s 6= r, then |= CTn+1
v s.D0 , as required.
2 ,
 if s = r, then s   and it is sufficient to show that there exists E  noimplynT2 , (B)
such that |= E v D0 . Suppose there does not exist such an E. Then, by (the
contraposition of) the induction hypothesis, T2 |= D0 v B. But this contradicts
T2 6|= D v A (as A  r.B  T2 ).
(c) A is conjunctive in T2 and A  F  T2 . This case is analogous to the case in which
A is conjunctive in T2 and n = 0.
Corollary 20. For all normalised EL-terminologies T1 and T2 and all A  NC the following
conditions are equivalent:
 there exists an EL -concept C such that T1 |= C v A and T2 6|= C v A;
 there exists n  0 and C  noimplynT2 , (A) such that T1 |= C v A.
Observe that a direct application of Corollary 20 does not yield a procedure for comn
puting cWtnrhs
 (T1 , T2 ) as it gives no bound on n for the set noimplyT2 , (A). At this point
we present two ways of avoiding this problem (as well as the problem that concepts in
noimplynT2 , (A) can be of exponential size). Firstly, instead of working with covers we construct an ABox encoding covers. In contrast to concepts, ABoxes admit the encoding of
structure sharing d
and cycles and so, intuitively, admit the polynomial reconstruction of the
infinite concept n0,Cnoimplyn (A) C.
T2 ,
The ABox AT2 , is constructed in Figure 3, where for a normalised EL-terminology T
and a concept name A  sig(T ), we set

{A}, A is non-conjunctive in T
non-conjT (A) =
{B1 , . . . , Bn }, A  B1 u    u Bn  T
Note that the construction of AT2 , is very similar to the construction of noimplynT2 , (A).
The assertions for the individual  play the role of the concepts alln , n  0, and the
assertions for the individuals A play the role of the sets noimplynT2 , (A), n  0. In fact, one
can readily show that AT2 , |= C(A ) for any C  noimplynT2 , (A) and A non-conjunctive in
T2 and, conversely, (a more involved proof) shows that whenever AT2 , |= D(A ) for some
EL-concept D, then there exist n  0 and C  noimplynT2 , (A) such that |= C v D. We
illustrate the construction of AT2 , using the EL-terminologies from Example 17.
650

fiThe Logical Difference for the Lightweight Description Logic EL

Let
{A | A  sig(T2 )   and non-conjunctive in T2 }  { }  NI .
be a set of individual names. For A non-conjunctive in T2 , define sets AT2 , (A) of assertions
as follows
 if A is pseudo-primitive in T2 , then
AT2 , (A) = {A0 (A ) | A0   \ pre
T2 (A)}  {r(A ,  ) | r  },
 if A  r.B  T2 , then
AT2 , (A) ={A0 (A ) | A0   \ pre
T2 (A)}
 {s(A ,  ) | r 6= s  }
 {r(A , B 0 ) | B 0  non-conjT2 (B), if r  }
Let
[

AT2 , = { A0 ( ) | A0   }  { r( ,  ) | r   } 

AT2 , (A)

Asig(T2 )
A is non-conjunctive in T2

Figure 3: Construction of AT2 , .
Example 21. (1) Let  = {A, B, r} and T2 = . Then
AT2 , = {A(B ), B(A ), r(A ,  ), r(B ,  )}  A ,
where A = {A( ), B( ), r( ,  )}.
(2) Let 0 = {A, B, r} and T20 = {A  r.A}. Then
AT20 ,0 = {A(B ), B(A ), r(A , A ), r(B , 0 )}  A0 ,
where A0 = {A(0 ), B(0 ), r(0 , 0 )}.
(3) Let 00 = {A, B1 , B2 } and T200 = {A  B1 u B2 }. Then
AT200 ,00 = {B1 (B2 ), B2 (B1 )}  A00 ,
where A00 = {A(00 ), B1 (00 ), B2 (00 )}.
We now obtain the following characterisation of cWtnrhs
 (T1 , T2 ).
Theorem 22. Let T1 and T2 be normalised EL-terminologies and  a signature. Then the
following conditions are equivalent for any A  :
 A  cWtnrhs
 (T1 , T2 );
 there exist n  0 and C  noimplynT2 , (A) such that T1 |= C v A;
651

fiKonev, Ludwig, Walther, & Wolter

 (T1 , AT2 , ) |= A(B ) for some B  non-conjT2 (A).
The equivalence of Points 1 and 2 follows from Corollary 20. We do not give a detailed
proof of the equivalence of Points 2 and 3 as this follows from the more general results for
ELHr -terminologies we present below.
Example 23. For a normalised form of the terminologies from Example 12,
0
00
T1 = {A0 v B0 , A1  Bn }  {Bi+1  Bi+1
u Bi+1
| 0  i < n}
0
00
 {Bi+1  r.Bi | 0  i < n}  {Bi+1  s.Bi | 0  i < n}

T2 = {A1 v F0 }  {Fi  Fi0 u Fi00 | 0  i < n}
 {Fi0 v r.Fi+1 | 0  i < n}  {Fi00 v s.Fi+1 | 0  i < n},
and  = {A0 , A1 , r, s}, the ABox AT2 , can be graphically represented as
r, s
r, s

r, s
r, s

F 00
A0 ,A1

r, s
r, s


A0 ,A1


F 00

F 0

A0 ,A1

A0 ,A1

1

r, s

n

F 00

r, s
A0
A1

n

1

r, s

A1
A0

F 0

A0 ,A1

0

A0
F 0

0

A0

It should be clear that (T1 , AT2 , ) |= A1 (A1 ). In fact, (T1 , A) |= A1 (A1 ) holds already for
the restriction A of AT2 , to the individuals {A1 ,  }.
Theorem 24. For EL-terminologies T1 and T2 and a signature , the set cWtnrhs
 (T1 , T2 )
can be computed in polynomial time.
Proof. It suffices to give a polynomial time algorithm that decides for every A   whether
A  cWtnrhs
 (T1 , T2 ). First, the ABox AT2 , can be computed in polynomial time and is
of quadratic size in T2 . By Theorem 22, A  cWtnrhs
 (T1 , T2 ) iff (T1 , AT2 , ) |= A(B ) for
some B  non-conjT2 (A), and the latter condition can be checked in polynomial time since
instance checking is in polynomial time for EL-TBoxes.
Regarding the efficiency of this approach, observe that for typical terminologies and large
, the ABox AT2 , is indeed of quadratic size in T2 since  \ pre
T2 (A) will typically contain
most of the concept names in . Thus, for very large terminologies and  a straightforward
implementation of this rather elegant algorithm does not work efficiently as one would have
to store an ABox of quadratic size and do instance checking for it. We refer the reader to
Table 3 and its discussion where a prototype implementation of this approach is applied to
modules of Snomed CT.
We now describe our second approach for computing cWtnrhs
 (T1 , T2 ), which only works
for acyclic EL-terminologies. Recall that A  cWtnrhs
(T
,
T
1 2 ) if, and only if, there ex
ists an EL -concept C such that T2 6|= C v A and T1 |= C v A. Thus, we have
A 6 cWtnrhs
 (T1 , T2 ) if, and only if, for every EL -concept C with C  noimplyT2 , (A)
652

fiThe Logical Difference for the Lightweight Description Logic EL

procedure NotWitness(E)
if E is pseudo-primitive
 in T1 then
	

NotWitness(E) := A   | pre
T1 (E)  preT2 (A)
end if
if (E  E1 u    u Ek S
 T1 ) then
NotWitness(E) := ki=1 NotWitness(Ei )
end if
if E  r.E 0  T1 then
0 ) then
if r 
/  or All  NotWitness(E

	

NotWitness(E) := A   | pre
T1 (E)  preT2 (A)
else

fi

fi A  r.A0  T2


fi
NotWitness(E) := A   fifi non-conjT2 (A0 )  NotWitness(E 0 )


fi pre (E)  pre (A)
T1
T2
end if
end if
end procedure
Figure 4: Computation of NotWitness(E).
it holds that C  noimplyT1 , (A). Our approach is now based on computing a not witness
relation NW  ((sig(T1 )  )  NC )  ((sig(T2 )  )  NC ), which is defined as follows:
(E, A)  NW

if, and only if,

() noimplyT2 , (A)  noimplyT1 , (E)

Observe that A  cWtnrhs
 (T1 , T2 ) if, and only if, (A, A) 6 NW; hence, to compute the
set cWtnrhs
(T
,
T
)
it
is
sufficient
to compute the relation NW. In practice, it is crucial to
1 2

compute the relation NW rather than its complement: in typical terminologies most concept
names are unrelated in the sense that they do not subsume each other. Thus, the relation
NW is much smaller than its complement (which contains, among others, all pairs (E, A)
that do not subsume each other in T1 and T2 ).
To determine the pairs (E, A)  NW, we aim at computing for every concept name
E  sig(T1 )   the set of concept names A  sig(T2 )   for which the property () holds.
This set will be called NotWitness(E) and is computed in Figure 4, with the following
modifications: (1) we only consider those A  sig(T2 )   which are non-conjunctive in T2
and take conjunctive concept names into account later. (2) We consider a fresh concept
name All not occurring in   sig(T1 )  sig(T2 )  informally standing for all possible concepts.
Thus, the procedure, NotWitness(E) given in Figure 4 recursively associates with every
E  sig(T1 )   a subset of the set
 = {All}  { A | A  (sig(T2 )  ), A is non-conjunctive in T2 }
and NW is a relation over
((sig(T1 )  )  NC )  (((sig(T2 )  )  NC )  {All}).
653

fiKonev, Ludwig, Walther, & Wolter

Note that unlike in the approach for computing cWtnrhs
 (T1 , T2 ) that was presented previously, the approach described here does not handle the two terminologies separately. In
the previous approach the ABox AT2 , could be precomputed for T2 and then be re-used to
compare T2 against any other terminology T1 , whereas here both terminologies are analysed
simultaneously. We now prove the correctness of the procedure NotWitness(E).
Lemma 25. For any normalised acyclic EL-terminologies T1 and T2 , any signature , any
E  sig(T1 )   and any A   the following holds: A  NotWitness(E) if, and only if,
(E, A)  NW.
Proof. We prove that for any E  sig(T1 )   and any A   the following two conditions
are equivalent:
 A  NotWitness(E);
 for all n  0 and all C  noimplynT2 , (A): T1 6|= C v E.
S
This is sufficient since n0 noimplynT2 , (A) is a cover of noimplyT2 , (A) (Lemma 19).
For E 6 sig(T1 ) the claim is trivial. For E  sig(T1 ) the proof is by induction relative
to the relation T1  sig(T1 )  sig(T1 ) (whose definition can be found on page 637). Note
that since the considered terminologies are acyclic and sig(T1 ) is finite, the relation T1 is
well-founded.
We distinguish between the possible definitions of E in T1 . Suppose E is pseudoprimitive in T1 . For A  , it follows from the definition of noimplynT2 , (A) and from
Lemma 15 that there exist n  0 and C  noimplynT2 , (A) such that T1 |= C v E if, and

only if, T1 |= B v E for some B  ( \ pre
T2 (A)). Note that for all B  ( \ preT2 (A)),
T1 6|= B v E holds if, and only if, for every B  , T1 |= B v E implies that B  pre
T2 (A).
n

Thus, for every n and C  noimplyT2 , (A), T1 6|= C v E if, and only if, preT1 (E)  pre
T2 (A)
if, and only if, A  NotWitness(E).
Assume that E  E1 u    u Ek  T1 . Then, for any concept C, T1 6|= C v E if, and
only if, T1 6|= C v Ei for some 1  i  k. Hence, by applying the induction hypothesis we
obtain for every n and C  noimplynT2 , (A), T1 6|= C v E if, and only if, A  NotWitness(Ei )
for some 1  i  k, if, and only if, A  NotWitness(E).
Finally, assume that E  r.E 0  T1 . Notice that, since All 
/ (  sig(T1 )  sig(T2 )) (in

particular, All is pseudo-primitive in T2 ), we have preT2 (All) = . Thus, by definition for
every n  0, noimplynT2 , (All) = {alln }. By applying the induction hypothesis we can assume
that the lemma holds for E 0 , which implies that All 
/ NotWitness(E 0 ) if, and only if, for
some n  0, T1 |= alln v E 0 . We now distinguish between the following cases, analogously
to the case distinction in procedure NotWitness(E) (see Figure 4).
If r 
/ , for any -concept of the form s.G, where s  NR  , we have r 6= s and
T1 6|= s.G v r.E 0 . Similarly, if All  NotWitness(E 0 ), it holds for every n  0 that
T1 6|= alln v E 0 . Hence, for any -concept of the form s.G, we obtain T1 6|= s.G v r.E 0
as otherwise T1 |= alln v E 0 would hold for n = depth(s.G) (where depth(s.G) is the
role-depth of s.G). So, by Lemma 15, these two cases are analogous to the case of E being
pseudo-primitive considered above.
Assume now that r   and All 
/ NotWitness(E 0 ), that is, for some n0  0 we have
n0
0
T1 |= all v E .
654

fiThe Logical Difference for the Lightweight Description Logic EL

First, we observe that if A does not have a definition of the form A  r.A0 in T2 , then for
+1
the unique C  noimplynT20,
(A) we have T1 |= C v E as r.alln0 is a conjunct of C (and as A
is non-conjunctive in T2 by definition of the set ). If A has a definition of the form A  r.A0
in T2 , for any n  0 and C  noimplynT2 , (A), we have by Lemma 15 that T1 6|= C v E
n1

0
0
if, and only if, pre
T1 (E)  preT2 (A), and, if n > 0, for every C  noimplyT2 , (A ) we have
0
0
T1 6|= C v A .
We can conclude that in case r   and All 
/ NotWitness(E 0 ), for any A  , any
n
n  0, and any C  noimplyT2 , (A), we have T1 6|= C v E, if, and only if, A  r.A0 
m
0

0
T2 , pre
T1 (E)  preT2 (A) and for any m  0 and any C  noimplyT2 , (A ) we have
m
0
0
T
(A0 ) =
S1 6|= C v E . Noticem further that, by definition for any m  0,0 noimplyT2 ,
m
0
Bnon-conjT (A0 ) noimplyT2 , (B). Thus, for any m  0 and any C  noimplyT2 , (A ),
2

T1 6|= C 0 v E 0 holds if, and only if, for any m  0, any B  non-conjT2 (A0 ) and any
0
0
0
C 0  noimplym
T2 , (B), T1 6|= C v E , if, and only if, for any B  non-conjT2 (A ), B 
0
NotWitness(E ) holds by applying the induction hypothesis.
Thus, T1 6|= C v E, for any n  0 and C  noimplynT2 , (A), if, and only if, A 
NotWitness(E).
Corollary 26. Let T1 and T2 be normalised acyclic EL-terminologies and  a signature.
Then cWtnrhs
 (T1 , T2 ) = { A  sig(T1 )   |  B  non-conjT2 (A) with B 6 NotWitness(A) }.
Proof. First, we observe that if A  cWtnrhs
 (T1 , T2 ), A  sig(T1 ) must hold as otherwise
for any -concept C we have T1 |= C v A if, and only if, |= C v A, and thus A 6
cWtnrhs
 (T1 , T2 ). Now, for all A  NC we have:
A  cWtnrhs
 (T1 , T2 )

iff

iff

iff
iff

A  sig(T1 )   (by our observation) and, by definition,
there exists a -concept C with T2 6|= C v A and T1 |=
CvA
A  sig(T1 )   and there exists B  non-conjT2 (A) and
a -concept C with T2 6|= C v B and T1 |= C v A (as
otherwise T2 |= C v A would hold)
A  sig(T1 )   and there exists B  non-conjT2 (A) with
(A, B) 6 NW (by definition of the relation NW)
A  sig(T1 )   and there exists B  non-conjT2 (A) with
B 6 NotWitness(A), by Lemma 25.

For acyclic terminologies, we now obtain an alternative proof of Theorem 24.
Theorem 27. For acyclic EL-terminologies T1 and T2 and a signature , cWtnrhs
 (T1 , T2 )
can be computed in polynomial time using the procedure NotWitness(E).
Proof. To compute the set cWtnrhs
 (T1 , T2 ), it is sufficient by Corollary 26 to compute the
sets NotWitness(E) for every E  sig(T1 ). Assuming that T1 and T2 are classified and the
result of classification is cached, NotWitness(E) can be computed for all E  sig(T1 ), in the
worst case, in time O((|T1 | + |T2 |)3 ).
Example 28. For the acyclic terminologies T1 , T2 and the signature  from Example 23,
NotWitness(A0 ) = {A0 },
655

NotWitness(B0 ) = {A0 }

fiKonev, Ludwig, Walther, & Wolter

and for all other concept names X  sig(T1 ), NotWitness(X) = . In particular A1 
/
NotWitness(A1 ), so we conclude that A1 is a concept difference witness.
4.3 Computing cWtnlhs
 (T1 , T2 )
Recall that the set of left-hand -concept difference witnesses, cWtnlhs
 (T1 , T2 ), is the set
of all A    NC such that there exists a concept C with A v C  cDiff  (T1 , T2 ). The
tractability of computing cWtnlhs
 (T1 , T2 ) for EL has been proved by Lutz and Wolter (2010)
for arbitrary EL-TBoxes by reduction to simulation checking. Here we formulate the main
steps again because we employ the same technique when dealing with the logical difference
for ELHr -terminologies.
For any two interpretations I1 and I2 we say that a relation S between I1 and I2 is a
-simulation if, and only if, the following conditions hold:
 if (d, e)  S and d  AI1 with A  , then e  AI2 ;
 if (d, e)  S and (d, d0 )  rI1 with r  , then there exists e0 with (d0 , e0 )  S and
(e, e0 )  rI2 .
For d  I1 and e  I2 we write (I1 , d)  (I2 , e) if there exists a -simulation relation S between I1 and I2 such that (d, e)  S. It can be checked in polynomial time
whether (I1 , d)  (I2 , e) and various polynomial-time algorithms checking the existence of
simulations have been developed (Clarke & Schlingloff, 2001; Crafa, Ranzato, & Tapparo,
2011; van Glabbeek & Ploeger, 2008). Simulations characterise the expressive power of
EL-concepts in the following sense.
Lemma 29 (Lutz & Wolter, 2010). Let I1 and I2 be interpretations,  a signature, d  I1 ,
and e  I2 . Then
(I1 , d)  (I2 , e)



for all EL -concepts C: d  C I1  e  C I2 .

It follows that for any A  , we have
A  cWtnlhs
 (T1 , T2 )



(IK1 , a) 6 (IK2 , a)

where Ki = (Ti , A) for A = {A(a)} and IKi is the canonical model for Ki , i = 1, 2.
To see this, recall that by Theorem 2 for every EL-concept C, a  C IKi if, and only if,
(Ti , A) |= C(a). The latter condition is equivalent to Ti |= A v C. We have, therefore,
proved:
Theorem 30 (Lutz & Wolter, 2010). For EL-TBoxes T1 and T2 and signatures , the set
cWtnlhs
 (T1 , T2 ) can be computed in polynomial time.
The following example illustrates the use of simulations between canonical models to
determine cWtnlhs
 (T1 , T2 ).
Example 31. Let  = {A, r, B1 , B2 } and
T1 = {A v r.F0 , F0 v F1 u F2 , F1 v r.B1 , F2 v r.B2 },
T2 = {A v G1 u G2 , G1 v r.G01 , G2 v r.G02 , G01 v r.B1 , G02 v r.B2 }
656

fiThe Logical Difference for the Lightweight Description Logic EL

To check whether A  cWtnlhs
 (T1 , T2 ) consider the KBs K1 = (T1 , {A(a)}) and K2 =
(T2 , {A(a)}). Then A  cWtnlhs
 (T1 , T2 ) iff (IK1 , a) 6 (IK2 , a), for the canonical models
IK1 and IK2 of K1 and K2 , respectively. Illustrations of the canonical models IK1 and IK2
are shown below.
xran(r),B1
B1

xran(r),B2
B2

r

xran(r),B1
B1

r

r

r

A

r

xran(r),G01

xran(r),F0

IK 1

xran(r),B2
B2
xran(r),G02

r

r

A

a

a

IK2

But (IK1 , a) 6 (IK2 , a) because the point xran(r),F0 is neither -simulated by xran(r),G01 nor
-simulated by xran(r),G02 . A concept inclusion in cDiff  (T1 , T2 ) with A on the left-hand side
is given by A v r.((r.B1 ) u (r.B2 )).

5. ELHr -Instance Difference
Our polynomial-time algorithms for inseparability and logical difference in ELHr are based
on extensions of the ideas used in Section 4 for EL. There is, however, one important
difference: we introduce new logics, ELran and ELran,u,u , for which the concept difference
captures exactly the instance and, respectively, query difference in ELHr . To prove an analogue of Theorem 16 for those languages and, thereby, for the instance and query difference
for ELHr , we introduce a sequent calculus which characterises all ELran -consequences of
ELHr -terminologies. We start our investigation with the instance difference case since it is
more transparent than the concept difference case (recall that for EL there is no difference
between the instance and the concept difference).
5.1 ELran -Concept Difference
Recall Example 4 showing that ELHr -concept inseparability does not imply -instance
inseparability:
T1 = {ran(r) v A1 , ran(s) v A2 , B  A1 u A2 },

T2 = ,

 = {r, s, B}.

Notice that for the ABox A = {r(a, c), s(b, c)}, exhibiting the instance difference between
T1 and T2 , c is in the range of both r and s. This example suggests that if ran(r) and ran(s)
could be used in complex concepts, this kind of difference can be made visible for a concept
language.
Definition 32 (ELran ). C ran -concepts are constructed using the following syntax rule
C :=

A

|

ran(r)

|

C uD

|

r.C,

where A  NC , C, D range over C ran -concepts and r  NR . The set of ELran -inclusions
consists of all concept inclusions C v D and role inclusions r v s, where C is a C ran concept, D an EL-concept, and r, s  NR .
657

fiKonev, Ludwig, Walther, & Wolter

Clearly, every ELHr -inclusion is an ELran -inclusion. Additionally, in ELran -inclusions
the concept ran(r) can occur everywhere in concepts on the left-hand side of inclusions.
This gives us additional concept inclusions for the -concept difference.
Example 33. For T1 and T2 from Example 4, we have T1 |= ran(r) u ran(s) v B, but
T2 6|= ran(r) u ran(s) v B. Thus, using the C ran -concept ran(r) u ran(s) we can simulate
the ABox {r(a, c), s(b, c)} from Example 4 and make the -difference that could not be
observed in ELHr visible in ELran .
We now show that Example 33 can be generalised to arbitrary TBoxes. To this end, we
consider the following straightforward generalisation of the -concept difference to differences over ELran .
ran
r
Definition 34 (ELran
 -difference). The EL -difference between ELH -TBoxes T1 and T2
ran
is the set cDiff ran
 (T1 , T2 ) of all EL -inclusions  such that T1 |=  and T2 6|= .

To prove the equivalence between -instance difference in ELHr and -concept differran of
ence in ELran , we first associate with every ABox A and individual a in A a set CA,a
ran
C -concepts. Assume A is given. Let, inductively, for a  obj(A):
l
l
0,ran
=(
CA,a
A) u (
ran(r));
A(a)A

and
n+1,ran
=(
CA,a

l

A(a)A

A) u (

r(b,a)A

l

ran(r)) u (

r(b,a)A

l

n,ran
),
r.CA,b

r(a,b)A

and set
n,ran
ran
| n  0}
CA,a
= {CA,a
n,ran
(a) fordall n > 0. Moreover, the lemma below shows d
that, intuObserve that A |= CA,a
ran is the most specific concept with A |=
ran (a).
itively, the infinite conjunction CA,a
CA,a
Conversely, we associate an ABox with a C ran -concept. The construction is straightforward; however, some care has to be taken since we do not introduce structure sharing
but associate distinct individual names with distinct occurrences of subconcepts. Given a
C ran -concept C, we first define a path in C as a finite sequence C0  r1  C1      rn  Cn ,
where C0 = C, n  0, and ri+1 .Ci+1 is a conjunct of Ci , for 0  i < n. We use paths(C)
to denote the set of all paths in C. If p  paths(C), then tail(p) denotes the last element
Cn in p.
Now, let aran and ap for p  paths(C) be individual names and set inductively:

AC = { s(ap , aq ) | p, q  paths(C); q = p  s  C 0 , for some C 0 }
 { A(ap ) | A is a conjunct of tail(p), p  paths(C) }
 { >(ap ) | > is a conjunct of tail(p), p  paths(C) }
 { r(aran , ap ) | ran(r) is a conjunct of tail(p), p  paths(C) }
Example 35. Let C = (r.(A u ran(v))) u (s.((t.(A u ran(v))) u (t.(B u ran(s))))) be a
C ran -concept. Then AC can be represented graphically as follows.
658

fiThe Logical Difference for the Lightweight Description Logic EL

s

A
v

B

t

t

A
r

v

aran

s

aC

We only indicate aC and aran ; other individuals are identified by paths in C. Note that
different occurrences of A u ran(v) in C correspond to different individuals in AC .
Lemma 36. Let T be an ELHr -TBox, A be an ABox, C0 and D0 be C ran -concepts, and let
a0  obj(A). Then
n,ran
 (T , A) |= D0 (a0 ) if, and only if, there exists n  0 such that T |= CA,a
v D0 ;
0

 T |= C0 v D0 if, and only if, (T , AC0 ) |= D0 (aC0 ).
Below, we will employ this lemma to transfer an analogue of Theorem 16 for ELran to
ELHr -instance differences. For now, we only note the following consequence:
Corollary 37. For any two ELHr -TBoxes T1 and T2 , cDiff ran
 (T1 , T2 ) =  if, and only if,
iDiff  (T1 , T2 ) = .
n,ran
Proof. If (A, D0 (a0 ))  iDiff  (T1 , T2 ), then there exists an n  0 such that CA,a
v
0
ran
D0  cDiff ran
(T
,
T
).
Conversely,
if
C
v
D

cDiff
(T
,
T
),
then
(A
,
D
(a
))

1
2
0
0
1
2
0
C
C


0
0
iDiff  (T1 , T2 ).

Note that Theorem 6 follows from Corollary 37 since for any ELHr -TBox T without
range restrictions T |= C v D if, and only if, T |= C 0 v D, where C 0 is obtained from C
by replacing any concept of the form ran(r) in C by >.
5.2 Proof System for ELHr
The Gentzen-style proof system for ELHr consists of the rules given in Figures 1 and 5.
Cut elimination, correctness, and completeness of the proof system can be shown similarly
to the corresponding proofs given by Hofmann (2005).
Theorem 38. For all ELHr -terminologies T and C ran -concepts C and D, it holds that
T |= C v D if, and only if, T ` C v D.
We now generalise Lemma 15 to ELHr -terminologies.
Lemma 39. Let T be an ELHr -terminology, A a concept name and r.D an EL-concept.
Assume
l
l
l
T |=
ran(si ) u
Aj u
rk .Ck v r.D,
1il

1jn

1km

where Ck , 1  k  m, are C ran -concepts and l, m, n  0. Then at least one of the following
conditions holds:
659

fiKonev, Ludwig, Walther, & Wolter

r.(C u ran(r)) v D
(ExRan)
r.C v D
BvD
(Dom)
r.C v D
where r.> v B  T
AvD
(Ran)
ran(r) v D
s.C v D
(Sub)
r.C v D

where ran(r) v A  T

ran(s) v D
(RanSub)
ran(r) v D

where r v s  T

Figure 5: Additional rules for ELHr -terminologies.
(e1) there exists rk , 1  k  m, such that T |= rk v r and T |= Ck u ran(rk ) v D;
(e2) there exists Aj , 1  j  n, such that T |= Aj v r.D;
(e3) there exists rk , 1  k  m, such that T |= rk .> v r.D;
(e4) there exists si , 1  i  l, such that T |= ran(si ) v r.D.
Now assume that A is pseudo-primitive and
l
l
T |=
ran(si ) u
Aj u
1il

1jn

l

rk .Ck v A,

1km

where Ck , 1  k  m, are C ran -concepts and l, m, n  0. Then at least one of the following
conditions holds:
(a1) there exists Aj , 1  j  n such that T |= Aj v A;
(a2) there exists rk , 1  k  m such that T |= rk .> v A;
(a3) there exists si , 1  i  l such that T |= ran(si ) v A.
Proof. We prove the first part of the lemma, the second part can then be proved analogously.
d
d
d
Let C = 1il ran(si ) u 1jn Aj u 1km rk .Ck and assume that T |= C v r.D
holds. Then, we have T ` C v r.D by Theorem 38, which implies that there exists a
derivation D of the sequent C v r.D. The proof now proceeds by induction on the depth
of D, i.e. the maximal length of any path from the root to one of the leaves of D.
Notice that if l + n + m  2, the root of D can only have been derived by AndL1 or
AndL2. The lemma follows then from the induction hypothesis.
Otherwise, we have l + n + m = 1. Note that l + m + n = 0 is not possible since
T 6|= > v r.D by definition of the terminology T . If C = A1 or C = ran(s1 ), then (e2) or
(e4), respectively, hold already. It remains to consider the case where C = r1 .C1 . Then,
the rule used to derive the root of D can only have been one of Ax, Ex, ExRan, Dom or
Sub. We consider those cases one by one:
660

fiThe Logical Difference for the Lightweight Description Logic EL

 the root of D was derived with Ax: then by considering the form of the inference rule,
r1 = r and C1 = D. Hence T |= r1 v r and T |= C1 u ran(r1 ) v D, which implies
that (e1) holds.
 the root of D was derived with Ex: then r1 = r and T ` C1 v D. Hence, T |= r1 v r
and T |= C1 v D holds by Theorem 38. Thus, T |= C1 u ran(r1 ) v D and we can
infer that (e1) holds again.
 the root of D was derived with Dom: we have T ` B v r.D and r1 .> v B  T .
Then by Theorem 38, T |= B v r.D and hence, T |= r1 .> v r.D, that is, (e3)
holds.
 the root of D was derived with ExRan: we obtain T ` r1 .(C1 u ran(r1 )) v r.D.
Since the sequent r1 .(C1 u ran(r1 )) v r.D has a derivation that is of shorter length
than D, we can apply the induction hypothesis. Hence, either T |= r1 .> v r.D,
that is, (e3) holds, or T |= r1 v r and T |= (C1 u ran(r1 )) u ran(r1 ) v D. Hence (e1)
holds as |= C1 u ran(r1 ) v (C1 u ran(r1 )) u ran(r1 ).
 the root of D was derived with Sub: we obtain T ` s.C1 v r.D and r1 v s  T .
By the induction hypothesis, either T |= s.> v r.D, or T |= s v r and T |=
C1 u ran(s) v D. It can be seen that T |= r1 .> v r.D, or T |= r1 v r and
T |= C1 u ran(r1 ) v D, respectively. Hence (e3) or (e1) holds.

We now prove an extension of Theorem 16 to ELran -consequences of ELHr -terminologies.
We give a rather detailed description of the simple witness inclusions contained in members
of cDiff ran
 (T1 , T2 ) since we are going to use this result again when analysing the concept
difference in ELHr .
Theorem 40 (Primitive witness for ELran -differences). Let T1 and T2 be ELHr -terminologies
and  a signature. If   cDiff ran
 (T1 , T2 ), then either there exist {r, s}  sig() with
ran
r v s  cDiff  (T1 , T2 ) or  is of the form C v D, and one of
1. C 0 v A or ran(r) u C 0 v A,
2. A v D0 , r.> v D0 or ran(r) v D0
0
is a member of cDiff ran
 (T1 , T2 ), where r  sig(), A  sig() is a concept name, C is a
subconcept of C and D0 is a subconcept of D.
ran -concept and D an EL-concept. We
Proof. Let C v D  cDiff ran
 (T1 , T2 ), where C is a C
prove the theorem by induction on the structure of D.
Notice that D 6= > as T2 |= C v >. If D is a concept name, then an inclusion from
Point 1 exists. If D = D1 u D2 , then one of C v Di , i = 1, 2, is in cDiff ran
 (T1 , T2 ).
We can apply the induction hypothesis anddwe can infer that
an
inclusion
from
Point 1
d
d
or Point 2 exists. If D = r.D1 , let C = 1il ran(si ) u 1jn Aj u 1km rk .Ck .
Then, by Lemma 39, one of (e1)(e4) holds. Cases (e2)(e4) directly entail that an
inclusion from Point 1 or Point 2 exists. In case of (e1), either rk v r  cDiff ran
 (T1 , T2 )

661

fiKonev, Ludwig, Walther, & Wolter

or T1 |= Ck u ran(rk ) v D1 but T2 6|= Ck u ran(rk ) v D1 (as otherwise T2 |= C v D would
hold). Now we can apply the induction hypothesis to D1 and conclude that an inclusion
from Point 1 or Point 2 exists.
5.3 Instance Difference Witnesses
Similarly to Theorem 16 for the concept difference between EL-terminologies and derived from its extension, Theorem 40, for ELran , we show that every member (A, ) of
iDiff  (T1 , T2 ) gives rise to a basic witness in which either the ABox or the instance query
are atomic. To keep the formulation succinct we give an abstract description of the relationship between (A, )  iDiff  (T1 , T2 ) and its witness using only the signature of (A, ).
The interested reader will have no problem to derive a stronger relationship between (A, )
and its witness from the proof.
Theorem 41 (Primitive witness for ELHr -instance differences). Let T1 and T2 be ELHr terminologies and  a signature. If   iDiff  (T1 , T2 ), then at least one of the following
conditions holds:
1. ({r(a, b)}, s(a, b))  iDiff  (T1 , T2 ), for some r, s  sig();
2. (A, A(b))  iDiff  (T1 , T2 ), for some concept name A  sig(), individual b, and
ABox A with sig(A)  sig().
3. (A, D(b))  iDiff  (T1 , T2 ), for some singleton ABox A, individual b in A, and ELconcept D such that sig(A), sig(D)  sig();
Proof. Let (A, )  iDiff  (T1 , T2 ). We distinguish the following cases.
(a) If  = s(a, b), then (T1 , A) |= s(a, b) if, and only if, for some r(a, b)  A we have T1 |=
r v s. As (T2 , A) 6|= s(a, b) we obtain T2 6|= r v s. Thus, ({r(a, b)}, s(a, b))  iDiff  (T1 , T2 )
and Point 1 holds.
(b) Assume  = D(b) for some EL-concept D. By Lemma 36, for some n  0 we have
n,ran
n,ran
v D. By Theorem 40, one of (i) r v s, (ii) A v D0 , (iii)
v D and T2 6|= CA,b
T1 |= CA,b
r.> v D0 , (iv) ran(r) v D0 , (v) C v A, or (vi) ran(r)uC v A is a member of cDiff ran
 (T1 , T2 ),
n,ran
and D0 is a
where r  sig(), A  sig() is a concept name, C is a subconcept of CA,b
subconcept of D. If (i) r v s  cDiff ran
 (T1 , T2 ), then ({r(a, b)}, s(a, b))  iDiff  (T1 , T2 ) and
Point 1 holds.
Now let F v G denote the member of cDiff ran
 (T1 , T2 ) in the cases (ii)-(vi) above. Conran
sider the ABox AF associated with the C -concept F in Point 2 of Lemma 36. Then
sig(AF )  sig() and (AF , G(aF ))  iDiff  (T1 , T2 ).
In case (ii), we obtain that F = A is a concept name. Hence AF = {A(aF )} and Point 3
holds. For case (iii), we obtain AF = {r(aF , a> ), >(a> )} and Point 3 of the lemma applies
again (after removing >(a> ) from AF ). Similarly, if (iv), then AF = {r(aran , aF )}, and
Point 3 of the lemma holds. Finally, for the cases (v) and (vi), G  sig() is a concept
name. Hence Point 2 of the lemma applies.
Theorem 41 justifies the following finite representation of the -instance difference between ELHr -terminologies. It corresponds exactly to the three distinct points of the theorem. Assume T1 and T2 are given. Let
662

fiThe Logical Difference for the Lightweight Description Logic EL

 the set of role -instance difference witnesses, iWtnR
 (T1 , T2 ), consist of all r v s such
that T1 |= r v s and T2 6|= r v s;
 the set of right-hand -instance difference witnesses, iWtnrhs
 (T1 , T2 ), consist of all
A   such that there exists A with (A, A(a))  iDiff  (T1 , T2 );
 the set of left-hand -instance difference witnesses, iWtnlhs
 (T1 , T2 ), consist of all A  
such that there exists C(a) with ({A(a)}, C(a))  iDiff  (T1 , T2 ) and all r   such
that there exists C(c) with c = a or c = b such that ({r(a, b)}, C(c))  iDiff  (T1 , T2 ).
The set of all -instance difference witnesses is defined as
rhs
lhs
iWtn (T1 , T2 ) = (iWtnR
 (T1 , T2 ), iWtn (T1 , T2 ), iWtn (T1 , T2 )).

By Theorem 41, observe that iWtn (T1 , T2 ) = (, , ) if, and only if, iDiff  (T1 , T2 ) = . The
set iWtnR
 (T1 , T2 ) can be easily computed in polynomial time and will not be analysed further
in this paper. Thus, our aim now is to present polynomial-time algorithms computing
lhs
iWtnrhs
 (T1 , T2 ) and iWtn (T1 , T2 ).
5.4 Computing iWtnrhs
 (T1 , T2 )
We compute iWtnrhs
 (T1 , T2 ) in two different ways: first, we present the more transparent
ABox approach that works for arbitrary ELHr -terminologies, and second we present the
more efficient dynamic programming approach that works for acyclic ELHr -terminologies
only. Both approaches have been introduced in Section 4.2 for EL-terminologies. We start
with the ABox approach and exhibit a -ABox AT2 , depending on T2 and  only such that
for non-conjunctive A   there exists an ABox A such that (A, A(d))  iDiff  (T1 , T2 ) if,
and only if, (T1 , AT2 , ) |= A(A ) for a certain individual name A . The case of conjunctive
A is reduced to this condition for its defining concept names.
To deal with ELHr -terminologies rather than with EL-terminologies we have to extend
the structure of AT2 , significantly. To describe the model-theoretic properties of AT2 , , we
require the notion of a -range simulation. They capture model-theoretically the expressive
power of C ran -concepts (the concepts that have been used to describe the -instance difference in terms of subsumption, cf. Lemma 36). For any two ABoxes A1 , A2 with designated
individual names a1 and a2 , we say that a relation S between obj(A1 ) and obj(A2 ) is a
-simulation if, and only if,
(S1) (a1 , a2 )  S;
(S2) for all A  : if (a, b)  S and A(a)  A1 , then A(b)  A2 ;
(S3) for all r  : if (a, b)  S and r(a, a0 )  A1 , then there exists b0 with (a0 , b0 )  S and
r(b, b0 )  A2 .
We say that S is a -range simulation if, in addition,
(RS) for all r  : if (a, b)  S and there exists c such that r(c, a)  A1 , then there exists
c0 with r(c0 , b)  A2 .
In what follows we write
663

fiKonev, Ludwig, Walther, & Wolter

 (A1 , a1 )  (A2 , a2 ) if there exists a -simulation between (A1 , a1 ) and (A2 , a2 ); and
 (A1 , a1 ) ran
(A2 , a2 ) if there exists a -range simulation between (A1 , a1 ) and

(A2 , a2 ).
The following lemma shows that range simulations characterise C ran -concepts.
Lemma 42. Let A1 and A2 be -ABoxes with designated individual names a1 and a2 . If
ran -concepts
(A1 , a1 ) ran
 (A2 , a2 ), then (T , A1 ) |= C(a1 ) implies (T , A2 ) |= C(a2 ) for all C
C.
Proof. We apply Lemma 36. Let S be a -range simulation between A1 and A2 with
(a1 , a2 )  S. One can prove by induction on n that for all n  0, for all a  obj(A1 ) and
for all b  obj(A2 ),
n,ran
(b).
() If (a, b)  S, then A2 |= CA
1 ,a
ran Now assume that (A1 , a1 ) ran
 (A2 , a2 ) and that (T , A1 ) |= C(a1 ) holds for a C
n,ran
concept C. Then, by Lemma 36, there exists n  0 such that T |= CA1 ,a1 v C. Moreover,
n,ran
as (A1 , a1 ) ran
 (A2 , a2 ), we have by () that A2 |= CA1 ,a1 (a2 ), which then implies that
(T , A2 ) |= C(a2 ), as required.

The construction of AT , is now given in Figure 6, where T is a normalised ELHr terminology and  a signature. We advise the reader to recall the definition of AT , given
in Figure 3 for EL-terminologies T and then consider the additional ingredients required
for ELHr -terminologies. We remind the reader of the definition of non-conjT (A) from
Section 4.2:

{A}, A is non-conjunctive in T
non-conjT (A) =
{B1 , . . . , Bn }, A  B1 u    u Bn  T
In Figure 6, we also use the following sets, for A  NC and r  NR :
 preC
T (A) = { B    NC | T |= B v A },
 preDom
T (A) = { r    NR | T |= r.> v A },
 preRan
T (A) = { r    NR | T |= ran(r) v A },
 preRole
T (r) = { s    NR | T |= s v r }.
The following example illustrates the definition of AT , .
Example 43. For T1 = {ran(r) v A1 , ran(s) v A2 , B  A1 u A2 }, T2 = , and  = {r, s, B}
defined as in Example 4, we have
AT2 , = {B( ), r( ,  ), s( ,  ), r(B ,  ), s(B ,  ), r( , B ), s( , B )}.
It holds that (T1 , AT2 , ) |= B(B ) and (T2 , AT2 , ) 6|= B(B ).

664

fiThe Logical Difference for the Lightweight Description Logic EL

Let
{A | A  sig(T )   and non-conjunctive in T }  { }  NI .
be a set of individual names. For A non-conjunctive in T , define sets AT , (A) of assertions
as follows
 if A is pseudo-primitive in T , then
AT , (A) = { A0 (A ) | A0   \ preC
T (A) }
 { r(A ,  ) | r   \ preDom
T (A) }
 { r( , A ) | r   \ preRan
T (A) },
 if A  r.B  T , then for s  NR let


0
A = { (s, B 0 ) | B 0  non-conjT (B), s  preRole
T (r) \ (preDomT (A)  preRanT (B )) }

and set
AT , (A) = { A0 (A ) | A0   \ preC
T (A) }
 { s( , A ) | s   \ preRan
T (A) }

 { s(A ,  ) | s   \ (preRole
T (r)  preDomT (A)) }

 { s(A , ) | (s, )  A }.
Let
AT , = { A0 ( ) | A0   }  { r( ,  ) | r   } 

[

AT , (A)

Asig(T )
A is non-conjunctive in T

Figure 6: Construction of AT , for ELHr -terminologies.
Lemma 44. For every normalised ELHr -terminology T and signature  the following
conditions are equivalent for all -ABoxes A, A  sig(T )   non-conjunctive in T , and
all a  obj(A):
1. (T , A) 6|= A(a);
2. A  obj(AT , ) and (A, a) ran
 (AT , , A ).
Lemma 44 is proved in the appendix.
Lemma 45. Let T1 and T2 be normalised ELHr -terminologies,  a signature and A  .
Let AT2 , be the ABox constructed in Figure 6. Then the following conditions are equivalent:
 there exists a -ABox A such that (T1 , A) |= A(a) and (T2 , A) 6|= A(a);
 (T1 , AT2 , ) |= A(B ) for some B  non-conjT2 (A).
665

fiKonev, Ludwig, Walther, & Wolter

Proof. Assume there exists a -ABox A and a  obj(A) with (T1 , A) |= A(a) and (T2 , A) 6|=
A(a). Then, as (T2 , A) 6|= A(a), for some B  non-conjT2 (A), (T2 , A) 6|= B(a). Hence,
by Lemma 44, (A, a) ran
 (AT2 , , B ). But then, by Lemma 42, (T1 , AT2 , ) |= A(B ), as
required.
Conversely, suppose that (T1 , AT2 , ) |= A(B ) for some B  non-conjT2 (A) with B 
obj(AT2 , ). Notice that, by Lemma 44, (T2 , AT2 , ) 6|= B(B ). Hence (T2 , AT2 , ) 6|= A(B )
and so AT2 , and B witness Point 1.
Theorem 46. Let T1 and T2 be normalised ELHr -terminologies and  a signature. Then
iWtnrhs
 (T1 , T2 ) can be computed in polynomial time.
Proof. By Lemma 45, A  iWtnrhs
 (T1 , T2 ) if, and only if, for some B  non-conjT2 (A) we have
(T1 , AT2 , ) |= A(B ). It remains to observe that AT2 , can be constructed in polynomial
time and checking whether (T1 , AT2 , ) |= A(B ) is in polynomial time.
We now briefly describe how the dynamic programming approach for computing the set
r
iWtnrhs
 (T1 , T2 ) for acyclic terminologies is extended from EL to ELH . The extension of
the NotWitness(E) algorithm from Figure 4 to ELHr is given in Figure 7. As in Figure 4,
the procedure NotWitness(E) recursively associates with every E  sig(T1 )   a subset of
 = {All}  { A | A  (sig(T2 )  ), A is non-conjunctive in T2 }.
The conditions for A  NotWitness(E) become more complex since now one has to take into

account the sets preRan
T (E) and preDomT (E). To prove the correctness of the NotWitness
algorithm, we observe the following consequence of Lemma 36.
Corollary 47. Let T1 and T2 be normalised acyclic ELHr -terminologies and  a signature.
ran -concept C such that C v A  cDiff ran (T , T ) }.
Then iWtnrhs
1 2
 (T1 , T2 ) = { A   |  C

Proof. First, let A  iWtnrhs
 (T1 , T2 ). Then there exists a -ABox A such that (T1 , A) |=
A(a) and (T2 , A) 6|= A(a). Hence, by Point 1 of Lemma 36 there exists n  0 such that
n,ran
n,ran
ran -concept. Conversely, assume A  
CA,a
v A  cDiff ran
 (T1 , T2 ). Note that CA,a is a C
such that there exists a C ran -concept C with C v A  cDiff ran
 (T1 , T2 ). Then by Point 2 of
Lemma 36, (AC , A(aC ))  iDiff  (T1 , T2 ), i.e. A  iWtnrhs
(T
,
T2 ).
1

We now formulate the correctness of the NotWitness algorithm in the same way as in
Corollary 26.
Theorem 48. Let T1 and T2 be normalised acyclic ELHr -terminologies and  a signature.
Then iWtnrhs
 (T1 , T2 ) = { A  sig(T1 )   |  B  non-conjT2 (A) with B 6 NotWitness(A) }.
The proof is an extension of the proofs of Lemma 25 and Corollary 26. Namely, one can
show that for all A  sig(T1 )   and all B  sig(T2 )   such that B is non-conjunctive
in T2 the following conditions are equivalent:
 B  NotWitness(A);
ran -concepts C: T 6|= C v B implies T 6|= C v A.
 for all C
2
1

Using Corollary 47, we thus obtain for every A  : A  iWtnrhs
 (T1 , T2 ) if, and only if,
ran
there exists a C -concept C with T2 6|= C v A and T1 |= C v A if, and only if, there exists
B  non-conjT2 (A) with B 6 NotWitness(A).
666

fiThe Logical Difference for the Lightweight Description Logic EL

procedure AuxPP (E)


if preC
T1 (E) =  and preRanT1 (E) =  and preDomT1 (E) =  then
return {All}
else

Auxconcept := { A   | preC
T1 (E)  preCT2 (A) }

Auxran := { A   | preRanT1 (E)  preRan
T2 (A) }

Auxdom := { A   | preDomT1 (E)  preDom
T2 (A) }
return Auxconcept  Auxran  Auxdom
end if
end procedure
procedure NotWitness(E)
if E is pseudo-primitive in T1 then
NotWitness(E) := AuxPP (E)
else if E  E1 u    uSEk  T1 then
k
NotWitness(E) := i=1 NotWitness(Ei )
else if E  r.E 0  T1 then
0
if preRole
T1 (r) =  or All  NotWitness(E ) then
NotWitness(E) := AuxPP (E)
else
fi


fi A is pseudo-primitive in T , and
fi
Auxrole,prim := A   fi

preRole
T1 (r)  preDomT2 (A)
fi

fi A  t.B  T2 ,

fi


fi





fi preRoleT1 (r)  preRoleT2 (t)  preDomT2 (A), and


fi




fi for all s  preRoleT (r)  preRoleT (t) with
1
2
Auxrole,exist := A   fifi

0

s

/
preDom
(A)
and
B

non-conj
fi

T2 (B) with
T2

fi


0
00

fi

s

6
preRan
(B
),
there
exists
E

non-conjT1 (E 0 )
T2

fi


00
0
00
fi
with B  NotWitness(E ) and s 6 preRan
T1 (E )
NotWitness(E) := (Auxrole,prim  Auxrole,exist )  AuxPP (E)
end if
end if
end procedure





















Figure 7: Computation of NotWitness(E) for ELHr .
5.5 Tractability of iWtnlhs
 (T1 , T2 )
We prove the tractability of iWtnlhs
 (T1 , T2 ) by the same reduction to simulation checking as
in the case of EL-terminologies (Theorem 30).
Theorem 49. Let T1 and T2 be ELHr -TBoxes and let  be a signature. Then the set
iWtnlhs
 (T1 , T2 ) can be computed in polynomial time.
Proof. For any concept name A   we have
A  iWtnlhs
 (T1 , T2 )


667

(IK1 , a) 6 (IK2 , a)

fiKonev, Ludwig, Walther, & Wolter

where Ki = (Ti , A) for A = {A(a)} and IKi is the canonical model for Ki , i = 1, 2. Indeed,
({A(a)}, C(a))  iDiff  (T1 , T2 ), for some EL -concept C, if, and only if, by Theorem 2, a 
C IK1 and a 
/ C IK2 . But this condition is, by Lemma 29, equivalent to (IK1 , a) 6 (IK2 , a).
The latter condition can be checked in polynomial time.
Similarly, for any role name r   we have
r  iWtnlhs
 (T1 , T2 )



(IK1 , a) 6 (IK2 , a) or (IK1 , b) 6 (IK2 , b)

where Ki = (Ti , A), A = {r(a, b)}, and IKi is the canonical model for Ki , i = 1, 2. Again,
the latter condition can be checked in polynomial time.

6. ELHr -Concept Difference
In this section we present polynomial-time algorithms deciding -concept inseparability and
computing a succinct representation of the concept difference between ELHr -terminologies.
The algorithms are essentially by reduction to the instance difference case.
We start by introducing the succinct representation of the -concept difference. Let
T1 and T2 be ELHr -terminologies. Since cDiff  (T1 , T2 )  cDiff ran
 (T1 , T2 ), it follows from
Theorem 40 for C v D  cDiff  (T1 , T2 ) that there exists an inclusion of at least one of the
following forms
(i) C 0 v A,
(ii) ran(r) u C 0 v A,
(iii) A v D0 ,
(iv) r.> v D0 , or
(v) ran(r) v D0
in cDiff  (T1 , T2 ), where r  sig(), A  sig() is a concept name, C 0 is a subconcept of C
and D0 is a subconcept of D. Notice in particular for case (ii) that C 0 is an EL-concept.
Hence, just as in the case of the -instance difference, we obtain the following representation
of the -concept difference. Assume T1 and T2 are given. Let
 the set of role inclusion -concept difference witnesses, cWtnR
 (T1 , T2 ), consist of all
r v s such that T1 |= r v s and T2 6|= r v s;
 the set of right-hand -concept difference witnesses, cWtnrhs
 (T1 , T2 ), consist of all
A   such that there exists an EL-concept C with either C v A  cDiff  (T1 , T2 ) or
there additionally exists a role name r   such that ran(r) u C v A  cDiff  (T1 , T2 ).
 the set of left-hand -concept difference witnesses, cWtnlhs
 (T1 , T2 ), consist of all A  
such that there exists an EL-concept C with A v C  cDiff  (T1 , T2 ), and of all
role names r   such that there exists an EL-concept C with either r.> v C 
cDiff  (T1 , T2 ) or ran(r) v C  cDiff  (T1 , T2 ).
The set of all -concept difference witnesses is defined as
rhs
lhs
cWtn (T1 , T2 ) = (cWtnR
 (T1 , T2 ), cWtn (T1 , T2 ), cWtn (T1 , T2 )).

668

fiThe Logical Difference for the Lightweight Description Logic EL

Observe that cWtn (T1 , T2 ) = (, , ) if, and only if, cDiff  (T1 , T2 ) = . We also obtain
lhs
that the sets cWtnR
 (T1 , T2 ) and cWtn (T1 , T2 ) coincide with the corresponding witness sets
for the instance difference, which allows us to re-use some results that we have developed
for detecting instance differences.
Lemma 50. Let T1 and T2 be normalised ELHr -terminologies and  a signature. Then the
following holds:
R
1. cWtnR
 (T1 , T2 ) = iWtn (T1 , T2 ),
lhs
2. cWtnlhs
 (T1 , T2 ) = iWtn (T1 , T2 )
rhs
3. cWtnrhs
 (T1 , T2 )  iWtn (T1 , T2 )
lhs
Proof. Point 1 follows directly from the definition. Proving cWtnlhs
 (T1 , T2 )  iWtn (T1 , T2 )
rhs
and cWtnrhs
 (T1 , T2 )  iWtn (T1 , T2 ) is similar to Lemma 10. Finally, to prove that
lhs
lhs
iWtn (T1 , T2 )  cWtn (T1 , T2 ), assume that A  iWtnlhs
 (T1 , T2 ). Then there exists an ELconcept D(a) with ({A(a)}, D(a))  iDiff  (T1 , T2 ). But then T1 |= A v D and T2 6|= A v D
lhs
and, therefore, A  cWtnlhs
 (T1 , T2 ). The argument for r  iWtn (T1 , T2 ) is similar.

We have presented polynomial-time algorithms which can compute iWtnlhs
 (T1 , T2 ) and
rhs
iWtnR
(T
,
T
).
Thus,
it
remains
to
analyse
cWtn
(T
,
T
).
1
2
1
2


6.1 Tractability of cWtnrhs
 (T1 , T2 )
We prove tractability of cWtnrhs
 (T1 , T2 ) by modifying the ABox AT2 , that has been introrhs
duced to prove tractability of iWtnrhs
 (T1 , T2 ). Recall that A  iWtn (T1 , T2 ) iff (T1 , AT2 , ) |=
A(B ) for some B  non-conjT2 (A) (cf. Lemma 45). Not all A satisfying this condition are in
cWtnrhs
 (T1 , T2 ) since the ABox AT2 , cannot always be captured by a set of EL-concepts
(cf. Example 4). Our modification of AT2 , is motivated by the observation that if an ABox
A does not contain any individual in the range of two distinct role names, then EL-concepts
rather than C ran -concepts are sufficient to capture the consequences of the ABox. Thus, we
are going to modify AT2 , in a minimal way so that the resulting ABox does not contain
any individual name in the range of two distinct role names.
Definition 51. An ABox A is role-splitting if there is no pair of assertions r(a, c), s(b, c) 
A, for individual names a, b, c and distinct role names r, s.
The following lemma states the main property of role-splitting ABoxes.
Lemma 52. Let T1 and T2 be normalised ELHr -terminologies,  a signature with A  
and let A be a role-splitting -ABox such that (T1 , A) |= A(a) and (T2 , A) 6|= A(a). Then
A  cWtnrhs
 (T1 , T2 ).
n,ran
n,ran
Proof. By Lemma 36, there exists n  0 such that T1 |= CA,a
v A and T2 6|= CA,a
v A.
Assume first that there does not exist b  obj(A) and r   such that r(b, a)  A. Then,
n,ran
by definition and since A is role-splitting, ran(r) only occurs in CA,a
in the direct scope
n,ran
of the existential restriction r. Hence CA,a is equivalent to an EL -concept, and we
are done. Now assume there exists r(b, a)  A. Then, again since A is role-splitting,
n,ran
CA,a
is equivalent to a concept ran(r) u C, where C is an EL -concept. In this case
T1 |= ran(r) u C v A and T2 6|= ran(r) u C v A, as required.

669

fiKonev, Ludwig, Walther, & Wolter

For a -ABox A such that sig(A)  NR 6= , we define its role-splitting unfolding A
with individuals { ar | a  obj(A), r  sig(A)  NR } by setting
A = { A(ar ) | A(a)  A, r  sig(A)  NR }  { r(as , br ) | r(a, b)  A, s  sig(A)  NR }.
Example 53. Consider T1 = {ran(r) v A1 , ran(s) v A2 , B  A1 u A2 }, T2 = ,  =
{r, s, B} and A = {r(a, c), s(b, c)} from Example 4. We have (T1 , A) |= B(c) but (T2 , A) 6|=
B(c). Notice that the role-splitting unfolding A = {r(ar , cr ), r(as , cr ), s(br , cs ), s(bs , cs )}
does not contain any individual in the range of more than one role
c

A

cr

A

cs
r

r

s

r

a

b

ar

s
s

br

as

bs

and (T1 , A ) 6|= B(cr ), (T1 , A ) 6|= B(cs ).
We apply the role-splitting unfolding to the ABox AT , from Figure 6. The following
result is the concept version of Lemma 44 and is proved in the appendix by a reduction to
Lemma 44. The ABox AC corresponding to an EL-concept C has been introduced before
Lemma 36. For simplicity, we consider signatures  containing at least one role name.
Lemma 54. For every normalised ELHr -terminology T , signature  such that   NR 6= ,
concept name A that is non-conjunctive in T , role name r  , and EL -concepts C the
following conditions are equivalent for D = C and D = ran(r) u C:
 T 6|= D v A;

 for some r    NR , (A )r  obj(AT , ) and (AD , aD ) ran
 (AT , , (A )r ).

The following lemma can now be proved similarly to Lemma 45, using Lemma 54 instead
of Lemma 44.
Lemma 55. Let T1 and T2 be normalised ELHr -terminologies,  a signature with A  
such that   NR 6= . Then the following conditions are equivalent:
 A  cWtnrhs
 (T1 , T2 );
 there exists r   such that (T1 , AT2 , ) |= A((B )r ) for some B  non-conjT2 (A).
Proof. Assume that A  cWtnrhs
 (T1 , T2 ). Then, there either exists an EL -concept C
with T1 |= C v A and T2 6|= C v A, or there additionally exists r   such that T1 |=
ran(r) u C v A and T2 6|= ran(r) u C v A. Hence, for D = C and D = ran(r) u C,
respectively, T2 6|= D v B, for some B  non-conjT2 (A), and by Lemma 54, there exists

r   with (A )r  obj(AT , ) and (AD , aD ) ran
 (AT2 , , (B )r ). But then, by Lemma 42
(T1 , AT2 , ) |= A((B )r ) as (T1 , AD ) |= A(aD ) holds by Lemma 36.
For the converse direction, it is easy to see that (B )r  obj(AT2 , ), B  obj(AT2 , ), and

(AT2 , , (B )r ) ran
 (AT2 , , B ), which implies that (T2 , AT2 , ) 6|= A((B )r ) by Lemma 44.
Consequently, we obtain A  cWtnrhs
 (T1 , T2 ) by applying Lemma 52 and by using the fact
that the ABox AT2 , is role-splitting.
670

fiThe Logical Difference for the Lightweight Description Logic EL

Finally, we obtain the tractability result.
Theorem 56. Let T1 and T2 be ELHr -terminologies and  a signature. Then the set
cWtnrhs
 (T1 , T2 ) can be computed in polynomial time.
rhs
Proof. If   NR = , then cWtnrhs
 (T1 , T2 ) = iWtn (T1 , T2 ), which can be computed in
polynomial time by Theorem 46.
Otherwise   NR 6=  and the result follows from Lemma 55 and the fact that AT2 ,
can be constructed in polynomial time in the size of T2 .

7. ELHr -Query Difference
To investigate the query difference between ELHr -terminologies, we introduce the language
ELran,u,u that extends ELran with the universal role and intersections of roles. We show
that concept differences in ELran,u,u correspond to query differences in ELHr . For ELran,u,u
we can prove an analogue of Theorem 40, which states that any inclusion in the concept
difference contains an inclusion in which either the left-hand side or the right-hand side
is atomic. Using the correspondence between concept difference in ELran,u,u and query
difference in ELHr we then obtain a meaningful definition of a succinct representation of
the query difference qDiff  (T1 , T2 ). Finally, we provide polynomial-time algorithms deciding
-query inseparability and computing the succinct representation of the query difference.
7.1 ELran,u,u -Concept Difference
We start this section by defining the language ELran,u,u .
Definition 57 (ELran,u,u ). Let u (the universal role) be a fresh logical symbol. C u,u concepts are constructed using the following syntax rule
C :=

A

|

C uD

|

R.C

|

u.C,

where A  NC , C, D range over C u,u -concepts and R = r1 u    u rn with r1 , . . . , rn  NR for
some n  1. The set of ELran,u,u -inclusions consists of concept inclusions C v D and role
inclusions r v s, where C is a C ran -concept, D a C u,u -concept, and r, s  NR .
The semantics of the additional constructors is straightforward by setting, for any interpretation I,
 (r1 u    u rn )I = rI1      rnI ;
 uI = I  I .
Note that we regard the universal role u as a logical symbol; i.e., u 6 NR and sig(u.C) =
sig(C) for any concept C. Assuming that u is a logical symbol reflects the fact that its firstorder translation uses no non-logical symbols. For example, the signature of the first-order
translation x.A(x) of u.A does not contain any non-logical symbols with the exception
of A itself.
It will be convenient to decompose C u,u -concepts. The set of C u -concepts is defined as
the set of all C u,u -concepts without the universal role. Every C u,u -concept C is equivalent
671

fiKonev, Ludwig, Walther, & Wolter

to a concept of the form D0 u u.D1 u    u u.Dk , where D0 , . . . , Dk are C u -concepts. To
see this, observe that any concept C with a subconcept u.D is equivalent to u.D u C 0 ,
where C 0 is obtained from C by replacing all occurrences of u.D by >. For example,
A u r.(B u u.E) is equivalent to the concept u.E u A u r.(B u >).
u,u
u ) the set of all C u,u (C u ) concepts whose signature
In the following we denote by C
(C
is contained in .
Clearly, every ELran -inclusion is an ELran,u,u -inclusion. In addition, role conjunctions
and the universal role in ELran,u,u -inclusions can be used to capture differences between
ELHr -TBoxes that cannot be captured by ELHr -inclusions.
Example 58. We first reconsider Example 8. Recall that
T1 = ,

T2 = {A v r.B},

 = {A, B}.

Then T2 |= A v u.B but T1 6|= A v u.B and, as the universal role is regarded as a
logical symbol, sig(A v u.B)  . Thus, by employing the universal role ELran,u,u we can
simulate the query difference ({A(a)}, x.B(x)) using the subsumption A v u.B.
Second, we reconsider Example 9. Recall that
T1 = {A v s.>, s v r1 , s v r2 },

T2 = {A v r1 .> u r2 .>},

 = {A, r1 , r2 }.

Then T1 |= A v (r1 u r2 ).> and T2 6|= A v (r1 u r2 ).>. Thus, we can simulate the query
difference ({A(a)}, x.(r1 (a, x)  r2 (a, x))) using the subsumption A v (r1 u r2 ).>.
We introduce the appropriate notion of -concept difference for ELran,u,u .
ran,u,u
Definition 59 (EL
-difference). The ELran,u,u
-difference between ELHr -TBoxes T1

ran,u,u
ran,u,u
-inclusions  such that T1 |=  and
(T1 , T2 ) of all EL
and T2 is the set cDiff 
T2 6|= .

We now extend Lemma 39 for concepts that use the universal role or conjunctions of
roles.
Lemma 60. Let T be an ELHr -terminology and R.D a C u -concept with R = t1 u    u tq
a conjunction of role names. Assume
l
l
l
T |=
ran(si ) u
Aj u
rk .Ck v R.D,
1il

1jn

1km

where Ck , 1  k  m, are C ran -concepts and l, m, n  0. Then at least one of the following
conditions holds:
(e1u ) there exists rk , 1  k  m, such that rk vT t1 ,. . . , rk vT tq , and T |= Ck uran(rk ) v
D;
(e2u ) there exists Aj , 1  j  n, such that T |= Aj v R.D;
(e3u ) there exists rk , 1  k  m, such that T |= rk .> v R.D;
(e4u ) there exists si , 1  i  l, such that T |= ran(si ) v R.D.
672

fiThe Logical Difference for the Lightweight Description Logic EL

If u is the universal role and T |= C v u.D, where C is a C ran -concept and D is a
C u -concept, then at least one of the following holds:
(e1u ) there exists a subconcept r.C 0 of C such that T |= C 0 u ran(r)v D;
(e2u ) there exists a concept name A in C such that T |= A v u.D;
(e3u ) there exists a role name r in C such that T |= r.> v u.D;
(e4u ) there exists a role name r in C such that T |= ran(r) v u.D;
(e5u ) T |= C v D;
(e6u ) there exists a subconcept (ran(r) u C 0 ) of C such that T |= r.C 0 v D.
Theorem 61 (Primitive witnesses for ELran,u,u ). Let T1 and T2 be ELHr -terminologies
ran,u,u
and  a signature. If   cDiff 
(T1 , T2 ), then either there exist {r, s}  sig() with
ran,u,u
r v s  cDiff 
(T1 , T2 ) or  is of the form C v D, and one of
1. C 0 v A
2. A v D0 , r.> v D0 or ran(r) v D0
is a member of cDiff ran,u,u
(T1 , T2 ), where A  sig() is a concept name, r  sig() is a role

0
ran
name, C is a C -concept, D0 is a C u,u -concept, and sig(C 0 ), sig(D0 )  sig().
Proof. Let C v D  cDiff ran,u,u
(T1 , T2 ), where C is a C ran -concept and D a C u,u -concept.

We prove the result by induction on the structure of D. The proof is verydsimilar to the
proof of Theorem
d
d 40 and so we consider the case D = u.D1 only. Let C = 1il ran(si ) u
1jn Aj u 1km rk .Ck . Then, by Lemma 60, one of (e1u )(e6u ) holds.
Cases (e2u )(e4u ) directly entail the existence of an inclusion from Point 2 of the
theorem. In case (e1u ) there exists a subconcept r.C 0 of C such that T1 |= C 0 uran(r) v D1 .
We have that T2 6|= C 0 u ran(r) v D1 as otherwise we have T2 |= r.C 0 v r.D1 , i.e.
(T1 , T2 ). We can apply the
T2 |= C v D would hold. Thus, C 0 u ran(r) v D1  cDiff ran,u,u

induction hypothesis to D1 and infer that an inclusion from Point 1 or Point 2 exists.
(T1 , T2 ) as otherwise T2 |= C v
Similarly, for case (e5u ), we have C v D1  cDiff ran,u,u

D1 , i.e. T2 |= C v D due to D = u.D1 . By applying the induction hypothesis to D1 , we
obtain that an inclusion from Point 1 or Point 2 exists.
Finally, in case (e6u ) there exists a subconcept ran(r) u C 0 of C such that T1 |= r.C 0 v
D1 . Observe first that for every model I of T2 and for every d  C I , there exists d0 
(ran(r) u C 0 )I , which implies that there exists d00  (r.C 0 )I . If we now assume that
T2 |= r.C 0 v D1 , it would follow that for every model I of T2 and for every d  C I ,
there exists d00  D1I , i.e. T2 |= C v u.D1 would hold. We can infer that r.C 0 v D1 
ran,u,u
cDiff 
(T1 , T2 ) and by applying the induction hypothesis to D1 , we conclude that an
inclusion from Point 1 or Point 2 exists.
7.2 Query Difference Witnesses
We start by connecting concept differences in ELran,u,u with query differences between
ELHr -terminologies. The direction from query differences in ELHr to concept differences
in ELran,u,u is straightforward: observe that every assertion C(a) with C a C u,u -concept can
673

fiKonev, Ludwig, Walther, & Wolter

be regarded as a Boolean conjunctive query qC,a . For example, the assertion (u.Aur.B)(a)
is equivalent to the conjunctive query xy.(A(x)r(a, y)B(y)) (details of the translation
are provided in the appendix). We obtain (where AC is the ABox defined before Lemma 36):
Lemma 62. For any two ELHr -TBoxes T1 and T2 and signature , we have C v D 
cDiff ran,u,u
(T1 , T2 ) if, and only if, (AC , qD,aC )  qDiff  (T1 , T2 ).

In what follows we will not distinguish between an assertion C(a) with C a C u,u -concept
and the conjunctive query qC,a . It follows from Lemma 62 that if qDiff  (T1 , T2 ) = , then
cDiff ran,u,u
(T1 , T2 ) = .

We come to the (considerably more involved) direction from query differences to concept
differences in ELran,u,u . The following lemma provides a rather abstract description of how
inclusions in qDiff  (T1 , T2 ) are reflected by members of cDiff ran,u,u
(T1 , T2 ) by stating that

they are given in the same signature.
Lemma 63. For any two ELHr -TBoxes T1 and T2 and signature , if   qDiff  (T1 , T2 ),
(T1 , T2 ) with sig(0 )  sig().
then there exists 0  cDiff ran,u,u

The interested reader can extract a more detailed description from the proof given in the
appendix. The proof of Lemma 63 given in the appendix is model-theoretic and employs
the close relationship between conjunctive query entailment and homomorphisms (Chandra
& Merlin, 1977). The intuition behind the result, however, is rather straightforward: if
(T , A) |= q[~a] for a conjunctive query q(~x) = ~y (~x, ~y ) and ELHr -TBox T , then for every
model I of (T , A) there is a mapping  from the variables ~x and ~y into I such that ~a is a
-match of q(~x) and I. (T , A) has models that are essentially forest-shaped: they consist
of tree-shaped models attached to the ABox individuals in A (cf. Lutz et al., 2009). In
such forest-shaped models, the individuals from ~y that are not mapped to individuals in
A are mapped to the trees attached to the ABox individuals. Such a mapping, however,
exists already for a conjunctive query q 0 such that q is a homomorphic image of q 0 and q 0 is
essentially forest-shaped: the individuals not mapped to ABox individuals form trees that
are attached to the core of q 0 that is mapped to the ABox individuals. In other words, we
obtain q 0 by partitioning q into a core and into subsets that correspond to C u,u -concepts!
Now, if there exists a -ABox A and a conjunctive -query q(~a) such that (T2 , A) |= q[~a]
and (T1 , A) 6|= q[~a], then we find such a conjunctive -query q 0 with the same behaviour as
q that is essentially forest-shaped. From (A, q 0 ) one can then obtain the required ELran,u,u inclusion C v D, where D captures some subtree of the query q 0 (a C u,u -concept) and C
(a C ran -concept) the ABox A. The intuition for the last step is exactly the same as for
Lemma 36.
We note that the result holds for general TBoxes and not only terminologies. From
Lemma 63 and Theorem 61, we directly obtain the following description of primitive witnesses for query differences.
Theorem 64 (Primitive witness for ELHr -query differences). Let T1 and T2 be ELHr terminologies and  a signature. If   qDiff  (T1 , T2 ), then at least one of the following
conditions holds (for some individual names a, b):
1. ({r(a, b)}, s(a, b))  qDiff  (T1 , T2 ), for some r, s  sig();
674

fiThe Logical Difference for the Lightweight Description Logic EL

2. (A, A(b))  qDiff  (T1 , T2 ), for some concept name A  sig() and ABox A with
sig(A)  sig();
3. (A, D(b))  qDiff  (T1 , T2 ), for some singleton ABox A and C u,u -concept D such that
sig(A), sig(D)  sig().
Observe that Theorem 64 coincides with Theorem 41 with the exception that in Point 3
the concept D can now be a C u,u -concept. We can, therefore, define the following finite
representation of the -query difference. Assume T1 and T2 are given. Define the set
 qWtnR
 (T1 , T2 ) of role -query difference witnesses as the set of role -instance differR
ence witnesses; i.e., qWtnR
 (T1 , T2 ) = iWtn (T1 , T2 );
 qWtnrhs
 (T1 , T2 ) of right-hand -query difference witnesses as the set of right-hand
rhs
-instance difference witnesses; i.e., qWtnrhs
 (T1 , T2 ) = iWtn (T1 , T2 );
 qWtnlhs
 (T1 , T2 ) of left-hand -instance difference witnesses as the set of all A   such
that there exists a C u,u -concept C with ({A(a)}, C(a))  qDiff lhs
 (T1 , T2 ) and all r  
u,u
such that there exists a C -concept C such that ({r(a, b)}, C(c))  qDiff  (T1 , T2 ) for
c = a or c = b.
The set of all -query difference witnesses is defined as
rhs
lhs
qWtn (T1 , T2 ) = (qWtnR
 (T1 , T2 ), qWtn (T1 , T2 ), qWtn (T1 , T2 )).

By Theorem 64, qWtn (T1 , T2 ) = (, , ) if, and only if, qDiff  (T1 , T2 ) = . Algorithms
rhs
computing qWtnR
 (T1 , T2 ) and qWtn (T1 , T2 ) have been presented in the section on instance
difference. It thus remains to consider qWtnlhs
 (T1 , T2 ).
7.3 Tractability of qWtnlhs
 (T1 , T2 )
u,u -concepts
To prove tractability of qWtnlhs
 (T1 , T2 ) we first capture the expressive power of C
using a stronger form of simulation between interpretations. Let I1 and I2 be interpretations. A -simulation S between I1 and I2 is called a global intersection preserving
-simulation if, in addition,

 for every d  I1 there exists a d0  I2 with (d, d0 )  S;
 if (d, e)  S, d0  I1 , and R = {r   | (d, d0 )  rI1 } =
6 , then there exists e0 with
(e, e0 )  S and (d0 , e0 )  rI2 for all r  R.
We write (I1 , d) 
 (I2 , e) if there exists a global intersection preserving -simulation S
between I1 and I2 such that (d, e)  S.
Lemma 65. Let I1 and I2 be finite interpretations,  a signature, d  I1 , and e  I2 .
Then
u,u
(I1 , d) 

for all C  C
: d  C I1  e  C I2 .
 (I2 , e)
It can be checked in polynomial time whether (I1 , d) 
 (I2 , e).
675

fiKonev, Ludwig, Walther, & Wolter

The proof is a straightforward extension of the proof of Lemma 29 and the polynomialtime algorithm deciding the existence of -simulations.
We observe that Theorem 2 about the properties of the canonical model IK of a KB K
can be extended to C u,u -concepts (in the appendix, the proof is given for C u,u -concepts as
well). Namely, we have for all C u,u -concepts C0 :
 K |= C0 (a) if, and only if, aIK  C0IK .
 T |= C u D v C0 if, and only if, xC,D  C0IK .
It follows that for any concept name A  , we have
A  qWtnlhs
 (T1 , T2 )



(IK1 , a) 6
 (IK2 , a),

where Ki = (Ti , A) and A = {A(a)}, for i = 1, 2. We also have for every role name r  
that

r  qWtnlhs
 (IK1 , a) 6
 (T1 , T2 )
 (IK2 , a) or (IK1 , b) 6 (IK2 , b)
where Ki = (Ti , A) and A = {r(a, b)}, for i = 1, 2. Thus, we obtain the following tractability
result:
Theorem 66. Let T1 and T2 be ELHr -terminologies and  a signature. Then the set
qWtnlhs
 (T1 , T2 ) can be computed in polynomial time.

8. Implementation and Experiments
In this section, we describe an experimental evaluation of the theoretical work developed above. Our experiments employ the CEX2 tool.4 In CEX2, we have implemented
polynomial-time algorithms which, given acyclic ELHr -terminologies T1 and T2 and a signature  as input, compute witnesses for the concept difference cDiff  (T1 , T2 ) and the
instance difference iDiff  (T1 , T2 ).5
CEX2 is written in OCaml and the reasoner CB (Kazakov, 2009) is internally used as
classification engine. In the implementation of CEX2, we have employed the algorithms
developed in this paper. In more detail, for the instance difference case for acyclic ELHr terminologies T1 and T2 ,
 to compute iWtnR
 (T1 , T2 ), CEX2 performs a straightforward comparison of the role
inclusion chains entailed by the terminologies T1 and T2 ;
 to compute iWtnrhs
 (T1 , T2 ), CEX2 uses the NotWitness algorithm in Figure 7 and then
employs Theorem 48;
 to compute iWtnlhs
 (T1 , T2 ), CEX2 checks for the existence of a -simulation between
the canonical models (Theorem 49).
4. Available under an open-source license at http://www.csc.liv.ac.uk/~michel/software/cex2/
5. An extended version of CEX2 computing witnesses for the query difference qDiff  (T1 , T2 ) as well is
presented by (Konev, Ludwig, & Wolter, 2012). In addition, Konev et al. describe experiments comparing
query difference witnesses with concept and instance difference witnesses that are not presented in this
paper.

676

fiThe Logical Difference for the Lightweight Description Logic EL

The output for iWtnlhs
 (T1 , T2 ) is partitioned into three sets:
 the set of left-hand atomic -instance difference witnesses, iWtnlhs,A
(T1 , T2 ), which is

defined as the set of all concept names A   such that there exists an EL-concept C
such that ({A(a)}, C(a)})  iDiff  (T1 , T2 ) (equivalently A v C  cDiff  (T1 , T2 ));
 the set of left-hand domain -instance difference witnesses, iWtnlhs,dom
(T1 , T2 ), which

is defined as the set of all role names r   such that there exists an EL-concept C
with ({r(a, b)}, C(a))  iDiff  (T1 , T2 ) (equivalently, r.> v C  cDiff  (T1 , T2 )); and
 the set of left-hand range -instance difference witnesses, iWtnlhs,ran
(T1 , T2 ), which is

defined as the set of all role names r   such that there exists an EL-concept C with
({r(a, b)}, C(b))  iDiff  (T1 , T2 ) (equivalently, ran(r) v C  cDiff  (T1 , T2 )).
Obviously, it holds that:
lhs,A
iWtnlhs
(T1 , T2 )  iWtnlhs,dom
(T1 , T2 )  iWtnlhs,ran
(T1 , T2 ).
 (T1 , T2 ) = iWtn



For the concept difference case, recall that
R
cWtnR
 (T1 , T2 ) = iWtn (T1 , T2 ),

lhs
cWtnlhs
 (T1 , T2 ) = iWtn (T1 , T2 ),

and so we use the same algorithms as in the instance case. We also set
(T1 , T2 ) = iWtnlhs,X (T1 , T2 )
cWtnlhs,X

rhs
for X  {A, dom, ran}. To compute iWtnrhs
 (T1 , T2 ), CEX2 exploits that cWtn (T1 , T2 ) 
rhs
rhs
iWtn (T1 , T2 ) (Lemma 50) and first computes iWtn (T1 , T2 ) and then checks using a
straightforward variant of the NotWitness algorithm for concept differences whether A 
cWtnrhs
 (T1 , T2 ).
In the following three subsections we describe the experiments that we have conducted.
The experimental settings were as follows. All programs were run on PCs equipped with
an Intel Core 2 Duo E6400 CPU and 3 GiB of main memory. Version 2.0.1 of CEX2 was
used.

8.1 Comparing Different Versions of Snomed CT
We applied CEX2 to compare a January 2009 (SM09a) and a July 2009 (SM09b) version of Snomed CT. SM09a and SM09b contain 310013 and 307693 concept names, respectively. Both versions use the same 62 role names, and they contain role inclusions
but no domain or range restrictions are present. Consequently, one can infer from Corollary 47 that iWtn (SM09b, SM09a) = cWtn (SM09b, SM09a). In what follows we consider
cWtn (SM09b, SM09a) only.
For our experiments we used signatures ranging over so called Snomed CT subsets,
which are employed in the UK for the deployment of Snomed CT in specific areas. We compared SM09a with SM09b on 159 such signatures  by computing cWtn (SM09b, SM09a)
for each of these sets . The considered signatures always contain all of the 62 Snomed
CT role names. The comparisons which resulted in a non-empty difference are reproduced
677

fiKonev, Ludwig, Walther, & Wolter

in Table 2. In none of the cases, differences regarding role inclusions have been detected. In
Table 2, the second column gives the number of concept names in the respective subset ,
and the third and fifth column the number of concept witness differences. Observe that the
number of differences does not correlate with the size of the considered signatures , i.e.
there exist signatures that are somewhat comparable in size, but induce a greatly varying
number of difference witnesses (see e.g. the subsets Diagnosis and Manumat).
In order to determine how many difference witnesses computed by CEX2 can be obtained
from a straightforward comparison of the class hierarchies already, we have also computed
the sets
clsWtnlhs
 (SM09b, SM09a) = { A   |  B   : A v B  cDiff  (SM09b, SM09a) }
and
clsWtnrhs
 (SM09b, SM09a) = { B   |  A   : A v B  cDiff  (SM09b, SM09a) }
for each of the considered comparison signatures . The results that we have obtained are
also depicted in Table 2. One can see that often a great number of differences cannot be
detected by considering the classification difference only.
In the last three columns of Table 2, we give the CPU times required for computing all
concept witnesses:
 first, the times are given when CEX2 is directly applied to the full terminologies
SM09a and SM09b;
 second, the times are given when one first extracts -modules using the module extraction tool MEX (Konev, Lutz, Walther, & Wolter, 2008) from SM09a and, respectively,
SM09b and then applies CEX2 to the extracted -modules. Observe that a -module
extracted by MEX is -query (and, therefore, -concept and -instance) inseparable
from the whole terminology. Thus, the computed concept witnesses are the same.
 finally, the times are given if, in addition to computing concept witnesses from the full
terminologies SM09a and SM09b, CEX2 also computes examples of concept inclusions
in the logical difference that explain the witnesses. We discuss this feature of CEX2
below.
One can observe that extracting MEX modules leads to a significant improvement of the
performance of CEX2. Of course, if the signature is very large (e.g., for Diagnosis and
Finding), the resulting modules are almost as large as Snomed CT itself and the effect
is less significant. Secondly, one can observe that the additional computation of example concept inclusions in the logical difference roughly doubles the times needed for the
comparison.
Finally, to evaluate the practical feasibility of using the ABox approach to compute
the sets iWtnrhs
 (SM09b, SM09a), we have implemented the computation of ABoxes AT ,
together with an ABox reasoning algorithm for checking the second condition of Lemma 45.
We have then tested our implementation on the subsets  of Snomed CT used for evaluating the performance of CEX2. To limit the size of the ABoxes AT , and to speed up
computations, we first computed modules using MEX. The results that we obtained are
678

fiThe Logical Difference for the Lightweight Description Logic EL

shown in Table 3. The size of the -modules computed by MEX, i.e. T1 of SM09b and T2
of SM09a, is shown in columns two and three, respectively. As expected from the definition of AT , , one can observe that the number of concept and role membership assertions
present in the ABoxes AT2 , can grow very large, even for modules and signatures with only
a few thousand concept names.
For 8 of the 41 considered subsets our implementation ran out of available physical
memory (indicated by a time value -) when all possible concept membership consequences
of the ABox were to be computed. Overall, we observed the longest execution time of
over 5 hours for the set Specmatyp. In conclusion, one can see that a straightforward
implementation of the ABox approach is practically useful only for terminologies and
signatures of a few thousand concept names.
8.2 Comparing Different Versions of the NCI Thesaurus
We have also used the CEX2 tool to compare distinct versions of the NCI Thesaurus. Most
distributed releases of the NCI Thesaurus contain language constructs which are not part of
ELHr (such as disjunction and value restriction). To obtain ELHr -terminologies, we have
removed all inclusions that contain a non-ELHr constructor from the original terminologies.
Typically, this affected 5%-8% of the inclusions present in each of the distributed NCI
versions. Most of the ELHr -versions generated in this way contain role inclusions as well
as domain and range restrictions.
Similarly to the work of Goncalves et al. (2011), we have compared 71 consecutive
ELHr -versions of the NCI Thesaurus ranging between the versions 03.10J and 10.02d, with
the exception of 05.03F and 05.04d, which could not be parsed correctly. Version 10.03h
and some later versions of the NCI Thesaurus are not acyclic, and hence, they could not
be handled by the CEX2 tool.
For any two consecutive versions NCIn and NCIn+1 within the considered range, we
computed the sets cWtn (NCIn+1 , NCIn ) and iWtn (NCIn+1 , NCIn ) on signatures  =
sig(NCIn )  sig(NCIn+1 ). An overview of the set sizes for cWtnrhs
 (NCIn+1 , NCIn ) and
lhs,A
cWtn (NCIn+1 , NCIn ) that we obtained can be found in Figure 8. The comparisons are
sorted chronologically along the x-axis according to the release dates of the NCI ontology
versions, whereas the corresponding number of left-hand atomic difference witnesses or
right-hand difference witnesses can be found on the y-axis. One can see the number of righthand difference witnesses remained fairly low throughout the different versions. However,
occasional spikes occurred in the number of left-hand atomic difference witnesses with a
maximum value of 33487 for comparing the versions 05.01d and 05.03d. Moreover, in none
of the comparisons except for those shown in Figure 9 left-hand role domain or left-hand role
range difference witnesses were identified. Overall, no witnesses regarding role inclusions
were detected and we found that for every two considered consecutive versions NCIn and
NCIn+1 on  = sig(NCIn )  sig(NCIn+1 ),
cWtn (NCIn+1 , NCIn ) = iWtn (NCIn+1 , NCIn ).
A running time of 140 seconds and 228 MiB of memory were required on average for
computing witnesses and example inclusions for iDiff  (NCIn+1 , NCIn ). Computing witnesses and example inclusions for cDiff  (NCIn+1 , NCIn ) on average took 157 seconds and
used 228 MiB of memory.
679

fiKonev, Ludwig, Walther, & Wolter

Subset Name 
Admin
Adminproc
Cdacarest
Crcareneur
Crcareresp
Devicetyp
Diagimg
Diagnosis
Drgadrcon
Endosfind
Endosproc
Epcream.6a
Epenema.7a
Epenema.7b
Epeye.4
Epiuds16
Famhist
Finding
Foodadrcon
Ffoodaller
Invest
Labinvest
Labinvmeth
Labisolate
Labmorph
Labspec
Labtopog
Lifestyle
Manumat
Nofoodall
Nonhuman
Pbcl
Pbhllng
Pf
Provadv
Sf
Socpercir
Specmatyp
Treatment
Vmp
Vtm

|  NC |
7684
3198
355
1640
1082
6539
4162
75879
8009
178
73
403
25
6
223
1
416
168383
2378
468
14839
3904
3794
16313
4854
1221
27277
13090
90503
686
1839
5866
1113
79
1052
613
6786
8830
43660
13667
2117

|cWtnrhs
 |
7
0
1
28
72
26
27
7410
131
0
1
0
0
0
0
0
8
11824
11
1
1396
61
103
150
32
3
866
77
2
1
24
633
1
0
2
0
8
10
2419
2
0

|clsWtnrhs
 |
5
0
1
8
18
26
13
881
131
0
1
0
0
0
0
0
5
2497
11
1
534
45
81
150
32
3
220
41
0
1
11
116
0
0
1
0
8
8
1255
0
0

|cWtnlhs,A
|

29
6
1
197
262
22
13
12409
47
13
5
3
3
2
6
1
31
31228
15
9
5549
2520
3380
661
45
18
169
826
22
13
469
1342
27
4
158
3
2
46
9251
22
13

|clsWtnlhs
 |
7
0
1
13
64
22
8
5406
47
0
3
0
0
0
0
0
4
20063
14
9
5441
133
3374
661
45
3
169
148
0
13
131
402
0
0
108
0
2
10
8740
0
0

Time (s)
cWtn - from
full ontologies
358.51
344.60
337.91
399.57
377.36
369.20
444.66
844.26
1419.52
363.23
352.84
337.41
337.42
337.50
337.53
337.26
339.36
1559.23
481.20
379.42
511.12
382.32
367.20
671.36
858.11
360.80
1947.19
445.75
349.73
421.23
678.53
395.27
454.39
337.68
343.78
338.13
366.14
380.19
793.12
342.70
339.14

Time (s)
cWtn - with
module extraction
9.89
8.24
6.76
15.58
12.24
8.01
38.56
486.53
10.17
7.86
7.30
7.39
6.86
6.76
7.20
6.69
8.84
1366.08
7.74
7.03
76.90
12.47
10.70
14.14
8.28
13.38
38.05
32.49
15.36
7.11
12.50
12.18
7.99
7.12
8.19
7.44
8.99
16.10
330.45
12.95
9.45

Time (s)
cWtn
with examples
654.12
642.23
556.41
704.21
680.51
589.81
775.37
2699.89
1708.49
662.67
573.66
631.51
556.31
629.57
1236.84
1233.89
633.94
5017.02
1516.47
677.97
769.93
680.94
1290.83
1005.95
1113.70
1272.51
4463.05
765.10
1224.92
721.74
1907.70
1358.88
761.00
634.26
569.56
629.50
1300.47
685.35
1315.23
1247.18
633.50

Table 2: Subset Comparisons for T1 = SM09b and T2 = SM09a Resulting in a Non-Empty
Difference

680

fiThe Logical Difference for the Lightweight Description Logic EL

Subset Name 
Admin
Adminproc
Cdacarest
Crcareneur
Crcareresp
Devicetyp
Diagimg
Diagnosis
Drgadrcon
Endosfind
Endosproc
Epcream.6a
Epenema.7a
Epenema.7b
Epeye.4
Epiuds16
Famhist
Finding
Foodadrcon
Foodaller
Invest
Labinvest
Labinvmeth
Labisolate
Labmorph
Labspec
Labtopog
Lifestyle
Manumat
Nofoodall
Nonhuman
Pbcl
Pbhllng
Pf
Provadv
Sf
Socpercir
Specmatyp
Treatment
Vmp
Vtm

|  NC |

|sig(T1 )  NC |

|sig(T2 )  NC |

|{ A(a) | A(a)  AT2 , }|
(in thousands)

|{ r(a, b) | r(a, b)  AT2 , }|
(in thousands)

Time (s)

7684
3198
355
1640
1082
6539
4162
75879
8009
178
73
403
25
6
223
1
416
168383
2378
468
14839
3904
3794
16313
4854
1221
27277
13090
90503
686
1839
5866
1113
79
1052
613
6786
8830
43660
13667
2117

6746
3071
322
6484
5273
3617
11007
156588
8323
1487
809
1425
85
13
851
5
3126
323809
2716
636
42071
9308
10132
16281
4575
7106
27118
26233
11605
990
8728
8497
2488
386
3104
1856
6757
12928
111178
11972
7655

6750
3120
323
6375
5206
3619
11074
156441
8361
1534
826
1446
86
15
859
7
3136
324400
2723
644
42559
9302
10147
16313
4558
7064
27142
26473
11649
991
8848
8793
2487
389
3014
1860
6754
12871
111612
12018
7711

66942
12352
148
8568
4361
43743
40817
8636801
70643
210
48
641
4
0
214
0
1003
41381927
6745
326
504618
36048
36738
267268
24538
5566
723594
250140
8851332
727
13698
64174
3083
37
3202
1332
48627
112252
3716810
289683
16540

1081
480
52
651
503
830
1220
14134
1095
148
82
198
19
10
120
8
301
30521
353
87
4224
1147
1203
2033
628
570
3294
2374
12127
132
926
1357
344
59
378
270
889
1580
10578
2629
970

9291.75
1642.41
3.86
3110.07
3689.22
2381.00
12503.63
2097.23
143.87
17.88
315.58
0.32
0.06
60.80
0.05
137.34
277.80
11.57
8632.09
4131.02
7785.59
1275.48
646.59
26.99
10110.25
16410.12
933.00
3.86
518.47
249.26
5819.23
18306.56
2861.37

Table 3: Performance of the ABox Approach for Computing iWtnrhs
 (SM09b, SM09a)

681

fiKonev, Ludwig, Walther, & Wolter

35000
Nr of Right-Hand Witnesses
Nr of Left-Hand Atomic Witnesses
30000

25000

20000

15000

10000

5000

0

lhs,A
Figure 8: Sizes of cWtnrhs
(NCIn+1 , NCIn ) between Consec (NCIn+1 , NCIn ) and cWtn
utive ELHr -versions NCIn and NCIn+1 of the NCI Thesaurus

T1
04.04j
04.11a
05.03d
06.02d
08.10e
08.12d
09.06e

T2
04.03n
04.09a
05.01d
06.01c
08.09d
08.11d
09.05d

|  NC |
34245
35976
38020
45582
66052
68229
70493

|  NR |
76
91
92
113
123
123
123

|cWtnrhs
 |
252
106
138
419
1774
968
1305

|cWtnlhs,A
|

4926
4023
33487
1438
19055
4726
575

|cWtnlhs,dom
|

1
2
92
1
113
114
1

|cWtnlhs,ran
|

1
2
92
1
113
113
1

lhs
Figure 9: Detailed Results for cWtnrhs
 (T1 , T2 ) and cWtn (T1 , T2 ) on Selected Versions of
the NCI Thesaurus using Shared Signatures  = sig(T1 )  sig(T2 )

682

fiThe Logical Difference for the Lightweight Description Logic EL

The peaks in atomic left-hand difference witnesses mostly resulted from changes to a few
very general concepts. As mentioned above already, Goncalves et al. (2011) provide an indepth analysis of NCI versions. A systematic comparison of the methods used by Goncalves
et al. with the logical diff introduced in this paper would be very interesting, but is beyond
the scope of this paper. One interesting observation that can be made is, however, that the
peak of atomic left-hand witnesses that we observed between the versions 05.01d and 05.03d
correlates with the fact that according to Goncalves et al. a large number of non-redundant
axioms were added to version 05.03d. However, a comparable number of non-redundant
axioms were also added to version 04.12g, but no peak in atomic left-hand or right-hand
witnesses was observed in our analysis.
8.3 Scalability Analysis
We demonstrated in the previous sections that CEX2 is capable of finding the logical difference between two unmodified versions of Snomed CT and between distinct versions of the
NCI thesaurus restricted to ELHr . In order to see how CEX2s performance scales, we have
also tested it on randomly generated acyclic terminologies of various sizes. Each randomly
generated terminology contains a certain number of defined- and primitive concept names
and role names. The ratio between concept equations and concept inclusions is fixed, as is
the ratio between existential restrictions and conjunctions. The random terminologies were
generated for a varying number of defined concept names using the parameters of SM09a:
62 role names; the equality-inclusion ratio is 0.525; and the exists-conjunction ratio is 0.304.
For every chosen size, we generated 10 samples consisting of two random terminologies as
described above. We then applied CEX2 to find the logical difference of the two terminologies over their joint signature. Figure 10 shows the average memory consumption of CEX2
over 10 randomly generated terminologies of various sizes. In 10(a) the maximum length
of conjunctions was fixed as two (M=2), and in 10(b) the number of conjuncts in each conjunction is randomly selected between two and M. It can be seen that the performance of
CEX2 crucially depends on the length of conjunctions. In 10(b), the curves break off at the
point where CEX2 runs out of physical memory6 . For instance, in the case of M=22, this
happens for terminologies with more than 7 500 defined concept names. Finally, we note
that the time required by CEX2 to compare two such random terminologies highly varied
across the different samples. The maximum time required by CEX2 was 11 333 seconds.
8.4 Additional User Support for Analysing Differences
So far we have discussed experiments with CEX2 in which one computes the set of concept
and instance difference witnesses between two terminologies. Clearly, such witnesses do not
provide sufficient information for a detailed analysis of the logical difference between two
terminologies. For a more thorough analysis, it is required to consider examples  from
cDiff  (T1 , T2 ) and iDiff  (T1 , T2 ) that show why certain concept names are concept/instance
difference witnesses. Thus, whenever it searches for concept names A such that there
exists a C with C v A  cDiff  (T1 , T2 ), CEX2 can output example concept inclusions
C v A  cDiff  (T1 , T2 ). Similarly, if requested, CEX2 can also compute example inclusions
6. In some cases the classification of the terminologies through CB already requires more than 3 GiB of
memory.

683

fiKonev, Ludwig, Walther, & Wolter

1200

3500

3000

Memory Consumption in MiB

Memory Consumption in MiB

1000

800

600

400

2500

2000

1500

1000

200
500

M=10

M=2

M=22

0

Number of Concept Names

95
00

85
00

75
00

65
00

55
00

45
00

35
00

25
00

15
00

50
0

10
00
0
30
00
0
50
00
0
70
00
0
90
00
0
11
00
00
13
00
00
15
00
00
17
00
0
19 0
00
00
21
00
00
23
00
00
25
00
00
27
00
00
29
00
0
31 0
00
00
33
00
00
35
00
00

0

Number of Concept Names

(a) Short Conjunctions

(b) Long Conjunctions

Figure 10: Memory Consumption of CEX2 on Randomly Generated Terminologies
illustrating left-hand concept differences A v C, r.> v C, or ran(r) v C, and examples for
the instance difference case. We know from Example 12 that even minimal such examples
can be of exponential size in the input terminologies. In practice, however, for Snomed CT
and NCI the additional computation of an example inclusion for every concept/instance
difference witness only doubles the times required for the computation. As described
above already, this can be observed in Table 2, where the computation times with examples
are shown in the last column and the computation times without examples are shown in the
7th column. The examples computed by CEX2 are often of reasonable size. For instance, if
we consider the subset Specimen Material Type (Specmatyp) from Table 2, it holds that
(i) there exist 10 right-hand -concept witnesses, i.e. |cWtnrhs
 (SM09b, SM09a)| = 10;
(SM09b, SM09a),
(ii) the set of left-hand atomic -concept difference witnesses, cWtnlhs,A

contains 46 concept names.
In Point (i) and (ii), the longest concepts C, D for C v A  cDiff  (SM09b, SM09a) and
A v D  cDiff  (SM09b, SM09a) that were computed by CEX2 had twelve concept and role
name occurrences (thus were far smaller than the exponential worst case suggests).
Having computed not only difference witnesses but also example concept inclusions for
witnesses, it is of interest to explain why an example concept inclusion is entailed by one
terminology but not the other. Computing minimal subsets of a terminology that entail an
example concept inclusion is a promising approach to explaining logical differences that is
also known as axiom pinpointing or justification. It is not supported by CEX2, but has been
investigated extensively for various description logics including EL (Schlobach & Cornet,
2003; Baader, Penaloza, & Suntisrivaraporn, 2007; Kalyanpur, Parsia, Horridge, & Sirin,
2007; Horridge, Parsia, & Sattler, 2010; Penaloza & Sertkaya, 2010). To illustrate this
approach, consider again the subset Specimen Material Type (Specmatyp) from Table 2.
CEX2 outputs
VenipunctureForBloodTest  cWtnlhs,A
(SM09b, SM09a).

684

fiThe Logical Difference for the Lightweight Description Logic EL

(1)

LaboratoryTest v LaboratoryProcedure u EvaluationProcedure
BloodTest  LaboratoryTest u  roleGroup. hasSpecimen. BloodSpecimen

(2)

(3) VenipunctureForBloodTest  (roleGroup.hasFocus .BloodTest)
u Venipuncture
u (roleGroup.((procedureSiteDirect.VenousStructure)
u (method.PunctureAction)))

Figure 11: Minimal Axiom Set
It also computes the following concept inclusion (slightly simplified by hand) as a member of cDiff  (SM09b, SM09a):
()

VenipunctureForBloodTest
v roleGroup.hasFocus.EvaluationProcedure

Using axiom pinpointing one can then compute a minimal set of inclusions from SM09b
which entails the concept inclusion above; such a set is shown in Figure 11. Axioms 2 and 3
are in both terminologies, but SM09a contains
LaboratoryTest v LaboratoryProcedure
instead of Axiom 1, which explains this difference between the two terminologies. Note
that concept and role names from  are shaded in grey. It can be seen that the interaction
between -concepts heavily depends on inclusions that are built up mainly from non-concepts; actually none of inclusions required to derive () is a -inclusion.
We finally note that CEX2 is a text-based tool. In order to make it more accessible to
ontology users, a Protege plugin, LogDiffViz7 , was created, which calls CEX2 and visualises
both ontology versions and the differences as a hierarchical structure. LogDiffViz also
provides basic axiom pinpointing. The plugin is distributed as a self-contained Java archive
file (JAR) in which CEX2 is bundled.

9. Related Work
We describe the relationship between the work presented in this paper and existing work on
logical difference and inseparability of ontologies. Related work on versioning and the distinction between syntactical, structural, and logic-based approaches to versioning have been
discussed in the introduction already and will not be presented again here. The problem
of deciding whether two ontologies are -inseparable for some signature  has been investigated for many ontology languages and different notions of inseparability such as concept
inseparability, instance inseparability, conjunctive query inseparability, and model-theoretic
inseparability (i.e., the -reducts of models of the first ontology coincide with the -reducts
of models of the second ontology). Inseparability is also closely related to the notion of conservative extensions since one ontology is a conservative extension of another ontology if
it contains the other ontology as a subset and both are inseparable w.r.t. the signature of
7. Available at http://protegewiki.stanford.edu/wiki/Logical_Difference_Vizualiser_(LogDiffViz)

685

fiKonev, Ludwig, Walther, & Wolter

the smaller ontology. Thus, algorithmic results on deciding conservativity are directly relevant for inseparability as well. The tractability results presented in this paper are in sharp
contrast to most other known results. We start with general EL-TBoxes: for general ELTBoxes deciding inseparability and conservative extensions are ExpTime complete problems
for concept, instance and conjunctive queries. Both problems are undecidable for modeltheoretic inseparability and model-theoretic conservative extensions (Lutz & Wolter, 2010).
(We note, however, that in the model-theoretic case unexpected positive algorithmic results
have been obtained in Konev, Lutz, et al., 2008, for acyclic EL and ALC and their extensions
with inverse roles.) For ALC and its standard extensions without nominals deciding concept
inseparability and conservative extensions is 2ExpTime-complete (Ghilardi, Lutz, & Wolter,
2006; Lutz et al., 2007; Lutz & Wolter, 2011) and for ALCQIO deciding concept inseparability and conservative extensions becomes undecidable (Lutz et al., 2007; Cuenca Grau
et al., 2008). Nothing is known for ALC about the complexity of inseparability for instance
and conjunctive queries. For DL-Lite dialects (Calvanese, Giacomo, Lembo, Lenzerini, &
Rosati, 2006), the complexity of concept, instance, and query inseparability ranges from
PSpace-hard (and in ExpTime) for the description logic underlying the OWL 2 QL standard, NP-complete for DL-Litehorn , and p2 -complete for DL-Litebool (Konev, Kontchakov,
Ludwig, Schneider, Wolter, & Zakharyaschev, 2011; Kontchakov et al., 2010). For DLLitebool model-theoretic inseparability is decidable (Kontchakov et al., 2010) and for DLLitecore concept, instance, and query inseparability are in PTime (Konev et al., 2011). In
contrast to the work presented in this paper, however, no attempt is made to present the
logical difference to the user if two ontology are not inseparable. As mentioned above, in
the work of Konev et al. (2012), CEX2 is extended to the conjunctive query difference case
between acyclic ELHr -terminologies and various experiments based on the NCI thesaurus
are discussed.
The work discussed so far is concerned with the logical difference and inseparability between description logic TBoxes. The difference between description logic concepts has been
investigated, for example, in the work of Teege (1994), and of Brandt, Kusters, and Turhan
(2002) but besides of the interest in some kind of difference the problems considered as well
as the techniques employed are rather different. Inseparability and conservativity between
ontologies given in ontology languages that are more expressive than description logics (including first-order logic) have been considered in the work of Kutz and Mossakowski (2008,
2011). Similar relationships between theories have also been investigated in answer set
programming (Pearce & Valverde, 2004; Eiter, Fink, & Woltran, 2007; Pearce & Valverde,
2012).
Finally, we note that Lemma 15 and the ABox constructed in Figure 3 appear to capture and describe fundamental properties of EL and ELHr -terminologies. Both have been
applied to investigate seemingly unrelated problems such as query containment for ontology
based data access using EL-terminologies (Bienvenu, Lutz, & Wolter, 2012b) and first-order
rewritability of instance queries (Bienvenu, Lutz, & Wolter, 2012a).

10. Conclusion
In this paper, we have presented polytime algorithms that decide concept, instance, and
query-inseparability w.r.t. a signature  for ELHr -terminologies and compute a represen686

fiThe Logical Difference for the Lightweight Description Logic EL

tation of the difference if it is non-empty. Experiments using CEX2 based on SNOMED
CT and NCI show that the outputs given by our algorithm are mostly of reasonable size
and can be analysed by users. Many extensions, applications, and open problems remain
to be explored. Here we mention some of them:
(1) We have motivated the study of -inseparability between terminologies by the problem of comparing different versions of a terminology regarding what they say about a
certain signature. Other potential and promising applications can be found in the area
of decomposing and composing ontologies. For example, when importing an ontology T
into an ontology T 0 (i.e., forming T  T 0 ) it is often important to ensure that T 0 does not
interfere with the signature of T . In other words, T  T 0 should be a conservative extension
of T in the sense that the consequences of T  T 0 in the signature of T should coincide
with the consequences of T itself (Cuenca Grau et al., 2008; Ghilardi et al., 2006; Vescovo,
Parsia, Sattler, & Schneider, 2011). As observed above already, -inseparability generalises conservative extensions and, therefore, our algorithms can be used to check whether
one terminology is a conservative extension of another terminology. Algorithms checking
conservative extensions can also be used to extract modules from ontologies (Cuenca Grau
et al., 2008; Kontchakov, Pulina, Sattler, Schneider, Selmer, Wolter, & Zakharyaschev, 2009;
Konev et al., 2011). It would be of interest to explore applications of our inseparability
testing algorithms to extract modules of terminologies and check conservativity.
(2) Inseparability as defined in this paper does not mean that one terminology can be
replaced by another terminology in every context. In various applications of inseparability
for modularity it is important to ensure that if T1 and T2 are -inseparable, then T1  T
and T2  T are -inseparable as well, for any ontology T . This is called the replacement
property by Konev, Lutz, Walther, and Wolter (2009) and has been exploited and discussed,
for example, in the work of Cuenca Grau et al. (2008) and of Kontchakov et al. (2010). The
notions of inseparability introduced in this paper do not have the replacement property. To
see this, let  = {A, A0 , B, B 0 } and

T1 =

A v r.B
A0  r.B 0




and T2 =

A v r.B
A0 v r.B 0


.

T1 and T2 are -query inseparable (and, therefore, -concept and -instance inseparable),
but T1  T is not even -concept inseparable from T2  T , for T = {B v B 0 }. Indeed,
observe that (T1  T ) |= A v A0 , but (T2  T ) 6|= A v A0 .
It is an important open research problem to determine the complexity of, and to develop
algorithms for strong versions of inseparability with the replacement property for EL and
ELHr -terminologies.
(3) ELHr is a rather weak description logic. It would be of great interest to explore in
how far techniques developed for ELHr can be applied to ontologies which contain additional constructors, but still consist mainly of ELHr -inclusions. It is unlikely that tractable
sound and complete algorithms for interesting extensions exist, but it seems worth exploring algorithms that are sound and incomplete extensions of the algorithms presented in this
paper. Some results in that direction have been presented by Goncalves, Parsia, and Sattler
(2012).
687

fiKonev, Ludwig, Walther, & Wolter

Acknowledgments
This research was supported by EPSRC grant EP/H043594/1. We would like to thank
William Gatens for the development of the LogDiffViz Protege plugin and three anonymous
reviewers for their helpful comments.

Appendix A. Proofs for Section 2
Lemma 1 For every terminology T , one can construct in polynomial time a normalised
terminology T 0 of polynomial size in |T | such that sig(T )  sig(T 0 ), T 0 |= T , and for every
model I of T there exists a model J of T 0 such that I = J and X I = X J for every
X  sig(T ). Moreover, T 0 is acyclic if T is acyclic.
Proof. Given a terminology T , construct a normalised terminology T 0 in five steps as follows:
First, remove all occurrences of > in conjunctions, and replace C in each occurrence of r.C,
where C is not a concept name or >, with a fresh concept name A and add the concept
definition A  C to the terminology. Repeat the last step exhaustively.
Second, replace every ri .Bi in each inclusion with a right-hand side of the form F u
r1 .B1 u    u rm .Bm (m  1), where each Bi is either a concept name or Bi = >, and F
is a conjunction of concept names such that F 6= > or m  2, with a fresh concept name
Bi0 and add the concept definition Bi0  ri .Bi to the terminology.
Third, replace every inclusion of the form A  r.> with two inclusions A v r.> and
r.> v A in the terminology.
Fourth, consider any concept name A such that there are sequences B0 , . . . , Bn1 and
F0 , . . . , Fn , where the Fi are conjunctions of concept names, such that the terminology
contains the concept definitions A  F0 and Bi  Fi+1 , for i < n, where Bi is a conjunct of
Fi and A a conjunct of Fn . Let Fn0 be the conjunction of concept names in Fn except A. Let,
0
recursively, Fi1
be the result of replacing the conjunct Bi1 in Fi1 with the conjunction
0
Fi , for 1  i  n. Replace the concept definition A  F0 in the terminology with the
primitive concept definition A v F00 .
Fifth, for each inclusion A  F , A v F , r.> v F , or ran(r) v F , where F is a
conjunction of concept names, replace every conjunct B in F for which there is a B  F 0
in the terminology, where F 0 is a conjunction of non-conjunctive concept names, with F 0 .
To see that the construction indeed yields a normalised terminology T 0 , observe that
the steps 1, 2, and 3 ensure that each inclusion has one of the following forms: A  r.B,
A  F , E v r.B, E v r.>, or E v F , where B is a concept name, E is either a concept
name, or is of the form s.>, or ran(s), and F is a conjunction of (possibly conjunctive)
concept names. Step 4 breaks cycles in concept definitions and Step 5 takes care that all
conjuncts of the conjunction of concept names F in the right-hand side of each inclusion of
the form A  F , A v F , r.> v F , or ran(r) v F are non-conjunctive concept names. It is
readily verified that T 0 is acyclic if T is acyclic as none of the above steps introduces cycles
in concept definitions.
We now show that T 0 can be obtained in polynomial time and that T 0 is of polynomial
size in |T |. Let n be the number of inclusions in T and c the maximal length of an inclusions
right-hand side in T . Clearly, the steps 1, 2 and 3 each do not increase the number of
inclusions by more than c  n, raising the total number of inclusions to at most 4nc. Steps 4
688

fiThe Logical Difference for the Lightweight Description Logic EL

and 5 do not increase the number of inclusions, but the length of their right-hand sides. The
length of the right-hand side of an inclusion can increase to at most the sum of the lengths
of the right-hand sides of all inclusions, i.e., 4nc2 is an upper bound for each right-hand
side. The upper bound of the running time for each of the steps in the construction is
therefore 16n2 c3 . Hence, the size of T 0 and the running time of the construction are both
in O(n2  c3 ).
Notice that every new concept name occurs on the left-hand side of a unique concept
definition A  C in T 0 . Thus, every model I of T can be expanded to a model J of T 0 by
interpreting the fresh concept names in sig(T 0 ) \ sig(T ) by setting AJ = C I .
Moreover, it is readily checked that T 0 |= T .
We prove an extended version of Theorem 2 according to which not only EL-concepts
and concepts of the form ran(r) are evaluated correctly in the canonical model IK , but
also C u,u -concepts (which are introduced in Definition 57).
Theorem 2[Extended Version] Let K = (T , A) be an ELHr -KB. Then
1. IK is a model of K;
2. IK can be computed in polynomial time in the size of K;
3. for all xC,D  IK and all a  obj(A), if C0 is a C u,u -concept or of the form ran(r),
then
 K |= C0 (a) if, and only if, aIK  C0IK .
 T |= C u D v C0 if, and only if, xC,D  C0IK .
Proof. Point 2 follows from the fact that instance checking in ELHr can be done in polynomial time.
We first prove Point 3 for EL-concepts C0  sub(T ). The proof is by simultaneous
induction on the construction of C0 . The interesting step is for C0 = r.D0 .
We start with the proof of the direction from left to right. Assume first that K |= C0 (a).
Then (a, xran(r),D0 )  rIK . We have T |= (ran(r) u D0 ) v D0 . Thus, by the induction
hypothesis, xran(r),D0  D0IK . But then a  C0IK , as required. Now assume T |= C uD v C0 .
Then (xC,D , xran(r),D0 )  rIK . We have T |= (ran(r) u D0 ) v D0 . By the induction
hypothesis, xran(r),D0  D0IK . But then xC,D  C0IK , as required.
Conversely, assume that aIK  C0IK . There exists d  IK such that (aIK , d)  rIK
and d  D0IK . Assume first that d = b  obj(A). By the induction hypothesis, K |= D0 (b).
There exists s such that s(a, b)  A and s vT r. Thus, K |= C0 (a), as required. Assume
now that d = xran(s),F . Then K |= s.F (a), s vT r and xran(s),F  D0IK . By the induction
hypothesis, T |= ran(s) u F v D0 . Thus, K |= C0 (a), as required.
Now assume xC,D  C0IK . There exists xran(s),F with T |= C u D v s.F , s vT r and
xran(s),F  D0IK . By the induction hypothesis, T |= ran(s) u F v D0 . Thus T |= C u D v
r.D0 , as required.
We now prove Point 3 for concepts of the form C0 = ran(r). Assume K |= (ran(r))(a).
Then there exist b and s with s(b, a)  A and s vT r. But then a  ran(r)IK . Conversely,
689

fiKonev, Ludwig, Walther, & Wolter

assume that a  ran(r)IK . Then, by definition of IK , there exist b and s with s(b, a)  A
and s vT r. Hence K |= (ran(r))(a), as required.
Assume T |= C u D v ran(r). Then we have, for C = ran(s), s vT r. Then xC,D 
ran(r)IK since there is a path in WK with tail xC,D . The converse direction is similar.
It follows from what has been proved so far that IK is a model of (T , A). Thus we have
proved Point 1, and it remains to prove Point 3.
We prove Point 3 for arbitrary C u,u -concepts C0 . The interesting step is for C0 = S.D0 ,
where S = r1 u    u rn .
Assume first that K |= C0 (a). Then a  C0IK since IK is a model of K. Similarly, if
T |= C u D v C0 , then xC,D  C0IK since xC,D  (C u D)IK and IK is a model of T .
Conversely, assume that a  C0IK . There exists d  IK such that (aIK , d)  S IK and
d  D0IK . Assume first that d = b  obj(A). By the induction hypothesis, K |= D0 (b). For
every ri , 1  i  n, there exists si with si (a, b)  A and si vT ri . Thus, K |= C0 (a), as
required.
Assume now that d = xran(s),F . Then K |= s.F (a), s vT ri for 1  i  n and
xran(s),F  D0IK . By the induction hypothesis, T |= ran(s) u F v D0 . Thus, K |= C0 (a), as
required.
Now assume xC,D  C0IK . There exists xran(s),F with T |= C u D v s.F , s vT ri ,
1  i  n, and xran(s),F  D0IK . By the induction hypothesis, T |= ran(s) u F v D0 . Thus
T |= C u D v S.D0 , as required.

Appendix B. Proofs for Section 5
In some proofs, we require models for infinite sets of concepts. We introduce some notation
and a well known result about the existence of minimal models. Let  be a (possibly
infinite) set of C ran -concepts (which are introduced in Definition 32), T an ELHr -TBox, and
D either a C u,u -concept (which are introduced in Definition 57) or a C ran -concept. We write
T   |= D and say that  is included in D w.r.t. T if, for every model I of T and d  I ,
d  DI follows from d  C I for all C  . The following observation follows from the fact
that all C u,u and C ran -concepts are equivalent to Horn formulas (in the sense of Chang and
Keisler, 1990):
Lemma 67. For all ELHr -TBoxes T and sets  of C ran -concepts there exists a model I of
T and d  I such that the following are equivalent, for all C u,u  C ran -concepts D:
 T   |= D;
 d  DI .
We now come to the proof of Lemma 36. For the convenience of the reader we formulate
the result again.
Lemma 36. For every ELHr -TBox T , ABox A, and all C ran -concepts C0 and D0 , and
a0  obj(A):
n,ran
 (T , A) |= D0 (a0 ) if, and only if, there exists n  0 such that T |= CA,a
v D0 ;
0

690

fiThe Logical Difference for the Lightweight Description Logic EL

 T |= C0 v D0 if, and only if, (T , AC0 ) |= D0 (aC0 ).
n,ran
(a0 )
Proof. We prove Point 1. For the direction from right to left observe that A |= CA,a
0
n,ran
for all n  0. Thus, T |= CA,a0 v D0 implies (T , A) |= D0 (a0 ).
ran |= D . Then, using compactness,
Now assume (T , A) |= D0 (a0 ). We show that T CA,a
0
0
n,ran
we find an n  0 such that T |= CA,a0 v D0 , as required.
ran 6|= D . Take, for every a  obj(A), a model I of T with a point
Assume T  CA,a
0
a
0
I
ran |= C. Such
da   a such that for all C ran -concepts C: da  C Ia if, and only if, T  CA,a
models exist by Lemma 67. We may assume that they are mutually disjoint. Take the
following union I of the models Ia :
S
 I = aobj(A) Ia ;
S
 AI = aobj(A) AIa , for A  NC ;
S
 rI = aobj(A) rIa  {(da , db ) | r0 (a, b)  A, r0 vT r}, for r  NR ;

 aI = da , for a  obj(A).
Claim 1. For all C ran -concepts C and all a  obj(A) the following holds for all d  Ia :
d  C Ia iff d  C I .
The proof is by induction on the construction of C. The interesting cases are C = ran(r)
and C = r.D and the direction from right to left.
Let d S
 C I and assume first that C = ran(r). Let d  C I  Ia and (d0 , d)  rI . For
(d0 , d)  aobj(A) rIa , the claim follows from the definition. Otherwise, d = da , d0 = db
n,ran
for every n  0. Hence,
for some b with r0 (b, a)  A and r0 vT r. Thus, ran(r0 )  CA,a
ran
I
a
T  CA,a |= ran(r) and we obtain d  C .
Assume now
r.D and d  C I  Ia . Take d0 with (d, d0 )  rI and d0  DI .
S that C =
0
I
0
For (d, d )  a0 obj(A) r a , d  C Ia follows immediately from the induction hypothesis.
Otherwise, d = da and d0 = db for some b with r0 (a, b)  A and r0 vT r. By the induction
ran |= D. By compactness, there exists a concept E  C ran
hypothesis, d0  DIb . Hence, T CA,b
A,b
n,ran
for every n > 0. But
such that T |= E v D. From r0 (a, b)  A, we obtain r0 .E  CA,a
ran |= r 0 .D and we obtain d  C Ia using r 0 v r. This finishes the proof of
then, T  CA,a
a
T
the claim.
Now, for C v D  T , let d  I with d  C I , i.e. d  Ia for some a  obj(A). By
Claim 1 we have d  C Ia , which implies that d  DIa as C Ia  DIa . We can conclude
that d  DI by applying Claim 1 again. Similarly, one can show that C I = DI for every
C  D  T and rI  sI for every r v s  T . It follows that I is a model of T . By
construction of I, we have (aI , bI )  rI for every r(a, b)  A. Moreover, for A(a)  A with
ran |= A, which implies that d  AIa and aI  AI by our
a  obj(A), it holds that T  CA,a
a
ran 6|= D ,
claim. We can thus infer that I is a model of (T , A) and I 6|= D0 (a0 ) as T  CA,a
0
0
Ia

which implies that da0 6 D0 0 and aI0 6 D0I , by Claim 1. Hence, (T , A) 6|= D0 (a0 ) and we
have derived a contradiction.
The proof of Point 2 is a simple application of the definition.
691

fiKonev, Ludwig, Walther, & Wolter

Now we prove cut elimination, correctness, and completeness of the calculus for ELHr
given in Figures 1 and 5. We start with some basic observations, which can be easily proved
by induction on the length of derivations.
Lemma 68. For any ELHr -terminology T , C ran -concepts C, D and any role names r, s
we have
1. if T ` > v D, then T ` C v D;
2. if T ` C v A and A v CA  T or A  CA  T , then T ` C v CA ;
3. if T ` C v r.D then T ` C v r.(D u ran(r));
4. if T ` C v r.D, and r.> v B  T , then T ` C v B;
5. if T ` C v ran(r) and ran(r) v A  T , then T ` C v A;
6. if T ` C v r.D, and r v s  T , then T ` C v s.D;
7. if T ` C v ran(r) and r v s  T , then T ` C v ran(s).
Lemma 69 (Cut elimination). For any ELHr -terminology T , C ran -concepts C, D, and E,
if T ` C v D and T ` D v E then T ` C v E.
Proof. Let D1 be the derivation of C v D and D2 be the derivation of D v E. Let Li be
the length of Di , i = 1, 2. The proof of the lemma is by induction on the lexicographical
ordering on pairs (L2 , L1 ).
The case when L2 = 0 or L1 = 0, as well as the cases when L2 ends with one of
AndL1, AndL2, AndR, Ex, DefL, DefR or PDefL are virtually the same as in the
proof of Hofmann (2005). Assume D2 ends with Dom, and so its last sequent is of the form
r.D0 v E, and the sequent above it is B v E. By Lemma 68, Item 4, T ` C v r.D0
implies T ` C v B, so by the induction hypothesis, T ` C v E.
The cases when D2 ends with ExRan, Ran, Sub, or RanSub can be dealt with in the
similar way using Lemma 68, Items 3, 57.
Theorem 38. Let T be an ELHr -terminology; C0 and D0 be C ran -concepts. Then T |=
C0 v D0 if, and only if, T ` C0 v D0 .
Proof. It can be easily checked that the proof system rules are sound and so if T ` C0 v D0 ,
then T |= C0 v D0 .
Conversely, assume that T |= C0 v D0 . To prove T ` C0 v D0 we construct an
interpretation I based on the derivability of sequents from T . We show that I is a model
of T . As a consequence we obtain C0I  D0I and conclude that T ` C0 v D0 based on the
properties of I.
The domain I is the set of all well-formed pairs x = hC, RC i, where C is a C ran -concept
and RC is a finite set of role names such that
l
s  NR : if T ` (C u
ran(r)) v ran(s), then s  RC .
rRC

692

fiThe Logical Difference for the Lightweight Description Logic EL

We introduce the following abbreviation. Let
l
Ran(RC ) =
ran(r).
rRC

C ran -concepts C are interpreted as
I(C) = {hD, RD i  I | T ` (D u Ran(RD )) v C},
and r  NR are interpreted as
I(r) = {(hC, RC i , hD, RD i)  I  I | r  RD
and T ` (C u Ran(RC )) v r.(D u Ran(RD ))}.
Note that I(C) is nonempty for every C: consider R0C = {s  NR | T ` C v ran(s)}. As
0
T is finite, R0C is finite.
d Notice that, by Ax and AndR, T ` C v C u Ran(RC ) so, by
Lemma 69, if T ` (C u rR0 ran(r)) v ran(s), for some s, then T ` C v ran(s), so s  R0C .
C


ff


ff
That is, C, R0C is a well-formed pair and, obviously, C, R0C  I(C).
We now show that I(C) = C I for all C ran -concepts C. The proof is by induction on the
construction of C.
1. I(>) = I .
For any well-formed pair hC, RC i, T ` C u Ran(RC ) v > is an axiom.
2. I(C u D) = I(C)  I(D).
Let hC, RC i  I(D1 u D2 ), that is T ` (C u Ran(RC )) v (D1 u D2 ). Since T ` (D1 u D2 ) v
D1 , by Lemma 69, we have T ` (C u Ran(RC )) v D1 , that is, hC, RC i  I(D1 ). Similarly,
hC, RC i  I(D2 ).
Conversely, suppose hC, RC i  I(D1 ) and hC, RC i  I(D2 ) holds, that is, T ` (C u
Ran(RC )) v D1 and T ` (C uRan(RC )) v D2 . By AndR, T ` (C uRan(RC )) v (D1 uD2 ),
that is, hC, RC i  I(D1 u D2 ).
3. I(r.C) = {x  I | y  I(C) : (x, y)  I(r)}.
Suppose for some well-formed pair hD, RD i we have hD, RD i  I(r.C), that is T `
(D u Ran(RD )) v r.C. Then, by Lemma 68, Item 3, T ` (D u Ran(RD )) v r.(C u ran(r)).
Consider RrC = {s  NR | T ` (C u ran(r)) v ran(s)}. Clearly, r  RrC and, similarly
to the argument for R0C above, hC, RrC i is a well-formed pair. By Ax and AndR, T `
Curan(r) v CuRan(RrC ), by Ex, T ` r.(Curan(r)) v r.(CuRan(RrC )) and by Lemma 69,
T ` (D u Ran(RD )) v r.(C u Ran(RrC )). Then, by definition, (hD, RD i , hC, RrC i)  I(r)
and, since T ` (C u Ran(RrC )) v C, we have hC, RrC i  I(C).
Conversely, let (hD1 , RD1 i , hD2 , RD2 i)  I(r) and hD2 , RD2 i  I(C), that is, T ` (D1 u
Ran(RD1 )) v r.(D2 uRan(RD2 )), r  RD2 , and T ` (D2 uRan(RD2 )) v C. By Ex we have
T ` r.(D2 u Ran(RD2 )) v r.C, and, by Lemma 69, we have T ` (D1 u Ran(RD1 )) v r.C,
that is, hD1 , RD1 i  I(r.C).
4. I(ran(r)) = {y  I | x : (x, y)  I(r)}.
First we show that I(ran(r)) = {hC, RC i  I | r  RC }. If r  RC , we have T `
C u Ran(RC ) v ran(r), that is, I(ran(r))  {hC, RC i  I | r  RC }. Suppose hC, RC i 
I(ran(r)), that is, T ` (C u Ran(RC )) v ran(r). Then, since hC, RC i is a well-formed pair,
r  RC , that is, I(ran(r))  {hC, RC i  I | r  RC }.
693

fiKonev, Ludwig, Walther, & Wolter

Suppose now that hC, RC i  I(ran(r)), that is, hC, RC i is such that r  RC . Let D
denote (C u Ran(RC )). By induction on the length of derivations one can see that a sequent
of the form r.D v ran(s) is not derivable for any s  NR . Therefore, hr.D, i is a wellformed pair and (hr.D, i , hC, RC i)  I(r). Conversely, let (hD1 , RD1 i , hD2 , RD2 i)  I(r)
then, in particular, r  RD2 . That is, hD2 , RD2 i  I(ran(r)).
Now we show that I is a model of T . We need to show that all axioms of T are true in
I.
1. I(X)  I(CX ), whenever X  CX  T or X v CX  T .
Let hC, RC i  I(X), that is, T ` (C u Ran(RC )) v X. By Lemma 68, Item 2, T `
(C u Ran(RC )) v CX , that is, hC, RC i  I(CX ).
2. I(CX )  I(X), whenever X  CX  T .
Let hC, RC i  I(CX ), that is, T ` (C u Ran(RC )) v CX . Since by Ax and DefR
T ` CX v X, by Lemma 69, T ` (C u Ran(RC )) v X, that is hC, RC i  I(X).
3. (x, y)  I(r)  y  I(A), whenever ran(r) v A  T .
Let (hC, RC i , hD, RD i)  I(r), that is, T ` (C u Ran(RC )) v r.(D u Ran(RD )) and
r  RD . Since r  RD and, as, by Ax and Ran, T ` ran(r) v A, by AndL1, AndL2 we
have T ` (D u Ran(RD )) v A, that is, hD, RD i  I(A).
4. (x, y)  I(r)  x  I(B), whenever r.> v B  T .
Let (hC, RC i , hD, RD i)  I(r), that is, T ` (C u Ran(RC )) v r.(D u Ran(RD )) and
r  RD . Notice that, by Lemma 68, Item 4, we have T ` (C u Ran(RC )) v B, that is,
hC, RC i  I(B).
5. I(s)  I(r), whenever s v r  T .
Let (hC, RC i , hD, RD i  I(r)), that is T ` (C uRan(RC )) v r.(DuRan(RD )) and r  RD .
By Lemma 68, Item 6, T ` (C u Ran(RC )) v s.(D u Ran(RD )). Since r v s  T , by
Ax and RanSub, T ` ran(r) v ran(s) and T ` (D u Ran(RD )) v ran(s) by AndL1 and
AndL2. Since hD, RD i is well-formed, s  RD . Thus, (hC, RC i , hD, RD i)  I(s)


ff
As T |= C0 v D0 , we have I(C0 )  I(D0 ). Since C0 , R0C0  I(C0 ), we have


ff
C0 , R0C0  I(D0 ), that is T ` (C0 u Ran(R0C0 )) v D0 . As T ` C0 v C0 u Ran(R0C0 ),
we have T ` C0 v D0 by Lemma 69.
Proof of Lemma 44. Let T be a normalised ELHr -terminology and  a signature. Additionally, let A be a -ABox, A  sig(T )   non-conjunctive in T and a  obj(A).
For the direction (1.)  (2.), it is a direct consequence of the construction of AT ,
that for all b  obj(A) and B  sig(T )   non-conjunctive in T if (T , A) 6|= B(b) then
B  obj(AT , ).
Assume that (T , A) 6|= A(a). Then A  obj(AT , ). We now define a -range simulation S by setting,
 for b  obj(A) and for B  sig(T )   non-conjunctive in T with B  obj(AT , ) :
(b, B )  S if, and only if, (T , A) 6|= B(b),
 (b,  )  S for all b  obj(A).
We show that S is indeed a -range simulation with (a, A )  S by verifying that the
conditions (S1)(S3) and (RS) introduced on page 663 hold.
694

fiThe Logical Difference for the Lightweight Description Logic EL

(S1)

As (T , A) 6|= A(a) and A  obj(AT , ), it immediately follows that (a, A )  S.

(S2) Let now (b, )  S and B(b)  A with B  . We have to prove that B()  AT , .
For  = B with B  sig(T )   non-conjunctive in T , we obtain from the definition of S
that (T , A) 6|= B(b). Moreover, it holds that B 6 preC
T (B) as otherwise (T , A) |= B(b).
Thus, by the definition of AT , (B) we have B(B )  AT , . For  =  , it immediately
follows that B( )  AT , by the definition of AT , .
(S3) Now, let (b, )  S and r(b, b0 )  A with r  . We have to prove that there exists
 0  obj(AT , ) with (b0 ,  0 )  S and r(,  0 )  AT , . For  =  , it immediately follows from
the definition of AT , that r( ,  )  AT , and (b0 ,  )  S holds by the definition of S.
For  = B with B  sig(T )   non-conjunctive in T it follows from the definition
of S that (T , A) 6|= B(b). Additionally, we can infer that r 6 preDom
T (B) as otherwise
(T , A) |= (r.>)(b) would imply that (T , A) |= B(b).
Consider cases how B is defined in T . If B is pseudo-primitive in T , we obtain from the
definition of AT , (B) that r(B ,  )  AT , and it holds that (b0 ,  )  S by the definition
of S.
For B  r0 .B 0  T , we have to distinguish between the following two cases. If r 6
 0

0
preRole
T (r ), we obtain r   \ (preRoleT (r )  preDomT (B)) and thus r(B ,  )  AT , by
the definition of AT , and it holds again that (b0 ,  )  S by the definition of S. In the case
 0

0
where r  preRole
T (r ), we have r  preRoleT (r ) \ preDomT (B). Furthermore, as (T , A) 6|=
0
0
B(b) and so (T , A) 6|= (r .B )(b), it is easy to see that there must exist Bi00  non-conjT (B 0 )
00
00 0
with r 6 preRan
T (Bi ) and (T , A) 6|= Bi (b ). Then we have r(B , Bi00 )  AT , by the
0
definition of AT , (B) and (b , Bi00 )  S by the definition of S.
(RS) Let now (b, )  S such that r(c, b)  A for r  . We have to show that there exists
 0 with r( 0 , )  AT , . For  = B with B  sig(T )   non-conjunctive in T , we obtain
again from the definition of S that (T , A) 6|= B(b). Furthermore, we have r 6 preRan
T (B)
as otherwise (T , A) |= B(b). Thus, by the definition of AT , (B) we have r( , B )  AT , .
For  =  , it follows by the definition of AT , that r( ,  )  AT , .
For the converse direction (2.)  (1.), we assume that A  obj(AT , ) and (A, a) ran

(AT , , A ). It is then sufficient to show for all n that
n,ran
T 6|= CA
vA
T , ,A

as this implies that (T , AT , ) 6|= A(A ) by Lemma 36. We then obtain from Lemma 42 that
(T , A) 6|= A(a) holds.
Thus, we now prove by induction on n that for every concept name B  sig(T )  
n,ran
non-conjunctive in T with B  obj(AT , ), we have T 6|= CA
v B.
T , ,B
Let n = 0 and B  sig(T )   non-conjunctive in T with B  obj(AT , ). It then follows
that
l
l
l
0,ran
0
CA
=
B
u
ran(s)
u
ran(s)
T , ,B
B 0 \preC
T (B)

s\preRan
T (B)

695

Ar.BT
Bnon-conjT (B)


spreRole
T (r)\(preDomT (A)preRanT (B))

fiKonev, Ludwig, Walther, & Wolter

0,ran
Hence, one can see that for every subconcept of the form ran(s) that occurs in CA
,
T , ,B

we obtain that s 6 preRan
T (B). As B it non-conjunctive in T , it holds that either B is
pseudo-primitive in T or that B  r0 .B 0  T . Hence, by Lemma 39 we can conclude that
0,ran
T 6|= CA
v B.
T , ,B
For n > 0, let again B  sig(T )   non-conjunctive in T with B  obj(AT , ). We then
distinguish between the following two cases. If B is pseudo-primitive in T , we obtain
n,ran
CA
=
T , ,B

l

l

B0 u

s\preRan
T (B)

B 0 \preC
T (B)

l

ran(s) u

ran(s)

Ar.BT
Bnon-conjT (B)


spreRole
T (r)\(preDomT (A)preRanT (B))

u

l

s.Cs

s\preDom
T (B)
n,ran
v B.
for C ran -concepts Cs . It follows again from Lemma 39 that T 6|= CA
T , ,B
0
0
For B  r .B , we obtain
n,ran
=
CA
T , ,B

l
B 0 \preC
T (B)

u

l

B0 u

s\preRan
T (B)

l

ran(s)

Ar.BT
Bnon-conjT (B)


spreRole
T (r)\(preDomT (A)preRanT (B))

l

s.Cs u


0
s\(preRole
T (r )preDomT (B))

l

ran(s) u

n1,ran
s.CA
T , , 00

B 00 non-conjT (B 0 )
0 )\(preDom (B)preRan (B 00 ))
spreRole
(r
T
T
T

B

for C ran -concepts Cs . It is easy to see that the conditions (e2), (e3) and (e4) of Lemma 39
n,ran
v B to hold, condition (e1) would have to be fulfilled.
do not hold. Thus, for T |= CA
T , ,B
n,ran
n1,ran
with B 00  non-conjT (B 0 )
of CA
We observe that for every subconcept s.CA
T , ,B
T , , 00
B

n1,ran


00
00
0
and s  preRole
T (r ) \ (preDomT (B)  preRanT (B )), we obtain T 6|= CAT , , 00 v B from
B

n1,ran
u ran(s) v B 0 by Lemma 39
the induction hypothesis. Thus, we have T 6|= CA
T , ,B 00
for every such B 00 and s. We can infer that condition (e1) does not hold and, therefore,
n,ran
v B.
T 6|= CA
T , ,B

Appendix C. Proofs for Section 6
Proof of Lemma 54. Let T be a normalised ELHr -terminology and  a signature such
that   NR 6= . Additionally, let A  NC be a concept name that is non-conjunctive
in T , let r   be a role name, and let C be an EL -concept. Finally, let D = C or
D = ran(r) u C.
First observe that we obtain from Lemma 36 that T 6|= D v A holds if, and only if,
(T , AD ) 6|= A(aD ). Additionally, by Lemma 44, we have (T , AD ) 6|= A(aD ) if, and only if,
A  obj(AT , ) and (AD , aD ) ran
 (AT , , A ). Thus, it is sufficient to show the following
equivalence:

ran

(AD , aD ) ran
 (AT , , A )   r   : (A )r  obj(AT , ) and (AD , aD )  (AT , , (A )r )

696

fiThe Logical Difference for the Lightweight Description Logic EL

Next note that the ABox AD is role-splitting as C is an EL-concept and if D = ran(r) u C,
then { s(b, aD )  AD | b  obj(AD ), s  sig(AD ) } = {r(aran , aD )}.
Assume first A  obj(AT , ), (AD , aD ) ran
 (AT , , A ) and let S  obj(AD )obj(AT , )
be the corresponding -range simulation. We define a relation S   obj(AD )  obj(AT , )
by setting for every a  obj(AD ), every   obj(AT , ) and every role name r   such that
r  obj(AT , ):
(a, r )  S 

 (a, )  S and if s(c, a)  AD for some s  sig(AD ) and c  obj(AD ),
then s = r

Note that S  is well-defined as AD is role-splitting.
To show that S  is a -range simulation such that there exists r  sig(A,T ) with (A )r 
obj(AT , ) and (aD , (A )r )  S  , we prove that the conditions (S1)(S3) and condition (RS)
from page 663 hold.
(S1) If there exists s(c, aD )  AD for some s  sig(AD )   and c  obj(AD ), then there
exists  0  obj(AT , ) with s( 0 , A )  AT , as (aD , A )  S and S is a -range simulation,
i.e. s(( 0 )s , (A )s )  AT , and (A )s  obj(AT , ). Hence, (aD , (A )s )  S  .
Otherwise, it is easy to see that there exists r   with (A )r  obj(AT , ) as A 
obj(AT , ) and sig(AT , )  . Thus, as (aD , A )  S, we have (aD , (A )r )  S  .
(S2) Let (a, r )  S  and A(a)  AD for a  obj(AD ),   obj(AT , ), A   and
r  sig(AT , ). It follows from the definition of S  that (a, )  S. Hence, as S is a -range
simulation, we have A()  AT , , which implies that A(r )  AT , by the definition of
AT , .
(S3) Let (a, r )  S  and s(a, a0 )  AD for a, a0  obj(AD ),   obj(AT , ), r  sig(AT , )
and s  . From the definition of S  we obtain (a, )  S. Additionally, as S is a -range
simulation, there exists  0  obj(AT , ) such that (a0 ,  0 )  S and s(,  0 )  AT , . Thus, we
have s(r , s0 )  AT , by the definition of AT , and (a0 , s0 )  S  by the definition of S  as
AD is role-splitting.
(RS) Let (a, r )  S  and s(c, a)  AD for a, c  obj(AD ),   obj(AT , ), r  sig(AT , )
and s  . By the definition of S  , (a, )  S holds and r = s. As S is a -range simulation,
there exists  0  obj(AT , ) with s( 0 , ) = r( 0 , )  AT , . Hence, r(r0 , r )  AT , holds by
the definition of AT , .
For the converse direction, we assume that there exists r   such that (A )r  obj(AT , )



and (AD , aD ) ran
 (AT , , (A )r ) holds. Let S  obj(AD )  obj(AT , ) be the corresponding
-range simulation. We define a relation S  obj(AD )  obj(AT , ) by setting for every
a  obj(AD ) and every   obj(AT , ):
(a, )  S



 r  sig(AT , ) : (a, r )  S  .

It is straightforward to verify that A  obj(AT , ) and that S is a -range simulation with
(aD , A )  S.
697

fiKonev, Ludwig, Walther, & Wolter

Appendix D. Proofs for Section 7
Proof of Lemma 60. We require some preliminary observations. Let AC be the ABox
associated with a C ran -concept C (Lemma 36). Then, for any ELHr -terminology T , C ran concept C and C u,u concept D, we have T |= C v D if, and only if K |= D(aC ), where
K = (T , AC ). By Theorem 2 (extended version),
 T |= C v D if, and only if, IK |= D(aC ), where IK is the canonical model for K.
Note that T |= C v u.D if, and only if, DIK 6=  and that for any d, d0  IK and
R = t1 u    u tn , we have (d, d0 )  RIK if, and only if, there exists a role name s such that
(d, d0 )  sIK and s vT ti , for i = 1, . . . , n. We summarise the consequences we require in
the proof below:
(i) if D is a C u -concept with occurrences Si = ri,1 u . . . u ri,mi of intersections of roles,
1  i  k, then T |= C v D if, and only if, there exist role names si , 1  i  k, such
that si vT ri,j for 1  i  k, 1  j  mi and T |= C v D0 , where D0 is obtained from
D by replacing Si with si .
(ii) If D is a C u -concept, then T |= C v u.D if, and only if, there exists a sequence
r10 , . . . , rn0 such that IK |= (r10 .    rn0 .D)(aran ) or IK |= (r10 .    rn0 .D)(aC ). In
the first case, there exists a subconcept (ran(r) u C 0 ) of C (up to commutativity
and associativity of u) such that T |= r.C 0 v r10 .    rn0 .D. In the second case
T |= C v r10 .    rn0 .D.
d
d
d
Now assume that C = 1il ran(si )u 1jn Aj u 1km rk .Ck and T |= C v R1 .D.
Let R1 , . . . , Rk be all the occurrences of role intersections in R1 .D, where Ri = ri,1 u . . . u
ri,mi , for 1  i  k. By (i), we find role names si , 1  i  k, such that si vT ri,j for
1  i  k, 1  j  mi and T |= C v D0 , where D0 is obtained from D by replacing Ri with
si . By applying Lemma 39 to T |= C v s1 .D0 and by using that t1 vT r1,j , for 1  j  m1
and T |= D0 v D, we obtain that one of the conditions (e1u ), (e2u ), (e3u ), or (e4u ) must
hold.
For the second part of the lemma, we first prove by induction on n  1 for every C ran concept C and for every C u -concept D with T |= C v r1 .    rn .D that at least one of
the following conditions holds
(e1n ) there exists a subconcept r.C 0 of C such that T |= C 0 u ran(r)v D;
(e2n ) there exists a concept name A in C such that T |= A v u.D;
(e3n ) there exists a role name r in C such that T |= r.> v u.D;
(e4n ) there exists a role name r in C such that T |= ran(r) v u.D.
For n = 1, let C be a C ran concept and D be a C u -concept with T |= C v r1 .D. We
then obtain that at least one of the conditions (e1u ), (e2u ), (e3u ), or (e4u ) must hold from
the first part of the lemma, and hence, one of (e1n ), (e2n ), (e3n ), or (e4n ) is satisfied. For
n > 1, let C now be a C ran concept and D be a C u -concept such that T |= C v r1 .    rn .D.
We can apply the first part of the lemma again, and if conditions (e2u ), (e3u ), or (e4u ) are
fulfilled, then we can conclude that conditions (e2n ), (e3n ), or (e4n ) are also satisfied. In the
698

fiThe Logical Difference for the Lightweight Description Logic EL

case where (e1u ) holds, there exists a subconcept r.C 0 of C such that T |= C 0 u ran(r) v
r2 .    rn .D. From the induction hypothesis we obtain that at least one of the conditions
(e1n ), (e2n ), (e3n ), or (e4n ) is fulfilled for T |= C 0 u ran(r) v r2 .    rn .D, and thus also
for T |= C v r1 .    rn .D as r  sig(C) and as every subconcept of C 0 is also a subconcept
of C.
Now, if T |= C v u.D for a C ran -concept C and a C u -concept D, then by (ii) we have
to distinguish between the following two cases:
 There exists a subconcept ran(r) u C 0 of C and a sequence r10 , . . . , rn0 0 such that T |=
r.C 0 v r10 .    rn0 0 .D. For n0 = 0, we have T |= r.C 0 v D and condition (e6u )
holds. For n0  1 we obtain that at least one of the conditions (e1n ), (e2n ), (e3n ), or
(e4n ) is satisfied. If (e1n ) holds, then there exists a subconcept r0 .C 00 of r.C 0 such
that T |= C 00 u ran(r0 ) v D. If r.C 0 = r0 .C 00 , we have T |= C 0 u ran(r) v D. If
(C 0 u ran(r)) occurs at the top-level of the concept C, then T |= C v D holds, and
thus, condition (e5u ). Otherwise, there exists a subconcept s.((C 0 u ran(r)) u E) in
C and (e1u ) is satisfied as T |= C 0 u ran(r) u E u ran(s) v D. If r.C 0 6= r0 .C 00 , r0 .C 00
is a subconcept of C 0 (thus, of C) and so condition (e1u ) holds. Finally, if one of the
conditions (e2n ), (e3n ), or (e4n ) is satisfied, then one of (e2u ), (e3u ), or (e4u ) holds
by (ii).
 There exists a sequence r10 , . . . , rn0 0 with T |= C v r10 .    rn0 0 .D. For n0 = 0 condition
(e5u ) holds. If n0  1, then at least one of the conditions (e1n ), (e2n ), (e3n ), or (e4n )
holds. Then, by (ii), we can conclude that one of the conditions (e1u ), (e2u ), (e3u ),
or (e4u ) is satisfied as well.

We give the translation of C u,u -assertions to conjunctive queries. It is similar to the
construction of an ABox from a C ran -concept given in Section 5.1. First, given a C u -concept
C, we define a path in C as a finite sequence C0  R1  C1 . . . Rn  Cn , where C0 = C, n  0,
and Ri+1 .Ci+1 is a conjunct of Ci , for 1  i < n (Ri are conjunctions of role names). Let
xp for p  paths(C) be pairwise distinct variable names and set
XC = { s(xp , xq ) | p, q  paths(C); q = p  R  C 0 , s conjunct of R }
 { A(xp ) | A is a conjunct of tail(p), p  paths(C) }
Let ~x be the sequence
V of all variables in XC except xC . Then the conjunctive query qC,a is
obtained from ~x. XC  by replacing xC with
Va. Finally,
V for D = D0 uu.D1 u  uu.Dk
we obtain the conjunctive query qD,a from ~x.( 0ik XD ), (we assume that distinct
i
variables are used in every XDi , 0  i  k, and that ~x is a sequence of all variables except
xD0 ) by replacing xD0 with a.
To prove Lemma 63 we require some preparation. Query answering is closely related to
the existence of certain homomorphisms between interpretations. Let  be a signature, O
a set of individual names, and I1 , I2 interpretations. A function f : I1  I2 is called a
(O, )-homomorphism if
 f (aI1 ) = f (aI2 ) for all a  O;
699

fiKonev, Ludwig, Walther, & Wolter

 d  AI1 implies f (d)  AI2 for all A  ;
 (d1 , d2 )  rI1 implies (f (d1 ), f (d2 ))  rI2 for all r  .
It is known (Chandra & Merlin, 1977) that if there exists a (O, )-homomorphism from I1
to I2 and I1 |= q[~a] for a conjunctive -query q using only individual names from O and
~a = a1 , . . . , ak from O, then I2 |= q[~a].
For the proof below we slightly refine the notion of an (O, )-homomorphism by considering partial (O, )-homomorphisms with domains that satisfy certain conditions. Namely,
for every n  0, we will call a partial (O, )-homomorphism a level n homomorphism if its
domain contains all elements reachable by a -role chain of length at most n from either
a named individual or from an element without a -predecessor. We then prove that if
for every ELran,u,u -inclusion C v D with depth(C), depth(D)  n, T1 |= C v D implies
T2 |= C v D, then there exists a such a partial level n homomorphism from a certain model
of (T1 , A) to a certain model of (T2 , A).
We consider such partial homomorphisms on certain interpretations only, which we
introduce first. Let O be a finite set of individual names and I an interpretation. d  I
is called O-named if there exists a  O with d = aI . A model I is called an O-forest if
(F1) for everySd  I which is not O-named, there exists at most one d0  I such that
(d0 , d)  rNR rI ;
S
(F2) there are no infinite sequences d0 , d1 , . . . with (di+1 , di )  rNR rI for all i  0 such
that no di is O-named.
S
(F3) if (d, d0 )  rNR rI and d0 is O-named, then d is O-named.
Let O be a finite set of individual names, n  0, and  a signature. A partial function f
from an O-forest I to a model I 0 is called an (O, n, )-homomorphism if
0

(H1) for all a  O: aI is in the domain of f and f (aI ) = aI ;
0

(H2) for all d, d0 in the domain of f and r  : (d, d0 )  rI implies (f (d), f (d0 ))  rI ;
0

(H3) for all d in the domain of f and A  : d  AI implies f (d)  AI ;
(H4) for all d if there does not exist a chain d1 , . . . , dm = d with (di , di+1 ) 
length m > n of not O-named di , then d is in the domain of f .

S

r r

I

of

Now one can prove the following
Lemma 70. Suppose I is an O-forest, I 0 an interpretation and for every m > 0 there
exists a (O, m, )-homomorphism from I to I 0 . Assume as well that I |= q[~a] with q a
conjunctive -query using only individual names from O and ~a = a1 , . . . , ak from O. Then
I 0 |= q[~a].
Proof. Assume that ~a is a -match of I and q(~x) = ~y .q 0 (~x, ~y ) such that ~a consists of
elements of O. By (F2) and (F3) in the definition of O-forests and (H1) and (H4) in the
definition of partial homomorphisms, there exists m > 0 such that all (v), v from ~x  ~y ,
are in the domain of any (O, m, )-homomorphism f . Take a (O, m, )-homomorphism f .
Then ~a is a  0 -match of q(~x) and I 0 , where  0 (v) = f ((v)), for all v  ~x  ~y .
700

fiThe Logical Difference for the Lightweight Description Logic EL

Finally, we also need a technique for constructing (O, m, )-homomorphisms. Let I be
an interpretation. For each d  I and m > 0, let
u
tIm,,u (d) = {C  C
| depth(C)  m, d  C I },

where, as above, depth(C) is the role-depth of C; i.e., the number of nestings of existential
restrictions in C.
Lemma 71. Let  be a finite signature and let m > 0 Suppose I is an O-forest and I 0 an
interpretation such that
0

0

0

(in0) (aI , bI )  rI implies (aI , bI )  rI , for all a, b  O and r  ;
0

(in1) tIm,,u (aI )  tIm,,u
(aI ), for all a  O;
0
0

(d0 );
(d)  tm,,u
(in2) for all d  I there exists d0  I such that tm,,u
I
I0
Then there exists a (O, m, )-homomorphism g from I to I 0 .
Proof. We construct g by constructing a sequence of functions f0 , . . . , fm , where fi : I  I 0 ,
as follows: the domain dom(f0 ) of f0 consists
of all aI with a  O and all d  I such that
S
0
0
0
there does not exist a d with (d , d)  r rI . For aI with a  O we set f0 (aI ) = aI .
For every remaining d  dom(f0 ) choose a d0 according to (in2) and set f0 (d) = d0 . Observe
that tm,,u
(d)  tIm,,u
(f0 (d)) for all d  dom(f0 ).
0
I
Now suppose that fn has been constructed and
(fn (d)) for all d  dom(fn );
(d)  tmn,,u
(in3) tmn,,u
I
I0
(in4) for n > 0: d  dom(fn ) if, and only if, d is not O-named and there exists a sequence
d0 r1I d1 r2I    rnI dn = d of which at most d0 is O-named such that ri   and d0 
dom(f0 ).
S
To construct fn+1 consider a d  dom(fn ) and a not O-named d0 such that (d, d0 )  r rI .
0
0
I
u
0
The
d domain of fn+1 consists of all such d . Let Rd,d = {r   | (d, d )  r } and Rd,d0 =
( rR 0 r). Then
d,d
l
u
Rd,d
D  tmn,,u
(d)
0.
I
mn1,,u 0
(d )
DtI

By (in3),
u
Rd,d
0.

l

D  tImn,,u
(fn (d))
0

mn1,,u 0
DtI
(d )
0

Thus, we can choose an e with (fn (d), e)  rI for all r  Rd,d0 and tImn1,,u (d0 ) 
tmn1,,u
(e) and set fn+1 (d0 ) = e. This defines fn+1 . Observe further that fn+1 is wellI0
defined by (F1). Observe that fn+1 has the properties (in3) and (in4), by (F3).
S
Now we set g = 0nm fm . It is readily checked that g is as required.
701

fiKonev, Ludwig, Walther, & Wolter

We are now in the position to prove Lemma 63.
Lemma 63 If   qDiff  (T1 , T2 ), then there exists 0  cDiff ran,u,u
(T1 , T2 ) with sig(0 ) 

sig().
Proof. Assume T1 and T2 are given and let (A, q(~a))  qDiff  (T1 , T2 ). Let 0 = sig(A) 
sig(q). Assume that, in contrast to what is to be shown,
T1 |= 

()



T2 |= 

for all ELran,u,u -inclusions  with sig()  0 .
Consider a model I 0 of (T2 , A) with I 0 6|= q[~a]. By Lemma 70, we obtain a contradiction
if there exists an obj(A)-forest I which is a model of (T1 , A) and such that for every n > 0
there exists an (obj(A), n, 0 )-homomorphism fn from I to I 0 .
0
Take, for every a  obj(A) a model Ia0 of T1 with da  Ia such that for all C ran  C u,u concepts C:
0
da  C Ia  T1  tI 0 (a) |= C
where

0

0

I
ran
 C I }.
tI 0 (a) = {C  C
0 | a

Such interpretations Ia0 exist by Lemma 67. We now define the unfolding
Ia of Ia0 . A path
d
in Ia0 is a finite sequence d0 R1 d1 . . . Rn dn , n  0, such that Ri+1 = Ri+1 for a set Ri+1
0
of role names with r  Ri+1 iff (di , di+1 )  rIa , for all i < n. For a path p, tail(p) denotes
the last element of p. Now let Ia consist of all paths in Ia0 and set
0

 AIa = {p  Ia | tail(p)  AIa };
 rIa = {(d, dRd0 )  Ia  Ia | r  R}.
Then Ia is an O-forest for O = . Moreover, for all C u,u -concepts C and all p  Ia :
()

p  C Ia



0

tail(p)  C Ia .

In particular, Ia is still a model of T1 .
Take the following (disjoint) union I of the interpretations Ia :
S
 I = aobj(A) Ia ;
S
 AI = aobj(A) AIa , for A  NC ;
S
 rI = aobj(A) rIa  {(da , db ) | r0 (a, b)  A, r0 vT1 r}, for r  NR ;
 aI = da , for a  obj(A).
We show that I is an obj(A)-forest, a model of (T1 , A) and that there exist (obj(A), n, )homomorphisms from I to I 0 for all n > 0. First observe the following:
Claim 1. For all EL concepts C and d  Ia :
d  C I  d  C Ia
702

fiThe Logical Difference for the Lightweight Description Logic EL

The proof is by induction on the construction of C. The interesting case is C = r.D and
the direction from left to right.
Assume that d  C I  Ia . Take d0 with (d, d0 )  rI
S
and d0  DI . For (d, d0 )  a0 obj(A) rIa0 , d  C Ia follows immediately from the induction
hypothesis. Otherwise, d = da , d0 = db for some b with r0 (a, b)  A and r0 vT1 r. By the
induction hypothesis, d0  DIb . Hence, by (), T1  tI 0 (b) |= D. By compactness, there
exists a concept E  tI 0 (b) such that T1 |= E v D. We obtain r0 .E  tI 0 (a). But then
T1 |= r0 .E v r0 .D and we obtain da  C Ia using r0 vT1 r and ().
Claim 2. I is an obj(A)-forest and a model of (T1 , A).
That I is an obj(A)-forest and a model of A follows from the construction. It remains to
show that I is a model of T1 . For role inclusions r v s  T1 it follows from the construction
that rI  sI . Suppose C1 v C2  T1 . If C1 is an EL-concept, then I |= C1 v C2 follows
from Claim 1 and the condition that the Ia are models of T1 . Now assume that C1 = ran(r)
and let d  ran(r)I . If d 6= da for any a, then d  C2I since the Ia are models of T1 . If d = da ,
there exists r0 (b, a)  A with r0 vT1 r. We have ran(r0 )  tI 0 (a), and so T1  tI 0 (a) |= C2 .
Hence, by (), da  C2Ia , i.e. da  C2I by Claim 1.
Claim 3. For every n > 0 there exists an (obj(A), n, 0 )-homomorphism from I to I 0 .
By Lemma 71, it is sufficient to show conditions (in0), (in1), and (in2). Condition (in0)
follows directly from (). Condition (in1) is proved by induction on the construction of C.
The interesting step is for C = S.D with S = r1 u    u rm . Let a  obj(A) and C 
0
tIn, ,u (aI ). Take d0 with (aI , d0 )  S I and d0  DI . If d0  Ia , then, by (), T1  tI 0 (a) |=
0 ,u
0
(aI ). Now assume
S.D. By () and compactness, T2  tI 0 (a) |= S.D. Hence C  tIn,
0
d0 6 Ia . Then there are r10 , . . . , rk0 and b with d0 = bI such that ri0 (a, b)  A for 1  i  k
0
and for every 1  i  m there exists an 1  j  m with rj0 vT1 ri . We have D  tIn, ,u (bI ).
0

0

,u I
(b ). By (), for every 1  j  m there exists an
By the induction hypothesis D  tn,
I0
0 ,u
0
0
1  j  k with rj vT2 ri . But then C  tIn,
(aI ), as required.
0
d
For (in2), let d  I and C = Dtn,0 ,u (d) D. If d 6= aI for any a  obj(A), then
I

by () there exists b  obj(A) such that T1  tI 0 (b) |= u.C. By compactness and (),
0 ,u
0 ,u
0
(d)  tn,
(d0 ), as required. If
T2  tI 0 (b) |= u.C. Hence, there exists d0  I with tn,
I
I0
0
d = aI for some a  obj(A), then, by (in1) shown above, d0 = aI is as required.
This finishes the proof of Lemma 63.

References
Baader, F., Brandt, S., & Lutz, C. (2008). Pushing the EL envelope further. In Proceedings
of the 6th International Workshop on OWL: Experiences and Directions (OWLED
2009), Vol. 529 of CEUR Workshop Proceedings. CEUR-WS.org.
Baader, F., Penaloza, R., & Suntisrivaraporn, B. (2007). Pinpointing in the description
logic EL+ . In Proceedings of the 30th Annual German Conference on Artificial Intelligence (KI 2007), Vol. 4667 of Lecture Notes in Computer Science, pp. 5267,
Heidelberg/Berlin, Germany. Springer Verlag.
703

fiKonev, Ludwig, Walther, & Wolter

Baader, F. (2003). Terminological cycles in a description logic with existential restrictions.
In Proceedings of the 18th International Joint Conference on Artificial Intelligence
(IJCAI 2003), pp. 325330, San Francisco, CA, USA. Morgan Kaufmann.
Bienvenu, M., Lutz, C., & Wolter, F. (2012a). Deciding FO-rewritability in EL. In Proceedings of the 25th International Workshop on Description Logics (DL 2012).
Bienvenu, M., Lutz, C., & Wolter, F. (2012b). Query containment in description logics revisited. In Proceedings of the 13th International Conference on Principles of Knowledge
Representation and Reasoning (KR 2012).
Brandt, S., Kusters, R., & Turhan, A.-Y. (2002). Approximation and difference in description logics. In Proceedings of the 8th International Conference on Principles and
Knowledge Representation and Reasoning (KR-02), pp. 203214, San Francisco, CA,
USA. Morgan Kaufmann.
Calvanese, D., Giacomo, G. D., Lembo, D., Lenzerini, M., & Rosati, R. (2006). Data
complexity of query answering in description logics. In Proceedings of the Tenth
International Conference on Principles of Knowledge Representation and Reasoning
(KR 2006), pp. 260270.
Chandra, A. K., & Merlin, P. M. (1977). Optimal implementation of conjunctive queries in
relational data bases. In Proceedings of the 9th Annual ACM Symposium on Theory
of Computing (STOC 77), pp. 7790, New York, NY, USA. ACM.
Chang, C. C., & Keisler, H. J. (1990). Model Theory, Vol. 73 of Studies in Logic and the
Foundations of Mathematics. Elsevier, Amsterdam, The Netherlands.
Clarke, E., & Schlingloff, H. (2001). Model checking. In Handbook of Automated Reasoning,
Vol. II, chap. 24, pp. 16351790. Elsevier, Amsterdam, The Netherlands.
Conradi, R., & Westfechtel, B. (1998). Version models for software configuration management. ACM Computing Surveys (CSUR), 30 (2), 232282.
Crafa, S., Ranzato, F., & Tapparo, F. (2011). Saving space in a time efficient simulation
algorithm. Fundamenta Informaticae, 108 (1-2), 2342.
Cuenca Grau, B., Horrocks, I., Kazakov, Y., & Sattler, U. (2008). Modular reuse of ontologies: theory and practice. Journal of Artificial Intelligence Research (JAIR), 31,
273318.
Delaitre, V., & Kazakov, Y. (2009). Classifying ELH ontologies in SQL databases. In
Proceedings of the 6th International Workshop on OWL: Experiences and Directions
(OWLED 2009), Vol. 529 of CEUR Workshop Proceedings. CEUR-WS.org.
Eiter, T., Fink, M., & Woltran, S. (2007). Semantical characterizations and complexity of
equivalences in answer set programming. ACM Transactions on Computational Logic,
8 (3).
Ghilardi, S., Lutz, C., & Wolter, F. (2006). Did I damage my ontology? A case for conservative extensions in description logic. In Proceedings of the Tenth International
Conference on Principles of Knowledge Representation and Reasoning (KR 2006),
pp. 187197, Menlo Park, CA, USA. AAAI Press.
704

fiThe Logical Difference for the Lightweight Description Logic EL

Golbeck, J., Fragaso, G., Hartel, F., Hendler, J., Oberhaler, J., & Parsia, B. (2003). The
National Cancer Institutes thesaurus and ontology. Journal of Web Semantics, 1 (1),
7580.
Goncalves, R. S., Parsia, B., & Sattler, U. (2011). Analysing multiple versions of an ontology:
A study of the NCI thesaurus. In Proceedings of the 24th International Workshop
on Description Logics (DL 2011), Vol. 745 of CEUR Workshop Proceedings. CEURWS.org.
Goncalves, R. S., Parsia, B., & Sattler, U. (2012). Concept-based semantic difference in
expressive description logics. In Proceedings of the 25th International Workshop on
Description Logics (DL 2012).
Hofmann, M. (2005). Proof-theoretic approach to description-logic. In Proceedings of the
20th Annual IEEE Symposium on Logic in Computer Science (LICS 2005), pp. 229
237, Washington, DC, USA. IEEE Computer Society.
Horridge, M., Parsia, B., & Sattler, U. (2010). Justification oriented proofs in OWL. In
Proceedings of the 9th International Semantic Web Conference (ISWC 2010), Vol.
6496 of Lecture Notes in Computer Science, pp. 354369, Berlin/Heidelberg, Germany.
Springer-Verlag.
IHTSDO (2008). SNOMED Clinical Terms User Guide. The International Health Terminology Standards Development Organisation (IHTSDO). Available from
http://www.ihtsdo.org/publications/introducing-snomed-ct/.
Jimenez-Ruiz, E., Cuenca Grau, B., Horrocks, I., & Llavori, R. B. (2011). Supporting
concurrent ontology development: Framework, algorithms and tool. Data & Knowledge
Engineering, 70 (1), 146164.
Kalyanpur, A., Parsia, B., Horridge, M., & Sirin, E. (2007). Finding all justifications of
OWL DL entailments. In Proceedings of the 6th International and 2nd Asian Semantic
Web Conference (ISWC07+ASWC07), pp. 267280, Berlin/Heidelberg, Germany.
Springer Verlag.
Kazakov, Y. (2009). Consequence-driven reasoning for Horn SHIQ ontologies. In Proceedings
of the 21st International Conference on Artificial Intelligence (IJCAI 2009), pp. 2040
2045.
Kazakov, Y., Krotzsch, M., & Simancik, F. (2011). Unchain my EL reasoner. In Proceedings of the 24th International Workshop on Description Logics (DL 2011), CEUR
Workshop Proceedings. CEUR-WS.org.
Klein, M. C. A., Fensel, D., Kiryakov, A., & Ognyanov, D. (2002). Ontology versioning and
change detection on the web. In Knowledge Engineering and Knowledge Management:
Ontologies and the Semantic Web, Vol. 2473 of Lecture Notes in Computer Science,
pp. 247259. Springer Verlag, Berlin/Heidelberg, Germany.
Konev, B., Lutz, C., Walther, D., & Wolter, F. (2008). Semantic modularity and module
extraction in description logic. In Proceedings of the 18th European Conference on
Artificial Intelligence (ECAI 2008), Vol. 178 of Frontiers in Artificial Intelligence and
Applications, pp. 5559, Amsterdam, The Netherlands. IOS Press.
705

fiKonev, Ludwig, Walther, & Wolter

Konev, B., Walther, D., & Wolter, F. (2008). The logical difference problem for description
logic terminologies. In Proceedings of the 4th International Joint Conference on Automated Reasoning (IJCAR 2008), Vol. 5195 of Lecture Notes in Computer Science,
pp. 259274, Berlin/Heidelberg, Germany. Springer Verlag.
Konev, B., Kontchakov, R., Ludwig, M., Schneider, T., Wolter, F., & Zakharyaschev, M.
(2011). Conjunctive query inseparability of OWL 2 QL TBoxes. In Proceedings of
the 25th Conference on Artificial Intelligence (AAAI 2011), Menlo Park, CA, USA.
AAAI Press.
Konev, B., Ludwig, M., & Wolter, F. (2012). Logical difference computation with CEX2.5.
In Proceedings of the 6th International Joint Conference on Automated Reasoning
(IJCAR 2012), Lecture Notes in Computer Science, Berlin/Heidelberg, Germany.
Springer.
Konev, B., Lutz, C., Walther, D., & Wolter, F. (2009). Formal properties of modularisation.
In Modular Ontologies, pp. 2566. Springer Verlag, Berlin/Heidelberg, Germany.
Kontchakov, R., Wolter, F., & Zakharyaschev, M. (2010). Logic-based ontology comparison
and module extraction, with an application to DL-Lite. Artificial Intelligence, 174 (15),
10931141.
Kontchakov, R., Pulina, L., Sattler, U., Schneider, T., Selmer, P., Wolter, F., & Zakharyaschev, M. (2009). Minimal module extraction from DL-Lite ontologies using
QBF solvers. In Proceedings of the 21st International Joint Conference on Artificial
Intelligence (IJCAI 2009), pp. 836841, San Francisco, CA, USA. Morgan Kaufmann.
Kutz, O., & Mossakowski, T. (2008). Conservativity in structured ontologies. In Proceedings
of the 18th European Conference on Artificial Intelligence (ECAI 2008), Vol. 178
of Frontiers in Artificial Intelligence and Applications, pp. 8993, Amsterdam, The
Netherlands. IOS Press.
Kutz, O., & Mossakowski, T. (2011). A modular consistency proof for DOLCE. In Proceedings of the 25th Conference on Artificial Intelligence (AAAI 2011), Menlo Park, CA,
USA. AAAI Press.
Kremen, P., Smd, M., & Kouba, Z. (2011). OWLDiff: A practical tool for comparison and
merge of OWL ontologies. In Proceedings of the 10th International Workshop on Web
Semantics, pp. 229233, Los Alamitos, CA, USA. IEEE Computer Society Press.
Lutz, C., Toman, D., & Wolter, F. (2009). Conjunctive query answering in the description
logic EL using a relational database system. In Proceedings of the 21st International
Joint Conference on Artificial Intelligence (IJCAI 2009), pp. 20702075, Menlo Park,
CA, USA. AAAI Press.
Lutz, C., Walther, D., & Wolter, F. (2007). Conservative extensions in expressive description logics. In Proceedings of the 20th International Joint Conference on Artificial
Intelligence (IJCAI 2007), pp. 453458, Menlo Park, CA, USA. AAAI Press.
Lutz, C., & Wolter, F. (2010). Deciding inseparability and conservative extensions in the
description logic EL. Journal of Symbolic Computing, 45 (2), 194228.
Lutz, C., & Wolter, F. (2011). Foundations for uniform interpolation and forgetting in expressive description logics. In Proceedings of the 22nd International Joint Conference
706

fiThe Logical Difference for the Lightweight Description Logic EL

on Artificial Intelligence (IJCAI 2011), pp. 989995, Menlo Park, CA, USA. AAAI
Press.
Mendez, J., & Suntisrivaraporn, B. (2009). Reintroducing CEL as an OWL 2 EL reasoner.
In Proceedings of the 22nd International Workshop on Description Logics (DL 2009),
Vol. 477 of CEUR Workshop Proceedings. CEUR-WS.org.
Noy, N. F., & Musen, M. A. (2002). PromptDiff: A fixed-point algorithm for comparing
ontology versions. In Proceedings of the 18th national conference on Artificial intelligence, pp. 744750, Menlo Park, CA, USA. AAAI Press.
Ohst, D., Welle, M., & Kelter, U. (2003). Differences between versions of UML diagrams.
In Proceedings of the 9th European software engineering conference held jointly with
11th ACM SIGSOFT international symposium on Foundations of software engineering
(ESEC03/SIGSOFT FSE03), pp. 227236, New York, NY, USA. ACM.
Oliver, D. E., Shahar, Y., Shortliffe, E. H., & Musen, M. A. (1999). Representation of
change in controlled medical terminologies. Artificial Intelligence in Medicine, 15 (1),
5376.
Palma, R., Haase, P., Corcho, O., & Gomez-Perez, A. (2009). Change representation for
OWL 2 ontologies. In Proceedings of the 6th International Workshop on OWL: Experiences and Directions (OWLED 2009), Vol. 529 of CEUR Workshop Proceedings.
CEUR-WS.org.
Pearce, D., & Valverde, A. (2004). Uniform equivalence for equilibrium logic and logic programs. In Proceedings of the 7th International Conference on Logic Programming and
Nonmonotonic Reasoning (LPNMR 2004), Vol. 2923 of Lecture Notes in Computer
Science, pp. 194206, Berlin/Heidelberg, Germany. Springer.
Pearce, D., & Valverde, A. (2012). Synonymous theories and knowledge representations in
answer set programming. Journal of Computer and System Sciences, 78 (1), 86104.
Penaloza, R., & Sertkaya, B. (2010). On the complexity of axiom pinpointing in the EL
family of description logics. In Proceedings of the 12th International Conference on
Principles of Knowledge Representation and Reasoning (KR 2010), Menlo Park, CA,
USA. AAAI Press.
Poggi, A., Lembo, D., Calvanese, D., Giacomo, G. D., Lenzerini, M., & Rosati, R. (2008).
Linking data to ontologies. Journal of Data Semantics, 10, 133173.
Redmond, T., Smith, M., Drummond, N., & Tudorache, T. (2008). Managing change: An
ontology version control system. In Proceedings of the 5th International Workshop
on OWL: Experiences and Directions (OWLED 2008), Vol. 432 of CEUR Workshop
Proceedings. CEUR-WS.org.
Rosati, R. (2007). On conjunctive query answering in EL. In Proceedings of the 2007
International Workshop on Description Logic (DL 2007), Vol. 250 of CEUR Workshop
Proceedings. CEUR-WS.org.
Schlobach, S., & Cornet, R. (2003). Non-standard reasoning services for the debugging of
description logic terminologies. In Proceedings of the 18th International Joint Conference on Artificial Intelligence (IJCAI 2003), pp. 355362, San Francisco, CA, USA.
Morgan Kaufmann.
707

fiKonev, Ludwig, Walther, & Wolter

Teege, G. (1994). Making the difference: A subtraction operation for description logics.
In Proceedings of the 4th International Conference on Principles of Knowledge Representation and Reasoning (KR94), pp. 540550, San Francisco, CA, USA. Morgan
Kaufmann.
van Glabbeek, R. J., & Ploeger, B. (2008). Correcting a space-efficient simulation algorithm.
In Proceedings of the 20th International Conference on Computer Aided Verification
(CAV 2008), Vol. 5123 of Lecture Notes in Computer Science, pp. 517529, Heidelberg/Berlin, Germany. Springer Verlag.
Vescovo, C. D., Parsia, B., Sattler, U., & Schneider, T. (2011). The modular structure of
an ontology: Atomic decomposition. In Proceedings of the 22nd International Joint
Conference on Artificial Intelligence (IJCAI 2011), pp. 22322237, Menlo Park, CA,
USA. AAAI Press.

708

fi