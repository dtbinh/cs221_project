Journal of Artificial Intelligence Research 56 (2016) 1-59

Submitted 06/15; published 05/16

Query and Predicate Emptiness in Ontology-Based Data Access
Franz Baader

FRANZ . BAADER @ TU - DRESDEN . DE

TU Dresden, Germany

Meghyn Bienvenu

MEGHYN @ LIRMM . FR

CNRS, Universite de Montpellier
& INRIA, France

Carsten Lutz

CLU @ UNI - BREMEN . DE

University of Bremen, Germany

Frank Wolter

WOLTER @ LIVERPOOL . AC . UK

Department of Computer Science
University of Liverpool, UK

Abstract
In ontology-based data access (OBDA), database querying is enriched with an ontology that
provides domain knowledge and additional vocabulary for query formulation. We identify query
emptiness and predicate emptiness as two central reasoning services in this context. Query emptiness asks whether a given query has an empty answer over all databases formulated in a given
vocabulary. Predicate emptiness is defined analogously, but quantifies universally over all queries
that contain a given predicate. In this paper, we determine the computational complexity of query
emptiness and predicate emptiness in the EL, DL-Lite, and ALC-families of description logics,
investigate the connection to ontology modules, and perform a practical case study to evaluate the
new reasoning services.

1. Introduction
In recent years, the paradigm of ontology-based data access (OBDA) has gained increased popularity. The general idea is to add an ontology to database querying to provide domain knowledge
and to enrich the vocabulary that is available for the formulation of queries. This is particularly
useful when the data to be queried is highly incomplete and when multiple data sources with diverging vocabularies are integrated (Poggi, Lembo, Calvanese, De Giacomo, Lenzerini, & Rosati,
2008). OBDA has been taken up with particular verve in the area of description logic (DL) where it
has been studied intensively both for lightweight DLs such as the members of the DL-Lite and EL
families, which are tractable regarding the data complexity of querying, and for more expressive
DLs such as those of the ALC and SHIQ families where querying is intractable in data complexity. For the use in OBDA of the former, see for example the work of Calvanese, De Giacomo,
Lembo, Lenzerini, Poggi, Rodriguez-Muro, and Rosati (2009), Lutz, Toman, and Wolter (2009),
Perez-Urbina, Motik, and Horrocks (2009), Chortaras, Trivela, and Stamou (2011) and Eiter, Ortiz,
Simkus, Tran, and Xiao (2012), and the surveys by Krotzsch (2012) and Kontchakov, RodriguezMuro, and Zakharyaschev (2013); for the latter, see the work of Glimm, Lutz, Horrocks, and Sattler
(2008), Ortiz, Calvanese, and Eiter (2008), and Bienvenu, ten Cate, Lutz, and Wolter (2014) as well
as the references given in the work of Ortiz and Simkus (2012).
c
2016
AI Access Foundation. All rights reserved.

fiBAADER , B IENVENU , L UTZ , & W OLTER

The OBDA approach is fueled by the availability of ontologies that aim at providing a standard
vocabulary for the targeted application domain. In particular, there are now many such ontologies
in the bio-medical domain such as SNOMED CT (IHTSDO, 2016), NCI (Golbeck, Fragoso, Hartel, Hendler, Oberthaler, & Parsia, 2003), and GO (Gene Ontology Consortium, 2016), which are
all formulated in a DL and allow a comparably inexpensive adoption of OBDA in bio-medical applications such as querying electronic medical records (Patel, Cimino, Dolby, Fokoue, Kalyanpur,
Kershenbaum, Ma, Schonberg, & Srinivas, 2007). Ontologies of this kind typically have a very
broad coverage and their vocabulary often contain tens or even hundreds of thousands of predicates
that embrace various subject areas such as anatomy, diseases, medication, and even social context
and geographic location. In any given application, only a small fragment of the ontologys vocabulary will actually occur in the data. Still, the remaining predicates are potentially very useful for
formulating queries as they are linked to the data vocabulary by the ontologythis is precisely how
OBDA enriches the vocabulary available for query formulation.
Due to the size and complexity of the involved ontologies and vocabularies, however, it can
be difficult to understand which of the additional predicates are useful for query formulation and
how to write meaningful queries in the extended vocabulary. Static analysis tools for analyzing these
queries would thus be very useful. In this paper, we consider the fundamental static analysis problem
of query emptiness as well as a natural variation of it called predicate emptiness. In the former,
the problem is to decide whether a given query q provides an empty answer over all databases
formulated in a given data vocabulary . Query emptiness thus helps to identify queries which are
useless due to wrong use of the ontology vocabulary. It is a standard static analysis problem in many
subareas of database theory such as XML, see e.g. the work of Benedikt, Fan, and Geerts (2008)
and references therein.
As an example, consider the following simple ontology O:
DiabetesPatient  Patient u has disease.Diabetes
DiabetesPatientwithoutMedication  Patient u has disease.Diabetes u
on medication for.Diabetes
Assume that O is used to support querying of a medical patient database which has a unary table
for the concept names Patient and Diabetes and binary tables for the role names has disease and
on medication for, distinguishing in particular between diabetes of type 1 and type 2. For example,
the database could be given by the following set A of assertions:
Patient(a),
has disease(a, type1),

Patient(b),

on medication for(a, type1),

Diabetes(type1),

has disease(b, type2),

Diabetes(type2).

Thus, a is a patient with diabetes of type 1 who is on medication for it and b is a patient with
diabetes of type 2. In OBDA, queries are interpreted under an open world assumption and thus one
is interested in the certain answers to a query q w.r.t. O and A, that is, the answers to q on which
all extension of A that satisfy the ontology O are in agreement. For the concrete query
q1 (x) = DiabetesPatient(x),
a and b are the certain answers to q1 (x) w.r.t. O and Adespite the fact that the predicate DiabetesPatient used in q1 (x) does not occur in A. Since A is formulated using only the data vocabulary
 = {Patient, has disease, on medication for, Diabetes},
2

fiQ UERY AND P REDICATE E MPTINESS

Q UERY EVALUATION

E MPTINESS

DL

IQ

CQ

IQ-query / CQ-predicate

CQ-query

EL

PT IME-c.

NP-c.

PT IME-c.

PT IME-c

EL

PT IME-c.

NP-c.

E XP T IME-c.

E XP T IME-c.

ELI

E XP T IME-c.

E XP T IME-c.

E XP T IME-c.

E XP T IME-c.

Horn-ALCIF

E XP T IME-c.

E XP T IME-c.

E XP T IME-c.

E XP T IME-c.

NL OG S PACE-c.

NP-c.

NL OG S PACE-c.

coNP-c.

PT IME-c.

NP-c.

coNP-c.

coNP-c.

ALC

E XP T IME-c.

E XP T IME-c.

NE XP T IME-c.

NE XP T IME-c.

ALCI

E XP T IME-c.

2E XP T IME-c.

NE XP T IME-c.

2E XP T IME-c.

ALCF

E XP T IME-c.

E XP T IME-c.

undecidable

undecidable

DL-Litecore|F |R
DL-Litehorn

Figure 1: Known complexity results for query evaluation and new complexity results for emptiness

we say that q1 (x) is non-empty for  given O. We regard this as evidence that q1 (x) is a potentially
useful query on databases formulated in vocabulary . As another example, consider the query
q2 (x) = DiabetesPatientwithoutMedication(x)
There is no certain answer to q2 (x) w.r.t. O and A since, under the open world assumption, the mere
absence of the information that b is on medication for diabetes of type 1 or type 2 does not imply
that its negation is true. One can even show that, whatever database A0 formulated in vocabulary 
we use, there will never be any certain answer to q2 (x) w.r.t. O and A0 . In this case, we say that
q2 (x) is empty for  given O. In contrast to q1 (x), this query is thus useless on -databases.
We also consider predicate emptiness, the problem to decide whether for a given predicate p
and data vocabulary , it is the case that all queries q which involve p yield an empty answer over
all -databases. In the example above, the predicate DiabetesPatientwithoutMedication is empty
w.r.t. O and  for the important class of conjunctive queries (queries constructed from atomic formulas using conjunction and existential quantification). Predicate emptiness can be used to identify
predicates in the ontology that are useless for query formulation, before even starting to construct
a concrete query. In a graphical user interface, for example, such predicates would not be offered
to users for query formulation. Our notion of predicate emptiness is loosely related to predicate
emptiness in datalog queries as studied e.g. by Vardi (1989) and Levy (1993).
The aim of this paper is to perform a detailed study of query emptiness and predicate emptiness
for various DLs including members of the EL, DL-Lite, and ALC families, concentrating on the
two most common query languages in DL-based OBDA: instance queries (IQs) and conjunctive
queries (CQs). For all of the resulting combinations of DLs and query languages, we determine the
(un)decidability and exact computational complexity of query emptiness and predicate emptiness.
Our results are summarized on the right side of Figure 1 and range from PT IME for basic members
of the EL and DL-Lite families via NE XP T IME for basic members of the ALC family to undecidable for ALC extended with functional roles (ALCF). We adopt the standard notion of combined
3

fiBAADER , B IENVENU , L UTZ , & W OLTER

complexity, which is measured in terms of the size of the whole input (TBox, data vocabulary, and
query or predicate symbol).
Because of the restricted data vocabulary  and the quantification over all -databases in their
definition, query emptiness and predicate emptiness do not reduce to standard reasoning problems
such as query evaluation and query containment. Formally, this is demonstrated by our undecidability result for ALCF, which should be contrasted with the decidability of query entailment and
containment in this DL, as shown by Calvanese, De Giacomo, and Lenzerini (1998). When emptiness is decidable, the complexity still often differs from that of query evaluation. To simplify the
comparison, we display in Figure 1 known complexity results for query evaluation in the considered DLs; please consult the work of Baader, Brandt, and Lutz (2005, 2008), Krotzsch, Rudolph,
and Hitzler (2007), and Eiter, Gottlob, Ortiz, and Simkus (2008) for the results concerning EL and
its Horn extensions, the work of Calvanese, De Giacomo, Lembo, Lenzerini, and Rosati (2007) and
Artale, Calvanese, Kontchakov, and Zakharyaschev (2009) for the results on DL-Lite, and the work
of Tobies (2001), Hustadt, Motik, and Sattler (2004), Lutz (2008), and Ortiz, Simkus, and Eiter
(2008) for the results on DLs from the ALC family. By comparing the two sides of Figure 1, we
observe that there is no clear relationship between the complexity of emptiness checking and the
complexity of query evaluation. Indeed, while the problems are often of similar complexity, there
are several cases in which emptiness checking is more difficult than the corresponding query evaluation problem. It can also be the other way around, and complexities can also be incomparable. Note
that for the extension EL of EL with the bottom concept  (used to express class disjointness), we
observe a particularly significant difference between the tractability of evaluating instance queries
and the E XP T IME-completeness of checking IQ-query emptiness.
A key ingredient in developing algorithms and establishing upper complexity bounds for emptiness is to show that, when searching for databases that witness non-emptiness (such as the database
A for the non-emptiness of q1 for  given O in the above example), one can often focus on a single
database constructed specifically for that purpose or on a class of databases that are easier to handle
than the class of all databases. Which single database / class of databases to consider depends on the
DL in question. For this reason, a secondary theme of this paper is to analyze the shape of witness
databases. It turns out that in ALC and its extension ALCI with inverse roles, we can consider a
single exponential-size database whose construction is reminiscent of type elimination and filtration
constructions known from the modal logic literature. For EL and its extension ELI, we may also
concentrate on a single witness candidate, but a much simpler one: it consists of all facts that can
be constructed using the data vocabulary and a single constant. For other extensions of EL, we
use a class of databases as witness candidates, namely those that have a tree or forest structure. In
DL-Lite, we may restrict our attention to the class of databases whose size is bounded polynomially
w.r.t. the input query and ontology.
To demonstrate that predicate emptiness is a useful reasoning service for static analysis, we
perform experiments using the well-known and large-scale medical ontology SNOMED CT coupled
with both a real-world data vocabulary (corresponding to terms obtained by analyzing clinical notes
from a hospital) and with randomly generated vocabularies. For the real world vocabulary, which
contains 8,858 of the 370,000 concept names and 16 of the 62 role names in SNOMED CT,
16,212 predicates turned out to be non-empty for IQs and 17,339 to be non-empty for CQs. Thus,
SNOMED CT provides a very substantial number of additional predicates for query formulation
while a large number of other predicates cannot meaningfully be used in queries over -databases;
thus, identifying the relevant predicates via predicate emptiness is potentially very helpful.
4

fiQ UERY AND P REDICATE E MPTINESS

We also consider the use of query and predicate emptiness for the extraction of modules from
an ontology. Thus, instead of using emptiness directly to support query formulation, we show how
it can be used to simplify an ontology. A -substitute of an ontology is a subset of the ontology
that gives the same certain answers to all conjunctive queries over all -databases. Replacing a
large ontology with a (potentially quite small) -substitute supports comprehension of the ontology
and thereby the formulation of meaningful queries. We show that, for ELI, one can use predicate emptiness to extract a particularly natural -substitute of an ontology, called its CQ -core,
containing exactly those axioms from the original ontology that contain only predicates which are
non-empty for -databases. Thus, all predicates in the CQ -core of an ontology can be meaningfully used in queries posed to -databases. In our example, the CQ -core of the ontology O is
O0 = {DiabetesPatient  Patient u has disease.Diabetes}.
The second axiom was removed because any CQ that contains DiabetesPatientwithoutMedication
is empty for  given O. To analyze the practical interest of CQ -cores, we carry out a case study
where we compute CQ -cores for the ontology SNOMED CT coupled with various signatures,
showing that they tend to be drastically smaller than the original ontology and also smaller than
-modules, a popular way of extracting modules from ontologies (Grau, Horrocks, Kazakov, &
Sattler, 2008).
This article is structured as follows. We begin in Section 2 by recalling the syntax and semantics of the description logics considered in this work. In Section 3, we introduce four notions of
emptiness (IQ-query, IQ-predicate, CQ-predicate, and CQ-query) and investigate the formal relationships between them. We first observe that IQ-query and IQ-predicate emptiness coincide
(so there are only three problems to consider) and that CQ-predicate emptiness corresponds to CQquery emptiness where CQs are restricted to a very simple form. We also exhibit two polynomial
reductions between predicate and query emptiness: for all DLs considered in this paper except those
from the DL-Lite family, CQ-predicate emptiness is polynomially reducible to IQ-query emptiness, and for all Horn-DLs considered in this paper, IQ-query emptiness is polynomially reducible
to CQ-predicate emptiness.
In Section 4, we investigate the computational complexity and decidability of query and predicate emptiness in the ALC family of expressive DLs. For ALC and ALCI, we provide tight
complexity bounds, showing NE XP T IME-completeness for all three emptiness problems in ALC
and for IQ-query emptiness and CQ-predicate emptiness in ALCI, and 2E XP T IME-completeness
for CQ-query emptiness in ALCI. The situation is dramatically (and surprisingly) different for
ALCF, for which all emptiness problems are proven undecidable. As previously mentioned, the
complexity upper bounds for ALC and ALCI rely on a characterization of non-emptiness in terms
of a special witness database. The complexity lower bounds and undecidability results are proven
by means of reductions from tiling problems.
In Section 5, we continue our investigation of query and predicate emptiness by considering
the DL EL and its Horn extensions. For plain EL, we provide a simple characterization of nonemptiness in terms of a maximal singleton database, which allows us to show that all three emptiness
problems can be decided in polynomial time. Using the same characterization and the fact that
standard reasoning in ELI is E XP T IME-complete, we obtain E XP T IME-completeness of emptiness
checking in ELI. For extensions of EL that allow for contradictions, the singleton database may not
be consistent with the ontology, requiring another approach. To handle such extensions, we show
5

fiBAADER , B IENVENU , L UTZ , & W OLTER

that it is sufficient to consider tree-shaped databases as witnesses for non-emptiness, and we devise
a decision procedure for emptiness checking based upon tree automata. We obtain in this manner an
E XP T IME upper bound for Horn-ALCIF, which sharply contrasts with our undecidability result
for (non-Horn) ALCF. Interestingly, we can show a matching E XP T IME lower bound for the
considerably simpler DL EL , for which standard reasoning tasks are tractable.
In Section 6, we turn our attention to the DL-Lite family of lightweight DLs, which are the most
commonly considered DLs for ontology-based data access. We show that CQ-query emptiness is
coNP-complete for all considered DL-Lite dialects. For IQ-query emptiness and CQ-predicate
emptiness, we show that the complexity depends on whether the considered dialect allows for conjunctions on the left-hand side of axioms. For standard dialects like DL-Litecore , DL-LiteR , and
DL-LiteF , which do not allow for conjunction, we show that IQ-query emptiness and CQ-predicate
emptiness are NL OG S PACE-complete. For dialects like DL-Litehorn that admits conjunctions, both
IQ-query emptiness and CQ-predicate emptiness are coNP-complete. This difference in complexity is due to the fact that for dialects allowing conjunction, we need to consider witnesses for nonemptiness that are of polynomial size, whereas in the absence of conjunction, it is sufficient to
consider databases that consist of a single assertion.
In Section 7, we apply query and predicate emptiness to extract modules of an ontology. We
introduce the notion of a -substitute and of a CQ -core of an ontology and show that for ELI the
CQ -core of an ontology is a -substitute. We also relate -substitutes to other notions of module
proposed in the literature. In particular, we observe that semantic and syntactic -modules (Grau
et al., 2008) are examples of -substitutes, and thus, algorithms for computing such modules can
also be used to compute (possibly non-minimal) -substitutes. We then demonstrate the potential
utility of -substitutes and emptiness checking by experiments based on SNOMED CT.
Finally, in Sections 8 and 9, we conclude the paper by discussing related and future work. Please
note that to improve the readability of the text, some technical proofs are deferred to the appendix.

2. Preliminaries
In DLs, concepts are inductively defined with the help of a set of constructors, starting with countably infinite sets NC of concept names and NR of role names. The constructors that are most important in this paper are summarized in Figure 2. An inverse role has the form r with r a role name
and a role is a role name or an inverse role. For uniformity, we define double inverse to be identity,
that is, (r ) := r for all role names r. Throughout the paper, we use A, B to denote concept
names, C, D to denote (possibly compound) concepts, and r and s to denote roles.
We shall be concerned with a variety of different DLs that are all well-known from the literature.
The least expressive ones are EL and DL-Lite, which are the logical underpinnings of the OWL2
profiles OWL2 EL and OWL2 QL, respectively (Motik, Grau, Horrocks, Wu, Fokoue, & Lutz,
2009). In EL, concepts are constructed according to the following grammar using the constructors
top concept, conjunction, and existential restriction:
C, D

::=

>

|

A

| C uD

|

r.C

with A ranging over concept names and r over role names. DL-Lite concepts and TBoxes will be
introduced in Section 6. The basic expressive DL we consider in this paper is ALC which is the
extension of EL with the constructors bottom concept, negation, disjunction and value restriction:
C, D

::=

>

|



| A

| C uD
6

|

C tD

|

r.C

|

r.C

fiQ UERY AND P REDICATE E MPTINESS

Name

Syntax

concept name
role name

A
r

Semantics
AI
rI

top concept
bottom concept
negation
conjunction
disjunction
existential restriction
value restriction
role inverse

>

C
C uD
C tD
r.C
r.C
r

>I = I
I = 
I \ C I
C I  DI
C I  DI
{d  I | e  C I with (d, e)  rI }
{d  I | e  I : (d, e)  rI  e  C I }
{(d, e) | (e, d)  rI }

concept inclusion
concept assertion
role assertion

CvD
A(a)
r(a, b)

C I  DI
aI  AI
(aI , bI )  rI

Figure 2: Syntax and semantics of DL constructors, TBox axioms, and ABox assertions.

The availability of additional constructors is indicated by concatenation of letters or subscripts: the
letter I stands for the addition of inverse roles (inside existential and value restrictions, if present)
and the subscript  stands for adding . This gives, for example, the extension ALCI of ALC
with inverse roles, whose constructors are exactly the ones shown in Figure 2. It also defines the
extension ELI  of EL with inverse roles in existential restrictions and the bottom concept.
A concept inclusion (CI) in a DL L takes the form C v D, where C and D are L-concepts.
We use C  D as an abbreviation for the CIs C v D and D v C. In description logic, ontologies
are formalized as TBoxes. Given any of the DLs L introduced above, an L-TBox is a finite set of
CIs in L. We use the letter F and write LF to denote the description logic in which TBoxes consist
not only of CIs in L, but also of functionality statements funct(r), where r is a role name or an
inverse role (if inverse roles are admitted in L). For example, ALCF is thus the extension of ALC
in which TBoxes can contain CIs in ALC and functionality statements for role names. We use the
term axioms to refer to concept inclusions and functionality statements in a uniform way.
In addition to the DLs introduced above, we also consider some DLs that impose restrictions
on which constructors can be used on which side of concept inclusions. A Horn-ALCI concept
inclusion (CI) is of the form L v R, where L and R are concepts defined by the syntax rules
R, R0 ::= > |  | A | A | R u R0 | L t R | r.R | r.R
L, L0 ::= > |  | A | L u L0 | L t L0 | r.L
with A ranging over concept names and r over (potentially inverse) roles. A Horn-ALCIF-TBox
T is a finite set of Horn-ALCI CIs and functionality statements funct(r). Note that different
definitions of Horn-DLs can be found in the work of Hustadt, Motik, and Sattler (2007), Eiter et al.
(2008), and Kazakov (2009). As the original definition by Hustadt, Motik, and Sattler based on
polarity is rather technical, we prefer the above (equivalent) definition.
The size |T | of a TBox T is obtained by taking the sum of the lengths of its axioms, where the
length of an axiom is the number of symbols needed to write it as a word.
7

fiBAADER , B IENVENU , L UTZ , & W OLTER

Databases are represented using an ABox, which is a finite set of concept assertions A(a) and
role assertions r(a, b), where a, b are drawn from a countably infinite set NI of individual names,
A is a concept name, and r is a role name. Note that role assertions cannot use inverse roles. As
a shortcut, though, we sometimes write r (a, b)  A for r(b, a)  A. We use Ind(A) to denote
the set of individual names used in the ABox A. A knowledge base is a pair K = (T , A) with T a
TBox and A an ABox.
The semantics of description logics is defined in terms of an interpretation I = (I , I ). The
domain I is a non-empty set and the interpretation function I maps each concept name A  NC
to a subset AI of I , each role name r  NR to a binary relation rI on I , and each individual
name a to an element aI  I . The extension of I to compound concepts is inductively defined
as shown in the third column of Figure 2. An interpretation I satisfies (i) a CI C v D if C I  DI ,
a statement funct(r) if rI is functional, (iii) an assertion A(a) if aI  AI , and (vi) an assertion
r(a, b) if (aI , bI )  rI . Then, I is a model of a TBox T if it satisfies all axioms in T , and a model
of an ABox A if it satisfies all assertions in A. A TBox is satisfiable if it has a model and an ABox
A is satisfiable w.r.t. a TBox T if T and A have a common model. We write T |= C v D if all
models of T satisfy the CI C v D.
We consider two types of queries. First, instance queries (IQs) take the form A(v), where A is a
concept name and v an individual variable taken from a set NV . Note that instance queries can only
be used to query concept names, but not role names. This is the traditional definition, which is due
to the fact that role assertions can only be implied by an ABox if they are explicitly contained in it,
and thus querying is trivial.1 The more general conjunctive queries (CQs) take the form ~u (~v , ~u)
where  is a conjunction of atoms of the form A(v) and r(v, v 0 ) with v, v 0 individual variables from
~v  ~u  NV . Variables that are not existentially quantified are called answer variables, and the
arity of q is defined as the number of its answer variables. Queries of arity 0 are called Boolean.
We use var(q), avar(q), and qvar(q) to denote the set of variables, answer variables, and quantified
variables respectively in the query q. From now on, we use IQ to refer to the set of all IQs and CQ
to refer to the set of all CQs.
Let I be an interpretation and q an (instance or conjunctive) query q of arity k with answer
variables v1 , . . . , vk . A match of q in I is a mapping  : var(q)  I such that (v)  AI for
all A(v)  q, ((v), (v 0 ))  rI for all r(v, v 0 )  q, and for every answer variable v  var(q),
there is an individual name a with (v) = aI . We write I |= q[a1 , . . . , ak ] if there is a match
 of q in I such that (vi ) = aIi for every 1  i  k. For a knowledge base (T , A), we write
T , A |= q[a1 , . . . , ak ] if I |= q[a1 , . . . , ak ] for all models I of T and A. In this case, (a1 , . . . , ak )
is a certain answer to q w.r.t. T and A. We use certT ,A (q) to denote the set of all certain answers
to q w.r.t. T and A. Note that when q is a Boolean query, we have ()  certT ,A (q) if there is a
match for q in every model of T , A, and otherwise certT ,A (q) = . The query evaluation problem
for CQs for a DL L is the problem to decide for an L-TBox T , ABox A, CQ q of arity k, and tuple
~a  Ind(A)k , whether ~a  certT ,A (q).
We use the term predicate to refer to a concept name or role name and signature to refer to a
set of predicates (in the introduction, we informally called a signature a vocabulary). Then sig(q)
denotes the set of predicates used in the query q, and similarly sig(T ) and sig(A) refer to the
signature of a TBox T and ABox A. A -ABox is an ABox that uses only predicates from the
signature , and likewise for a -concept.
1. This is no longer true in the presence of role hierarchy statements which, however, we do not consider in this paper.

8

fiQ UERY AND P REDICATE E MPTINESS

In the context of query answering in DLs, it is sometimes useful to adopt the unique name
assumption (UNA), which requires that aI 6= bI for all interpretations I and all a, b  NI with
a 6= b. The results obtained in this paper do not depend on the UNA. The following well-known
lemma shows that the UNA does not make a difference in ALCI (and all its fragments such as EL
and ALC) because the certain answers to queries do not change.
Lemma 1 Let T be an ALCI-TBox, A an ABox, and q  CQ. Then certT ,A (q) is identical with
and without the UNA.
An analogous statement fails for ALCF, e.g. because the ABox A = {f (a, b), f (a, b0 )} is satisfiable w.r.t. the TBox T = {funct(r)} without the UNA (and thus certT ,A (A(v)) = ), but
unsatisfiable with the UNA (and thus certT ,A (A(v)) = Ind(A)).

3. Query and Predicate Emptiness
We introduce the central notions and reasoning problems studied in this paper, show how they are
interrelated, and make some basic observations that are used throughout the paper. The following
definition introduces the different notions of emptiness studied in this paper.
Definition 2 Let T be a TBox,  a signature, and Q  {IQ, CQ} a query language. Then we call
 an Q-query q empty for  given T if for all -ABoxes A that are satisfiable w.r.t. T , we have
certT ,A (q) = .
 a predicate S Q-empty for  given T if every Q-query q with S  sig(q) is empty for 
given T .
In what follows, the signatures  used in ABoxes will be called ABox signatures. We quantify over
all ABoxes that are formulated in the ABox signature to address typical database applications in
which the data changes frequently, and thus deciding emptiness based on a concrete ABox is not of
much interest. As an example, assume that ABoxes are formulated in the signature
 = {Person, hasDisease, DiseaseA, DiseaseB}
where here and in the following, all upper-case words are concept names and all lower-case ones
are role names. This signature is typically fixed in the application design phase, similar to schema
design in databases. For the TBox, we take
T = {Person v hasFather.(Person u Male), DiseaseA v InfectiousDisease}.
Then both the IQ InfectiousDisease(v) and the CQ v hasFather(u, v) are non-empty for  given T
despite using predicates that cannot occur in the data, as witnessed by the -ABoxes {DiseaseA(a)}
and {Person(a)}, respectively. This illustrates how the TBox T enriches the vocabulary that is
available for query formulation. By contrast, the CQ
vv 0 (hasFather(u, v)  hasDisease(v, v 0 )  InfectiousDisease(v 0 )),
which uses the same predicates plus an additional one from the ABox signature, is empty for 
given T .
9

fiBAADER , B IENVENU , L UTZ , & W OLTER

Regarding predicate emptiness, it is interesting to observe that the choice of the query language
is important. For example, the predicate Male is IQ-empty for  given T , but not CQ-empty as
witnessed by the -ABox {Person(a)} and the CQ v Male(v). It thus makes no sense to use Male
in instance queries over -ABoxes given T , whereas it can be meaningfully used in conjunctive
queries.
As every IQ is also a CQ, a predicate that is CQ-empty must also be IQ-empty. As illustrated
by the above example, the converse does not hold. Also note that all role names are IQ-empty for 
given any T since a role name cannot occur in an instance query. By contrast, hasFather is clearly
not CQ-empty in the above example.
It follows from Lemma 1 that, in ALCI and its fragments, query emptiness and predicate emptiness are oblivious as to whether or not the UNA is made, both for IQ and CQ. As established by the
following lemma, this is also true in ALCIF despite the fact that the certain answers to queries
can differ with and without the UNA.
Lemma 3 Let T be an ALCIF-TBox. Then each CQ q is empty for  given T with the UNA iff it
is empty for  given T without the UNA.
The proof of Lemma 3 is given in the appendix. For the direction from left to right one assumes
that q is non-empty for  given T without the UNA and takes a witness -ABox A. Using a model
I satisfying A and T without the UNA and by identifying any a, b  Ind(A) with aI = bI one
can define a -ABox A0 from A that shows that q is non-empty for  given T with the UNA.
Conversely, one assumes that q is non-empty for  given T with the UNA and takes a witness
-ABox A. One can use A to show that q is non-empty for  given T without the UNA.
With the exception of a DL-Lite dialect (containing role inclusions) all DLs considered in this
paper are fragments of ALCIF. Thus, we are free to adopt the UNA or not. In the remainder of
the paper, we will choose whatever is more convenient, but be careful to always point out explicitly
whether the UNA is made or not. For the DL-Lite dialect not covered by the formulation of Lemma 3
we will observe in our discussion of DL-Lite that even Lemma 1 holds and so we are free to adopt
the UNA or not in that case as well.
It is also relevant to note that our decision to disallow individual names in query atoms is without
any loss of generality. Indeed, it is easily verified that predicate emptiness is the same whether we
admit individuals in queries or not. Moreover, there is an immediate reduction of query emptiness
for generalized CQs (which may contain individual names) to query emptiness for CQs as defined
in this paper: it suffices to replace every individual a in the query by a fresh answer variable xa , and
then test whether the resulting query (without individuals) is empty for  given T .
Definition 2 gives rise to four natural decision problems.
Definition 4 Let Q  {IQ, CQ}. Then
 Q-query emptiness is the problem of deciding, given a TBox T , a signature , and an Qquery q, whether q is empty for  given T ;
 Q-predicate emptiness means to decide, given a TBox T , a signature , and a predicate S,
whether S is Q-empty for  given T .
10

fiQ UERY AND P REDICATE E MPTINESS

IQ-query = IQ-predicate
emptiness
emptiness
Trivial

CQ-query
emptiness

Theorem 7
(materializable DLs)

Lemma 5

Theorem 6

CQ-predicate
emptiness

Figure 3: Polytime reductions between emptiness notions.
Clearly, these four problems are intimately related. In particular, IQ-query emptiness and IQpredicate emptiness are effectively the same problem since an instance query consists only of a
single predicate. For this reason, we will from now on disregard IQ-predicate emptiness and only
speak of IQ-query emptiness. In the CQ case, things are different. Indeed, the following lemma
shows that CQ-predicate emptiness corresponds to CQ-query emptiness where CQs are restricted to
a very simple form. It is an easy consequence of the fact that, since composite concepts in queries
are disallowed, CQs are purely positive, existential, and conjunctive.
Lemma 5 A  NC (resp. r  NR ) is CQ-predicate empty for  given T iff the conjunctive query
v A(v) (resp. vv 0 r(v, v 0 )) is empty for  given T .
Lemma 5 allows us to consider only queries of the form v A(v) and vv 0 r(v, v 0 ) when dealing
with CQ-predicate emptiness. From now on, we do this without further notice.
Trivially, IQ-query emptiness is a special case of CQ-query emptiness. The following observation is less obvious and applies to all DLs considered in this paper except those from the DL-Lite
family.
Theorem 6 In any DL contained in ALCIF that admits CIs r.B v B and r.> v B with B a
concept name, CQ-predicate emptiness can be polynomially reduced to IQ-query emptiness.
Proof. Let T be a TBox,  a signature, B a concept name that does not occur in T and , and s a
role name that does not occur in T and . We prove that
1. A is CQ-predicate empty for  given T iff the IQ B(v) is empty for   {s} given the TBox
T 0 = T  TB  {A v B}, where TB = {r.B v B | r = s or r occurs in T };
2. r is CQ-predicate empty for  given T iff the IQ B(v) is empty for   {s} given the TBox
T 0 = T  TB  {r.> v B}, where TB is as above.
The proofs of Points 1 and 2 are similar, and we concentrate on Point 1. First suppose that A is CQpredicate non-empty for  given T . Then there is a -ABox A such that T , A |= v A(v). Choose
an a0  Ind(A) and set A0 := A  {s(a0 , b) | b  Ind(A)}. Using the fact that T , A |= v A(v)
and the definition of A0 and T 0 , it can be shown that T 0 , A0 |= B(a0 ). For the converse direction,
suppose that B is IQ-query non-empty for {s} given T 0 . Then there is a {s}-ABox A0 such
that T 0 , A0 |= B(a) for some a  Ind(A0 ). Let A be obtained from A0 by removing all assertions
s(a, b). Using the fact that T 0 , A0 |= B(a) and the definition of A0 and T 0 , it can be shown that
T , A |= v A(v).
o

11

fiBAADER , B IENVENU , L UTZ , & W OLTER

Figure 3 gives an overview of the available polytime reductions between our four (rather: three)
problems. In terms of computational complexity, CQ-query emptiness is thus (potentially) the hardest problem, while CQ-predicate emptiness is the simplest. More precisely, if CQ-query emptiness
in a DL L belongs to a complexity class C (larger than or equal to PT IME), then IQ-query emptiness
and CQ-predicate emptiness in L are also in C. Moreover, for DLs L satisfying the conditions of
Theorem 6, C-hardness of CQ-predicate emptiness in L implies C-hardness of CQ-query emptiness
and IQ-query emptiness in L.
Under certain conditions, we can also prove the converse of Theorem 6. Following the work of
Lutz and Wolter (2012), we call a model I of a TBox T and an ABox A a materialization of T
and A if for every CQ q of arity k and tuple ~a  Ind(A)k , I |= q[~a] iff T , A |= q[~a]. A DL L is
called materializable if for every ABox A that is satisfiable w.r.t. T there exists a materialization
of T and A. Typical DL-Lite dialects, the DL EL, and Horn-extensions of EL such as ELIF  are
materializable (Lutz & Wolter, 2012).
Theorem 7 Let L be a materializable DL that admits CIs of the form A1 u A2 v A3 , where
A1 , A2 , A3  NC . Then, in L, IQ-query emptiness can be polynomially reduced to CQ-predicate
emptiness.
Proof. We claim that the IQ A(v) is empty for  given T iff B is CQ-empty for   {X} given the
TBox T 0 = T  {A u X v B}, where B and X are concept names that do not occur in T .
For the if direction, assume that A(v) is IQ non-empty for  given T , and let A be a ABox such that T , A |= A(a) for some a  Ind(A). Set A0 := A  {X(a)}. It is easy to see that
T 0 , A0 |= v B(v) and thus B is CQ-predicate non-empty for   {X} given T 0 .
For the only if direction, assume that B is CQ non-empty for   {X} given T 0 , and let A0
be a   {X}-ABox which is satisfiable with T 0 and such that T 0 , A0 |= v B(v). We may assume
that X(a)  A0 for all a  Ind(A0 ) as adding these assertions can neither result in unsatisfiability
w.r.t. T 0 nor invalidate T 0 , A0 |= v B(v). By our assumption of materializability, there exists a
materialization I 0 of T 0 and A0 and we have I 0 |= v B(v). By definition of T 0 , we may assume
0
0
0
0
that X I = Ind(A0 ) and B I = AI  X I (if this is not the case, we can take a modified version,
00
00
0
0
00
0
I 00 , of I 0 that is defined by setting X I := Ind(A0 ), B I := AI  X I , and Y I := Y I for all
0
remaining concept and role names Y ; then I 00 still satisfies T 0 and A0 since X I  Ind(A0 ) and
00
0
A u X v B is the only inclusion containing X or B and it is still a materialization since Y I  Y I
for all concept and role names Y ). But then I 0 |= v B(v) implies that there is an a  Ind(A0 ) with
I 0 |= B(a). Since I 0 is a materialization of T 0 and A0 , this implies T 0 , A0 |= B(a). By definition of
T 0 , this implies T , A |= A(a), where A is obtained from A0 by dropping all assertions of the form
X(b). Since A is a -ABox and satisfiable w.r.t. T (since A0 is satisfiable w.r.t. T 0 ), it witnesses
that A(v) is non-empty for  given T .
o
As a final observation in this section, we note that deciding query and predicate emptiness is
essentially just ABox satisfiability whenever  contains all symbols used in the TBox. By the
described reductions, it suffices to consider CQ-query emptiness. For a CQ q = ~u (~v , ~u) we
associate with every individual variable v in q an individual name av and set
Aq = {A(av ) | A(v) is a conjunct in }  {r(av , av0 ) | r(v, v 0 ) is a conjunct in }.
Theorem 8 Let T be an ALCIF-TBox,  a signature with sig(T )  , and q a CQ. Then q is
empty for  given T iff sig(q) 6  or Aq is unsatisfiable w.r.t. T .
12

fiQ UERY AND P REDICATE E MPTINESS

Proof. (If) Assume that q is non-empty for  given T . Then there is a -ABox A that is
satisfiable w.r.t. T and such that certT ,A (q) 6= . This clearly implies sig(q)   since otherwise
there is a predicate in sig(q) \  and we can find a model of T and A in which this predicate is
interpreted as the empty set, which would mean certT ,A (q) = . It thus remains to show that Aq is
satisfiable w.r.t. T . To this end, let I be a model of T and A. Since certT ,A (q) 6= , there exists a
match  of q in I. Modify I by setting aIv = (v) for all variables v used in q. It is readily checked
that the modified I is a model of Aq and T , thus Aq is satisfiable w.r.t. T as required.
(Only if) Assume that sig(q)   and Aq is satisfiable w.r.t. T . Then sig(Aq )  . Since
clearly certT ,Aq (q) 6= , this means that q is non-empty for  given T .
o

4. Expressive Description Logics
We consider query and predicate emptiness in the ALC family of expressive DLs, establishing tight
complexity results for ALC and ALCI, and undecidability for ALCF. We start with upper bound
proofs, showing that IQ-query emptiness and CQ-predicate emptiness in ALCI are in NE XP T IME, and so is CQ-query emptiness in ALC. Moreover, we establish that CQ-query emptiness
is in 2E XP T IME. We then move on to the corresponding lower bound proofs and also establish
undecidability of all considered emptiness problems in ALCF.
4.1 Upper Bounds
The first main step in our proofs is to show that, when deciding emptiness problems in ALC or
ALCI, it suffices to consider a single special -ABox. Specifically, we show how to construct
from a given satisfiable TBox T and ABox signature  the canonical -ABox AT , such that for
every CQ q, we have certT ,AT , (q) 6=  if and only if there exists a -ABox A that is satisfiable
w.r.t. T such that certT ,A (q) 6= . We then prove NE XP T IME upper bounds for IQ-query emptiness in ALCI by computing AT , (in exponential time) and then guessing a model of AT , (of
exponential size in |T | and ) that falsifies the query; an 2E XP T IME upper bound for CQ-query
emptiness in ALCI is obtained in an even simpler way by computing AT , and then checking
whether certT ,AT , (q) =  using known algorithms. Significantly more work is required to obtain
a NE XP T IME upper bound for CQ-query emptiness in ALC. We again construct AT , , but need to
exercise a lot of care to check whether certT ,AT , (q) =  without leaving NE XP T IME.
Let T be a satisfiable ALCI-TBox and  an ABox signature. To define the canonical -ABox
for T , we introduce the well-known notion of types (or Hintikka sets) (Pratt, 1979; Kaminski,
Schneider, & Smolka, 2011). The closure cl(T , ) of T and  is the smallest set that contains
  NC as well as all concepts that occur (potentially as a subconcept) in T and is closed under
single negations. A type for T and  is a set t  cl(T , ) such that for some model I of T and
some d  I , we have t = tI (d), where tI (d) = {C  cl(T , ) | d  C I } is the type for T
and  realized by d in I. Let TT , denote the set of all types for T and . For a role name r and
t, t0  TT , , we say that the pair (t, t0 ) is r-coherent and write t ;r t0 if
 C  t0 whenever r.C  t, and
 C  t whenever r .C  t0 .
It can be seen that the above implies also corresponding conditions on existential restrictions, such
as C  t0 and r.C  cl(C, T ) implies r.C  t.
13

fiBAADER , B IENVENU , L UTZ , & W OLTER

Definition 9 (Canonical -ABox) Let T be a satisfiable ALCI-TBox and  an ABox signature.
Fix a (distinct) individual name at for each t  TT , . The canonical -ABox AT , for T is defined
as follows:
AT , = {A(at ) | A  t and t  TT , , A    NC } 
{r(at , at0 ) | t ;r t0 and t, t0  TT , , r    NR }.
The cardinality of TT , is at most exponential in the size of T and the cardinality of , and the
set TT , can be computed in exponential time by making use of well-known E XP T IME procedures
for concept satisfiability w.r.t. TBoxes in ALCI (Gabbay, Kurucz, Wolter, & Zakharyaschev, 2003,
p. 72) Thus, AT , is of exponential size and can be computed in exponential time. It is interesting
to note that the ABox AT , is a finitary version of the canonical model for basic modal logic and is
essentially identical to the model constructed by Pratts type elimination procedure (Pratt, 1979); in
fact, it is exactly identical when   sig(T ). We now show that AT , is satisfiable w.r.t. T .
Lemma 10 Let T be a satisfiable ALCI-TBox and  an ABox signature. Then AT , is satisfiable
w.r.t. T .
Proof. Let the interpretation IT , be defined by setting
IT ,

= TT ,

AIT ,

= {t  TT , | A  t}

rIT ,

= {(t, t0 )  TT ,  TT , | t ;r t0 }

for all A  NC and r  NR . One can prove by induction on the structure of C that for all C 
cl(T , ), we have C  t iff t  C IT , . By definition of types, C v D  T and C  t imply D  t.
Thus, IT , is a model of T . It is an immediate consequence of the definition of AT , that IT , is
also a model of AT , ; in fact, AT , can be regarded as the reduct of IT , to signature .
o
As a crucial tool for analyzing the properties of canonical ABoxes, we introduce homomorphism
between ABoxes. Let A and A0 be ABoxes. An ABox homomorphism from A to A0 is a total
function h : Ind(A)  Ind(A0 ) such that the following conditions are satisfied:
 A(a)  A implies A(h(a))  A0 ;
 r(a, b)  A implies r(h(a), h(b))  A0 .
The next lemma identifies a central property of ABox homomorphisms regarding query answering.
Lemma 11 If T is an ALCI-TBox, q is a CQ such that T , A |= q[a1 , . . . , an ], and h is an ABox
homomorphism from A to A0 , then T , A0 |= q[h(a1 ), . . . , h(an )].
Proof. We prove the contrapositive. Thus assume that T , A0 6|= q[h(a1 ), . . . , h(an )]. Then there is a
model I 0 of T and A0 such that I 0 6|= q[h(a1 ), . . . , h(an )]. Define a model I by starting with I 0 and
0
reinterpreting the individual names in Ind(A) by setting aI = h(a)I for each a  Ind(A). Since
individual names do not occur in T , I is a model of T . It is also a model of A: if A(a)  A, then
A(h(a))  A0 by definition of ABox homomorphisms. Since I 0 is a model of A0 and by definition
of I, it follows that aI  AI . The case r(a, b)  A is analogous. Finally, I 0 6|= q[h(a1 ), . . . , h(an )]
and the definition of I yield I 6|= q[a1 , . . . , an ]. We have thus shown that T , A 6|= q[a1 , . . . , an ].
o
14

fiQ UERY AND P REDICATE E MPTINESS

The following lemma characterizes satisfiability of -ABoxes w.r.t. T by the existence of an ABox
homomorphism into AT , .
Lemma 12 Let T be a satisfiable ALCI-TBox and  an ABox signature. A -ABox A is satisfiable
w.r.t. T iff there is an ABox homomorphism from A to AT , .
Proof. Assume A is satisfiable w.r.t. T . Let I be a model of T and A. Define a homomorphism h
from A to AT , by setting h(a) = at , where t is the type for T and  realized by aI in I. Using
the definition of AT , , one can see that h is indeed an ABox homomorphism. Conversely, let h be
an ABox homomorphism from A to AT , . By Lemma 10, AT , is satisfiable w.r.t. T . The proof
of Lemma 11 shows how one can construct a model of T and A from a model of T and AT , using
the homomorphism h. Thus A is satisfiable w.r.t. T .
o
We are now ready to prove the main property of AT , regarding emptiness, as discussed at the
beginning of this section.
Theorem 13 Let T be a satisfiable ALCI-TBox and  an ABox signature. A CQ q is empty for 
given T iff certT ,AT , (q) = .
Proof. The only if direction follows directly from the fact that AT , is satisfiable w.r.t. T (by
Lemma 10). For the if direction, let certT ,AT , (q) = . To show that q is empty for  given T ,
take a -ABox A that is satisfiable w.r.t. T . By Lemmas 11 and 12, certT ,AT , (q) =  implies
certT ,A (q) = , as required.
o
We now employ Theorem 13 to prove the NE XP T IME upper bounds for IQ-query emptiness.
Theorem 14 In ALCI, IQ-query emptiness is in NE XP T IME.
Proof. Let T be a satisfiable TBox,  an ABox signature, and A(v) an IQ for which emptiness for
 given T is to be decided. We employ the following:
Fact. For any ABox A, if T , A 6|= A(a), then there exists a model I of T and A with aI 6 AI and
|I |  |Ind(A)| + 2|T | .
Proof of Fact. If T , A 6|= A(a), then there exists a model J of T and A with aJ 6 AJ . We
may assume that {aJ | a  Ind(A)} is disjoint from the domain TT ,0 of the interpretation IT ,0
defined in the proof of Lemma 10 (where we assume that 0 := ). Now define I as the union of
the restriction of J to {aJ | a  Ind(A)} and the interpretation IT ,0 expanded by adding to rI
all pairs
 (aJ , t) such that tJ (aJ ) ;r t, a  Ind(A), and t  TT ,0 ;
 (t, aJ ) such that t ;r tJ (aJ ), a  Ind(A), and t  TT ,0 .
Then I is a model of T and A with aI 6 AI of the required size. This finishes the proof of the fact.
The NE XP T IME algorithm computes the canonical ABox AT , (in exponential time) and guesses
for every a  Ind(AT , ) a model Ia with |Ia |  |Ind(AT , )| + 2|T | . The algorithm returns yes
if for all a  Ind(AT , ):
1. Ia is a model of AT , and T , and
15

fiBAADER , B IENVENU , L UTZ , & W OLTER

2. aIa 6 AIa .
Both conditions can be checked in exponential time. Thus, by Theorem 13 and the fact above, the
algorithm returns yes iff A(v) is empty for  given T .
o
Note that by Theorem 6 CQ-predicate emptiness in ALCI is in NE XP T IME as well. For CQ-query
emptiness in ALCI, we can easily derive a 2E XP T IME upper bound using AT , and results from
the work of Calvanese et al. (1998) on the complexity of query answering in DLs.
Theorem 15 In ALCI, CQ-query emptiness is in 2E XP T IME.
Proof. The 2E XP T IME algorithm is obtained by first computing the canonical ABox AT , and
certT ,AT , (q), and then checking whether the latter is empty. This can be done in 2E XP T IME since
it is shown in the work of Calvanese et al. (1998) that for all T , A, and q with T an ALCI-TBox,
p(n)
the set certT ,A (q) can be computed in time 2p(m)2
with p a polynomial, m the size of T  A,
and n the size of q.
o
We provide an improved NE XP T IME upper bound for CQ-query emptiness in ALC, which will
allow us to show that for ALC our three emptiness problems have the same complexity.
Theorem 16 In ALC, CQ-query emptiness is in NE XP T IME.
The proof is somewhat technical and reuses the machinery of fork rewritings and spoilers introduced
by Lutz (2008), who proves that the combined complexity of CQ-answering in the DL SHQ is
in E XP T IME. More concretely, we show that one can decide emptiness of a CQ q for an ABox
signature  given an ALC-TBox T by guessing an extension AeT , of the canonical ABox AT ,
with assertions that prevent any possible match of q and then checking that AeT , is satisfiable w.r.t.
T . For example, if q is A(x), then it obviously suffices to add A(a) for every individual a in AT ,
(we allow here also complex concepts to be used in an ABox). The general case requires a careful
analysis of the assertions that have to be considered as additions, and this is where the mentioned
fork rewritings and spoilers enter the picture. In fact, they are used to prove that, since there are
no inverse roles in the TBox, it suffices to consider extensions of AT , that contain no additional
individual names and where the additional assertions are taken from a candidate set whose size is
polynomial in the size of AT , and q. It remains to show that satisfiability of (T , AeT , ) can be
decided (non-deterministically) in time single exponential in the size of T and q. Full details are
given in the appendix.
4.2 Lower Bounds and Undecidability
We prove matching lower bounds for the upper complexity bounds presented above and show undecidability of IQ-query emptiness, CQ-predicate emptiness, and CQ-query emptiness for ALCF.
The undecidability proof and the NE XP T IME-lower bound proof are by reduction of two different
tiling problems, where the first asks for a tiling of a finite rectangle of any (unbounded) size and the
second asks for a tiling of the 2n  2n -square. The 2E XP T IME lower bound for CQ-query emptiness in ALCI is by a straightforward reduction to query entailment in ALCI. We begin with the
NE XP T IME lower bound.
Theorem 17 In ALC, CQ-predicate emptiness is NE XP T IME-hard.
16

fiQ UERY AND P REDICATE E MPTINESS

Proof. The proof is by reduction of a NE XP T IME-hard 2n  2n -tiling problem. An instance of this
tiling problem is given by a natural number n > 0 (coded in unary) and a triple (T, H, V ) with
T a non-empty, finite set of tile types including an initial tile Tinit to be placed on the lower left
corner, H  T  T a horizontal matching relation, and V  T  T a vertical matching relation. A
tiling for (T, H, V ) is a map f : {0, . . . , 2n  1}  {0, . . . , 2n  1}  T such that f (0, 0) = Tinit ,
(f (i, j), f (i + 1, j))  H for all i < 2n  1, and (f (i, j), f (i, j + 1))  V for all j < 2n  1. It is
NE XP T IME-complete to decide whether an instance of the 2n  2n -tiling problem has a tiling.
For the reduction, let n > 0 and (T, H, V ) be an instance of the 2n  2n -tiling problem with
T = {T1 , . . . , Tp }. We construct a signature  and a TBox T in ALC such that (T, H, V ) has a
solution if and only if a selected concept name A is CQ-predicate empty for  given T . For the
proof, it is convenient to impose the UNA.
When formulating the reduction TBox, we use role names x and y to represent the 2n  2n grid and two binary counters X and Y for counting from 0 to 2n  1. The counters use concept
names X0 , . . . , Xn1 and Y0 , . . . , Yn1 as their bits, respectively. T contains the following wellknown inclusions stating that the value of the counter X0 , . . . , Xn1 is incremented when going to
x-successors and the value of the counter Y0 , . . . , Yn1 is incremented when going to y-successors:
for k = 1, . . . , n  1,

u

0j<k

and

t

0j<k

Xj v (Xk t x.Xk ) u (Xk t x.Xk )

Xj v (Xk t x.Xk ) u (Xk t x.Xk )

and similarly for Y0 , . . . , Yn1 and y. T also states that the value of the counter X does not change
when going to y-successors and the value of the counter Y does not change when going to xsuccessors: for i = 0, . . . , n  1,
Xi v y.Xi ,

Xi v y.Xi

Yi v x.Yi ,

Yi v x.Yi .

and
In addition, T states that when the counter X is 2n  1, it does not have an x-successor and if the
counter Y is 2n  1, it does not have a y-successor:
X0 u    u Xn1 v x.,

Y0 u    u Yn1 v y..

T states that Tinit holds at (0, 0) and that the tiling is complete:
X0 u    u Xn1 u Y0 u    u Yn1 v Tinit ,
T states that if a tiling condition is violated, then A is true:
 for all 0  i < j  p: Ti u Tj v A,
 for all 0  i, j  p such that (Ti , Tj ) 6 H: Ti u x.Tj v A,
 for all 0  i, j  p such that (Ti , Tj ) 6 V : Ti u y.Tj v A.
17

>v

t

1ip

Ti ,

fiBAADER , B IENVENU , L UTZ , & W OLTER

Finally, since we cannot use negation in ABoxes, T states that concept names X 0 , . . . , X n1
and Y 0 , . . . , Y n1 are equivalent to X0 , . . . , Xn1 and Y0 , . . . , Yn1 , respectively: for i =
1, . . . , n  1:
Xi v X i , Xi v X i , Yi v Y i , Yi v X i .
We set  = {x, y, X0 , . . . , Xn1 , Y0 , . . . , Yn1 , X 0 , . . . , X n1 , Y 0 , . . . , Y n1 } and show
Claim. (T, H, V ) has no 2n  2n -tiling iff there exists a -ABox A that is satisfiable w.r.t. T such
that T , A |= v A(v).
Proof of claim. Assume first that (T, H, V ) has no 2n  2n -tiling. To construct A, we regard
the pairs (i, j) with i < 2n and j < 2n as individual names and let x((i, j), (i + 1, j))  A for
i < 2n  1 and y((i, j), (i, j + 1))  A for j < 2n  1. We also set Xk (i, j)  A if the kth bit of
i is 1, X k (i, j)  A if the kth bit of i is 0, Yk (i, j)  A if the kth bit of j is 1, and Y k (i, j)  A if
the kth bit of j is 0. It is readily checked that A is satisfiable w.r.t. T and that T , A |= v A(v).
Conversely, assume that (T, H, V ) has a 2n  2n -tiling given by f : {0, . . . , 2n  1} 
{0, . . . , 2n 1}  T. Let A be a -ABox that is satisfiable w.r.t. T . We show that T , A 6|= v A(v).
Let I be a model of T and A. If AI = , we are done. Otherwise re-define the interpretation of
T1 , . . . , Tp and A as follows. Associate with every d  I the uniquely determined pair (id , jd )
given by the values of the counters X and Y at d in I. Then set d  TkI iff f (id , jd ) = Tk and let
AI = . It is readily checked that the resulting interpretation is still a model of T and A.
o
It follows from the preceding result that IQ-query emptiness and CQ-query emptiness for
ALC and ALCI are NE XP T IME-hard. For CQ-query emptiness in ALCI, we can easily derive
a 2E XP T IME lower bound from results on the complexity of query entailment in ALCI.
Theorem 18 In ALCI, CQ-query emptiness is 2E XP T IME-hard.
Proof. It was shown by Lutz (2008) that CQ entailment in ALCI is 2E XP T IME-hard already for
ABoxes of the form {A(a)} and for Boolean CQs. This can clearly be strengthened to empty
ABoxes: replace A(a) with the empty ABox and compensate for this by adding to the TBox > v
r.A with r a fresh role name. It thus remains to observe that a Boolean CQ q is entailed by T and
the empty ABox iff q is non-empty for  =  and T .
o
We now show that the simple addition of functional roles to ALC leads to undecidability of CQpredicate emptiness, thus also of IQ-query emptiness and CQ-query emptiness. The proof is by
reduction from a tiling problem that asks for a tiling of a rectangle of finite size (which is neither
fixed nor bounded). The reduction involves a couple of technical tricks such as using concept
names that are not in  as universally quantified second-order variables. This allows us to enforce
a grid structure using standard frame axioms from modal logic (which are second-order in nature).
The reduction requires role names that are both functional and inverse functional. Since inverse
functionality cannot be expressed in ALCF, we also use a modal logic frame axiom to enforce that
a different, (forwards) functional role name is interpreted as the inverse of the role name that we
are interested in. Of course, undecidability carries over to variants of ALCF that use a concept
constructor ( 1 r) instead of functional roles as an additional sort, and to all DLs with qualified or
unqualified number restrictions.
Theorem 19 In ALCF, CQ-predicate emptiness is undecidable.
18

fiQ UERY AND P REDICATE E MPTINESS

An instance of the aforementioned tiling problem is given by a triple (T, H, V ) with T a non-empty,
finite set of tile types including an initial tile Tinit to be placed on the lower left corner and a final tile
Tfinal to be placed on the upper right corner, H  T  T a horizontal matching relation, and V 
TT a vertical matching relation. A tiling for (T, H, V ) is a map f : {0, . . . , n}{0, . . . , m}  T
such that n, m  0, f (0, 0) = Tinit , f (n, m) = Tfinal , (f (i, j), f (i + 1, j))  H for all i < n, and
(f (i, j), f (i, j + 1))  v for all i < m. It is undecidable whether an instance of the tiling problem
has a tiling.
For the reduction, let (T, H, V ) be an instance of the tiling problem with T = {T1 , . . . , Tp }. We
construct a signature  and a TBox T such that (T, H, V ) has a solution if and only if a selected
concept name A is CQ-predicate non-empty for  given T .
The ABox signature is  = {T1 , . . . , Tp , x, y, x , y  } where T1 , . . . , Tp are used as concept
names, and x, y, x , and y  are functional role names. We use the role names x and y to represent horizontal and vertical adjacency of points in the rectangle, and the role names x and y  to
simulate the inverses of x and y. In T , we use additional auxiliary concept names. In particular U
and R mark the upper and right border of the rectangle, Zc,1 , Zc,2 , Zx,1 , Zx,2 , Zy,1 , Zy,2 serve as
second-order variables, C serves as a flag which indicates that grid cells are closed at the position
where it is set, and Ix and Iy are similar flags for the intended behavior of the role names x, x and
y, y  . The concept name Y is propagated through the grid from the upper right corner to the lower
left one, ensuring that these flags are set everywhere, that every position of the grid is labeled with
at least one tile type, and that the horizontal and vertical matching conditions are satisfied. When
the lower left corner of the grid is reached, we set A as a flag, which is what the query v A(v) asks
for.
The TBox T is defined as the set of the following CIs, where (Ti , Tj , T` ) range over all triples
from T such that (Ti , Tj )  H and (Ti , T` )  V and where Be , for e  {c, x, y}, ranges over all
Boolean combinations of the concept names Ze,1 and Ze,2 , i.e., over all concepts L1 u L2 where Li
is Ze,i or Ze,i :
Tfinal v Y u U u R
x.(U u Y u Tj ) u Ix u Ti v U u Y
y.(R u Y u T` ) u Iy u Ti v R u Y
x.(Tj u Y u y.Y ) u y.(T` u Y u x.Y ) u Ix u Iy u C u Ti v Y
Y u Tinit v A
Bx u x.x .Bx v Ix
By u y.y  .By v Iy
x.y.Bc u y.x.Bc v C
U v y. R v x. U v x.U

R v y.R

t

1s<tp

Ts u Tt v 

The CIs for Ix and Iy are responsible for enforcing that x is the inverse of x and y  the inverse
of y, at least at those ABox individuals that we are interested in. In fact, if the ABox contains
assertions x(a, b) and x (b, c) and thus violates the intended interpretation of x and x , then we
can interpret Zx,1 and Zx,2 such that the left-hand sides of all possible instantiations of the CI
for Ix are violated, e.g. by making Zx,1 and Zx,2 true at a, but false at c. If the ABox contains
x(a, b), x (b, a), then this is not possible. Since x and y  are functional, we thus enforce that x
19

fiBAADER , B IENVENU , L UTZ , & W OLTER

and y are inverse functional. The CIs for C achieve in a similar way the closing of grid cells, i.e.,
that the x-y-successor and the y-x-successor of every relevant ABox individual coincide. However,
as can be seen from the proofs, this only works if x and y are inverse functional.
To establish Theorem 19, it suffices to prove the following lemma (see the appendix for details).
Lemma 20 (T, H, V ) admits a tiling iff there is a -ABox A that is satisfiable with T and such
that T , A |= v A(v).

5. EL and its Horn Extensions
We study query and predicate emptiness for the DL EL and several of its Horn extensions. First, we
show that, in plain EL, all three emptiness problems can be decided in polynomial time. The reason
is that in this case, the exponential-size canonical ABox AT , from Section 4 can be replaced with
a total -ABox A that contains only a single individual which is an instance of all -predicates.
Note that A is satisfiable w.r.t. any EL-TBox because EL cannot express unsatisfiability. The
same approach works for ELI, but in this case one obtains only an E XP T IME upper bound which
is optimal since subsumption for ELI is already E XP T IME-hard (Baader et al., 2005, 2008). As
soon as unsatisfiability can be expressed, the situation changes drastically. In fact, we show that
even in EL where subsumption and other standard reasoning tasks are still tractable, (all versions
of) emptiness are E XP T IME-hard. Nevertheless, emptiness in Horn extensions of EL turns out to
be easier than emptiness in expressive DLs. In contrast to the undecidability result for ALCF and
the NE XP T IME-hardness result for ALC, emptiness is in E XP T IME even in Horn-ALCIF. The
reason is the unraveling tolerance of Horn description logics observed in the work of Lutz and
Wolter (2012), which implies that when looking for ABoxes that witness non-emptiness, we can
restrict ourselves to tree-shaped ones. This enables the use of automata-theoretic techniques to
decide emptiness.
5.1 EL and ELI
We begin by showing that in EL, CQ-query emptiness, CQ-predicate emptiness, and IQ-query
emptiness are all in PT IME. The proofs are transparent and simple. For any signature , the total
-ABox is A := {A(a ) | A  }  {r(a , a ) | r  }.
Lemma 21 Let T be an EL-TBox and  a signature. Any CQ q is empty for  given T iff
certT ,A (q) = .
Proof. The proof is a simplified version of the proof of Theorem 13. The (contrapositive of the)
only if direction follows from the fact that A is satisfiable w.r.t. T . For the if direction, let
certT ,A (q) = . To show that q is empty for  given T , take a -ABox A. Define an ABox
homomorphism from A to A by setting h(a) := a for all a  Ind(A ). By Lemmas 11 and 12,
certT ,A (q) =  implies certT ,A (q) = , as required.
o
Lemma 21 provides a polytime reduction of CQ-query emptiness (and, therefore, IQ-query
emptiness and CQ-predicate emptiness) to the query evaluation problem for CQs over A . In the
appendix, we show that due to the simple shape of A , checking whether certT ,A (q) =  can be
done in polynomial time. In fact, we give a polytime procedure that either returns certT ,A (q) =
 or succeeds in constructing a Boolean forest-shaped query qb that is empty for  given T iff q is.
20

fiQ UERY AND P REDICATE E MPTINESS

The construction relies on the fact that, as an immediate consequence of results proved by Lutz and
Wolter (2010), emptiness of q for  given T implies the existence of a model I of T and A with
certT ,A (q) =  and such that I has the shape of a tree extended with reflexive loops at the root.
Checking T , A 6|= qb then only requires to answer concept queries in the extension ELu of EL
with the universal role, which is possible in PT IME (Lutz & Wolter, 2010). We obtain the following
result.
Theorem 22 In EL, IQ-query emptiness and CQ-query emptiness can be decided in PT IME.
A matching PT IME lower bound for Theorem 22 can be shown by a reduction of subsumption in
EL, which is PT IME-hard (Haase, 2007). Consider an EL-TBox T and EL-concepts C and D.
Then the CI C v D follows from T if, and only if, the IQ B(v) is non-empty for the signature {A}
given the TBox T  {A v C, D v B}, where A, B are concept names that do not appear in C, D
or T . Thus, we obtain
Theorem 23 In EL, IQ-query emptiness and CQ-query emptiness are PT IME-hard.
Observe that by Lemma 7 and materializability of EL we obtain that CQ-predicate emptiness is
PT IME-complete as well in EL.
Note that we need very little for the proof of Lemma 21 to go through: it suffices that the total
-ABox A is satisfiable with every TBox. We can thus reduce emptiness to query answering
over the total -ABox in any extension of EL that is unable to express contradictions. As another
important example, we consider ELI. Since CQ evaluation in ELI is E XP T IME-complete, we
only obtain an E XP T IME upper bound in this case. A matching lower bound is obtained from the
E XP T IME-hardness of subsumption in ELI and the simple reduction of subsumption to IQ-query
emptiness given above.
Theorem 24 In ELI, IQ-query emptiness and CQ-query emptiness are E XP T IME-complete.
It follows from Lemma 7 and materializability of ELI that CQ-predicate emptiness is E XP T IMEcomplete in ELI.
5.2 Horn Extensions Involving Negation or Functionality
The simplest extension of EL that can express unsatisfiability is EL . We begin by showing that
IQ-emptiness in EL is E XP T IME-hard, and thus significantly harder than subsumption and instance checking (both of which can be decided in polynomial time). To this end, we first show
that to decide IQ-query emptiness in EL it is sufficient to consider emptiness w.r.t. directed treeshaped ABoxes, where an ABox A is called directed tree-shaped if the following conditions hold:
1. the directed graph GdA = (Ind(A), {(a, b) | r(a, b)  A}) is a tree;
2. for all a, b  Ind(A), there is at most one role name r such that r(a, b)  A or r(b, a)  A
(and only one of these is the case).
Proposition 25 An instance query B(v) is non-empty for a signature  given an EL -TBox T iff
there exists a directed tree-shaped -ABox A that is satisfiable w.r.t. T such that T , A |= B(a) for
the root a of A.
21

fiBAADER , B IENVENU , L UTZ , & W OLTER

Proof. We provide a sketch only since this result also follows from the more general Proposition 30 proved below. Assume B(v) is non-empty for  given T . We find a -ABox A that is
satisfiable w.r.t. T such that T , A |= B(a). Let the potentially infinite ABox A be obtained by
unfolding A as follows: the individuals of A are the words a0 r0    rn1 an such that a0 = a and
ri (ai , ai+1 )  A for all 0  i < n; then include A(a0 r0    rn1 an ) in A iff A(an )  A and
include r(a0 r0    an , a0 r0    an rn an+1 ) in A if rn (an , an+1 )  A. One can show that A is satisfiable w.r.t. T since A is, and that T , A |= B(a) iff T , A |= B(a). By compactness of first-order
consequence, we obtain a finite ABox A0  A with T , A0 |= B(a). A0 is as required.
o
Theorem 26 In EL , IQ-query emptiness is E XP T IME-hard.
Proof. Let T , , and B(v) be given. By Proposition 25, B(v) is non-empty for  given T iff
there exists a directed tree-shaped -ABox A that is a witness for the non-emptiness of B(v) for
 given T . Directed tree-shaped -ABoxes can be viewed as EL-concepts using symbols from 
only, and vice versa. Thus, such a witness -ABox exists iff there exists an EL-concept C using
symbols from  only such that C is satisfiable w.r.t. T and T |= C v B. Now the following can
be established by carefully analyzing the reduction underlying Theorem 36 in the work of Lutz and
Wolter (2010): given an EL -TBox T , a signature , and a concept name B, it is E XP T IME-hard
to decide if there exists an EL-concept C using symbols from  only such that C is satisfiable
w.r.t. T and T |= C v B. This establishes E XP T IME-hardness of non-emptiness. Using the fact
that E XP T IME = coE XP T IME, this hardness result transfers to IQ-query emptiness.
o
Observe that by Lemma 7 and materializability of EL we obtain that CQ-predicate emptiness is
E XP T IME-hard as well in EL .
Instead of proving a matching E XP T IME upper bound only for emptiness in EL , we do this
for the expressive Horn DL Horn-ALCIF, of which EL is a fragment. In fact, the rest of this
section is devoted to the proof of the following theorem. It is interesting to contrast this result with
the undecidability of emptiness in ALCF.
Theorem 27 In Horn-ALCIF, CQ-query emptiness is in E XP T IME.
The strategy for the proof of Theorem 27 is as follows. We first exhibit a polynomial-time reduction
from CQ-query emptiness in Horn-ALCIF to CQ-query emptiness in ELIF  . Then, we show
that non-emptiness of a CQ q under an ELIF  -TBox is always witnessed by ABoxes of a certain,
forest-like shape. We then consider canonical models of forest-shaped ABoxes (and the TBox
under consideration), which can be constructed by a chase-like procedure and are a special kind of
materialization (cf. Section 3), that is, the answers returned for this model are precisely the certain
answers. A central observation is that matches of q in canonical models of forest-shaped ABoxes
can be grouped into equivalence classes that are induced by certain splittings of q. We finally
show how to construct, for each equivalence class, a tree automaton that decides the existence of a
forest-shaped witness ABox whose canonical model admits a match of q that falls into that class.
Throughout this proof, we generally impose the UNA.
We begin with the reduction to CQ-query emptiness in ELIF  . In fact, the reduction even
shows that it suffices to consider ELIF  -TBoxes that are in normal form, by which we mean that
all CIs take one of the forms
A1 u    u An v B,

A v r.B,
22

r.A v B,

fiQ UERY AND P REDICATE E MPTINESS

where A, A1 , . . . , An , B  NC  {>, } and r is a role name or inverse role.
Proposition 28 For every Horn-ALCIF TBox T , ABox signature , and CQ q, one can construct
in polynomial time an ELIF  -TBox T 0 in normal form such that q is empty for  given T iff q is
empty for  given T 0 .
The proof of Proposition 28 is standard and given in the appendix. In what follows, we assume that
all ELIF  TBoxes are in normal form.
We next define canonical models. Let (T , A) be an ELIF  KB such that A is satisfiable
w.r.t. T . To construct the (typically infinite) canonical model IT ,A of (T , A), start with A viewed
as an interpretation, that is: IT ,A = Ind(A), AIT ,A = {a | A(a)  A}, and rIT ,A = {(a, b) |
r(a, b)  A}. Then exhaustively apply the following completion rules:
I

1. If A1 u    u An v A  T and d  Ai T ,A for 1  i  n, and d 
/ AIT ,A , then add d to
AIT ,A .
2. If r.A v B  T , (d, e)  rIT ,A , e  AIT ,A , and d 
/ B IT ,A , then add d to B IT ,A ;
3. If A v r.B  T , d  AIT ,A , and either d 
/ (r.B)IT ,A and funct(r) 6 T or d 
/
I
I
I
I
I
T
,A
T
,A
T
,A
T
,A
T
,A
(r.>)
, then add (d, e) to r
and e
to 
and B
, where e is a fresh
element.
/ B IT ,A , then add e to
4. If A v r.B  T , funct(r)  T , d  AIT ,A , (d, e)  rIT ,A , and e 
I
T
,A
B
.
The construction can be rendered deterministic by using an ordering of the inclusions and domain
elements to decide among different possible rule applications. For this reason, we may speak of the
canonical model. We call a model U of T and A universal if there is a homomorphism from U to
any model I of T and A, that is, a function h : U  I such that d  AU implies h(d)  AI ,
(d, e)  rU implies (h(d), h(e))  rI , and h(aU ) = aI for all a  Ind(A). The most important
property of IT ,A is that it is universal.2 In fact, the following is standard to prove and we omit
details, see for example the work of Lutz and Wolter (2012).
Lemma 29 Let T be an ELIF  -TBox and A an ABox that is satisfiable w.r.t. T . Then IT ,A is a
universal model of (T , A).
Let T be an ELIF  TBox and A a -ABox that is satisfiable w.r.t. T . It is an easy consequence
of Lemma 29 that a -ABox A is a witness for a CQ q being non-empty for  given T if and only
if A is satisfiable w.r.t. T and there is a match of q in IT ,A .
The next step in our proof of Theorem 27 is to establish a proposition that constrains the shape
of ABoxes to be considered when deciding emptiness in ELIF  . Here and in what follows, an
ABox A is called tree-shaped if
1. the undirected graph GA = (Ind(A), {{a, b} | r(a, b)  A}) is a tree;
2. For readers wondering about the relationship between universal models and materializations as defined in Section 3,
we remark that every universal model of a TBox T and ABox A is a materialization of T and A. Conversely, if there
is a materialization of T and A, then there exists also a universal model of T and A (Lutz & Wolter, 2012).

23

fiBAADER , B IENVENU , L UTZ , & W OLTER

2. for all a, b  Ind(A), there is at most one role name r such that r(a, b)  A or r(b, a)  A,
and only one of these is the case.
When working with tree-shaped ABoxes, we often designate one of the individuals as the root. If
the root of the tree-shaped ABox A has been fixed, then we use A|a to denote the restriction of A
to those individuals b whose unique path to the root in GA contains a, and we call b  Ind(A) an
r-successor (resp. r -successor) of a  Ind(A) if r(a, b)  A|a (resp. r(b, a)  A|a ). We will
also consider (rooted) tree-shaped interpretations and tree-shaped queries, defined analogously to
tree-shaped ABoxes.
A -ABox A is forest-shaped if there are ABoxes A0 , A1 , . . . , Ak such that the following
conditions are satisfied:
1. A is the union of A0 , A1 , . . . , Ak ;
2. k  |Ind(A0 )|;
3. for 1  i < j  k: Ind(Ai )  Ind(Aj ) =  and |Ind(Ai )  Ind(A0 )| = 1;
4. for 1  i  k: Ai is a tree-shaped ABox rooted at some individual in Ind(A0 ).
We call A0 the root component of A and A1 , . . . , Ak the tree components. The width of A if k. The
degree of A is the smallest number n such that for every tree component Ai and every a  Ind(Ai ),
the number of assertions r(a, b) and r(b, a) in Ai is bounded by n. The following proposition
clarifies the role of forest-shaped ABoxes as witnesses for non-emptiness.
Proposition 30 Let T be an ELIF  -TBox,  an ABox signature, and q a CQ. If q is non-empty
for  given T , then this is witnessed by a -ABox that is forest-shaped, has width at most |q|, and
degree at most |T |.
Proposition 30 is proved in the appendix by taking a witness -ABox A, selecting a part of A of
size |q| that is identified by a match of q and that serves as the root component of the forest-shaped
ABox, then unraveling A into a infinite ABox starting from the selected part, afterwards removing
unnecessary individual names to obtain the desired degree, and finally applying compactness to
make the resulting witness finite.
Clearly, we can assume w.l.o.g. that in forest-shaped witness ABoxes according to Proposition 30, the individual names used in the root component are taken from a fixed set Ind of cardinality
|q|. We will make this assumption without further notice in what follows.
We next analyze matches in forest-shaped ABoxes, using a splitting of the query into components. These are similar to the splittings of queries used in Appendix B, but simpler. A forest
splitting of a CQ q is a tuple F = (q 0 , q0 , q1 , . . . , qn , ) where q 0 can be obtained from q by identifying variables, q0 , q1 , . . . , qn is a partition of the atoms of q 0 , and  : var(q0 )  Ind such that the
following conditions are satisfied
1. q1 , . . . , qn are tree-shaped;
2. var(qi )  var(q0 )  1 for 1  i  n;
3. var(qi )  var(qj ) =  for 1  i < j  n.
24

fiQ UERY AND P REDICATE E MPTINESS

Let T be an ELIF  -TBox, A a forest-shaped ABox with root component A0 , and  a match
of q in IT ,A . Note that IT ,A consists of A extended with (potentially infinite) trees attached
to ABox individuals that have been generated by the completion rules. Then  is of type F =
(q 0 , q0 , q1 , . . . , qn , ) if q 0 can be obtained from q by identifying those variables that  sends to the
same element, q0 consists of the atoms in q 0 that  matches to the A0 -part of IT ,A , q0 , . . . , qn are
the maximal connected components of q 0 \ q0 , and  is the restriction of  to range Ind. Note
that, no matter which match  we choose, the maximal connected components of q 0 \ q0 must be
tree-shaped because they match into a tree-shaped part of IT ,A , which consists of a tree component
of A plus the attached trees generated by the completion rules. Thus every match  has a type and
the following is immediate, where WT ,q,F denotes the set of forest-shaped -ABoxes of width at
most |q| and degree at most |T | that admit a match of q which is of type F .
Lemma 31 Let T be an ELIF  -TBox,  an ABox signature, and q a CQ. Then q is empty for 
given T if and only if WT ,q,F is empty for every forest splitting F of q.
From now on, let T be an ELIF  -TBox T in normal form,  an ABox signature, and q a CQ, and
assume that we want to decide whether q is empty for  given T . By Lemma 31, it suffices to check
whether WT ,q,F is empty for every forest splitting F of q.
Note that defining the set WT ,q,F is possible only because the definition of a forest splitting
does not refer to a particular ABox, which in turn is due to our use of the fixed set of individual
names Ind for the root components of forest ABoxes. In fact, first quantifying over forest splittings
as in Lemma 31 and then quantifying over forest-shaped ABoxes (when testing emptiness of some
WT ,q,F ) is essential for obtaining a single exponential time upper bound. Since the number of
forest splittings is single exponential in |q|, we obtain such a bound if we can test emptiness of
each WT ,q,F in time single exponential in |T | + |q|. We will achieve this by constructing, for each
forest splitting F of q, a two-way alternating parity automaton on infinite trees (TWAPA) AF that
accepts a non-empty language if and only if WT ,q,F 6= . Note that infinite trees are needed because
automata will take trees as input that represent not only a (finite) forest-shaped -ABox A, but also
a (potentially infinite) model of A and T .
We start by introducing the necessary background for TWAPAs. Let
denote the positive
integers. A tree is a non-empty (and potentially infinite) set T   closed under prefixes. The
node  is the root of T . We use standard concatenation on the words from  (nodes of trees) and,
as a convention, take x  0 = x and (x  i)  1 = x for all x   and i  . Note that   1 is
undefined. When i  1, the node x  i is said to be a child of the node x, and x is called the parent of
x  i. We will slightly depart from Vardis original definition of TWAPAs (Vardi, 1998) by working
with trees which are not full, that is, we define an m-ary tree as a tree each of whose nodes has at
most (rather than exactly) m children. W.l.o.g., we assume that all nodes in an m-ary tree are from
{1, . . . , m} . An infinite path P of T is a prefix-closed set P  T such that for every n  0, there
is a unique x  P with |x| = n.
For any set X, we use B + (X) to denote the set of all positive Boolean formulas over X, i.e.,
formulas built using conjunction and disjunction over the elements of X used as propositional variables, and where the special formulas true and false are allowed as well. For an alphabet , a
-labeled tree is a pair (T, V ) with T a tree and V : T   a node labeling function.

N

N

N
N
N

Definition 32 (TWAPA) A two-way alternating parity automaton (TWAPA) on m-ary trees is a
tuple A = (S, , , s0 , F ) where S is a finite set of states,  is a finite alphabet,  : S   
25

fiBAADER , B IENVENU , L UTZ , & W OLTER

B + (tran(A)) is the transition function with tran(A) = {hii, [i] | i  {1, 0, . . . m}}  S the set
of transitions of A, s0  S is the initial state, and F = (G1 , . . . , Gk ) is a sequence of subsets of S
satisfying G1  G2  . . .  Gh = S, called the parity condition.
Intuitively, a transition (hii, s) with i > 0 means that a copy of the automaton in state s is sent to the
i-th successor of the current node, which is then required to exist; by contrast, the transition ([i], s)
only sends a copy if the i-th successor exists. The transitions (hii, s) and ([i], s) with i  {1, 0} are
interpreted similarly where 1 indicates sending a copy to the predecessor and 0 indicates sending
a copy to the current node. Note that a transition (h1i, s) cannot be applied at the root.
Definition 33 (Run, Acceptance) A run of a TWAPA A = (S, , , s0 , F ) on a -labeled tree
(T, V ) is a T  S-labeled tree (T , ) such that () = (, s0 ) and for all y  T , (y) = (x, s)
and (s, V (x)) =  implies that there is a (possibly empty) set {(d1 , s1 ), . . . , (dn , sn )}  tran(A)
that satisfies  and is such that for 1  i  n:
1. if di = hji, then x  j is defined, x  j  T , y  i  T , and (y  i) = (x  j, si ).
2. if di = [j] and x  j is defined and belongs to T , then y  i  T and (y  i) = (x  j, si ).
Given an infinite path P  T , we denote by inf(P ) the set of all states q such that there are infinitely
many y  P such that (y) is of the form (d, q). We say that the run (T , ) is accepting if for all
infinite paths P  T , there exists an even k such that inf(P )  Gk 6=  and inf(P )  Gk1 = .
A -labeled tree (T, V ) is accepted by A if there is an accepting run of A on (T, V ). We use
L(A) to denote the set of all -labeled trees accepted by A.
We note that the original definition of TWAPAs (Vardi, 1998) only uses transitions of the form
(hii, q) with i  {1, . . . , m}, since (hii, q) and ([i], q) coincide for full m-ary trees. It is easy to
see that emptiness for our version of TWAPAs can be reduced in polynomial time to emptiness for
TWAPAs in the original definition since we can encode m-ary trees as full m-ary trees. Vardi (1998)
has shown that the emptiness problem of TWAPAs is E XP T IME-complete. More precisely, there
is an algorithm that, given a TWAPA A = (S, , , s0 , F ), decides whether L(A) =  and runs in
time exponential in the cardinality of S and polynomial in the cardinality of  and size of . We
also remind the reader that given two TWAPAs A1 and A2 with Ai = (Si , i , i , s0,i , Fi ), it is very
easy to construct (in polynomial time) a TWAPA A such that L(A) = L(A1 )  L(A2 ) and A has
state set S1  S2 .
To make them accessible to TWAPAs, we encode forest-shaped -ABoxes of width at most |q|
and degree at most |T | as m-ary trees, where m = |q|  |T |. As has already been mentioned, each
such tree additionally encodes a model of the encoded ABox. We now explain the alphabet used
and the shape of the trees in more detail. The root node is labeled with an element of the alphabet
R that consists of all sig(T )-ABoxes A such that (i) Ind(A)  Ind, (ii) r(a, b)  A implies r  ,
and (iii) A satisfies all functionality statements in T . Let sub(T ) denote the set of concepts that
occur in T and their subconcepts. Non-root nodes are labeled with elements from the alphabet N
that consists of all subsets
  (NC  sub(T )) ] {M } ] {r, r | r  NR occurs in T } ] Ind ] {A | B v r.A  T }
26

fiQ UERY AND P REDICATE E MPTINESS

such that  contains (i) exactly one role name or inverse role, (ii) at most one element of Ind, and
(iii) either M and a role name or inverse role from  or exactly one element of the form A and, in
the latter case, also A.
A tree hT, `i with ` a labeling as described above is supposed to represent a forest-shaped ABox AhT,`i together with a model IhT,`i of this ABox and of T . The individuals of AhT,`i are
those in the ABox that labels the root of T , plus all non-root nodes of T whose label contains the
marker M . All other nodes of T denote domain elements of IhT,`i that are not identified by any
ABox individual. Both the assertions in AhT,`i and the concept and role memberships in IhT,`i are
represented by the labels of hT, `i. Note that the ABox A is a sig(T )-ABox whereas AhT,`i uses
signature . In fact, only the -assertions in A will be part of AhT,`i while all assertions in A will
be part of IhT,`i .
We need to impose some additional conditions to make sure that a R  N -labeled tree hT, `i
indeed represents an ABox and model as intended. We call hT, `i proper if it satisfies the following
conditions for all x  T :
1. the root is labeled with an element A of R and all other nodes with an element of N ;
2. `(x)  N contains an element of Ind(A) if x is a child of the root of T , and no element of
Ind otherwise;
3. if we take any path in T and remove the root node (because it carries a special label), then the
nodes whose label contains M form a finite (possibly empty) prefix of the resulting path;
4. if y is a child of x and A  `(y)  N , then there is some B v r.A  T such that one of
the following is true:
(a) x is not the root, B  `(x) and r  `(y);
(b) x is the root and for some a  Ind, B(a)  `(x) and {a, r}  `(y).
The roles and individual names in element labels describe how these elements are connected to
other elements via roles in AhT,`i and in IhT,`i . In particular, if a successor of the root contains both
the role r and the individual name a  Ind, then that node represents an r-successor of a. The label
elements that are of the form A serve a special marking purpose: if A  `(x), then this means
that the element x (which is part of IhT,`i but not of AhT,`i since `(x) cannot contain M ) is there
to satisfy some concept inclusion B v r.A. We will later need these special markers to make
sure that IhT,`i is not just some model of AhT,`i , but a materialization of AhT,`i and T . With these
explanations and the subsequent definitions, the three conditions imposed on the elements of  and
the four conditions used to define properness above should make sense to the reader.
Let hT, `i be a proper R  N -labeled tree. We now define AhT,`i and IhT,`i formally. Let A
be the ABox that labels the root  of T , and let A be the restriction of A to signature . Then the
-ABox AhT,`i described by hT, `i is
AhT,`i = A  {A(x) | A  `(x)  NC   and M  `(x)}
 {r(b, x) | {b, r, M }  `(x)}  {r(x, b) | {b, r , M }  `(x)}
 {r(x, y) | y is a child of x and M  `(x)  `(y) and r  `(y)}
 {r(y, x) | y is a child of x and M  `(x)  `(y) and r  `(y)}
27

fiBAADER , B IENVENU , L UTZ , & W OLTER

and the interpretation IhT,`i is as follows:
IhT,`i

= (T \ {})  Ind(A)

A

IhT,`i

= {a | A(a)  A}  {x | A  `(x)  NC }

r

IhT,`i

= {(a, b) | r(a, b)  A}  {(a, x) | {a, r}  `(x)}  {(x, a) | {a, r }  `(x)}
 {(x, y) | y is a child of x and r  `(y)}  {(x, y) | x is a child of y and r  `(x)}

cIhT,`i

= c

for all c  Ind(AhT,`i )

Apart from being represented as an ABox instead of as an interpretation, AhT,`i is identical to the
restriction of IhT,`i to the individuals in AhT,`i and symbols in , which in particular means that
IhT,`i is a model of AhT,`i . Note that the ABox AhT,`i is a forest-shaped -ABox. Conversely,
for any forest-shaped -ABox of width at most |q| and degree at most |T |, we can define a proper
m-ary R  N -labeled trees hT, `i such that AhT,`i = A and IhT,`i = IT ,A .
Let F = (q 0 , q0 , q1 , . . . , qn , ) be a splitting for q. We now build a TWAPA AF over m-ary
R  N -labeled trees that accepts exactly those trees hT, `i such that AhT,`i  WT ,q,F . The
number of states of AF will be polynomial in |T | + |q| and since it can be checked in time singleexponential in the number of states whether L(AF ) =  , we obtain the desired E XP T IME upper
bound for deciding whether WT ,q,F = . We construct AF as the intersection of the following
TWAPAs:
1. Aprop , which makes sure that the input tree is proper;
2. AT , which ensures that the input tree hT, `i is such that IhT,`i is a model of T ;
3. Awf which ensures that hT, `i satisfies a certain well-foundedness condition;
4. Amatch which guarantees, exploiting the conditions ensured by the previous automata, that
the input tree hT, `i is such that AhT,`i  WT ,q,F .
The construction of the first automaton Aprop is straightforward, and details are left to the reader.
Note that, to enforce Condition 3 of proper trees, the automaton needs to make use of the parity
acceptance condition (a co-Buchi condition would actually be sufficient). The second TWAPA AT
ensures that the following conditions are satisfied for all non-root nodes x, x0 of the input tree:
 if r(a, b)  `() and funct(r)  T , then {a, r} 6 `(x);
 if funct(r)  T and {a, r}  `(x)  `(x0 ), then x = x0 ;
 if funct(r)  T , then x has at most one child y with r  `(y), and if additionally r  `(x),
then there is no such child y;
 if A1 u    u An v A  T and {A1 (a), . . . , An (a)}  `(), then A(a)  `();
 if A1 u    u An v A  T and {A1 , . . . , An }  `(x), then A  `(x);
 if A v r.B  T and A(a)  `(), then (i) there is some b such that {r(a, b), B(b)}  `(),
or (ii) there is a child x of the root such that {a, r, B}  `(x);
28

fiQ UERY AND P REDICATE E MPTINESS

 if A v r.B  T and A  `(x), then (i) {a, r }  `(x) and B(a)  `(), (ii) r  `(x) and
x has non-root parent y with B  `(y), or (iii) x has a child y with {r, B}  `(y);
 if r.A v B  T and (i) {r(a, b), A(b)}  `() or (ii) there is some child y of the root such
that {a, r, A}  `(y), then B(a)  `();
 if r.A v B  T and (i) {a, r }  `(x) and A(a) is in the label of the root, (ii) r  `(x)
and x has parent y with A  `(y), or (iii) x has child y with {r, A}  `(y), then B  `(x).
Working out the exact details of Aprop is again left to the reader.
Ideally, we would like the third automaton Awf to ensure that IhT,`i is the canonical model of T
and AhT,`i . However, this does not seem to be easily possible because that model is constructed by
applying completion rules in a certain order which is difficult to simulate by an automatonnote
that applying the rules in a different order might result in the construction of an interpretation that is
not isomorphic to the one obtained when following the prescribed application order. We thus define
Awf to achieve only the crucial property of canonical models that all positive information (concept
and role memberships of domain elements) is there for a reason, namely because it is contained in
AhT,`i or because it is logically implied by AhT,`i together with T . We formalize this in terms of
derivations.
I
Let hT, `i be a proper R  N -labeled tree, A0  (NC  sub(T ))  {>}, and x0  A0 hT,`i . A
derivation of A0 at x0 in hT, `i is a finite L-labeled tree hT 0 , `0 i, where L is the set of pairs (A, x)
with A  (NC  sub(T ))  {>} and x  AIhT,`i . We require that the root of T 0 is labeled with
(A0 , x0 ) and that T 0 is minimal such that for all nodes z of T 0 with `0 (z) = (A, x), one of the
following holds:
1. A    {>} and x  Ind(AhT,`i );
2. A 6 `(x) and there are a CI A1 u    u An v A  T and children z1 , . . . , zn of z in T 0 such
that `0 (zi ) = (Ai , x) for 1  i  n;
3. A 6 `(x) and there is a CI r.A0 v A  T and a child z 0 of z in T 0 with `0 (z 0 ) = (A0 , x0 )
such that (x, x0 )  rIhT,`i . Moreover, if B   `(x), then there is a child z 00 of z in T 0 with
`0 (z 00 ) = (B, x).
4. A 6 `(x) and there is a CI A0 v r.A  T with funct(r)  T and a child z 0 of z in T 0 with
`0 (z 0 ) = (A0 , x0 ) such that (x0 , x)  rIhT,`i . Moreover, if B   `(x), then there is a child z 00
of z in T 0 with `0 (z 00 ) = (B, x).
5. A = >, > 6 `(x), B   `(x), and there is a child z 0 of z in T 0 with `0 (z 0 ) = (B, x).
6. A  `(x), there is a CI A0 v r.A  T , and there is a child z 0 of z in T 0 with `0 (z 0 ) =
(A0 , x0 ) such that (x0 , x)  rIhT,`i and either (i) x is a child of x0 in T , or (ii) x is a child of
the root, x0  Ind, and {r, x0 }  `(x).
We say that hT, `i is well-founded if whenever x  AIhT,`i , with A  NC  {>}, then there is a
derivation of A at x in hT, `i. It is not hard to construct a TWAPA Awf that accepts precisely the
well-founded proper R  N -labeled trees; essentially, the automaton can verify the existence of
all required derivations by implementing the Conditions 1 to 6 above as transitions, additionally
using a co-Buchi condition to ensure finiteness of the derivation.
Next let F = (q 0 , q0 , q1 , . . . , qn , ). The automaton Amatch checks that
29

fiBAADER , B IENVENU , L UTZ , & W OLTER

1.  is a match for q0 in IhT,`i and
2. there is a match  for qi in IhT,`i such that if v  var(q0 )  var(qi ), then (v) = (v).
Amatch is easy to construct and we once more omit details. As announced, we define AF such that
it accepts the intersection of the languages accepted by Aprop , AT , Awf , and Amatch . It remains to
show that WT ,q,F is empty iff L(AF ) is empty.
To do this, we first clarify the relation between well-foundedness, canonical models, and universal models. We call a proper R  N -labeled tree hT, `i canonical if (i) IhT,`i is the canonical
model of AhT,`i and T , and (ii) for every x  T \{} with M 6 `(x), the concept A  `(x) is such
that the element x was created due to an application of the third completion rule to an inclusion of
the form B v r.A and the parent of x in T .
Lemma 34
1. If a proper R  N -labeled tree is canonical, then it is well-founded;
2. If hT, `i is a proper R  N -labeled tree that is well-founded and IhT,`i is a model of T ,
then IhT,`i is a universal model of T and AhT,`i .
A proof of Lemma 34 can be found in the appendix. Point 1 is established by tracing the applications
of the completion rules applied to construct the canonical model of AhT,`i and T and showing that
each addition that they make gives rise to a derivation. For Point 2, we first show that one can
make a certain uniformity assumption on derivations and then show how to define a homomorphism
from IhT,`i to any model of AhT,`i and T by starting at the part of IhT,`i that corresponds to the root
component of AhT,`i and then moving downwards along the tree-shaped parts of IhT,`i .
Lemma 35 WT ,q,F =  iff L(AF ) = .
Proof. First assume that WT ,q,F 6= . Then there is a forest-shaped -ABox A of width at most
|T | and degree at most |q| that is satisfiable w.r.t. T and a match  of q in IT ,A that is of type F .
Let hT, `i be an m-ary proper R  N -labeled tree that satisfies AhT,`i = A and is canonical.
Then hT, `i  L(Aprop ). Since A is satisfiable w.r.t. T , IhT,`i = IT ,A is a model of T and thus
hT, `i  L(Aprop ). By Point 1 of Lemma 34, hT, `i  L(Awf ). Finally, the match  witnesses that
Conditions 1 and 2 from the definition of Amatch are satisfied and thus hT, `i  L(Amatch ) and we
are done.
Conversely, assume that there is a tree hT, `i  L(AF ). Since hT, `i  L(Aprop ), A = AhT,`i
is defined; by definition, it is a forest-shaped -ABox of width at most |T | and degree at most |q|.
It remains to show that there is a match  of q in IT ,A that is of type F . Since hT, `i  L(AT ) 
L(Awf ), IhT,`i is a model of T and hT, `i is well-founded. By Point 2 of Lemma 34, IhT,`i is thus
a universal model of T and A. Because hT, `i  L(Amatch ), Conditions 1 and 2 from the definition
of Amatch are satisfied. It can be verified that, consequently, there is a match  of q in IhT,`i that is
of type F . Composing  with the homomorphism from IhT,`i to IT ,A , which exists since IhT,`i is
universal, yields a match of q in IT ,A that is of type F .
o

30

fiQ UERY AND P REDICATE E MPTINESS

6. The DL-Lite Family
We study query and predicate emptiness in the DL-Lite family of description logics (Calvanese
et al., 2007; Artale et al., 2009). To begin with, we introduce the dialects of DL-Lite we consider.
Basic concepts B are defined by
B

::=

>

| A

|

r.>

where A ranges over NC and r over all (possibly inverse) roles. A DL-Litecore TBox T is a finite
set of CIs of the form B1 v B2 and B1 u B2 v , where B1 and B2 are basic concepts. Thus,
DL-Litecore is included in ELI but, because it includes inverse roles, not included in EL. DL-LiteF
is the extension of DL-Litecore with functionality statements. DL-LiteR is the extension of DLLitecore with role inclusions r v s, where r, s are roles. DL-LiteR is the logical underpinning of the
OWL profile OWL2 QL (Motik et al., 2009). Finally, DL-Litehorn is the extension of DL-Litecore
with conjunctions of basic concepts on the left hand side of CIs. Alternatively, it can be defined as
the fragment of ELI  with qualified existential restrictions r.C replaced by unqualified existential
restrictions r.>. For further details, we refer readers to the work of Calvanese et al. (2007), Artale
et al. (2009), and Calvanese, De Giacomo, Lembo, Lenzerini, and Rosati (2013).
We briefly discuss the UNA for the DL-Lite dialects introduced above. First observe that DLLitehorn and DL-LiteF are fragments of ALCIF. Thus, by Lemma 3, query emptiness and predicate emptiness for DL-Litehorn and DL-LiteF are oblivious as to whether the UNA is made or not.
DL-LiteR is not a fragment of ALCIF. It is, however, straightforward to show that for DL-LiteR
the certain answers to CQs do not depend on whether one adopts the UNA or not. Thus, also for
DL-LiteR query emptiness and predicate emptiness are oblivious as to whether the UNA is made or
not. In the following proofs we make the UNA.
Our main results are as follows: CQ-query emptiness is coNP-complete for all DL-Lite dialects.
The coNP-lower bound holds already for the fragment of DL-Litecore without role names. By
contrast, the complexity of deciding IQ-query emptiness and CQ-predicate emptiness depends
on whether conjunctions are admitted on the left-hand side of concept inclusions or not. If no
conjunctions are admitted (as in DL-Litecore , DL-LiteR , and DL-LiteF ), then IQ-query emptiness
and CQ-predicate emptiness are NL OG S PACE-complete. If conjunctions are admitted (as in DLLitehorn ), then both IQ-query emptiness and CQ-predicate emptiness are coNP-complete. Again,
the lower bound holds already for the fragments of the DLs without role names.
We note that in what follows we do not use Theorem 6 which gives a polynomial reduction of
CQ-predicate emptiness to IQ-query emptiness for certain DLs but does not apply to the DL-Lite
dialects. Instead we give direct proofs. The results presented in Figure 1 for the DL-Lite dialects
are straightforward consequences of the results established in this section.
We begin by proving the coNP lower bounds. Let Lcore be the DL that admits only CIs A v B
and A u B v , and let Lhorn be the DL that admits only CIs A u A0 v B and A u B v , where
A, A0 , and B are concept names.
Theorem 36 In Lhorn , IQ-query emptiness, CQ-query emptiness, and CQ-predicate emptiness are
coNP-hard. In Lcore , CQ-query emptiness is coNP-hard.
Proof. The proofs are by reduction from the well-known coNP-complete problem of testing whether
a propositional formula in conjunctive normal form (CNF) is unsatisfiable. Let  = 1      k
31

fiBAADER , B IENVENU , L UTZ , & W OLTER

be a CNF formula, v1 , . . . , vn the variables used in , A1 , . . . , Ak concept names for representing clauses, and Av1 , Av1 , . . . , Avn , Avn concept names for representing literals. Let A be an
additional concept name, and set  = {Av1 , Av1 , . . . , Avn , Avn }. Consider the Lhorn -TBox T
consisting of the following CIs:
 Avj u Avj v  for all 1  j  n;
 A`j v Ai for all 1  i  k and each `j = ()vj that is a disjunct of i ;
 A1 u    u Ak v A .
It is straightforward to show that A(u) is empty for  given T iff u A(u) is empty for  given T
iff  is unsatisfiable. Thus, deciding IQ-query emptiness, CQ-predicate emptiness, and CQ-query
emptiness in Lhorn is coNP-hard. For the coNP-hardness result for CQ-query emptiness in Lcore ,
we drop the last CI from T and use the CQ A1 (u)      Ak (u) instead.
o
We now prove matching upper complexity bounds, considering the logics DL-Litecore , DLLiteR , DL-LiteF , and DL-Litehorn . To this end, we formulate general sufficient conditions for
deciding emptiness in PT IME and in coNP. We say that a DL L has the polysize emptiness witness property if whenever a CQ q is not empty for  given T , then there exists a -ABox A of
polynomial size in the size of T and q that is satisfiable w.r.t. T and such that certT ,A (q) 6= .
Lemma 37 Let L be any description logic with the polysize emptiness witness property such that
the query evaluation problem for CQs for L is in NP. Moreover, assume that satisfiability of ABoxes
w.r.t. L-TBoxes can be decided in polynomial time. Then CQ-query emptiness in L is in coNP.
Proof. An NP-algorithm deciding whether a CQ q is not empty w.r.t. T and  guesses (i) a -ABox
A of polynomial size in T and q, (ii) a tuple ~a of individual names from Ind(A) of the appropriate
length, and (iii) a polysize certificate that ~a  certT ,A (q); it then verifies in polynomial time that A
is satisfiable w.r.t. T and the guessed certificate is valid.
o
Theorem 38 In DL-Litecore , DL-LiteR , DL-LiteF , and DL-Litehorn , deciding CQ-query emptiness
is in coNP.
Proof. The conditions stated in Lemma 37 have been shown by Calvanese et al. (2007) and Artale
et al. (2009). We sketch a proof of the polysize emptiness witness property. Assume ~a  certT ,A (q)
for a CQ q = ~u (~v , ~u) and a TBox T in any of the DLs listed in the theorem statement and
further assume that A is satisfiable w.r.t. T . We use the canonical model IT ,A from Lemma 29
(for DL-Litecore , DL-LiteF , and DL-Litehorn this can be used without any modification since they
are fragments of ELIF  ; for DL-LiteR , one has to add the following completion rule for the
construction of IT ,A : if (x, y)  rIT ,A and r v s  T , then add (x, y) to sIT ,A ). Let  be a
match for q in IT ,A . We recall that IT ,A consists of its restriction to the individuals aIT ,A with
a  Ind(A) and tree-shaped interpretations Ia attached to aIT ,A . Let A00 be the set of assertions in
A that only use individual names a  Ind(A) such that there exists v  var(q) with (v) = aIT ,A
or (v)  Ia . Moreover, for any individual a  Ind(A00 ) selected above such that there exists a
role r and b with r(a, b)  A, select one such r(a, b ) and include it in A01 . Let A0 = A00  A01 .
Clearly the ABox A0 is as required: it is of polynomial size, it is satisfiable w.r.t. T (being a subset
of A), and by construction, it satisfies ~a  certT ,A0 (q).
o

32

fiQ UERY AND P REDICATE E MPTINESS

We say that a DL L has the singleton emptiness witness property if whenever a CQ q of the form
A(v) or v A(v) is not empty for  given T , then there exists a -ABox A containing at most one
assertion which is satisfiable w.r.t. T and such that certT ,A (q) 6= .
Lemma 39 Let L be any description logic with the singleton emptiness witness property such that
the query evaluation problem for CQs of the form A(v) and v A(v) for L is in NL OG S PACE. Moreover, assume that satisfiability of singleton ABoxes w.r.t. L-TBoxes can be decided in NL OG S PACE.
Then IQ-query emptiness and CQ-predicate emptiness in L are in NL OG S PACE.
Proof. A non-deterministic logarithmic space algorithm deciding whether a CQ of the form A(v)
or v A(v) is not empty w.r.t. T iterates over all -ABoxes A containing at most one assertion and
checks whether at least one of those ABoxes A is satisfiable w.r.t. T and satisfies T , A |= v A(v)
or, respectively, T , A |= A(a), for an individual a  Ind(A).
o
Theorem 40 In DL-Litecore , DL-LiteR , and DL-LiteF , deciding IQ-query emptiness and CQpredicate emptiness are NL OG S PACE-complete.
Proof. For the NL OG S PACE-upper bound, the conditions stated in Lemma 39 have been shown
by Calvanese et al. (2007) and Artale et al. (2009). We sketch a proof of the singleton emptiness
witness property. Assume ~a  certT ,A (q) for a CQ q of the form A(v) or v A(v) and a TBox
T in any of the DLs listed in the theorem statement. Further assume that A is satisfiable w.r.t. T .
We consider the case q = v A(v); the case q = A(v) is similar. As in the proof of Theorem 38,
we use the canonical model IT ,A . Let  be a mapping into IT ,A such that (v)  AIT ,A and
consider the uniquely determined a  Ind(A) such that (v) = aIT ,A or (v)  Ia . Using the
fact that no conjunctions occur on the left-hand side of CIs in T , one can show that there exists a
single assertion of the form B(a) or r(a, b) such that for the ABox A0 consisting of that assertion,
we have ()  certT ,A0 (q). It follows that A0 is the desired witness ABox.
The matching lower bound follows directly from the fact that deciding whether T |= A v B is
NL OG S PACE-hard for TBoxes T in DL-Litecore (Artale et al., 2009).
o

7. Case Study and Application to Modularity
We demonstrate the usefulness of emptiness in two ways. First, we carry out a case study for
predicate emptiness in the medical domain, where we find that the use of a realistic ontology adds
a significant number of non-empty predicates to the ABox signature while there is also a large
number of predicates that are empty. In static analysis, it is thus potentially non-trivial for a user to
manually distinguish the non-empty from the empty predicates. Second, we show that (predicate)
emptiness can be used to produce a smaller version of a TBox T that is tailor-made for querying
with a given ABox signature (in a sense: a module of the TBox). Replacing T with the potentially
much smaller module facilitates comprehension of the TBox, thus helping with query formulation.
We again support our claims by experiments.
In the case study, we use the comprehensive medical ontology SNOMED CT, which provides
a systematic vocabulary used for medical information interchange and to enable interoperable electronic health records. It covers diverse medical areas such as clinical findings, symptoms, diagnoses, procedures, body structures, organisms, substances, pharmaceuticals, devices and specimens.
33

fiBAADER , B IENVENU , L UTZ , & W OLTER

concepts roles

IQ
CQ axioms
axioms
non-empty non-empty -mod. CQ -core

500

16

3557

4631

8910

4597

500

31

3654

4734

8911

4696

1000

16

5827

7385

14110

7349

1000

31

6242

7762

14147

7731

5000

16

18330

21451

33469

21427

5000

31

18469

21557

33616

21532

10000

16

29519

33493

47044

33489

10000

31

30643

34645

47256

34637

Figure 4: Experimental Results
SNOMED CT is formulated in EL extended with role inclusions (which we removed for the experiments). It contains about 370,000 concept names and 62 role names. We use SNOMED CT
together with an ABox signature from a real-world application and with randomly generated ABox
signatures. The real-world signature was obtained by analyzing clinical notes of the emergency
department and the intensive care unit of two Australian hospitals, using natural language processing methods to detect SNOMED CT concepts and roles.3 It contains 8,858 concepts and 16 roles.
For this signature, 16,212 IQ-non-empty predicates and 17,339 CQ-non-empty predicates were
computed. Thus, SNOMED CT provides a substantial number of additional predicates for query
formulation, roughly identical to the number of predicates in the ABox signature. However, these
numbers also show that the majority of predicates in SNOMED CT cannot meaningfully be used in
queries over -ABoxes, and thus identifying the relevant ones via predicate emptiness is potentially
very helpful. Somewhat surprisingly, the number of CQ-non-empty predicates is only about 10%
higher than the number of IQ-non-empty symbols.
We have analyzed randomly generated signatures that contain 500, 1,000, 5,000, and 10,000
concept names and 16 or 31 role names (1/2 and 1/4 of the role names in the ontology). Every
signature contains the special role name role-group, which is used in SNOMED CT to implement
a certain modeling pattern and should be present also in ABoxes to allow the same pattern there.
For each number of concept and role names, we generated 10 signatures. The columns IQ nonempty and CQ non-empty of Figure 4 show the results, where the numbers are averages for the
10 experiments for each size. These additional experiments confirm the findings for our real-world
signature: in each case, a substantial number of additional predicates becomes available for query
formulation, but there is also a large number of predicates that are empty.
We now come to the application in modularity. Recall that our main motivation for studying
emptiness is to support query formulation: as TBoxes can be large and complex, it can be difficult
to understand whether a TBox contains sufficient background knowledge so that a given query q
can have a non-empty answer over a -ABox. If this is not the case, it clearly does not make sense
3. See Current Collaborative Projects of the Health Information Technologies Research Laboratory at the University
of Sydney (HITRL, 2016).

34

fiQ UERY AND P REDICATE E MPTINESS

to pose q to any -ABox when this TBox is used as the background ontology. Similarly, it can be
hard to find out whether a TBox is sufficiently powerful to entail that a given predicate can occur
in some query that has a non-empty answer over some -ABox. Again, if this is not the case, then
that predicate should not be used when formulating queries. Here, we go one step further: instead
of using emptiness directly to support query formulation, we use it to simplify the TBox. More
precisely, we consider the problem of extracting a (hopefully small!) subset of a given TBox that
gives exactly the same answers to all CQs (or IQs) for any -ABox. Such a subset will be called
a -substitute w.r.t. CQ (or IQ, respectively) of the original TBox and can replace the original
TBox when answering CQs (or IQs, respectively). Working with a small -substitute instead of
the original TBox supports comprehension of the TBox and thereby the formulation of meaningful
queries.
It is beyond the scope of this paper to investigate -substitutes in depth. Instead, we show that,
in the description logic ELI, predicate emptiness gives rise to a particularly natural kind of substitute that we call the CQ -core. The CQ -core is obtained by removing all concept inclusions
that contain a predicate which is CQ-predicate empty for  w.r.t. the TBox. Thus, not only does
the CQ -core give the same answers to CQs as the original TBox for -ABoxes, but it also has
the appealing property that all predicates which occur in it can be used meaningfully in a CQ when
querying -ABoxes.
We also show that the widely known semantic -modules introduced by Grau et al. (2008) are
-substitutes and that CQ -cores cannot be larger than semantic -modules (unless the original
ontology contains tautological concept inclusions). To evaluate the method in practice and compare
the size of CQ -cores and -modules, we also extend our case study based on SNOMED CT to the
extraction of CQ -cores and their comparison with -modules. We start by defining -substitutes
in a formal way.
Definition 41 Let T 0  T and Q  {IQ, CQ}. Then T 0 is a -substitute for T w.r.t. Q if for all
-ABoxes A and all q  Q, we have that certT 0 ,A (q) = certT ,A (q).
We are not aware that -substitutes according to Definition 41 have been studied before, but they are
closely related to other types of modules. For example, -modules that give the same answers to all
CQs formulated in signature  for all -ABoxes are studied in the work of Lutz and Wolter (2010),
Kontchakov, Wolter, and Zakharyaschev (2010), Konev, Ludwig, Walther, and Wolter (2012), Botoeva, Kontchakov, Ryzhikov, Wolter, and Zakharyaschev (2014, 2016), and Romero, Kaminski,
Grau, and Horrocks (2015). A stronger version of a module is provided by -modules that require the original TBox to be a model-conservative extension of the module regarding the signature
, as studied by Konev, Lutz, Walther, and Wolter (2013) and Gatens, Konev, and Wolter (2014).
However, an important difference between all those -modules and our -substitutes is that the
latter only restrict the signature of the ABox, but not of the queries. In contrast, the mentioned
-modules only guarantee the same answers to CQs formulated in signature  (and for -ABoxes).
In particular, it follows that minimal modules, as defined in the work of Kontchakov et al. (2010)
and Konev et al. (2013), can in general not be used as a -substitute.
We now show that in ELI (and, therefore, also in its fragment EL) one can use CQ-predicate
emptiness in a straightforward way to compute a -substitute w.r.t. CQ. Let T be a TBox and  an
ABox signature. The CQ -core of T , denoted TCQ , is the set of all concept inclusions   T such
that no X  sig() is CQ-predicate empty for  given T .

35

fiBAADER , B IENVENU , L UTZ , & W OLTER

Theorem 42 Let T be a TBox in ELI. Then the CQ -core of T is a -substitute for T w.r.t. CQ
(and thus also w.r.t. IQ).
Proof. Let T 0 be the CQ -core of T and assume that T 0 , A 6|= q[~a] for some -ABox A. Consider
the canonical model IT 0 ,A , introduced in Section 5.2. Then IT 0 ,A is a model of T 0 and A, and
IT 0 ,A 6|= q[~a]. It is sufficient to show that IT 0 ,A is a model of T . Let C v D  T \ T 0 and
assume that IT 0 ,A 6|= C v D. Then C IT 0 ,A 6= . Let qC (v) be the tree-shaped conjunctive
query corresponding to C, constructed in the standard way (see Appendix B for a formal definition
of a similar construction). Then IT 0 ,A |= v qC (v) and so T 0 , A |= v qC (v). Hence T , A |=
v qC (v) and all X  sig(C) are not CQ-empty for  given T . Since C v D  T , we also
obtain T , A |= v qD (v), where qD (v) is the tree-shaped conjunctive query corresponding to D.
Thus, no X  sig(D) is CQ-empty for  given T . But this means that C v D  T 0 , which is a
contradiction.
o
Note that by Theorem 22, the CQ -core can be computed in polynomial time if T is an EL-TBox.
We make some simple observations regarding CQ -cores:
1. Theorem 42 fails in DLs that admit negation. For example, for T = {A v B, B v E}
and  = {A}, any -substitute of T w.r.t. CQ coincides with T , but the CQ -core of T is
empty.
2. the CQ -core is not always a minimal -substitute w.r.t. CQ. Consider, for example, T =
{A v B1 , A v B2 , B1 v B2 } and let  = {A}. Then T 0 = {A v B1 , A v B2 } is a
-substitute w.r.t. CQ of T but the CQ -core of T coincides with T .
3. let the IQ -core of TBox T be defined in analogy to the CQ -core of T , but based on IQemptiness instead of CQ-emptiness. Then the IQ -core cannot serve as a -substitute of T
w.r.t. IQ even when T is an EL-TBox. For example, let T = {A v r.B, r.B v E} and
 = {A}. Then B is IQ-empty for  given T and so the IQ -core of T is empty. However,
the empty TBox is not a -substitute of T w.r.t. IQ since T , A |= E(a) for A = {A(a)}.
Interestingly, in contrast to the -modules discussed above, the -modules introduced by Grau
et al. (2008) turn out to be examples of -substitutes. To define -modules, let  be a signature.
0
0
Two interpretations I and I 0 coincide w.r.t.  if I = I and X I = X I for all X  . A
subset T 0 of a TBox T is called a semantic -module of T w.r.t.  if for every interpretation I the
0
interpretation I 0 that coincides with I w.r.t.   sig(T 0 ) and in which X I =  for all X 6  
sig(T 0 ) is a model of T \ T 0 . It is shown in the work of Grau et al. (2008) that extracting a minimal
semantic -module is of the same complexity as standard reasoning (that is, subsumption). In
addition, it is shown that a syntactic approximation called the syntactic -module can be computed
in polynomial time (every syntactic -module is a semantic -module, but not necessarily the
other way around). The following lemma establishes the relationship between -modules and substitutes. A concept inclusion C v D is tautological if  |= C v D.
Proposition 43 Let T be a TBox formulated in any of the DLs introduced in this paper, and let T 0
be a semantic -module of T w.r.t. . Then
1. T 0 is a -substitute of T w.r.t. CQ;
36

fiQ UERY AND P REDICATE E MPTINESS

2.   sig(T 0 ) contains all predicates that are not CQ-empty for  given T ;
3. if T is an ELI-TBox and does not contain tautological CIs, then the CQ -core of T is
contained in T 0 .
Proof. For Point 1, suppose T 0 , A 6|= q[~a], where T 0 be a semantic -module of T w.r.t.  and A
is a -ABox. Let I be a model of T 0 and A such that I 6|= q[~a], and consider the interpretation I 0
that coincides with I 0 on   sig(T 0 ) and in which X I =  for all remaining predicates X. Then
I 0 is a model of T since T 0 is a semantic -module of T w.r.t. . and I 0 is a model of A since A
is a -ABox. Since we only shrank the extension of predicates when transitioning from I to I 0 and
I 6|= q[~a], we have I 0 6|= q[~a]. Hence T , A 6|= q[~a], as required.
For Point 2, assume X is not CQ-empty for  given T , but X 6   sig(T 0 ). Suppose X = A
for a concept name A (the case X = r for a role name r is similar and left to the reader). Take a
-ABox A that is satisfiable w.r.t. T and such that T , A |= v A(v). Let I be a model of (T , A),
0
and let I 0 be the interpretation that coincides with I on   sig(T 0 ) and in which Y I =  for all
0
remaining Y (in particular we have AI = ). By definition of semantic -modules, I 0 is a model
of (T , A). We have derived a contradiction because I 0 shows that T , A 6|= v A(v).
For Point 3, assume T is formulated in ELI and contains no tautological inclusions. Let C v
D  T \ T 0 . Then, by the definition of semantic -modules, sig(C v D) contains a predicate
X 6   sig(T 0 ) (because otherwise C v D is a tautology). Thus, by Point 2, sig(C v D)
contains a predicate that is CQ-empty for  given T . But then C v D is not in the CQ -core of T ,
as required.
o
By Point 1, we can use the algorithms for computing syntactic or semantic -modules such as the
ones provided in the work of Grau et al. (2008) to find -substitutes in a large variety of DLs.
By Point 2, such modules also provide an over-approximation of the set of predicates that are not
CQ-empty. Finally, Point 3 means that, in ELI, -modules cannot be smaller than the CQ -core
unless there are tautological concept inclusions. In general, however, -modules can be larger than
the CQ -core of a TBox. The following example shows that this can be the case already for acyclic
EL-TBoxes: let
T = {A v s1 .r1 .> u s2 .r2 .>, B  r1 .> u r2 .>}
and  = {A}. The predicates that are not CQ-empty for  given T are A, s1 , s2 , r1 , r2 . Hence the
CQ -core of T contains only the first CI of T . However, T has no non-trivial semantic -modules
w.r.t.  (and thus no syntactic ones either).
We now demonstrate the potential usefulness of -substitutes and the CQ -core by extending
our case study from the medical domain. We again use the ontology SNOMED CT and the ABox
signatures described at the beginning of this section, analyzing the size of the CQ -core and comparing it to the size of the original ontology and of the syntactic -module. For the real-world
signature, CQ -core contains 17,322 of the 370,000 concept inclusions in SNOMED CT. Thus, it
is of about 5% the size of the original ontology. The -module w.r.t.  turns out to be significantly
larger than the CQ -core, containing 27,383 axioms. For the random signatures, the sizes of CQ cores and -modules are shown in the two right-most columns of Figure 4. They again confirm the
findings for the real-world signature: the CQ -core is much smaller both than the original ontology
and than the -module.
37

fiBAADER , B IENVENU , L UTZ , & W OLTER

Q UERY C ONTAINMENT

Q UERY E MPTINESS

DL

IQ

CQ

IQ

CQ

EL

E XP T IME-c.

E XP T IME-c.

PT IME-c.

PT IME-c

EL

E XP T IME-c.

E XP T IME-c.

E XP T IME-c.

E XP T IME-c

ELI, Horn-ALCIF

E XP T IME-c.

2E XP T IME-c.

E XP T IME-c.

E XP T IME-c.

in PT IME

coNP-c.

NL OG S PACE-c.

coNP-c.

coNP-c.

p2 -c.

coNP-c.

coNP-c.

NE XP T IME-c.

NE XP T IME-h.,

NE XP T IME-c.

NE XP T IME-c.

NE XP T IME-c.

2E XP T IME-c.

DL-Litecore
DL-Litehorn
ALC

in 2NE XP T IME
ALCI

NE XP T IME-c.

2NE XP T IME-c.

Figure 5: Query Containment vs Query Emptiness

8. Related Work
Query emptiness is a fundamental problem in the static analysis of database queries. It is also
called the query satisfiability problem. For XML, for example, it takes the following form: given
an XPath query p and a DTD D, does there exist an XML document T such that T conforms to
D and the answer of p on T is non-empty. The complexity of this problem ranges from tractable
to undecidable depending on the XPath fragment, see e.g. the work of Benedikt et al. (2008) and
references therein. In a DL context, query emptiness has been first considered in the work of Lubyte
and Tessaris (2008), who use it as a step to guide the enrichment of ontologies.
The query emptiness problem studied in this paper is a special case of the following query
containment problem, first considered in the work of Bienvenu, Lutz, and Wolter (2012). We can
regard a pair (T , q) which consists of a TBox T and a query q as a compound query Q, called an
ontology-mediated query (OMQ), such that the answers to Q are the certain answers to q w.r.t. T
(Bienvenu et al., 2014). Now take two OMQs Qi = (Ti , qi ), i  {1, 2}, such that q1 and q2 are IQs
or CQs of the same arity. Then Q1 is -contained in Q2 , for an ABox signature , if for all ABoxes A that are satisfiable w.r.t. T1 and T2 , we have certT1 ,A (q1 )  certT2 ,A (q2 ). In this case, we
write Q1  Q2 . This notion of containment generalizes the more traditional query containment
problem in DLs (Calvanese et al., 2007) by relativizing it to an ABox signature and admitting
distinct TBoxes T1 and T2 . Query emptiness of an IQ q for  given T can clearly be polynomially
reduced to -containment by setting T1 = T , q1 = q, T2 = , and q2 = A(x) for a fresh concept
name A, and similarly for CQs. Deciding -containment, however, is often computationally harder
than deciding query emptiness. Table 5 summarizes known results; the results about EL and DLLite are from the work of Bienvenu et al. (2012), the results about ELI from the work of Bienvenu,
Hansen, Lutz, and Wolter (2016), and the results about ALC and ALCI from the work of Bienvenu
et al. (2014) and Bourhis and Lutz (2016).
Query emptiness is also closely related to explaining negative answers to queries. This problem
was studied, for example, by Calvanese, Ortiz, Simkus, and Stefanoni (2013). Adopting an abductive reasoning approach, it can be described as follows. Assume T , A 6|= q(~a) for a TBox T , ABox
A, and query q. To explain that ~a is not an answer to q, one wants to find minimal ABoxes E over
38

fiQ UERY AND P REDICATE E MPTINESS

a certain signature  of interest such that A  E is satisfiable w.r.t. T and T , A  E |= q(~a). Such
-ABoxes E are then regarded as an explanation for the missing answer and can be used for debugging purposes. It is shown in the work of Calvanese et al. (2013) that query emptiness of IQs and
Boolean CQs reduces (under many-one logarithmic space reductions) to the problem of deciding the
existence of an explanation for T , A 6|= q(~a) with A = . For DL-LiteA , the reduction even works
for unions of conjunctive queries of any arity. Calvanese et al. (2013) use this observation to obtain
lower complexity bounds for explaining negative query answers, exploiting the results published
in the conference predecessor of this paper (Baader, Bienvenu, Lutz, & Wolter, 2010). They also
conjecture that, conversely, techniques for proving upper complexity bounds for query emptiness
(such as the ones in this paper) can be used to obtain upper bounds for explaining negative answers.

9. Conclusion
We have investigated the computational complexity of query and predicate emptiness in the EL,
DL-Lite, and ALC families of DLs, concentrating on instance queries and conjunctive queries and
showing that complexities range from NL OG S PACE to undecidable. We have also highlighted that,
for different DLs and query languages, different kinds of witness ABoxes are sufficient to establish
non-emptiness. DLs and queries that are not considered in this paper, but which would be interesting
to investigate in future work, include the following:
 DLs that include transitive roles, role inclusions, symmetric roles, or role inclusion axioms
(Horrocks, Kutz, & Sattler, 2006; Kazakov, 2010).
In some cases, straightforward reductions to results presented in this paper are possible. For
example, IQ-query emptiness in Horn-SHIF is decidable in E XP T IME since for every
Horn-SHIF TBox T , IQ A(x), and ABox signature , one can construct in polynomial
time a Horn-ALCIF TBox T 0 such that T , A |= A(a) iff T 0 , A, |= A(a) for all -ABoxes
A (Hustadt et al., 2007; Kazakov, 2009). In other cases, such as CQ-query emptiness in
Horn-SHIF, there seems to be no such reduction.
 DLs that include nominals.
 Other important classes of queries such as unions of conjunctive queries (UCQs).
For materializable DLs such as Horn-ALCIF,
W UCQ query emptiness can be reduced to CQ
query emptiness since for every UCQ q = iI qi (~x), we have T , A |= q(~a) iff there is an
i  I such that T , A |= qi (~a). Such a simple reduction does not work for non-Horn DLs such
as ALC.
It would also be interesting to develop practical algorithms for emptiness and to evaluate these algorithms on real-world ontologies and queries. Note that our algorithms for EL and DL-Lite are
easily implementable and efficient as presented in this paper. This was actually confirmed by the
case study in Section 7. More work will be required to design efficient algorithms for more expressive DLs. Finally, it would be relevant to investigate the notion of a -substitute introduced
in our application to modularity in more detail. For example, it is an open question how to compute minimal -substitutes in expressive DLs such as ALC in practice, and what are the involved
complexities.
39

fiBAADER , B IENVENU , L UTZ , & W OLTER

Acknowledgements
The first author was partially supported by cfaed (Center for Advancing Electronics Dresden) and
the second author was partially supported by the ANR project PAGODA (ANR-12-JS02-007-01).
We are grateful to Julian Mendez and Dirk Walther for supporting us in the case study. We would
like to thank the anonymous reviewers who provided excellent comments that helped us to improve
the paper.

Appendix A. Proofs for Section 3
We formulate the result to be proved again.
Lemma 3 Let T be an ALCIF-TBox. Then each CQ q is empty for  given T with the UNA iff
it is empty for  given T without the UNA.
Proof. Consider a CQ q with answer variables v1 , . . . , vn .
(Only if) Assume that q is non-empty for  given T without the UNA. Then there is a ABox A such that A is satisfiable w.r.t. T without the UNA and certT ,A (q) 6=  without the UNA.
Take a model I of A and T and suppose without loss of generality that I is infinite. Define
an equivalence relation  over Ind(A) by setting a  b whenever aI = bI . Choose a single
representative from each equivalence class, and denote by a the representative of the equivalence
class containing a. Let A0 be the ABox obtained from A by replacing each individual a by a . We
show that A0 is satisfiable w.r.t. T with the UNA and that certT ,A0 (q) 6=  with the UNA.
Regarding satisfiability, it is easy to see that I is a model of (T and) A0 and that it satisfies the
UNA for the individuals appearing in A0 . Moreover, since I is infinite, we can reinterpret the
individual names in NI \ Ind(A0 ) to obtain an interpretation that is a model of A0 and T and satisfies
the UNA.
Now for showing certT ,A0 (q) 6=  with the UNA. Take some (a1 , . . . , an )  certT ,A (q) without
the UNA. We aim to show that (a1 , . . . , an )  certT ,A0 (q). Let J 0 be any model of T and A0 that
0
satisfies the UNA. We have to show that there is a match for q in J 0 with (vi ) = (ai )J for every
0
1  i  n. Consider the interpretation J obtained from J 0 by setting aJ = (a )J for every
a  Ind(A). It is easy to see that J is a model of A and T without the UNA, so J |= q[a1 , . . . , an ]
and there is a match  for q in J such that (vi ) = aJ
i for every 1  i  n. Then  is also the
desired match for q in J 0 , which finishes the proof.
(If) Assume that q is non-empty for  given T with the UNA. Then there is a -ABox A
such that A is satisfiable w.r.t. T with the UNA and certT ,A (q) 6=  with the UNA. Clearly, A is
also satisfiable w.r.t. T without the UNA and it remains to show that certT ,A (q) 6=  without the
UNA. Let (a1 , . . . , an )  certT ,A (q) with the UNA, and let I be any model of A and T without
the UNA. We have to show that I |= q[a1 , . . . , an ]. For any a  Ind(A), let Ia be the following
unfolding of I at aI :
 the domain Ia of Ia consists of all words d0 r0 d1    rk1 dk with d0 , . . . , dk  I and
r0 , . . . , rk1 (potentially inverse) roles such that d0 = aI , (di , di+1 )  riI for all i < k,
ri 6= ri+1 for functional ri+1 and i < k, and r0 (a, b) 6 A for any b  Ind(A) if r0 is
functional.
 AIa = {d0 r0 d1    dk | dk  AI } for all A  NC ;
40

fiQ UERY AND P REDICATE E MPTINESS

 rIa = {(d0 r0 d1    dk , d0 r0 d1    dk rk+1 dk+1 ) | r = rk+1 } 
{(d0 r0 d1    dk rk+1 dk+1 , d0 r0 d1    dk ) | r = rk+1 } for all r  NR .
Assume that the Ia are mutually disjoint and let the individual name a be the root of Ia . Then we
obtain the interpretation J by taking the disjoint union of all Ia , a  Ind(A), adding (a, b) to rJ
whenever r(a, b)  A, and setting aJ = a for all a  Ind(A). One can show that J is a model of A
and T with the UNA. Thus J |= q[a1 , . . . , an ] and there is a match  for q in J with (vi ) = (ai )J
for every 1  i  n. It can be verified that  0 defined by setting  0 (vi ) = aI if (vi ) = a  Ind(A)
and  0 (vi ) = dk if (v) = d0 , . . . , dk with k  1 is a match of q in I, thus I |= q[a1 , . . . , an ], as
required.
o

Appendix B. Proofs for Section 4
We restate the first result to be proved.
Theorem 16 In ALC, CQ-query emptiness is in NE XP T IME.
The general idea for proving Theorem 16 is as follows. Given an ALC-TBox T , a signature ,
and a CQ q, by Theorem 13 it suffices to test whether T , AT , 6|= q. We thus start by computing AT , . To check whether T , AT , 6|= q, we then guess an extension of T with a set T 0 of
concept inclusions and an extension of AT , with a set A0 of ABox assertions such that T 0 and A0
that are satisfied only in models of T and AT , in which q has no match; subsequently, it remains to
test the satisfiability of AT ,  A0 w.r.t. T  T 0 . The subtlety lies in selecting the class of extensions
to be guessed from in a careful enough way so that the final satisfiability check can be carried out
in NE XP T IME.
We reuse some technical definitions and results from the work of Lutz (2008) who proves that
the combined complexity of CQ-answering in the DL SHQ is in E XP T IME. The definitions are
slightly modified since Lutz considers only CQs without answer variables and uses the DL SHQ,
of which ALC is a proper fragment. However, it is straightforward to verify that the proofs given
by Lutz also work with our modified definitions.
A CQ q can be viewed as a directed graph Gdq = (Vqd , Eqd ) with Vqd = var(q) and Eqd =
{(v, v 0 ) | r(v, v 0 )  q for some r  NR }. We call q directed tree-shaped if Gdq is a directed tree and
r(v, v 0 ), s(v, v 0 )  q implies r = s. If q is directed tree-shaped and v0 is the root of Gdq , we call v0
the root of q. For U  var(q), we write q|U to denote the restriction of q to atoms that contain only
variables from U . The set DTrees(q) of directed tree-shaped subqueries of q is defined as follows:
DTrees(q) = {q|U | U = Reachq (v), v  var(q), q|U is directed tree-shaped}
where Reachq (v) is the set of variables that are reachable from v in Gdq . We say that
 q 0 is obtained from q by performing fork elimination if q 0 is obtained from q by selecting two
atoms r(v 0 , v) and s(v 00 , v) such that v 0 , v 00 , v  qvar(q) and v 0 6= v 00 , and identifying v 0
and v 00 ;
 q 0 is a fork rewriting of q if q 0 is obtained from q by repeatedly (but not necessarily exhaustively) performing fork elimination;
41

fiBAADER , B IENVENU , L UTZ , & W OLTER

 q 0 is a maximal fork rewriting of q if q 0 is a fork rewriting and no further fork elimination is
possible in q 0 .
The following is shown in the work of Lutz (2008), and it plays a central role in the subsequent
definitions.
Lemma 44 Up to variable renaming, every CQ has a unique maximal fork rewriting.
The following definitions of splittings and spoilers are also taken from the work of Lutz. To understand a splitting of a CQ q on an intuitive level, it is useful to consider matches of q in a model I of a
TBox T and ABox A that has a special shape: I consists of a core part whose elements are exactly
(the interpretations of) the ABox individuals in A and of tree-shaped parts that are attached to the
element in the core part and disjoint from each other. In fact, it is proved by Lutz that if T , A 6|= q,
then there is a model I of T and A of the described shape such that I 6|= q. A match of q in a model
of the described shape partitions the variables in q into several sets: a set R which contains the variables that are matched to an ABox individual; sets S1 , . . . , Sn which represent disjoint tree-shaped
subqueries of q that are matched into a tree part of I and whose root is connected to some variable
in R via a role atom in q; and a set T which represents a collection of tree-shaped subqueries of
q that are disconnected from the variables in R and Si . In addition to this partitioning, splittings
record the variable in R to which each set S1 , . . . , Sn is connected and the ABox elements that the
variables in R are mapped to. We now define splittings formally.
Let K = (T , A) be an ALC-knowledge base and q a CQ. A splitting of q w.r.t. K is a tuple  =
hR, T, S1 , . . . , Sn , , i, where R, T, S1 , . . . , Sn is a partitioning of var(q),  : {1, . . . , n}  R
assigns to each set Si a variable (i) in R, and  : R  Ind(A) assigns to each variable in R an
individual in A. A splitting has to satisfy the following conditions:
1. the CQ q|T is a variable-disjoint union of directed tree-shaped queries;
2. the queries q|Si , 1  i  n, are directed tree-shaped;
3. if r(v, v 0 )  q, then one of the following holds: (i) v, v 0 belong to the same set R, T, S1 , . . . , Sn
or (ii) v  R, (i) = v, and v 0  Si is the root of q|Si ;
4. for 1  i  n, there is a unique r  NR such that r((i), v0 )  q, with v0 the root of q|Si ;
5. avar(q)  R.
Let q be a directed tree-shaped CQ. We define an ALC-concept Cq,v for each v  var(q):
 if v is a leaf in Gdq , then Cq,v =
 otherwise, Cq,v =

u

A(v)q

Au

u C;
u r.C

A(v)q

r(v,v 0 )q

q,v 0 .

If v is the root of q, we use Cq to abbreviate Cq,v .
In the following, we allow compound concepts and negated roles to be used in ABox assertions. The semantics of such assertions and corresponding KBs is defined in the expected way: an
interpretation I satisfies C(a) if aI  C I and I satisfies r(a, b) if I does not satisfy r(a, b).
Let  = hR, T, S1 , . . . , Sn , , i be a splitting of q w.r.t. K such that q1 , . . . , qk are the (directed
tree-shaped) disconnected components of q|T . An ALC-knowledge base (T 0 , A0 ) is a spoiler for q,
K, and  if one of the following conditions hold:
42

fiQ UERY AND P REDICATE E MPTINESS

1. > v Cqi  T 0 , for some i with 1  i  k;
2. there is an atom A(v)  q with v  R and A((v))  A0 ;
3. there is an atom r(v, v 0 )  q with v, v 0  R and r((v), (v 0 ))  A0 ;
4. D(((i)))  A0 for some i with 1  i  n, and where D = r.Cq|S with v0 root of q|Si
i
and r((i), v0 )  q.
We call K0 a spoiler for q and K if (i) for every fork rewriting q 0 of q, and every splitting  of q 0
w.r.t. K, K0 is a spoiler for q 0 , K, and ; and (ii) K0 is minimal with Property (i). The following
result is proved in the work of Lutz (2008).
Theorem 45 Let K = (T , A) be an ALC-knowledge base and q a CQ. Then K 6|= q iff there is a
spoiler (T 0 , A0 ) for q and K such that A  A0 is satisfiable w.r.t. T  T 0 .
The following lemma, which was observed by Lutz, plays a central role for obtaining a NE XP T IME
decision procedure.
Lemma 46 Let K = (T , A) be an ALC-knowledge base, q a CQ, q  its maximal fork rewriting,
and K0 = (T 0 , A0 ) a spoiler for q and K. Then K0 contains only concept inclusions and ABox
assertions of the following form:
1. > v Cq0 with q 0  DTrees(q  );
2. A(a) with a  Ind(A) and A occurring in q;
3. r(a, b) with a, b  Ind(A) and r occurring in q;
4. D(a) with a  Ind(A) and D = r.Cq0 , where r occurs in q and q 0  DTrees(q  ).
Note that while the definition of a spoiler for q and K refers to all fork rewritings of q, of which
there are exponentially many, Lemma 46 only refers to the unique maximal form rewriting q  . In
fact, since the cardinality of DTrees(q  ) is clearly bounded by the size of q, the number of concept
inclusions and assertions listed in Lemma 46 is only polynomial in the size of A and q.
We are now set up for the proof of Theorem 16. By Theorems 13 and 45, a CQ q is empty for a
signature  given a TBox T iff there is a spoiler (T 0 , A0 ) for q and (T , AT , ) such that AT ,  A0
is satisfiable w.r.t. T  T 0 . Given a CQ q, signature  and TBox T , we can thus decide emptiness
of q for  given T as follows:
1. compute AT , ;
2. guess a TBox T 0 and an ABox A0 that satisfy Conditions 1 to 4 from Lemma 46 for the KB
K = (T , AT , ) and such that there is no role assertion r(a, b)  AT , with r(a, b)  A0 ;
3. verify that (T 0 , A0 ) is a spoiler for q and (T , AT , );
4. verify that AT ,  A0 is satisfiable w.r.t. T  T 0 .
43

fiBAADER , B IENVENU , L UTZ , & W OLTER

It remains to argue that this yields a NE XP T IME algorithm. As already noted, Step 1 can be carried
out in (deterministic) exponential time. Due to Conditions 1 to 4 from Lemma 46 and since AT ,
is of size at most exponential in T and , the TBox T 0 and ABox A0 guessed in Step 2 are of
size at most exponential in T and , and of size polynomial in q. Step 3 can be implemented by
a straightforward iteration over all fork rewritings q 0 of q and splittings  of q 0 w.r.t. (T , AT , ),
which requires only exponential time.
It thus remains to deal with Step 4. Let  be the closure under single negations of the union of
the following sets of concepts:
   NC ;
 all concepts that occur in T (possibly as subconcepts);
 all concept names that occur in q;
 all concepts Cq and r.Cq and their subconcepts, where q  DTrees(q  ), q  the maximal fork
rewriting of q, and r occurs in q.
Based on the remark after Lemma 46, it is easy to verify (and crucial for our argument) that ||
is polynomial in , T , and q. A -type is a set t   such that for some model I of T  T 0
and some d  I , we have t = {C   | d  C I }. As in Section 4, we introduce a notion of
coherence between types: we say that the pair of -types (t, t0 ) is r-coherent, denoted t ;r t0 , if
for all r.C  , C  t0 implies r.C  t. The set T of all -types can be computed in E XP T IME.
To verify satisfiability of AT ,  A0 w.r.t. T  T 0 , we guess a map  : Ind(AT , )  T , accept
if the following two conditions are satisfied and reject otherwise:
(i) C(c)  AT ,  A0 implies C  (c) and
(ii) r(b, c)  AT ,  A0 , C  (c), and r.C   imply r.C  (b).
Clearly, checking whether these two conditions are satisfied can be done in single exponential time.
It thus remains to argue that AT ,  A0 is satisfiable w.r.t. T  T 0 just in the case that there exists a
map  verifying these conditions. First note that given a model I of the KB (T  T 0 , AT ,  A0 ),
we can define the desired map by setting (c) = {C   | cI  C I }. Conversely, given a map 
satisfying conditions (i) and (ii), we define an interpretation I as follows:
I = T

AI = {t  T | A  t}

rI = {(t, t0 )  T  T | t ;r t0 }

cI = (c)

It is readily verified that for all C   and t  T , we have C  t iff t  C I . From this, we can
show, using a similar argument to that given in Lemma 10, that I is a model of (T T 0 , AT , A0 ).
We now complete the proof of our undecidability result (Theorem 19) by proving Lemma 20.
Lemma 20 (T, H, V ) admits a tiling iff there is a -ABox A that is satisfiable w.r.t. T and such
that T , A |= v A(v).
Proof. (Only if) Straightforward. Consider a tiling f : {0, . . . , n}  {0, . . . , m}  T for
(T, H, V ). Create individuals ai,j for 0  i  n and 0  j  m, and consider the ABox A
composed of the following assertions:
44

fiQ UERY AND P REDICATE E MPTINESS

 x(ai,j , ai+1,j ) for 0  i < n and 0  j  m
 x (ai+1,j , ai,j ) for 0  i < n and 0  j  m
 y(ai,j , ai,j+1 ) for 0  j < m and 0  i  n
 y  (ai,j+1 , ai,j ) for 0  j < m and 0  i  n
 Th (ai,j ) if f (i, j) = Th .
It can easily be verified that A is satisfiable w.r.t. T and satisfies T , A |= v A(v).
(If) Let A be a -ABox satisfiable w.r.t. T and such that T , A |= v A(v). We first show that
Ix and Iy enforce that x is the inverse of x and y  is the inverse of y, respectively, and that C
forces relevant grid cells to be closed. For r  {x, y} we call a  Ind(A) an r-defect if there exists
b  Ind(A) such that r(a, b)  A and r (b, a) 6 A. We call a an inv-defect if it is an x-defect or
a y-defect. We call a  Ind(A) a cl-defect if there exist x(a, b), y(a, c), y(b, d), x(c, e)  A with
d 6= e such that a is not an inv-defect, b is not a y-defect and c is not an x-defect.
Claim 1. There exists a model I of T and A such that for all a  Ind(A):
(d1) aI 6 IrI , for all r-defects a  Ind(A) and r  {x, y};
(d2) aI 6 C I , for all cl-defects a  Ind(A).
Moreover, I satisfies the following conditions for all a  Ind(A), role names r, and h  {1, . . . , p}:
1. I = Ind(A);
2. aI = a;
3. (a, a0 )  rI implies r(a, a0 )  A;
4. a  ThI implies Th (a)  A.
Proof of Claim 1. Let r  {x, y}. Call a two-element set {a, b} a r-defect witness if there exists
c  Ind(A) such that r(a, c), r (c, b)  A. Consider the undirected graph G with nodes Ind(A)
and the set of r-defect witnesses as its edges. Note that G has degree at most two (since r and r are
functional). Hence G is three-colorable. Choose a three coloring of G with colors Br,1 = Zr,1 uZr,2 ,
Br,2 = Zr,1 u Zr,2 and Br,3 = Zr,1 u Zr,2
of the concept names
Sand choose the interpretation
I

I
Zr,1 , Zr,2 in I correspondingly. We set Ir = i=1,2,3 (Br,i u r.r .Br,i ) .
Call a two-element set {d, e} a cl-defect witness if there exist x(a, b), y(a, c), y(b, d), x(c, e) 
A such that a is not an inv-defect, b is not a y-defect and c is not an x-defect. Consider the undirected
graph G with nodes Ind(A) and the set of cl-defect witnesses as its edges. Note that G has degree at
most two (again since x, x , y, and y  are all functional). Hence G is three-colorable with colors
C1 = Zc,1 u Zc,2 , C2 = Zc,1 u Zc,2 and C3 = Zc,1 u Zc,2 and we
S can choose the interpretation of
the concept names Zc,1 , Zc,2 in I correspondingly. We set C I = i=1,2,3 (x.y.Ci u y.x.Ci )I .
Since neither existential restrictions nor the concept names Th occur in the right-hand side of
CIs in T , it is not hard to verify that we can interpret the remaining concept names in T in such a
way that the additional conditions on I are satisfied. (End of proof of claim)
45

fiBAADER , B IENVENU , L UTZ , & W OLTER

Let I be a model satisfying the conditions of Claim 1. We additionally assume w.l.o.g. that I
is A, Y -minimal: there is no model J of T and A satisfying the conditions of Claim 1 such that
AJ  AI and Y J  Y I and at least one of these inclusions is proper.
Let aA  AI . We now exhibit a grid structure in A that gives rise to a tiling for (T, H, V ). We
start by identifying a diagonal that starts at aA and ends at an instance of Tfinal .
Claim 2. There is a set G = {r1 (ai0 ,j0 , ai1 ,j1 ), . . . , rk1 (aik1 ,jk1 aik ,jk ), Tfinal (aik ,jk )}  A such
that
 i0 = 0, j0 = 0, and a0,0 = aA ;
 for 1  ` < k, we either have (i) r` = x, i`+1 = i` + 1, and j`+1 = j` or (ii) r` = y,
j`+1 = j` + 1, and i`+1 = i` .
Proof of claim. If there is no such sequence, we can convert I into a new model J of T and
A by interpreting Y as false at all points reachable in I (equivalently: A) from aA and setting
AJ = AI \ {aA }, which contradicts the A, Y -minimality of I. (End of proof of claim)
Let n be the number of occurrences of the role x in the ABox G from Claim 1 and m the number of
occurrences of y. We next show
Claim 3. We have that
I .
(a) a0,0  Tinit

(b) ai,j  RI implies i = n;
(c) ai,j  U I implies j = m;
(d) ai,j  Y I for all ai,j  Ind(G);
(e) for all ai,j  Ind(G), there is a (unique) Th with ai,j  ThI , henceforth denoted Ti,j ;
(f) (Ti,j , Ti+1,j )  H for all ai,j , ai+1,j  Ind(G) and (Ti,j , Ti,j+1 )  V for all ai,j , ai,j+1 
Ind(G).
Proof of claim. Point (a) is an easy consequence of the fact that a0,0 = aA , aA  AI , and I is
A, Y -minimal. For (b), first note that there is a unique `  k such that is = n for all s  {`, . . . , k}
and is < n for all s  {0, . . . , `  1}. Due to the CI R v x., ai`1 ,j`1 
/ RI . To show that
I
ais ,js 
/ R for all s < `  1, it suffices to use the CIs R v x. and R v y.R. The proof of
(c) is similar. We prove (d)-(f) together, showing by induction on ` that (d)-(f) are satisfied for all
initial parts
G` := {r1 (ai0 ,j0 , ai1 ,j1 ), . . . , r`1 (ai`1 ,j`1 ai` ,j` )}
of G, with `  k. For the base case, ai0 ,j0 = aA  AI clearly implies ai0 ,j0  Y I , thus (d)
is satisfied. Point (e) follows from (a) and the disjointness of tiles expressed in T . Point (f) is
vacuously true since there is only a single individual in G0 . For the induction step, assume that G`1
satisfies (d)-(f). We distinguish four cases:
 ai`1 ,j`1  (U u R)I .
46

fiQ UERY AND P REDICATE E MPTINESS

Since G`1 satisfies (d), we have ai`1 ,j`1  Y I , and the definition of T and the A, Y minimality of I together with the fact ai`1 ,j`1  (U u R)I ensure that
ai`1 ,j`1  (x.(Tg u Y u y.Y ) u y.(Th u Y u x.Y ) u Ix u Iy u C u Tf )I
for some (Tf , Tg )  H and (Tf , Th )  V . Using the functionality of x and y, it is now easy
to show that G` satisfies (d)-(f).
 ai`1 ,j`1  (U u R)I .
Since ai`1 ,j`1  RI , T ensures that there is no x-successor of ai`1 ,j`1 in I. Moreover,
ai`1 ,j`1  Y I . Together with the definition of T , we get
ai`1 ,j`1  (y.(Tg u Y u R) u Iy u Tf )I
for some (Tf , Tg )  V . We must have i` = i`1 , j` = j`1 + 1, and r`1 = y. Using the
functionality of y, it is now easy to show that G` satisfies (d)-(f).
 ai`1 ,j`1  (U u R)I .
Analogous to the previous case.
 ai`1 ,j`1  (U u R)I .
Then there is neither an x-successor nor a y-successor of ai`1 ,j`1  (U u R)I . It follows
that `  1 = k, in contradiction to `  k.
(End of proof of claim)
Next, we extend G to a full grid such that Conditions (a)-(e) from Claim 3 are still satisfied. Once
this is achieved, it is trivial to read off a solution for the tiling problem. The construction of the grid
consists of exhaustive application of the following two steps:
1. if x(ai,j , ai+1,j ), y(ai+1,j , ai+1,j+1 )  G and there is no ai,j+1  Ind(G) with y(ai,j , ai,j+1 ) 
G and x(ai,j+1 , ai+1,j+1 )  G, then identify an ai,j+1  Ind(A) such that y(ai,j , ai,j+1 )  A
and x(ai,j+1 , ai+1,j+1 )  A and add the latter two assertions to G.
2. if y(ai,j , ai,j+1 ), x(ai,j+1 , ai+1,j+1 )  G and there is no ai+1,j  Ind(G) with x(ai,j , ai+1,j ) 
G and y(ai+1,j , ai+1,j+1 )  G, then identify an ai+1,j  Ind(A) such that x(ai,j , ai+1,j )  A
and y(ai+1,j , ai+1,j+1 )  A and add the latter two assertions to G.
It is not hard to see that exhaustive application of these rules yields a full grid, i.e., for the final G
we have (i) Ind(G) = {ai,j | i  n, j  m}, (ii) x(ai,j , ai0 ,j 0 )  G iff i0 = i + 1 and j = j 0 , and
(iii) y(ai,j , ai0 ,j 0 )  G iff i = i0 and j 0 = j + 1.
Since the two steps of the construction are completely analogous, we only deal with Case 1
in detail. Thus let x(ai,j , ai+1,j ), y(ai+1,j , ai+1,j+1 )  G with ai,j+1 
/ Ind(G). Clearly, i < n
and j < m. By (b) and (c), we thus have ai,j 
/ (R t U )I . Since ai,j  Y I by (d) and I is
A, Y -minimal, we get that
ai,j  (x.(Tg u Y u y.Y ) u y.(Th u Y u x.Y ) u Ix u Iy u C u Tf )I
for some (Tf , Tg )  H and (Tf , Th )  V . This together with the minimality of I means we can
select ai,j+1 , b  Ind(A) such that y(ai,j , ai,j+1 ), x(ai,j+1 , b)  A, ai,j+1 , b  Y I , and Ti,j+1 =
47

fiBAADER , B IENVENU , L UTZ , & W OLTER

Th . With this choice, (a), (d), (e), and the second half of (f) are clearly satisfied. To get the properties
required by Step 1 above, we have to show that b = ai+1,j+1 . If we can show this, then the
satisfaction of (b) and (c) before we apply the construction step, and the CIs
R v x. R v y.R

U v y. U v x.U

ensure that (b) and (c) are still satisfied after the construction step. Showing b = ai+1,j+1 will also
give us the first half of (f). Finally, to prove that b = ai+1,j+1 it is sufficient to show that ai,j is not
a cl-defect in Ind(A). But this follows from Claim 1 since ai,j  C I , ai,j  IxI  IyI , ai+1,j  IyI ,
and ai,j+1  IxI .
We can now use the completed grid to build a solution to our tiling problem: the tile at point
(i, j) is the unique tile which is satisfied by I at ai,j  Ind(A). Property (f) of Claim 2 and the
correctness of our grid construction ensure that adjacent tiles satisfy the vertical and horizontal
constraints.
o

Appendix C. Proofs for Section 5
Theorem 22. In EL, CQ-query emptiness can be decided in PT IME.
Proof. By Lemma 21, it suffices to show that for any n-ary CQ q and alphabet , it can be decided
in PT IME whether T , A |= q[a , . . . , a ] where A is the total -ABox. First note that we have
T , A |= q[a , . . . , a ] iff T , Ab |= qb, where
 Ab is obtained from A by adding the assertion X(a ), where X is a concept name that
does not occur in , T , and q;
 qb is the Boolean CQ obtained from q by adding the conjunct X(v) for each answer variable v
and then quantifying away all answer variables.
Recall from the discussion before Lemma 44 that every CQ q can be viewed as a directed graph
Gdq . We say that a Boolean CQ q is directed forest-shaped if it is a disjoint union of directed treeshaped Boolean CQs. Every Boolean CQ q that is directed forest-shaped corresponds to a concept
Cq in the description logic ELu that extends EL with the universal role u such that T , A |= q iff
T , A |= C(a) for all a  Ind(A) (Lutz & Wolter, 2010). Checking the latter condition is possible in
PT IME (Lutz & Wolter, 2010). Thus, it is sufficient to convert qb in polynomial time into a directed
forest-shaped CQ qb0 such that T , Ab |= qb iff T , Ab |= qb0 .
To construct qb0 from qb, we exhaustively apply the following rewriting rules:
1. if r(v, v 00 ) and r(v 0 , v 00 ) are in the query, then identify v and v 0 by replacing all occurrences
of v 0 with v;
2. if r(v 0 , v) and s(v 00 , v) are in the query (with r 6= s), then identify v, v 0 , and v 00 by replacing
all occurrences of v 0 and v 00 with v;
3. if a cycle r0 (v0 , v1 ), . . . , rn1 (vn1 , vn ), vn = v0 is in the query and {v0 , . . . , vn1 } contains
at least two variables, then identify all variables v0 , . . . , vn1 by replacing all occurrences of
v1 , . . . , vn1 with v0 .
48

fiQ UERY AND P REDICATE E MPTINESS

If the resulting query contains a reflexive loop r(v, v) with r 
/ , then we immediately return
no. Otherwise, we replace in a final step each reflexive loop r(v, v) with r   with X(v). The
query resulting from this last step is qb0 . It is easy to see that the query obtained at this point is
directed forest-shaped since every variable has at most one predecessor and there are no cycles in
the corresponding directed graph.
To prove correctness of this algorithm, we first establish the following claim:
Claim. If qb0 is defined, then T , Ab |= qb iff T , Ab |= qb0 .
It suffices to prove that each rule application preserves (non)entailment of the query by T and Ab .
As a preliminary, we recall that, as shown by Lutz and Wolter (2010), there exists a materialization
JT ,Ab of (T , Ab ) which is a directed tree-shaped interpretation with the individual a as its root
and (potentially) additional reflexive loops added to this root (an interpretation is directed treeshaped if the corresponding CQ in which the domain elements of the interpretation are regarded as
variables is directed tree-shaped). Assume that rewriting rule 1 is applied to a query p resulting in
a query p0 . It is clear that T , Ab |= pb0 implies T , Ab |= pb. For the converse, assume T , Ab |= pb
and let JT ,Ab be the materialization of T and Ab introduced above. Then there is a match of p
in JT ,Ab . Since JT ,Ab does not contain domain elements d, d0 , d00 with d 6= d0 and such that for
J

J

some role name r, (d, d00 )  r T ,Ab and (d0 , d00 )  r T ,Ab , this match of p in JT ,Ab must map the
identified variables v and v 0 to the same domain element and is thus also a match of p0 . The other
two rules and the replacement of r(v, v), r  , with X(v) can be dealt with in a similar way.
By the claim, we can substitute qb with qb0 as intended. Moreover, it is easy to see that we have
T , Ab 6|= qb if the algorithm returns no due to a reflexive loop r(v, v) with r 
/ : simply use the
interpretation JT ,Ab as in the proof of the claim.
o
Proposition 28. For every Horn-ALCIF TBox T , ABox signature , and CQ q, one can construct
in polynomial time an ELIF  -TBox T 0 in normal form such that q is empty for  given T iff q is
empty for  given T 0 .
Proof. The proof is similar to reductions provided in in the work of Hustadt et al. (2007) and
Kazakov (2009). Nevertheless, because Kazakov considers reductions preserving subsumption only,
and because Hustadt, Motik, and Sattler and also Kazakov do not reduce to ELIF  TBoxes, we
give a detailed proof.
The following rules can be used to rewrite T into an ELIF  -TBox in normal form (all freshly
introduced concept names are not in sig(T )    sig(q). Assume L v R is given.
 If L is of the form L1 u L2 and R is not a concept name, then take a fresh concept name A
and replace L v R by L v A and A v R. If R is a concept name, and either L1 or L2 are
not concept names, then take fresh concept names A1 , A2 and replace L v R by L1 v A1 ,
L2 v A2 and A1 u A2 v R;
 If L is of the form L1 t L2 and R is a concept name, then replace L v R by L1 v R and
L2 v R. Otherwise take a fresh concept name A and replace L v R by L v A and A v R;
 If L is of the form r.L0 and L0 is not a concept name, then take a fresh concept name A0 and
replace L v R by L0 v A0 and r.A0 v R;
 If R is of the form A, then replace L v R by L u A v ;
49

fiBAADER , B IENVENU , L UTZ , & W OLTER

 If R is of the form R1 u R2 and L is not a concept name, then take a fresh concept name A
and replace L v R by L v A and A v R. Otherwise take fresh concept names A1 , A2 and
replace L v R by L v A1 , L v A2 , A1 v R1 , and A2 v R2 ;
 If R is of the form L0 t R0 , then replace L v R by L u L0 v R0 ;
 If R is of the form r.R0 and R0 is not a concept name, then take a fresh concept name A0 and
replace L v R by L v r.A0 and A0 v R0 ;
 If R is of the form r.R0 , then replace L v R by r .L v R.
The resulting TBox T 0 is as required. In particular, for every -ABox A and model I of A and T 0 ,
we have that I is also a model of T ; conversely, every model I of A and T can be extended
to a model of T by appropriately interpreting the fresh concept names. Consequently, we have
certT (q, A) = certT 0 (q, A) and thus q is empty for  given T iff q is empty for  given T 0 .
o
Proposition 30. Let T be an ELIF  -TBox,  an ABox signature, and q a CQ. If q is non-empty
for  given T , then this is witnessed by a -ABox that is forest-shaped, has width at most |q|, and
degree at most |T |.
Proof. Assume that q has answer variables v1 , . . . , vn and is non-empty for  given T . Then we
can find a -ABox A that is satisfiable w.r.t. T and such that certT ,A (q) 6= . To identify a forestshaped witness for the non-emptiness of q for  given T , consider the canonical model IT ,A of
(T , A). By construction, IT ,A consists of an ABox part I0 , which is the restriction of IT ,A to
Ind(A), and tree-shaped interpretations Ia , a  Ind(A), rooted at a and containing no other ABox
individuals. Since IT ,A is universal, there is a match  of q in IT ,A . Let I consist of all individuals
a  Ind(A) such that there is some v  var(q) with (v) in Ia (possibly (v) = a). Let A0 be
the ABox obtained by restricting A to the individuals in I ; this is going to be the root component
of the forest-shaped witness we are seeking to define (observe that |Ind(A0 )|  |q|). To add the
tree components, we consider, for each a  I , the (typically infinite) tree-shaped ABox Aua that is
obtained by unraveling A starting from a, as in the work of Lutz and Wolter (2012):
 Ind(Aua ) is the set of sequences  = c0 r0 c1 . . . rm1 cm with c0 , . . . , cm  Ind(A) and
r0 , . . . , rm1 (possibly inverse) roles such that (i) c0 = a, (ii) c1 6 I , (iii) rj (cj1 , cj )  A

for all 0  j < m, and (iv) (cj1 , rj1
) 6= (cj+1 , rj ) for j > 0; we say that  is a copy
of cm ;
 if A(c)  A and   Ind(Aua ) is a copy of c, then A()  Aua ;
 if   Ind(Aua ) is a copy of c, and  = rc0  Ind(Aua ), then r(, )  Aua ;
 if   Ind(Aua ) is a copy of c, and  = r c0  Ind(Aua ), then r(, )  Aua .
We let Ab be the union of A0 and the tree-shaped ABoxes {Aua | a  I }. Observe that by Conditions
b Note
(ii) and (iv) of the first item and since A satisfies all functionality statements in T , so does A.
b
that A is forest-shaped, but need neither be finite nor of degree at most |T |; we are going to fix this
later.
We next aim to show that Ab is satisfiable w.r.t. T and that certT ,Ab(q) 6= . To this end, we
construct a universal model J of Ab and T . Start with Ab viewed as an interpretation J0 , as in
50

fiQ UERY AND P REDICATE E MPTINESS

the construction of canonical models. Then take, for each a  Ind(A) and each of as copies  
b a copy I of the tree interpretation Ia such that (i) the root of I is , (ii) J0 I = {},
Ind(A),
(iii)  6=  implies disjointness of I and I , and (iv) if  = a then I is identical to the original
tree interpretation Ia (and not a copy). If d0  I is the result of renaming d  Ia , then d0 is
called a copy of d. The desired interpretation J is obtained by taking the union of J0 and all I .
Note that every element of J is the copy of an element in IT ,A , and that, by construction, J is a
b
model of A.
It is straightforward to show by induction on the structure of C that for every ELI-concept C
and every element e  J that is a copy of d  IT ,A , e  C J iff d  C IT ,A . Since IT ,A is a
model of T , it follows that J is a model of T and thus Ab is satisfiable w.r.t. T . We only sketch the
proof that J is universal. Let I be a model of Ab and T . We start to define a homomorphism h0 from
b It remains to extend h0 to the I components of
J to I by setting h0 (a) = aI for all a  Ind(A).
J . Each such I is a copy of a tree interpretation Ia in IT ,A such that  is a copy of a. It is shown
in the work of Lutz and Wolter (2012) that4
b is a copy of a  Ind(A), then a  AIT ,A implies T , Ab |= A() for all concept
() if   Ind(A)
names A.
Recall that IT ,A was generated by the derivation rules for building canonical models. Using a
straightforward induction on the number of rule applications and exploiting () and the fact that
T is in normal form, one can construct a homomorphism ha from Ia to I such that h(a) = I .
By renaming, we obtain a homomorphism h from I to I such that h () = I . The desired
homomorphism h is the union of h0 and all h . We have thus established that J is universal. Going
through the construction of J (and in particular using Point (iv)), it can be verified that the match 
of q in IT ,A is also a match of q in J . Since J is universal, this yields certT ,Ab(q) 6=  as desired.
We now want to remove individuals from Ab such that the resulting ABox is of degree at most |T |
and still witnesses non-emptiness of q for  given T . Since J is universal, there is a homomorphism h from J to the canonical model IT ,Ab. Composing the match  with h, we obtain a match 
of q in IT ,Ab that sends every variable to an individual in A0 or to an element of a tree below such an
individual. We inductively mark individuals in Ab that are relevant for the match  , starting with all
individuals in A0 and then proceeding as follows: whenever Rule 2 or 4 adds a marked individual
x to AIT ,Ab during the construction of IT ,Ab because of the presence of (x, y)  rIT ,A (please see
the formulation of the mentioned rules), then mark y. It can be verified that every individual outside
of A0 has at most one marked neighbor for each existential restriction in T . The (potentially infinite) forest-shaped ABox Abd obtained from Ab by dropping all assertions that involve at least one
unmarked individual is thus of degree at most |T |. Moreover, the marking construction ensures that
the canonical model IT ,Abd contains A0 and each interpretation Ia , a  Ind(A0 ), hence  is a match
for q in IT ,Abd .
At this point, the ABox Abd is almost the required forest witness, except that it may be infinite.
It remains to invoke compactness to obtain a finite subset Abf  Abd such that certT ,Abf (q) 6= .
Clearly, Abf contains a forest witness for the non-emptiness of q for  given T .
o
4. Lutz and Wolter (2012) actually show this for the case where the root component A0 of Ab from which we start to
unravel consists of all the individual names in A, but contains no concept and role assertions; the proof also goes
through in our case.

51

fiBAADER , B IENVENU , L UTZ , & W OLTER

The following lemmas establish the two statements in Lemma 34.
Lemma 47 Every canonical proper R  N -labeled tree is well-founded.
Proof. Let hT, `i be a canonical proper R  N -labeled tree, and let I0 , I1 , . . . be the interpretations encountered during the construction of the canonical model of T and AhT,`i . Since hT, `i is
canonical, IhT,`i is the canonical model of AhT,`i and T .
We will slightly abuse terminology by using the term concept atom to refer to statements of the
form B(e) where B is a concept name (or >) and e is a domain element. A role atom will take the
form r(e, e0 ) with r a role and e, e0 domain elements. We will say that a concept atom B(e) (resp.
role atom r(e, e0 )) is in an interpretation J if e  B J (resp. (e, e0 )  rJ ). For each atom  in
IhT,`i , the rank of  is the smallest i such that  is in Ii . We show by induction on the rank that
every concept atom in IhT,`i has a derivation, thus hT, `i is well-founded.
The induction start is straightforward as concept atoms in I0 involve a concept from   {>}
and an element x such that either x  Ind(A) with A = `() or x  T \ {} with M  `(x), and
every such atom has a derivation of depth 0. For the induction step, let B(x) be a concept atom in
Ii+1 \ Ii . We consider the rule application that resulted in the addition of B(x):
1. Assume that B(x) is in Ii+1 because of an application of Rule 1, that is, A1 u    u An v
B  T and x  AIj i for 1  j  n.
For every 1  j  n, the atom Aj (x) has rank at most i, so by the IH, there is a derivation
hTj0 , `0j i of Aj at x. We obtain a derivation hT 0 , `0 i of B at x by setting T 0 = {}  {jw | w 
Tj0 }, `0 () = (B, x), and `0 (jw) = `0j (w).
2. Assume that B(x) is in Ii+1 because of an application of Rule 2, that is, there is r.A v B 
T such that x  (r.A)Ii .
As x  (r.A)Ii , there must exist some y  Ii such that (x, y)  rIi and y  AIi .
The atom A(y) has rank at most i, so by the IH, there is a derivation hT 00 , `00 i of A at y. If
x  I0 , then x  Ind(AhT,`i ), and so we can define a derivation hT 0 , `0 i of B at x by setting
T 0 = {}  {1w | w  T 00 }, `0 () = (B, x), and `0 (1w) = `00 (w).
Next consider the case in which x 6 I0 . Then x 6 Ind(AhT,`i ), so by properness of T , there
is a concept E  NC  {>} such that E   `(x). Since x 6 I0 but x 6 Ii , there is some
0 < j < i such that x  Ij \ Ij1 . Since hT, `i is canonical, the element x was created
due to an application of Rule 3 using a concept inclusion of the form F v s.E, so x  E Ij .
Applying the IH, we obtain a derivation hT 000 , `000 i of E at x. We can thus define a derivation
hT 0 , `0 i of B at x by setting T 0 = {}  {1w | w  T 00 }  {2w | w  T 000 }, `0 () = (B, x),
`0 (1w) = `00 (w), and `0 (2w) = `000 (w).
3. Assume that B(x) is in Ii+1 because of an application of Rule 3 involving A v r.B  T ,
that is, there is some y  Ii such that y  AIi and (y, x)  rIi+1 \ rIi .
The atom A(y) has rank at most i, so by the IH, there exists a derivation hT 00 , `00 i of A at y.
Moreover, since x was created by applying the inclusion A v r.B  T to y, the second
condition of canonicity ensures that B   `(x). We can thus define a derivation of B at x by
taking the tree hT 0 , `0 i with T 0 = {}  {1w | w  T 00 }, `0 () = (B, x), and `0 (1w) = `00 (w).
52

fiQ UERY AND P REDICATE E MPTINESS

4. Assume that B(x) = >(x) is in Ii+1 because of an application of Rule 3 involving A v
r.E  T (E 6= >), that is, there is some y  Ii such that y  AIi and (y, x)  rIi+1 \ rIi .
The atom A(y) has rank at most i, so by the IH, there exists a derivation hT 00 , `00 i of A at y.
Moreover, since x was created by applying the inclusion A v r.E  T to y, the second
condition of canonicity ensures that E   `(x). We can thus define a derivation of > at x by
taking the tree hT 0 , `0 i with T 0 = {, 1}  {11w | w  T 00 }, `0 () = (>, x), `0 (1) = (E, x),
and `0 (11w) = `00 (w).
5. Assume that B(x) is in Ii+1 because of an application of Rule 4, that is, A v r.B  T ,
funct(r)  T , y  AIi , and (y, x)  rIi .
The atom A(y) has rank at most i, so by the IH, there exists a derivation hT 00 , `00 i of A at y. If
x  I0 , we obtain a derivation of B at x by taking the tree hT 0 , `0 i with T 0 = {}  {1w |
w  T 00 }, `0 () = (B, x), and `0 (1w) = `00 (w). If If x 6 I0 , then we can use the same
argument as in Point 2 to find a derivation hT 000 , `000 i of E at x. We then obtain a derivation
hT 0 , `0 i of B at x by setting T 0 = {}  {1w | w  T 00 }  {2w | w  T 000 }, `0 () = (B, x),
`0 (1w) = `00 (w), and `0 (2w) = `000 (w).
o
Lemma 48 Let hT, `i be a proper R  N -labeled tree that is well-founded and such that IhT,`i
is a model of T . Then IhT,`i is a universal model of T and AhT,`i .
Proof. Assume that hT, `i is well-founded proper R  N -labeled tree and that IhT,`i is a model
of T . An obligation is a pair (A, x) such that x  T and A  `(x). For every obligation
(A, x), choose a derivation hTA,x , `A,x i of A at x in hT, `i that is of minimal depth. For obligations (A1 , x1 ),(A2 , x2 ), we write (A1 , x1 )  (A2 , x2 ) if (A1 , x1 ) occurs as a node label in
hTA2 ,x2 , `A2 ,x2 i.
Claim. The  relation is acyclic.
Proof of claim. Assume to the contrary that there are obligations (A0 , x0 ), . . . , (An , xn ) such that
(Ai , xi )  (Ai+1 , xi+1 ) for all i  n and (An+1 , xn+1 ) := (A0 , x0 ). We may assume without loss of generality that for all 0  i < j  n, (Ai , xi ) 6= (Aj , xj ), i.e., the obligations
(A0 , x0 ), . . . , (An , xn ) are pairwise distinct. Let ki be the depth of hTAi ,xi , `Ai ,xi i and `i the
depth of the most shallow derivation of (Ai , xi ) contained in hTAi+1 ,xi+1 , `Ai+1 ,xi+1 i. Because
hTAi ,xi , `Ai ,xi i is of minimal depth, we have ki  `i . Moreover, we clearly also have `i  ki+1 .
We thus have shown that k0 = `0 =    = kn = `n . Consequently, the derivation of (A0 , x0 )
in hTA1 ,x1 , `A1 ,x1 i must start at the root of hTAi ,xi , `Ai ,xi i, which implies (A0 , x0 ) = (A1 , x1 ) in
contradiction to the fact that these obligations are distinct. This finishes the proof of the claim.
By the claim, we can assume w.l.o.g. that if in some chosen derivation hTA,x , `A,x i, a node is
labeled with (B, y), then the subtree of hTA,x , `A,x i rooted at this node is the chosen derivation
hTB,y , `B,y i (uniformity assumption).
To prove that IhT,`i is a universal model of T and AhT,`i , take a model I of AhT,`i and T . We
show that there is a homomorphism h from IhT,`i to I, constructing h in a step-by-step fashion. To
start, set h(a) = aI for all individual names a that occur in AhT,`i . Now and after each extension
of h, we argue that
53

fiBAADER , B IENVENU , L UTZ , & W OLTER

1. if x  AIhT,`i with A a concept name, h(x) is defined and hTA,x , `A,x i uses only elements
from the domain of h, then h(x)  AI ;
2. if (x, y)  rIhT,`i with r a role and h(x), h(y) are defined, then (h(x), h(y))  rI ;
3. if (x, y)  rIhT,`i , y is a child of x in T , and h(y) is defined, then h(x) is also defined.
We start by observing that for the initial mapping h, Point 2 is trivial since I is a model of AhT,`i
and all role edges in the restriction of IhT,`i to the domain of h are from AhT,`i . For Point 3, we use
the fact that if y is an individual in AhT,`i and x is the parent of y in T , then properness of T implies
that x is also an individual in AhT,`i (and hence x belongs to the domain of h).
Point 1 is proved by induction on the depth of hTA,x , `A,x i. For the induction start, consider
depth zero. Then A    {>}, x  Ind(AhT,`i ), and A(x)  AhT,`i . Since I is a model of AhT,`i
and by definition of h, we have h(x)  AI .
Now for the induction step. Assume that hTA,x , `A,x i uses only elements from the domain of h.
The definition of derivations gives rise to the following cases:
 A 6 `(x), and there is a CI A1 u    u An v A  T such that for 1  i  n, there is a child
z 0 of z in TA,x with `A,x (z 0 ) = (Ai , x).
For 1  i  n, let zi be the child of z with `A,x (zi ) = (Ai , x). Then the subderivation
of hTA,x , `A,x i rooted at zi is the chosen derivation hTAi ,x , `Ai ,x i of Ai at x. It follows that
hTAi ,x , `Ai ,x i only uses elements from the domain of h and its depth is strictly smaller than
that of hTA,x , `A,x i. We can therefore apply the induction hypothesis to get h(x)  AIi . Since
I is a model of T and A1 u    u An v A  T , we obtain h(x)  AI .
 A 6 `(x), there is a CI r.A0 v A  T and a child z 0 of z in TA,x with `A,x (z 0 ) = (A0 , x0 )
such that (x, x0 )  rIhT,`i .
The subderivation of hTA,x , `A,x i rooted at z 0 is the chosen derivation hTA0 ,x0 , `A0 ,x0 i of A0 at
x0 , and thus it contains only elements from the domain of h and has a strictly smaller depth
than hTA,x , `A,x i. We can thus use the IH to infer that h(x0 )  B I , and we can use Point 2 to
get (h(x), h(x0 ))  rI . Since I is a model of T and r.A0 v A  T , we have h(x)  AI .
 A 6 `(x), there is a CI A0 v r.A  T with funct(r)  T and a child z 0 of z in TA,x with
`A,x (z 0 ) = (A0 , x0 ) such that (x0 , x)  rIhT,`i .
As in the previous item, we can use the IH and Point 2 to get h(x0 )  B I and (h(x), h(x0 )) 
rI . Since I is a model of T and T contains both A0 v r.A and funct(r), it follows that
h(x)  AI .
 A = >, > 
/ `(x), B   `(x),and there is a child z of  in TA,x with `A,x (z) = (B, x).
This case is not applicable since if B   `(x), then M 6 `(x), hence x is not in the domain
of h.
 A  `(x), there is a CI A0 v r.A  T , and there is a child z 0 of z in TA,x with `A,x (z 0 ) =
(A0 , x0 ) such that (x0 , x)  rIhT,`i and either (i) x is a child of x0 in T , or (ii) x is a child of
the root, x0  Ind, and {r, x0 }  `(x).
This case is not applicable since if A  `(x), then M 6 `(x), hence x is not in the domain
of h.
54

fiQ UERY AND P REDICATE E MPTINESS

To extend h, we first show that if h is not yet total, then there exists an edge (b
x, yb)  rIhT,`i

and a concept name A such that h(b
x) is defined, h(b
y ) is undefined, A  `(b
y ) (and consequently
A  `(b
y )), and hTA,by , `A,by i is such that all elements in it except the root node are in the domain
of h.
Assume to the contrary that h is not total but there is no such edge, i.e., for every edge (b
x, yb) 
rIhT,`i such that h(b
x) is defined, h(b
y ) is undefined, and A  `(b
y ), the derivation hTA,by , `A,by i
contains a non-root node that is not in the domain of h. Pick one such edge (b
x, yb)  rIhT,`i such
that its associated derivation hTA,by , `A,by i is of minimal depth. Since h(b
x) is defined and h(b
y ) is
undefined, it follows from Point 3 that either x
b is the parent of yb in T , or yb is a child of the root node
and {b
x, r}  `(b
y ). Since derivation rule 6 is the only applicable rule when the node label contains

A and by the formulation of that rule, there must thus be a CI A0 v r.A  T such that the unique
child z of  in TA,by satisfies `A,by (z) = (A0 , x
b). Since x
b is in the domain of h, the non-root node that
is not in the domain of h must be somewhere below z. Consequently, we find nodes z1 , z2  TA,by
such that z2 is a successor of z1 and the domain element x
b0 in `A,by (z1 ) is in the domain of h, but
0
the domain element yb in `A,by (z2 ) is not in the domain of h. By definition of the derivation rules,
we must have (b
x0 , yb0 )  sIhT,`i for some role s, and by Point 3, either yb0 is a child of x
b0 in T , or yb0
0
0
is a child of the root node and its label contains {b
x , s}. It follows that x
b is related to yb0 by one of
the derivation rules 4 and 5. Consequently, there is a B   `(b
y 0 ) such that hTA,by , `A,by i contains the
IhT,`i
0
0
0
obligation (B, yb ). Thus, the edge (b
x , yb )  s
satisfies the above conditions and its associated
derivation hTB,by0 , `B,by0 i is of strictly smaller depth than hTA,by , `A,by i, contradicting the minimality
of hTA,by , `A,by i.
We now extend h using the edge (b
x, yb)  rIhT,`i whose existence we have just established.
By the definition of derivations, there is a CI A0 v r.A  T and a child z of  in TA,by with
`A,by (z) = (A0 , x
b). Since all elements in hTA,by , `A,by i except the root node are in the domain of h,
the subderivation of hTA,by , `A,by i rooted at z uses only elements from the domain of h. By our
uniformity assumption, this derivation is just hTA0 ,bx , `A0 ,bx i, and thus IH yields h(b
x)  A0 IhT,`i .
IhT,`i
IhT,`i
0
Since A v r.A  T , there is a (b
x, d)  r
with d  A
. Set h(b
y ) = d.
It remains to show that Points 1 and 2 are satisfied for the extended h (Point 3 obviously is).
We start with Point 2. Assume that (x, y)  sIhT,`i . If h(x) and h(y) were defined already before
the extension of h, we are done. Otherwise, by construction of h we must have (x, y, s) = (b
x, yb, r)
(or (x, y, s) = (b
y, x
b, r ), which is equivalent). By the choice of h(b
y ), we have (h(b
x), h(b
y ))  rI ,
hence (x, y)  sI . Point 1 is proved by induction on the depth of A(x) as for the initial version
of h. The induction start is exactly the same, and for the induction step, the only cases that differ
are the following ones:
 A 
/ `(x), B   `(x), A = >, and there is a child z of  in TA,x with `A,x (z) = (B, x).
Immediate since A = >.
 A  `(x), there is a CI A0 v r.A  T , and there is a child z 0 of z in TA,x with `A,x (z 0 ) =
(A0 , x0 ) such that (x0 , x)  rIhT,`i and either (i) x is a child of x0 in T , or (ii) x is a child of
the root, x0  Ind, and {r, x0 }  `(x).
Since A  `(x), we have x 6 Ind(AhT,`i ), so x must have been introduced into the domain
of h during the examination of edge (x0 , x)  rIhT,`i . Since the child z 0 is labeled (A0 , x0 ),
we will use the CI A0 v r.A  T and choose h(x) such that h(x)  AIhT,`i .
o
55

fiBAADER , B IENVENU , L UTZ , & W OLTER

References
Artale, A., Calvanese, D., Kontchakov, R., & Zakharyaschev, M. (2009). The DL-Lite family and
relations. Journal of Artifical Intelligence Research (JAIR), 36, 169.
Baader, F., Bienvenu, M., Lutz, C., & Wolter, F. (2010). Query and predicate emptiness in description logics. In Proceedings of the 12th International Conference on Principles of Knowledge
Representation and Reasoning (KR).
Baader, F., Brandt, S., & Lutz, C. (2005). Pushing the EL envelope. In Proceedings of the 19th
International Joint Conference on Artificial Intelligence (IJCAI), pp. 364369.
Baader, F., Brandt, S., & Lutz, C. (2008). Pushing the EL envelope further. In Proceedings of the
Workshop on OWL: Experiences and Directions (OWLED).
Benedikt, M., Fan, W., & Geerts, F. (2008). XPath satisfiability in the presence of DTDs. Journal
of the ACM, 55(2), 179.
Bienvenu, M., Hansen, P., Lutz, C., & Wolter, F. (2016). First-order rewritability of conjunctive
queries in Horn description logics. In Proceedings of the 25th International Joint Conference
on Artificial Intelligence (IJCAI).
Bienvenu, M., Lutz, C., & Wolter, F. (2012). Query containment in description logics reconsidered.
In Proceedings of the 13th International Conference on Principles of Knowledge Representation and Reasoning (KR).
Bienvenu, M., ten Cate, B., Lutz, C., & Wolter, F. (2014). Ontology-based data access: A study
through disjunctive datalog, CSP, and MMSNP. ACM Transactions on Database System
(TODS), 39(4), 33.
Botoeva, E., Kontchakov, R., Ryzhikov, V., Wolter, F., & Zakharyaschev, M. (2014). Query inseparability for description logic knowledge bases. In Proceedings of the 14th International
Conference in the Principles of Knowledge Representation and Reasoning (KR).
Botoeva, E., Kontchakov, R., Ryzhikov, V., Wolter, F., & Zakharyaschev, M. (2016). Games for
query inseparability of description logic knowledge bases. Artificial Intelligence Journal
(AIJ), 234, 78119.
Bourhis, P., & Lutz, C. (2016). Containment in monadic disjunctive datalog, mmsnp, and expressive
description logics. In Proceedings of the 15th International Conference on Principles of
Knowledge Representation and Reasoning (KR).
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., Poggi, A., Rodriguez-Muro, M., &
Rosati, R. (2009). Ontologies and databases: The DL-Lite approach. In Tutorial Lectures of
the 5th International Reasoning Web Summer School, Vol. 5689 of Lecture Notes in Computer
Science, pp. 255356. Springer.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2007). Tractable reasoning
and efficient query answering in description logics: The DL-Lite family. Journal of Automated
Reasoning (JAR), 39(3), 385429.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2013). Data complexity
of query answering in description logics. Artificial Intelligence Journal (AIJ), 195, 335360.
56

fiQ UERY AND P REDICATE E MPTINESS

Calvanese, D., De Giacomo, G., & Lenzerini, M. (1998). On the decidability of query containment
under constraints. In Proceedings of the 17th ACM SIGACT-SIGMOD-SIGART Symposium
on Principles of Database Systems (PODS), pp. 149158.
Calvanese, D., Ortiz, M., Simkus, M., & Stefanoni, G. (2013). Reasoning about explanations for
negative query answers in DL-Lite. Journal of Artificial Intelligence Research (JAIR), 48,
635669.
Chortaras, A., Trivela, D., & Stamou, G. B. (2011). Optimized query rewriting for OWL 2 QL.
In Proceedings of the 23rd International Conference on Automated Deduction (CADE), pp.
192206.
Eiter, T., Gottlob, G., Ortiz, M., & Simkus, M. (2008). Query answering in the description logic
Horn-SHIQ. In Proceedings of the 11th European Conference on Logics in Artificial Intelligence (JELIA), pp. 166179.
Eiter, T., Ortiz, M., Simkus, M., Tran, T., & Xiao, G. (2012). Query rewriting for Horn-SHIQ plus
rules. In Proceedings of the 26th AAAI Conference on Artificial Intelligence (AAAI).
Gabbay, D., Kurucz, A., Wolter, F., & Zakharyaschev, M. (2003). Many-Dimensional Modal Logics:
Theory and Applications. Elsevier.
Gatens, W., Konev, B., & Wolter, F. (2014). Lower and upper approximations for depleting modules
of description logic ontologies. In Proceedings of the 21st European Conference on Artificial
Intelligence (ECAI), pp. 345350.
Gene Ontology Consortium (2016). The gene ontology. http://geneontology.org/. [Online; accessed
16-April-2016].
Glimm, B., Lutz, C., Horrocks, I., & Sattler, U. (2008). Answering conjunctive queries in the
SHIQ description logic. Journal of Artificial Intelligence Research (JAIR), 31, 150197.
Golbeck, J., Fragoso, G., Hartel, F., Hendler, J., Oberthaler, J., & Parsia, B. (2003). The national
cancer institutes thesaurus and ontology. Journal of Web Semantics: Science, Services and
Agents on the World Wide Web, 1(1), 7580.
Grau, B. C., Horrocks, I., Kazakov, Y., & Sattler, U. (2008). Modular reuse of ontologies: Theory
and practice. Journal of Artifical Intelligence Research (JAIR), 31, 273318.
Haase, C. (2007). Complexity of subsumption in extensions of EL. Masters thesis, Dresden University of Technology.
HITRL (2016). Health Information Technologies Research Laboratory. University of Sydney.
http://sydney.edu.au/engineering/it/hitru. [Online; accessed 16-April-2016].
Horrocks, I., Kutz, O., & Sattler, U. (2006). The even more irresistible SROIQ. In Proceedings of
the 10th International Conference on Principles of Knowledge Representation and Reasoning
(KR), pp. 5767.
Hustadt, U., Motik, B., & Sattler, U. (2004). A decomposition rule for decision procedures by
resolution-based calculi. In Proceedings of the 11th International Conference on Logic for
Programming Artificial Intelligence and Reasoning (LPAR), pp. 2135.
Hustadt, U., Motik, B., & Sattler, U. (2007). Reasoning in description logics by a reduction to
disjunctive datalog. Journal of Automated Reasoning (JAR), 39(3), 351384.
57

fiBAADER , B IENVENU , L UTZ , & W OLTER

IHTSDO (2016). SNOMED CT: The global language of healthcare. http://www.ihtsdo.org/snomedct. [Online; accessed 16-April-2016].
Kaminski, M., Schneider, T., & Smolka, G. (2011). Correctness and worst-case optimality of Prattstyle decision procedures for modal and hybrid logics. In Proceedings of the 20th International Conference on Automated Reasoning with Analytic Tableaux and Related Methods
(TABLEAUX), pp. 196210.
Kazakov, Y. (2009). Consequence-driven reasoning for Horn-SHIQ ontologies. In Proceedings of
the 21st International Joint Conference on Artificial Intelligence (IJCAI), pp. 20402045.
Kazakov, Y. (2010). An extension of complex role inclusion axioms in the description logic
SROIQ. In Proceedings of the 5th International Joint Conference on Automated Reasoning
(IJCAR), pp. 472486.
Konev, B., Ludwig, M., Walther, D., & Wolter, F. (2012). The logical difference for the lightweight
description logic EL. Journal of Artificial Intelligence Research (JAIR), 44, 633708.
Konev, B., Lutz, C., Walther, D., & Wolter, F. (2013). Model-theoretic inseparability and modularity
of description logic ontologies. Artificial Intelligence Journal (AIJ), 203, 66103.
Kontchakov, R., Rodriguez-Muro, M., & Zakharyaschev, M. (2013). Ontology-based data access
with databases: A short course. In Proceedings of the International Reasoning Web Summer
School, pp. 194229.
Kontchakov, R., Wolter, F., & Zakharyaschev, M. (2010). Logic-based ontology comparison and
module extraction, with an application to DL-Lite. Artificial Intelligence, 174(15), 1093
1141.
Krotzsch, M. (2012). OWL 2 profiles: An introduction to lightweight ontology languages. In Tutorial Lectures of the 8th International Reasoning Web Summer School, Vol. 7487 of Lecture
Notes in Computer Science, pp. 112183. Springer.
Krotzsch, M., Rudolph, S., & Hitzler, P. (2007). Complexity boundaries for Horn description logics.
In Proceedings of the 22nd AAAI Conference on Artificial Intelligence (AAAI), pp. 452457.
Levy, A. (1993). Irrelevance Reasoning in Knowledge Based Systems. Ph.D. thesis, Stanford University.
Lubyte, L., & Tessaris, S. (2008). Supporting the design of ontologies for data access. In Proceedings of the 21st International Description Logic Workshop (DL).
Lutz, C. (2008). The complexity of CQ answering in expressive description logics. In Proceedings
of the 4th International Joint Conference on Automated Reasoning (IJCAR), pp. 179193.
Lutz, C., Toman, D., & Wolter, F. (2009). Conjunctive query answering in the description logic EL
using a relational database system. In Proceedings of the 21st International Joint Conference
on Artificial Intelligence (IJCAI), pp. 20702075.
Lutz, C., & Wolter, F. (2010). Deciding inseparability and conservative extensions in the description
logic EL. Journal of Symbolic Computation, 45(2), 194228.
Lutz, C., & Wolter, F. (2012). Non-uniform data complexity of query answering in description
logics. In Proceedings of the 13th International Conference on Principles of Knowledge
Representation and Reasoning (KR).
58

fiQ UERY AND P REDICATE E MPTINESS

Motik, B., Grau, B. C., Horrocks, I., Wu, Z., Fokoue, A., & Lutz, C. (2009). OWL 2 Web Ontology Language: Profiles. W3C Recommendation. Available at http://www.w3.org/TR/owl2profiles/.
Ortiz, M., Calvanese, D., & Eiter, T. (2008). Data complexity of query answering in expressive
description logics via tableaux. Journal of Automated Reasoning (JAR), 41(1), 6198.
Ortiz, M., & Simkus, M. (2012). Reasoning and query answering in description logics. In Proceedings of the 8th International Reasoning Web Summer School, Vol. 7487 of Lecture Notes in
Computer Science, pp. 153. Springer.
Ortiz, M., Simkus, M., & Eiter, T. (2008). Worst-case optimal conjunctive query answering for an
expressive description logic without inverses. In Proceedings of the 23rd AAAI Conference
on Artificial Intelligence (AAAI), pp. 504510.
Patel, C., Cimino, J. J., Dolby, J., Fokoue, A., Kalyanpur, A., Kershenbaum, A., Ma, L., Schonberg,
E., & Srinivas, K. (2007). Matching patient records to clinical trials using ontologies. In
Proceedings of the 6th International Semantic Web Conference (ISWC), pp. 816829.
Perez-Urbina, H., Motik, B., & Horrocks, I. (2009). A comparison of query rewriting techniques
for dl-lite. In Proceedings of the 22nd International Description Logic Workshop (DL).
Poggi, A., Lembo, D., Calvanese, D., De Giacomo, G., Lenzerini, M., & Rosati, R. (2008). Linking
data to ontologies. Journal of Data Semantics, 10, 133173.
Pratt, V. R. (1979). Models of program logics. In Proceedings of IEEE Annual Symposium on
Foundations of Computer Science (FOCS), pp. 115122.
Romero, A. A., Kaminski, M., Grau, B. C., & Horrocks, I. (2015). Ontology module extraction
via datalog reasoning. In Proceedings of the 29th AAAI Conference on Artificial Intelligence
(AAAI), pp. 14101416.
Tobies, S. (2001). Complexity Results and Practical Algorithms for Logics in Knowledge Representation. Ph.D. thesis, RWTH Aachen.
Vardi, M. Y. (1989). Automata theory for database theoreticans. In Proceedings of the 7th ACM
SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems (PODS), pp. 83
92.
Vardi, M. Y. (1998). Reasoning about the past with two-way automata. In Proceedings of the 25th
International Colloquium on Automata, Languages and Programming (ICALP), pp. 628641.

59

fi