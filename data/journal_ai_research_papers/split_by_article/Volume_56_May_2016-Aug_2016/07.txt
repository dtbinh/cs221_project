Journal of Artificial Intelligence Research 56 (2016) 429-461

Submitted 02/16; published 07/16

Efficient Mechanism Design for Online Scheduling
Xujin Chen
Xiaodong Hu

xchen@amss.ac.cn
xdhu@amss.ac.cn

AMSS, Chinese Academy of Science, Beijing, China

Tie-Yan Liu
Weidong Ma
Tao Qin

tyliu@microsoft.com
weima@microsoft.com
taoqin@microsoft.com

Microsoft Research, Beijing, China

Pingzhong Tang

kenshin@mail.tsinghua.edu.cn

Tsinghua University, Beijing, China

Changjun Wang

wcj@amss.ac.cn

Beijing University of Technology, Beijing, China

Bo Zheng

zhengb10@mails.tsinghua.edu.cn

Tsinghua University, Beijing, China

Abstract
This paper concerns the mechanism design for online scheduling in a strategic setting.
In this setting, each job is owned by a self-interested agent who may misreport the release
time, deadline, length, and value of her job, while we need to determine not only the
schedule of the jobs, but also the payment of each agent. We focus on the design of
incentive compatible (IC) mechanisms, and study the maximization of social welfare (i.e.,
the aggregated value of completed jobs) by competitive analysis. We first derive two lower
bounds on the competitive ratio of any deterministic IC mechanism to characterize the
landscape of our research: one bound is 5, which holds for equal-length jobs; the other
bound is ln + 1  o(1), which holds for unequal-length jobs, where  is the maximum ratio
between lengths of any two jobs. We then propose a deterministic IC mechanism and show
that such a simple mechanism works very well for two models: (1) In the preemption-restart
model, the mechanism can achieve the optimal competitive ratio of 5 for equal-length jobs
1

and a near optimal ratio of ( (1)
2 + o(1)) ln  for unequal-length jobs, where 0 <  < 1
is a small constant; (2) In the preemption-resume model, the mechanism can achieve the
optimal competitive ratio of 5 for equal-length jobs and a near optimal competitive ratio
(within factor 2) for unequal-length jobs.

1. Introduction
Online scheduling has been widely studied in the literature (Baruah, Koren, Mao, Mishra,
Raghunathan, Rosier, Shasha, & Wang, 1992; Baruah, Haritsa, & Sharma, 1994; Porter,
2004; Zheng, Fung, Chan, Chin, Poon, & Wong, 2006; Ting, 2008), where each job is characterized by a release time, a deadline, a length, and a value for its successful completion
by the deadline. Inspired by emerging areas like computational economics and cloud computing, we consider a strategic setting of the online scheduling problem, where each job is
owned by a self-interested agent and she may have the incentive to manipulate the schedulc
2016
AI Access Foundation. All rights reserved.

fiChen, Hu, Liu, Ma, Qin, Tang, Wang & Zheng

ing algorithm in order to be better off. To be specific, the agent may deliberately delay the
release time of her job, inflate its length, and misreport its value and deadline.
Given this situation, a carefully designed online scheduling mechanism is needed to
regulate the strategic behaviors of the agents and to (approximately) optimize some system
objectives. In this work, we focus on the maximization of social welfare, i.e., the total
value of completed jobs.1 We use competitive analysis (Lavi & Nisan, 2004) to evaluate
the performance of such a mechanism, which compares the social welfare implemented by
the mechanism (without any knowledge of all future jobs) with that of the optimal offline
allocation (with the knowledge of future jobs).
In this work, we consider two scheduling models: the preemption-restart model (Ting,
2008) and the preemption-resume model (Porter, 2004). Once preempted, jobs in the first
model have to restart from the beginning; while jobs in the second model can resume from
the break point. Since preemption is always assumed in this work, the two models are also
referred to as restart model and resume model, respectively, and their involved jobs are
called non-resumable and resumable, respectively.
1.1 Problem Formulation
We consider online scheduling models with infinite time period T = R0 . Suppose there
is a single machine that processes at most one job at any given time. Jobs come over
time, and we use J to denote the set of jobs. Each job j  J is owned by a self-interested
agent (which is also denoted as j for simplicity); and it is characterized by a private type
j = (rj , dj , lj , vj )  T  T  R>0  R>0 , where rj is the release time2 , dj is the deadline,
lj is the length (i.e., the processing time), and vj is the value if the job is completed by its
deadline.
A resumable job j is completed if and only if it is processed for lj time units in total
between its release time rj and deadline dj , while a non-resumable job j is completed if and
only if it is processed for lj consecutive time units between its release time rj and deadline
dj .
Let  = maxi,jJ llji be the maximum ratio between the lengths of any two jobs. For
simplicity, we assume all job lengths are normalized, i.e., lj  [1, ] for all j  J, and assume
 is known in advance following the practice in the work of Chan et al. (2004) and Ting
(2008).
We study direct revelation mechanisms, in which each agent participates by simply
declaring the type of her job j = (rj , dj , lj , vj ) at time rj . We use  to denote the profile
of reported types of all the agents. Given the declared types of the agents, a mechanism
M is used to schedule/allocate the jobs and determine the payment of each agent. Here we
only consider reasonable mechanisms which (1) do not schedule a job after its reported
deadline and (2) do not schedule a job once it has been processed for a reported length.
Given a certain mechanism M and a job sequence , we use qj (, t) to denote whether
job j is completed by time t (if it is completed, qj (, t) = 1; otherwise qj (, t) = 0). Then
1. It is also referred as weighted throughput in the scheduling literature.
2. Note that release time is also referred as arrival time in the online auction literature (Parkes, 2007). It
is the earliest time at which the agent has full knowledge of her job. Thus it is the earliest time the job
is available to the scheduling process.

430

fiEfficient Mechanism Design for Online Scheduling

the value that agent j extracts from the mechanism can be represented by qj (, dj )vj , and
P
the social welfare of the mechanism can be represented by W (M, ) = j qj (, dj )vj .
Let pj () denote the amount of money that the mechanism charges agent j. We assume that agents have quasi-linear preferences (Nisan, 2007), i.e., the utility of agent j is
uj (, j ) = qj (, dj )vj  pj ().
Since agents are self-interested, they may misreport their types in a strategic way. It is
easy to see that the misreport of a shorter length is a dominated strategy; otherwise, her
job cannot be completed even if it is scheduled by the mechanism (since lj < lj ). Therefore,
the agents will not underreport the lengths of their jobs. Similar to the work of Porter
(2004), we assume that the system will not return a completed job to agent j until dj .3 In
this way, we restrict the agents report to be dj  dj . In addition, we assume that no agent
has knowledge about her job before its release time, so we also have rj  rj .
Considering the potential misreport of the agents, we are concerned with incentive
compatible and individually rational mechanisms. A mechanism is incentive compatible
(IC) if, for any agent j, regardless of the behaviors of other agents, truthful reporting
her own type maximizes her utility. A mechanism is individually rational (IR) if for each
job j, truthful reporting leads to a non-negative utility. In addition, we would also like the
mechanism to (approximately) maximize social welfare. We say a mechanism M is (strictly)
c-competitive if there does not exist any job sequence  such that c  W (M, ) < W (opt, ),
where opt denotes the optimal offline mechanism4 . Sometimes we also say that M has a
competitive ratio of c.
1.2 Related Work
The online scheduling problem has been studied in both the non-strategic setting (Lipton &
Tomkins, 1994; Borodin & El-Yaniv, 1998; Bar-Noy, Guha, Naor, & Schieber, 2001; Zheng
et al., 2006; Kolen, Lenstra, Papadimitriou, & Spieksma, 2007; Ting, 2008; Nguyen, 2011)
(whose focus is algorithm design) and the strategic setting (Nisan & Ronen, 2001; Lavi &
Nisan, 2004; Friedman & Parkes, 2003; Porter, 2004; Hajiaghayi, Kleinberg, Mahdian, &
Parkes, 2005; Parkes, 2007) (whose focus is mechanism design).
Non-strategic setting. For the case of  = 1, a lower bound of 4 on the competitive
ratio of any deterministic algorithm is given by Woeginger (1994). A 4.56-competitive
deterministic algorithm is constructed by Zheng et al. (2006) for the restart model, and
a 4.24-competitive deterministic algorithm is designed by Kim (2011) for both restart and
resume models. A 2-competitive randomized algorithm is introduced for restart model in
the work of Fung et al. (2014), and a lower bound of 1.693 is provided in the work of Epstein
and Levin (2010). By restricting release time and deadlines to be integers, a randomized
e
algorithm with competitive ratio e1
 1.582 is proposed by Chin et al. (2006), and a

deterministic algorithm with competitive ratio 2 2  1  1.828 is proposed by Englert et
3. Actually, it should be viewed as a decision by the mechanism designer rather than an assumption.
This decision is crucial to ensure the incentive compatibility which we will see later.
4. Since we only care about the social welfare performance of opt in the competitive analysis, which only
depends on the schedule, regardless of the payments, we also call opt as optimal offline allocation, or
simply optimal allocation.

431

fiChen, Hu, Liu, Ma, Qin, Tang, Wang & Zheng

al. (2012). The best lower bounds currently are 1.25 for randomized algorithms (Chin &
Fung, 2003) and 1.618 for deterministic algorithms (Hajek, 2001).

For general values of , a lower bound of  on the competitive ratio of any deterministic
algorithm is derived in the work of Chan et al. (2004). The lower bound is improved to

6
5/6 )
2 ln   1 by Ting and Fung (2008), and an algorithm with competitive ratio log  + O(
is given for the restart model. The scheduling problem with discrete time is considered in
the work of Durr, Jez and Nguyen (2012). In particular, the lower bound is improved to


model. A
ln   o(1), and a (3 + o(1)) ln  -competitive algorithm is designed for the resume q
randomized algorithm with competitive ratio O(log()) and a lower bound of ( logloglog  )
is provided by Canetti and Irani (1998).
Assuming the maximum ratio between the value densities (value divided by length) of

any two jobs is bounded above by a known number , a (1 + )2 -competitive algorithm is

given by Koren and Shasha (1995). The bound (1 + )2 is optimal as a matching lower
bound is given by Baruah et al. (1992).
There is also a rich literature concerned with non-preemptive scheduling (Lipton &
Tomkins, 1994; Goldman, Parwatikar, & Suri, 2000; Goldwasser, 2003; Ding & Zhang,
2006; Ding, Ebenlendr, Sgall, & Zhang, 2007; Ebenlendr & Sgall, 2009). However, it can
be easily verified that an algorithm with bounded competitive ratio cannot be designed in
the setting of unrestricted values and arbitrary release time. Therefore, the most common
assumption added in the non-preemptive scheduling problem is proportional values, i.e., the
value of each job is proportional to the length. In the work of Goldman et al. (2000), a
tight upper and lower bound of 2 are given for the deterministic competitiveness when all
jobs have equal length (thus, equal value), and a 6(blog2 c + 1)-competitive randomized
algorithm is provided for general value of , matching the (log ) lower bound (Lipton &
Tomkins, 1994) within a constant factor.
Strategic setting. In the work of Lavi and Nisan (2015), by assuming integer time
points, a scheduling problem for the  = 1 case is studied. The authors show that there
is no incentive compatible mechanism which can obtain a constant competitive ratio, if
the payment must be made when the job is completed. Hence, they propose a family of
semi-myopic algorithms with competitive ratio 3, under the assumption of semi-myopic
strategies. In the work of Hajiaghayi et al. (2005), a specific scheduling problem in which
 = 1 is considered under the restart model. A deterministic IC mechanism with competitive
ratio 5 is designed, and a lower bound of 2 is given to any deterministic IC mechanism.
However, to our knowledge, the case  > 1 in either the restart model or the resume model
has not been studied from the perspective of mechanism design (considering the incentive
issues). Our work fills this gap.
Assuming the maximum ratio between the value densities (value divided by length) of
any two jobs is bounded above by a known number , an IC mechanism with a competitive


ratio of (1 + )2 + 1 is designed by Porter (2004), and it is proved that (1 + )2 + 1 is a
lower bound of the competitive ratio for any deterministic mechanism.
Recently, online scheduling mechanisms have been investigated in cloud computing (Zaman & Grosu, 2012; Azar, Ben-Aroya, Devanur, & Jain, 2013; Zhang, Li, Jiang, Liu,
Vasilakos, & Liu, 2013; Lucier, Menache, Naor, & Yaniv, 2013; Mashayekhy, Nejad, Grosu,
& Vasilakos, 2014; Wu, Gu, Li, Tao, Chen, & Ma, 2014). In these works, mechanisms are
432

fiEfficient Mechanism Design for Online Scheduling

designed to allocate computational resources to users, and users can use those virtual machines during the entire period requested. In these model, jobs are non-preemptive, which
differs from our setting.
1.3 Our Results
Our main results can be summarized as follows.
First, in order to characterize the boundary of our research, we derive two lower bounds
on the competitive ratio for any online deterministic IC mechanism. One bound is 5, which
holds for the situation where all the jobs have equal length (i.e.,  = 1). This bound
improves the previous lower bound of 2 (Hajiaghayi et al., 2005). The other bound is

ln  + 1  o(1), which characterizes the asymptotical property of the competitive ratio when
the variance of job lengths, i.e., , is sufficiently large.
Second, we design a simple mechanism 1 and prove that in both the restart and resume
models 1 is not only IC, but also achieves good social welfare.
 In the restart model, 1 has a competitive ratio of  + 2 + (1 + 1 ) when  is small (in
1

particular, the ratio is 5 for  = 1), and ( (1)
2 + o(1))  ln  when  is large (  16
is enough), where 0 <  < 1 is a small constant.
 In the resume model, 1 has a competitive ratio of ( + 1)(1 + 1 ) + 1 when  is
2

small (in particular, the ratio is 5 for  = 1), and ( (1)
2 + o(1))  ln  when  is large
(  16 is enough), which is just slightly worse than that for the restart model (within
a factor of 2).
It is also worth mentioning that:
 Comparing with the lower bounds, we can see that, in both the restart and resume
models, 1 is optimal for equal-length jobs ( = 1), and near optimal (within a
constant factor) for unequal-length jobs.
 In comparison with the best-known algorithms without considering incentive compat5
6
6
ibility, asymptotically speaking, 1 improves the best-known ratio log
 +O( ) (Ting,
1

2008) in the restart model to ( (1)
2 + o(1))  ln  ; and improves the best-known ratio
2

(3+o(1)) ln (Durr, Jez, & Nguyen, 2012) in the resume model to ( (1)
2 +o(1)) ln  .
Thus even if one does not care about the strategic aspect, 1 would still be a very
nice algorithm to use.

Note that designing mechanisms for online scheduling problems is generally difficult
since it combines the challenges of mechanism design (i.e., ensuring incentive compatibility)
with the challenges of online algorithms (i.e., dealing with uncertainty about future inputs).
We would like to highlight the main techniques used in this work to tackle these challenges.
(1) The allocation rule of mechanism 1 uses a carefully selected function to trade-off
three key elements: value, length, and degree of completion. The trade-off function is
delicate in the sense that it ensures both the efficiency and the monotonicity which is
crucial to the incentive compatibility.
433

fiChen, Hu, Liu, Ma, Qin, Tang, Wang & Zheng

(2) In order to obtain good competitive ratios for the resume model, we design two nontrivial virtual charging schemes to bound the performance of the proposed mechanism:
the integral charging scheme and the segmental charging scheme.
While we focus on single machine model in this paper, our work extends to multiple
identical machines. One way of the extension is similar to the work of Lucier et al. (2013),
in which it is assumed that at most h machines can be allocated to each job at any given
time, and the parameter h stands for a common parallelism bound of the system. The
details of this extension can be found in Appendix E. Another way to extend our results to
multiple identical machines is to assume that each job j needs a fixed number of machines
when it is processed. Please refer to our working paper (Ma, Zheng, Qin, Tang, & Liu,
2014) for more details.5

2. Lower Bounds
In this section, we present two lower bounds on the competitive ratio of any deterministic
IC mechanism, which hold for both the restart and resume models.
The competitive analysis can be interpreted as a game between the designer of the online
mechanism and an adversary. Given mechanism 1 , the adversary selects the sequence of
jobs that maximizes the competitive ratio, the ratio of the social welfare obtained by an
offline optimal algorithm over the social welfare obtained by 1 . Therefore, the key of
proving lower bounds is to construct subtle adversary behaviors.
We first introduce two notions, the dominant job and the shadow job.
Definition 2.1 (Dominant Job). For a deterministic IC mechanism with competitive
ratio c, job i is called a dominant job at its release time ri , if and only if vi is larger than
c times the total value of all other jobs whose release time is no later than ri .
It is easy to see that, in order to obtain a reasonable competitive ratio, if a dominant job
i has a tight deadline, then the mechanism must schedule i at its release time ri . Otherwise,
consider the case in which no more jobs are released after ri . In this case, the mechanism
cannot obtain a competitive ratio of c if it gives up the dominant job i.
Definition 2.2 (Shadow Job). Suppose a job i has a tight deadline, i.e., di = ri + li , then
job i0 is called a shadow job of i, if i0 has the same parameters (ri , li , vi ) as i, except for a
later deadline (d0i > di ).
Clearly, the shadow job i0 is more flexible and can be completed later. As for shadow
jobs, we show that the following lemma holds for any IC mechanism with a non-trivial
competitive ratio.
Lemma 2.3 (Shadow Job Argument). For a deterministic IC mechanism  with a
non-trivial competitive ratio c, if  completes a job i (with tight deadline di ) under some
scenario I, then under scenario I 0 , which substitutes some shadow job i0 for job i,  must
also complete job i0 at time di .
5. In the working paper, we only consider the restart model, and ignore the misreport of release time or
deadline.

434

fiEfficient Mechanism Design for Online Scheduling

Proof. Suppose  has not completed job i0 at di under scenario I 0 , we could consider a subsidiary scenario I 00 , which includes all jobs in scenario I 0 and adds on several dominant jobs.
Remember that we call some job dominant if its value is sufficiently large (see Definition 2.1).
These dominant jobs are released one by one at di , di + 1, . . . , di + bd0i  di c respectively,
and denoted as 0, 1, . . . , bd0i  di c accordingly, where di is the deadline of job i and d0i is the
deadline of shadow job i0 . Whats more, each of these dominant jobs is of unit length and
has a tight deadline. We claim that, to achieve the desired (non-trivial) competitive ratio,
 must complete all these dominant jobs, thus the time interval [di , d0i ) is occupied. (The
reason is as follows: if  does not schedule any dominant job j  {0, 1, . . . , bd0i  di c}, then
we consider a scenario I 000 , which only includes jobs with release time no later than di + j
in I 00 . Since scenario I 000 is indistinguishable from I 00 up to time di + j, we know  does not
schedule the dominant job j in scenario I 000 , hence cannot obtain a competitive ratio of c.)
Because the subsidiary scenario I 00 is indistinguishable from scenario I 0 up to time di ,
job i0 will not be completed at di . Furthermore, because of the existence of dominant jobs,
job i0 will not be completed finally. However, if job i0 falsely declares its type to be the
same as that of job i, i.e., misreports its deadline to be di , it would be completed at time
di and be better off, contradicting the incentive compatibility6 .
In the following, we will derive lower bounds leveraging Lemma 2.3. First, the following
theorem specifies a lower bound when jobs have equal length (i.e.,  = 1). Note that our
result concerns the strategic setting, while Woeginger (1994) shows that the competitive
ratio of any deterministic algorithm in the non-strategic setting is at least 4.
Theorem 2.4. When  = 1, no deterministic IC mechanism can obtain a competitive ratio
less than 5.
To prove the theorem, in addition to using an adversary argument similar to that in the
work of Woeginger (1994), we need to further perturb the job sequence and leverage the
shadow job argument.
Intuitively, we construct a special job set, in which tight-deadline jobs are released one
by one, and any two jobs collide with each other (that is, the deadline of one job is later than
the release time of the other, and under any mechanism, it is impossible for these two jobs to
be both completed). The values of these jobs are carefully selected such that a later released
job is more valuable than the earlier one (predecessor), and the value difference between
such two neighboring jobs is constrained by a small-enough additive constant. Furthermore,
in such a job set, the values of the first and last jobs are set to obey a specific amplification.
Along with the execution of any mechanism, the adversary would release a series of such job
sets. Once the mechanism completes one job, the adversary stops releasing any job. The
subtleness lies in choosing the time to release such job sets: once the mechanism almost
completes some job a in a job set, the adversary may release a new job set whose jobs
all collide with job a but do not collide with the predecessor of job a. In this way, if the
mechanism would not abandon the current job a but complete it, then there should be an
optimal allocation which completes: (1) several jobs in the previous job sets, (2) the most
6. The above scenario contradicts the monotonicity condition (see a strict definition at start of Section 3.2);
And Theorem 1.15 of the work of Parkes (2007) shows that monotonicity is necessary for incentive
compatibility.

435

fiChen, Hu, Liu, Ma, Qin, Tang, Wang & Zheng

valuable job (i.e., the last job) in the newly released job set, and (3) the job a.7 However,
the mechanism can only complete job a. This discrepancy leads to the lower bound of
competitive ratio. The detailed proof can be found below.


   

SET
r1


   

vq = w



   
v2
v1 = v

t

Figure 1: Structure of SET (v, w, t, )
Proof. Suppose by contradiction that there exists a deterministic IC mechanism  which
achieves a competitive ratio of 5   for some 0 <  < 1. We adopt the notation of SET
introduced by Woeginger (1994). Define SET (v, w, t, ) (for w  v > 0, t > 0 and  > 0)
as a set of jobs {1, 2, . . . , q} satisfying the following properties:
(1) v1 = v, vq = w, and vj < vj+1  vj +  for 1  j  q  1. Hence, q can be any integer
no less than d wv
 e. We call  as the magnifying parameter of a SET .
(2) lj = dj  rj = 1, j, i.e., all jobs are unit-length and have tight deadlines.
(3) 0  r1 <    < rq < t < d1 <    < dq , thus, any two jobs collide with each other. We
call t as the split point of a SET .
We define the release time of a SET as the release time of its first job. Figure 1 shows the
visual structure of SET (v, w, t, ). The adversary behavior is as follows.
Adversary Behavior: The adversary will release some SET s one after another depending
on . First, SET0 = SET (1, , 1/2, ) is released at time 0, where  = 4  /2 and  < /4.
From the definition of SET , we know that the first job in SET0 has value 1, the last job
in SET0 has value , and the value difference between any two neighboring jobs is upper
bounded by .
Next, we specify: (1) when will the adversary release a new SETi (i  1), and (2) how
the adversary sets the parameters of SETi (i  1). For (1), we specify by Algorithm 1. The
notations used in Algorithm 1 are detailed in Table 1.
7. In the proof, we construct a new scenario, in which job a is perturbed to have later deadline, thus can
be completed later. We make use of the shadow job argument in the analysis, which makes the lower
bound increased by 1, compared with the previous lower bound in the non-strategic setting.

436

fiEfficient Mechanism Design for Online Scheduling

SETi
job ij
rij , dij and vij
wi
ti
i
job i
job i

Table 1: Summary of notation in the proof of Theorem 2.4
i-th released SET , in full, SET (vi1 , wi , ti , i )
j-th job in SETi .
release time, deadline and value of job ij.
value of the last job in SETi
split point of SETi
magnifying parameter of SETi
trigger job in SETi1
the preceding job of i in SETi1

Algorithm 1: The Adversary Behavior
1: Initial: Release SET0 at time 0.
2: while  has not completed any job, do
3:
if  almost completes the j-th job (j  2) in SETi (Precisely,  has been executing
job ij for di(j1)  rij period of time since rij ). then
4:
Release SETi+1 at time di(j1) .
5:
else
6:
Do not release any other job.
7:
end if
8: end while
It is worth mentioning that: (i) SETi+1 is only triggered when a non-first job in SETi
is almost completed, and we call such a job a trigger job. (ii) No more SET will be released
once some job is completed by .
Suppose the trigger jobs in SET0 , . . . , SETi1 are named 1 , . . . , i successively. Accordingly, we denote the job with release time just earlier than each trigger job as 1, . . . , i,
and we call them preceding jobs. From Line 4 of Algorithm 1, we know that each new SETi
is released at the deadline of i. Note that trigger job i and its preceding job i are both
located in SETi1 .
We now specify the parameters of SETi = SET (vi1 , wi , ti , i ), i  1. Remember that
SET0 is defined as SET (1, , 1/2, ), in which  = 4  /2 and  < /4.
 The adversary sets vi1 equal to the value of the trigger job i in SETi1 , that is
vi = vi1 . Note that vi1 is the value of the first job in SETi .
Pi1
 The adversary sets i = /2i , wi = max{(  1)vi1  j=1
vj1 , vi1 } for i  2, and
w1 = (  1)v11 .
 The adversary sets ti = (di + di )/2, where di and di are deadlines of trigger job i
and its preceding job i. Note that by setting ti = (di + di )/2, all jobs in SETi are
released after di but before di . Hence, all the new jobs collide with trigger job i and
none of them collides with job i.
Figure 2 illustrates how the adversary releases a new SET by an example. In this
example,  almost completes the j-th job (j  2) in SETi . SETi+1 is released at the
deadline of job i(j  1), and the value of the first job of SETi+1 is equal to vij .
437

fiChen, Hu, Liu, Ma, Qin, Tang, Wang & Zheng


   

   
ri1


   

SETi

   

   
vi1

SETi+1

   
vij
vi(j1)

     

v(i+1)1 = vij

ti+1
Figure 2: An example of SETi+1 and SETi

According to Algorithm 1, if  always gives up trigger jobs and switches to schedule
some job in the newly released SET , the adversary will release new SET s one after another.
One may wonder whether the adversary will release new SET s infinitely. In other words,
will subscript of SETi tend to infinity?
The answer is no, which can be seen from the definition of wi . Since 2 <  < 4, by
Lemma 4.3 of the work of Woeginger (1994), after a finite numberP(denote k) of steps, vk1
must be no less than the corresponding sum term (  1)vk1  k1
j=1 vj1 , and wk = vk1
must hold. Remember that vk1 and wk denote the value of first job and last job in SETk
respectively, thus there exists only one job in SETk . According to Algorithm 1, no matter
whether  completes this job or not, the adversary will not release any other job. Therefore,
SETk is the ultimate SET and job k1 is the ultimate job.
So far, we have clarified the adversarys behaviors. Next, we show how to derive the
lower bound based on such an adversary.
According to Algorithm 1 and the structure of SET , we know the adversary allows 
to complete at most one job. Actually, the completed job can be: (1) the first job in SET0
(i.e., job 01); (2) a trigger job i , 1  i  k; or the first job in SETi , 1  i < k (i.e., job
i1); or (3) the ultimate job k1. Let us analyze them one by one.
(1) If  completes job 01, then we consider a scenario in which job 01 is substituted by its
shadow job 010 , whose deadline is late enough (i.e., even if it started being executed
from the deadline of last job in SET0 , it still can be completed in time). According
to Lemma 2.3, mechanism  must complete job 010 at time 1, and thus abandon the
last job (with value w0 = ) in SET0 . Therefore, it only obtains a social welfare of
v01 = 1. However, the optimal allocation (which first completes the last job in SET0
and then job 010 ) obtains a social welfare of  + 1. This contradicts the fact that 
has a competitive ratio of 5  , since  + 1 = (4  /2) + 1 > 5  .
(2) If  completes a trigger job i or a job i1, 1  i  k, without loss of generality,
we denote such job as job ij, and we know vij = vi = vi1 . If  completes job ij,
1  i  k, then similarly, we consider a scenario in which job ij is substituted by
its shadow job (ij)0 , whose deadline is late enough. By Lemma 2.3,  must complete
job (ij)0 at time dij , obtaining a social welfare of vij = vi = vi1 . However, social
welfare of the optimal allocation
P(which completes jobs
P1, . . . , i, the last job in SETi ,
and then job (ij)0 ) is at least ij=1 vj + wi + vij > ij=1 (vj1  j1 ) + wi + vij >
438

fiEfficient Mechanism Design for Online Scheduling

P
 2 + (  1)vi1  i1
j=1 vj1 + vij > ( + 1)vi1  /2 > (5  )vi1 . This
contradicts the fact that  has a competitive ratio of 5  .

Pi

j=1 vj1

(3) If  completes the ultimate job k1, we consider a scenario in which the adversary
releases two copies of job k1 in SETk . Clearly, in this scenario,  will choose one
copy to complete. We denote the completed copy as job (k1)1 and the other as job
(k1)2 . We then consider a scenario in which job (k1)1 is substituted by its shadow job
(k1)0 , whose deadline is unit-time later than that of job k1. According to Lemma 2.3,
 must complete job (k1)0 at dk1 and obtains a social welfare of vk1 . However, the
0
optimal allocation (which completes
Pk jobs 1, . . . , k, job (k1)
Pk 2 , and then job (k1) ) can
obtain a social welfare of at least j=1 vj + vk1 + vk1 > j=1 (vj1  j1 ) + wk + vk1 >
Pk
Pk1
j=1 vj1 + vk1 > ( + 1)vk1  /2 > (5  )vk1 . Remember
j=1 vj  2 + (  1)vk1 
P
that in SETk , we have vk1 = wk = (  1)vk1  k1
j=1 vj1 . This contradicts the fact
that  has a competitive ratio of 5  .

Second, to understand the asymptotic property of the lower bound when  is large, we
construct scenarios inspired by the example of Durr et al. (2012) and obtain the following
theorem.
Theorem 2.5. When  is sufficiently large, no deterministic IC mechanism can obtain a
competitive ratio less than ln + 1  o(1). In particular, no deterministic IC mechanism
can obtain a competitive ratio less than ln + 0.94 for   16.
Proof. For convenience of analysis, we denote  =
Let us consider the following adversary behaviors.


ln  ,

r = de  1, and assume   16.

Adversary Behavior: At time 0, a long job B with type B = (0, , , ) is released, as
well as two short jobs a1 and a1 with the same type (0, 1, 1, 1). Moreover, at each integer
moment 0  t    1, if the mechanism schedules only job B in [0, t), then two short jobs
at+1 and at+1 of unit length are released at t, with tight deadline t + 1, and no new job is
released otherwise. The values of jobs at and at satisfy:
(
1
if t < ,
v(at ) = v(at ) =
(1)
t
1
e
if t  .
Note that job at and job at are of the same type, and the cases analyzed below for at0 can
be naturally applied to at0 .
According to the adversary behavior, we know the adversary allows  to complete at
most one job. Actually, the completed job can be: (1) a job at0 with t0 < ; (2) a job at0
with t0  ; or (3) job B. We analyze these three cases as follows.
(1) If the mechanism schedules a job at0 with t0 < , then we consider a scenario that
includes jobs B, a1 , a1 , . . . , at0 1 , at0 1 , at0 and job a0t0 . Here, job a0t0 with type (t0 
1,  + 1, 1, 1), is a shadow job of at0 . According to Lemma 2.3, the mechanism must
complete job a0t0 at t0 and only obtains a social welfare of 1. However, in this scenario,
the optimal mechanism will complete job B first, and then schedule a0t0 at time  and
complete it, with the optimal social welfare  + 1. So the ratio is  + 1.
439

fiChen, Hu, Liu, Ma, Qin, Tang, Wang & Zheng

(2) If the mechanism schedules a job at0 with t0  , then we consider a scenario that
includes jobs B, a1 , a1 , . . . , at0 1 , at0 1 , at0 , and job a0t0 . Here, job a0t0 with type (t0 
1, t0 + 1, 1, et0 /1 ), is a shadow job of at0 . According to Lemma 2.3, the mechanism
should schedule job a0t0 at time t0 and complete only a0t0 . Thus, the mechanism
only obtains a social welfare of v(a0t0 ). However, one of the optimal mechanisms will
schedule and complete all jobs at for t = 1, . . . , t0 , and then schedule a0t0 at time t0
and complete it, resulting in the following optimal social welfare
t0
X

de  1 +

e

t
1


+e

t0
1


=r+

t0
X

e

t
1


+e

t0
1


Z

t0

r

t

t0

e  1 + e  1

r

t=r+1

t=de

t0

r+

t0

=r  e  1 + ( + 1)e  1 = f (, r) + ( + 1)e  1 = f (, r) + ( + 1)v(a0t0 ).
r

Here, we have introduced a function f defined as f (, r)  r  e  1 . Considering
 = ln and r =   1, we have   r  (0, 1]. As ex  1 + x and both sides converge
to 1 as x approaches 0, we have
r

f (, r) = r  e  1  r   

r
= 0,


(2)

and f (, r) approaches 0 as  grows. So the ratio is  + 1  o(1).
(3) If the mechanism schedules and completes job B, obtaining a social welfare of ,
then we consider a scenario that includes jobs a1 , a1 , . . . , a , a and job B 0 . Here, job
B 0 with type B 0 = (0, 2, , ), is a shadow job of B. Similarly, we claim that an
IC mechanism should schedule job B 0 at time 0 and complete it at time . Thus,
the mechanism only obtains a social welfare of v(B 0 ). However, one of the optimal
mechanisms will schedule and complete all  small jobs at from t = 0 to   1, and
then schedule and complete job B 0 . This leads to a social welfare at least
Z 


X
X
t
t
t
1
1
de  1 +
e +  = r +
e  1 + 
e +   r +
r

t=r+1

t=de
r
1



1



1


+ e
+  = f (, r) + e
+  = f (, r) + eln 1 + 

ln 
ln 
=f (, r) +   +  = f (, r) + 2 
+  = f (, r) + ( 
+ 1)v(B 0 ).
e
e
e
=r  e

(3)

When   16, we have e  ln . Then the above equation is larger than f (, r) +
( + 1)v(B 0 ). Therefore the ratio is  + 1  o(1).
Combining the three cases together, we prove the nonexistence of ( ln + 1  o(1))competitive mechanisms. Since f (, r)  0.06 when   16, the competitive ratio is at
least ln + 0.94 for   16.

3. Mechanism Design
In this section, we describe a simple mechanism 1 (whose allocation and payment rules
are given in Algorithm 2), which works surprisingly well for both the restart and resume
440

fiEfficient Mechanism Design for Online Scheduling

models, and handles the settings with different values of  in a unified framework. In
contrast, previous works (Durr et al., 2012) need to design separate and very different
algorithms to deal with different values of .
3.1 The Mechanism 1
Before introducing our mechanism, we first introduce the concept of the valid active time
of an uncompleted job j, until time t, denoted as

(
t  min{s|x(t0 ) = j, t0  [s, t)}, for the restart model
ej (t) := R t
for the resume model
0 (x(s) = j)ds,

(4)

where x(t) is the mechanisms allocation function, which maps each time point to an available job, or to 0 if the machine is idle.8 And () is an indicator function that returns 1
if the argument is true, and zero otherwise. Note that ej () can also take a vector  as an
argument. For example, ej (, t) is shorthand for the ej (t) for the job sequence .
It can be seen that in the restart model, at time t, if a job j has received an allocation
at time t0 < t and has not been preempted after that, then ej (t) = t  t0 . In the resume
model, ej (t) is the accumulated processing time of job j until time t.
We say that a job j is feasible at time t if (1) its reported release time is before t; (2) it
has not been completed yet; and (3) it has enough time to be completed before its reported
deadline, i.e., dj  t  lj  ej (t). We use JF (t) to denote the set of all feasible jobs at time
t.
According to Algorithm 2, at any time t, 1 assigns a priority score, vj   lj ej (,t) ,
to each feasible job j  JF (t), and always processes the feasible job with the highest
priority (ties are broken in favor of the job with the smaller rj ). Here  is located in (0, 1)
and will be determined later during the competitive analysis. The payment rule of 1 is
essentially the critical-value payment (Parkes, 2007), which is similar to that of the secondprice auction. Hence, the payment is equal to the minimum bid the agents have to make to
remain allocated.9 In the following pseudocode, j denotes the reported types of all jobs
other than j.

8. In Equation 4, since s=t is a valid candidate for the minimization, if there does not exist an s, s.t.,
x(t0 ) = j, t0  [s, t) in the restart model, then ej (t) = 0.
9. Note that we use the critical-value payment, so the payment of a completed job j depends on other
jobs types between rj and dj . If our mechanism allows returning completed job before its reported
deadline, the calculation of critical-value payment will face trouble: it is possible that agent j misreports
a much later deadline to obtain a cheaper payment, but his job is completed and returned before its
true deadline. That is the reason why we restrict our mechanism to return completed job at its reported
deadline. It is worth mentioning that, if the payment must be made when the job is completed, (Lavi
& Nisan, 2015) has shown that there is no incentive compatible mechanism which can obtain a constant
competitive ratio.

441

fiChen, Hu, Liu, Ma, Qin, Tang, Wang & Zheng

Algorithm 2:
Allocation Rule
for all time t do
if JF (t) 6=  then
x(t)  arg maxjJF (t) (vj   lj ej (,t) )
else x(t)  0
end
Payment Rule
for all job j do
if qj (, dj ) = 1 then
pj () = min(v 0 |qj (((rj , dj , lj , v 0 ), j ), dj ) = 1)
j

j

else pj () = 0
end
The intuition of our mechanism is two-fold. First, to ensure efficiency, one must trade
value against length: a job with a larger value has a higher priority, and a job with a larger
remaining length has a lower priority. 1 uses a simple priority function to achieve the
tradeoff: as can be seen, the priority score vj   lj ej (,t) of a job is positively correlated
with its value and negatively correlated with its remaining length. Second, to ensure IC,
1 uses the critical-value payment rule and a monotone10 allocation rule.
Note that both the allocation rule and the payment rule can be implemented efficiently.
For the allocation rule, it is enough to consider the time point when some new jobs arrive
or some existing jobs are completed. And, we give algorithms in Appendix A to show that
the payment for each agent can be computed in polynomial time.
Clearly, because of the critical-value payment rule, 1 is individually rational. In the
following subsection, we prove its incentive compatibility.
3.2 Incentive Compatibility
We call an allocation rule of a mechanism monotone, if a job with truthfully reported type
j = (rj , dj , lj , vj ) cannot be completed in the mechanism, then a dominated11 declaration
of its type j = (rj , dj , lj , vj ) cannot make it completed either.
According to Theorem 1.13 of the work of Parkes (2007), in order to establish the
truthfulness of a mechanism, it is enough to prove the monotonicity of its allocation rule.
Theorem 3.1. Mechanism 1 is incentive compatible, in both the restart model and resume
model.
Proof. We prove the monotonicity of the allocation rule of 1 . Assume a job j is not
completed under 1 when j is truthfully declared (we denote this case as T rue). We now
show that j cannot be completed either by declaring j = (rj , dj , lj , vj ), where rj  rj ,
lj  lj , dj  dj and vj  vj . And we denote any such case as F alse.
Suppose job j has ever been executed for k > 0 times in the T rue case, we define the
following points in the execution of job j: let tsi and tpi be the ith time that job j starts
10. We have a strict definition of monotonicity at start of Section 3.2.
11. We say a type j is dominated by type j (denoted as j  j ) if rj  rj , dj  dj , 
lj  lj and vj  vj .

442

fiEfficient Mechanism Design for Online Scheduling

execution and is preempted respectively, where i = 1, 2, . . . , k, and let ta = arg inf t (ej (t) +
dj  t < lj ) be the time that job j is abandoned. If job j is never started, then we set
ts1 = tp1 = ta .
We also refer to P = [rj , ts1 )  [tp1 , ts2 ) . . .  [tpk , ta ] = P0  P1 . . .  Pk as the pending period
of job j, and A = [ts1 , tp1 )  [ts2 , tp2 ) . . .  [tsk , tpk ) = A1  A2 . . .  Ak as the executing period of
job j.
We first consider monotonicity with regard to rj , regardless of other variables. Clearly,
from the definition of ta , declaring rj > ta could not cause the job to be completed. Thus,
we can restrict our attention to rj  [rj , ta ] = P  A.
A necessary condition for job j to be completed (in F alse) is that job j should be
executed sometime in the period P . However, according to Lemma 3.2 (see below), job j
cannot be executed in P . Therefore, declaring rj  rj cannot cause the job to be completed.
Intuitively, Lemma 3.2 says that, under case T rue and F alse, the set of jobs that are
scheduled in the period P must be the same. Thus, job j cannot be executed in period P .
We then consider dj , lj and vj . The proof is essentially the same as the proof of rj :
declaring dj  dj , lj  lj and vj  vj will not improve job js priority, and as a result, there
cannot be a change in the execution of jobs in the pending period P . So declaring dj  dj ,
lj  lj and vj  vj cannot cause the job to be completed. This proves that the allocation
rule of 1 is monotone.
In the following, we formally introduce Lemma 3.2, which is used in the above theorem.
For this lemma we introduce some additional notation: under case T rue and F alse, denote
by J and J respectively the set of jobs which have ever been executed in P , and denote
by I and I respectively the set of jobs which have ever been pending in A.
Lemma 3.2. (1) I  J = , (2) I  J = , (3) J = J.
Proof. Consider a job i  I, according to the defintion of I, under case T rue, job i has
lower priority than job j in period A  P .
Relation (1) means that, under case T rue, job i cannot be executed in period P . It is
obvious, since job j (with higher priority than i) is pending in period P .
Relation (2) means that, under case F alse, job i cannot be executed in period P either.
We prove this by contradiction. Suppose job i is executed at some time point in P . We
denote ti = min{t  P |x(t) = i}, and assume ti  Pn for 0  n  k. We have an observation
for the pending period Pn , 0  n  k.
h(n)

Observation 3.3. In pending period Pn , if 1 schedules jobs by a sequence12 of jn1 . . . jn
(h(n)  1, is the number of such active jobs in Pn ) under case T rue, then we know (1) the
h(n)
release time of each job jn2 . . . jn is in the period Pn ; in particular, the release time of job
h(n)
jn1 in Pn (n  1) is exactly time tpn (2) each job jn1 . . . jn is either completed or abandoned
in Pn ; and there is no idle time in Pn .
Here, we use fj (t) to denote the priority of job j at time t. Suppose that, under case
h(n)
T rue, it is job jni (one of jn1 . . . jn ) that is executed at ti , and its priority is fjni (ti ). Then
12. A job may appear more than once in the sequence if it is preempted and resumed/restarted later.

443

fiChen, Hu, Liu, Ma, Qin, Tang, Wang & Zheng

under case F alse, since i is executed at ti , according to Observation 3.3, we can deduce
that the priority of job i at time ti , i.e., fi (ti ) must be larger than fjni (ti ).
Therefore, we can deduce that i must have been executed sometime in the period Ui =
(A1 . . .An ). Otherwise, i should also be executed at time ti under case T rue, contradicting
the fact that i  I. Similarly, we denote si = min{t  Ui |x(t) = i}, and assume si  Am
for 1  m  n.
We claim, under case F alse, the priority of job i at time si , i.e., fi (si ) satisfies the
inequality as below.
(
p
fjni (ti )   |An |+|An1 |++|Am+1 |+|tm si | ,
fi (si ) >
p
fjni (ti )   |tm si | ,

if m  n  1;
if m = n.

Otherwise, the priority of job i at time ti is at most fjni (ti ) (consider the case that all the
periods [si , tpm ), Am+1 , . . . , An1 , An are allocated to i).
According to the definition of si , we know si is the first time that i is executed in period
A. Therefore, the priority of job i at si remains the same when shifting from case T rue
to case F alse. However, under case T rue, job j is executed at time si (hence, with a
priority larger than fi (si )), and all the periods [si , tpm ), Am+1 , . . . , An1 , An are allocated to
j. Therefore, at time ti , job j will have a priority larger than fjni (ti ), contradicting the fact
that jni is executed at time ti .
Relation (3) means that, no matter case T rue or case F alse, the jobs that are executed
in the period P are the same. Relation (3) can be derived naturally from Relation (2).

4. Competitive Analysis
In this section, we show that mechanism 1 performs quite well in terms of social welfare
by comparison with the optimal offline allocation, which has full knowledge of the future
jobs at the beginning of the execution.
To perform the competitive analysis, we need to design virtual charging schemes. Under
a certain virtual charging scheme, for every job j completed by the optimal allocation opt,
we charge its value (or partial value) to some job f completed by 1 . If this virtual charging
scheme satisfies the property that every job f completed by 1 receives a total charge of
at most cvf , then we succeed in showing that 1 has a competitive ratio of at most c.
Designing an ingenious virtual charging scheme is crucial to the competitive analysis. In
the following, we will design different virtual charging schemes to obtain the competitive
ratio of 1 for the restart model and the resume model respectively.
As we use a parameter  in the priority function of mechanism 1 , we first derive
competitive ratios as functions of . We will specify later (in Section 4.3) how to choose
a suitable  (with respect to ) to optimize the performance of 1 , and derive competitive
ratios in terms of .
Here, we introduce some notation which will be used in both Section 4.1 and Section 4.2.
Denote by (1, 2, . . . , F ) the sequence of jobs completed by 1 over time. For each job f in
this sequence, let tf be the time when job f is completed, and for convenience denote t0 = 0.
Divide the time into F + 1 intervals If = [tf 1 , tf ), f = 1, 2, . . . , F , and [tF , +).
444

fiEfficient Mechanism Design for Online Scheduling

4.1 Analysis of the Restart Model
We study the restart model first. We assume, without loss of generality, that the optimal
allocation opt does not interrupt any allocation, since all interrupted jobs are non-resumable.
We have the following theorem.
Theorem 4.1. For the restart model, 1 has a competitive ratio of

1
1

+

1


+ 1.

Proof. We introduce the virtual charging scheme as follows. For any completed job j in
opt, if it is also completed in mechanism 1 , then its value is charged to itself.
Otherwise (i.e., job j is not completed by 1 ), we consider the time sj at which j begins
execution in opt. Note that opt does not interrupt any allocation, so j is exactly allocated
the time period [sj , sj + lj ). Then sj must be in some time interval If (recall If = [tf 1 , tf )),
and we charge the value of j to f . Define j := tf  sj to be the time amount between sj
and tf . As job j is feasible at time sj , according to Lemma 4.2, we know that the priority
jobs j at time sj is at most vf  tf sj = vf  j ; in the meanwhile, the priority of j at time
sj is vj  lj . We have vj  lj  vf  j , i,e., vj  vf  j lj . We defer the formal statement and
the proof of Lemma 4.2 to the end of this subsection.
We now calculate the maximum total value charged to a completed job f in 1 . In the
time interval If , denote by (1, 2, . . . , m), the sequence of jobs in opt whose starting time sj
belongs to If and ordered as s1 > s2 >    > sm . Remember that we define j := tf  sj to
be the time amount between sj and tf . Then it is clear that we have 0 < 1 < 2 <    < m
and j  lj  j1 for 2  j  m, since j is allocated and completed during time interval
[sj , sj1 ]. Furthermore, as the job lengths are normalized, i.e., 1  lj  , we can deduce
that:
(
0
for j = 1
j 
(5)
j  1 for j  2.
Recall that  < 1 P
and f may also be completed in opt. Therefore the total charge to
job f is at most vf + m
j=1 vj , which is upper bounded by
vf + vf

m
X
j=1



j lj

 vf (1 + 

l1

+

m
X



j1

)  vf (1 + 

l1

+

j=1

j=2

1
+
This shows that mechanism 1 is ( 1

m1
X

1


j

 )  vf (1 + 



+


X
j=0

+ 1)-competitive.

1
Actually, the competitive ratio obtained in this way is tight, i.e., the ratio 1
+ 1 + 1
is best possible for 1 . We give an example in Appendix B to show tightness.

Lemma 4.2. For any time point sj  If , if job j (6= f ) is feasible at time sj , then the
priority of j at sj is at most vf  tf sj . Moreover, the value of j, vj , is at most vf  tf sj lj .
Proof. Note that, sj is in time interval If , and according to the definition of If , we know
that f is the unique job that is completed in If by 1 . Now we prove the lemma by
enumerating all possible cases.
(1) If the executing job at sj is job f , then we know that the priority of job f at time
sj is exactly vf  tf sj (because the priority of job f at time tf is vf ). Clearly, the priority
of j at sj is not larger than that of job f , and thus not larger than vf  tf sj .
445

 j ).

fiChen, Hu, Liu, Ma, Qin, Tang, Wang & Zheng

(2) If the executing job at sj is not job f , then we assume that 1 executes job j1 , . . . , jk
and f successively13 in the time period [sj , tf ), where k  1. Since f is the unique job
completed in If , we can deduce that: j1 is preempted by j2 , j2 is preempted by j3 ,...,jk is
preempted by f , and finally f is completed at time tf . Denote 1 , . . . , k as the time points
at which j1 , . . . , jk are preempted respectively. We also denote fj (t) as the priority of job
j at time t. We now use backward induction: First, we know that the priority of job jk at
k is not larger than that of job f , i.e., fjk (k )  vf  tf k . Then, since jk1 is preempted
by jk at k1 , we know that the priority of jk1 at k1 is not larger than that of jk .
Hence, we have fjk1 (k1 )  fjk (k1 ) = fjk (k ) k k1  vf  tf k1 . And eventually,
we can get that fj1 (1 )  vf  tf t1 . Since j1 is executed at time sj , we can deduce that
fj1 (sj )  vf  tf sj . Clearly, the priority of j at time sj (i.e., vj  lj ) is not larger than that
of j1 , thus not larger than vf  tf sj .
By arranging vj  lj ej (sj )  vf  tf sj , we can get vj  vf  tf sj lj +ej (sj )  vf  tf sj lj ,
where ej (sj )  0 is the valid active time of job j at time sj .
Some remarks on Lemma 4.2: (1) Because f is the unique job completed by 1 in the
time interval If , the priorities of the executing jobs monotonically increase during If . (2)
Lemma 4.2 applies in both the restart model and resume model. (3) Lemma 4.2 provides
a useful tool to relate the priority of a feasible job (j) at some time point (sj  If ) to the
completed job f .
4.2 Analysis of the Resume Model
Compared with the restart model, the competitive analysis for the resume model is much
more complicated, because in the resume model, a job can be executed in several disjointed
time intervals. The charging scheme used in the previous subsection no longer works, and
we need to design a new virtual charging scheme.
Before introducing the new virtual charging scheme, we introduce some notation that
will be used in this subsection. Let (j) denote the number of disjoint time segments
(j)
allocated to a completed job j in opt, and s1j , s2j , . . . , sj denote the corresponding starting
time of each segment.
We say an allocation contains a violation if there exist two completed jobs i and j, each
of which has two segments with starting time sai , sci and sbj , sdj such that sai < sbj < sci < sdj .
An allocation is called standard if it does not contain a violation. This means if an allocation
is standard, for any completed job, if its starting time of execution is between two segments
of another jobs allocation, then its completion time is also in the same time interval (i.e.,
between the same two segments). We provide an obvious yet useful fact for the offline
optimal allocation below.
Claim 4.3. There exists an optimal allocation that is standard.
For the detailed proof, please refer to Appendix C. Without loss of generality, we assume
that the optimal allocation opt is standard.
Claim 4.4 presents an important property of the standard allocation, which will be used
in the following proofs.
13. Here, j1 can be job j, which does not affect the analysis.

446

fiEfficient Mechanism Design for Online Scheduling

Claim 4.4. Under the execution of opt, if a job js execution-starting time is between two
segments of another jobs allocation, then job js completion time is also in the same time
interval (i.e., between the same two segments).
To analyze the competitive ratio of 1 for the resume model, we propose two new virtual
charging schemes (referred to as integral charging scheme and segmental charging scheme,
respectively). In the integral charging scheme, we charge the whole value of job j in the
optimal allocation opt to some job completed by mechanism 1 ; while in the segmental
charging scheme, we charge the value of j by segment, and different segments of the same
job may be charged to different jobs completed by mechanism 1 . By using these two
 
schemes, in Theorem 4.5 we upper bound the competitive ratio of mechanism 1 by 1
+1
1
2
and   +  ln  +1 respectively. As discussed in Section 4.3, the two ratios work for situations
with different  values, i.e., the first one works well for small  and the second one works
well for large .
Theorem 4.5. For the resume model, the competitive ratio of 1 is at most

 
1

 

+ 1. In

particular, if  satisfies    , the competitive ratio of 1 is at most min{ 1 + 1,
2
 ln  + 1}.

1


+

The proof of the theorem will be given in Section 4.2.1 and Section 4.2.2.
4.2.1 Integral Charging Scheme
Remember that we denote (1, 2, . . . , F ) as the sequence of jobs completed by 1 over time.
For each job f in this sequence, we denote the tf as the time that job f is completed.
In the integral charging scheme, we restrict the total number of jobs (excluding f itself)
that charged to job f : we does not allow this number to exceed btf tf 1 c+1. In particular,
we introduce the notation of saturation  in Definition 4.6.
Definition 4.6 (Saturated). For any job f , if the number of jobs (excluding f itself )
charged to f is less than btf  tf 1 c + 1, we say that f is unsaturated; otherwise f is
saturated.
Let W denote the set of jobs completed by opt, and Wf  W denote the set of jobs
j  W with s1j  If . Let A denote the set of jobs in W whose values have already been
charged to some jobs completed by 1 .
The integral charging scheme is described in Scheme 1. For simplicity, we refer to Line
1  2 as Step 1, Line 4  11 as Step 2, and Line 12  21 as Step 3.
Here we give some intuitive explanations about Step 2 and Step 3.
In Step 2, for each job f (f = 1, . . . , F ), we pick at most btf  tf 1 c + 1 jobs from Wf
and charge their values to f . The rule of picking jobs follows largest s1j first, and the k-th
picked job14 with s1j no later than tf  k + 1.
14. By slight abuse of notations, we still denote it as job j, and thus the start time of its first segment is s1j .

447

fiChen, Hu, Liu, Ma, Qin, Tang, Wang & Zheng

SCHEME 1: Integral Charging Scheme
1: Initial: A  .
2: For any job in W , if it is also completed by mechanism 1 , charge its value to itself,
and add it to A.
3: while W \ A 6= , do
4:
for f = 1 to F , do
5:
for k = 0 to btf  tf 1 c, do
6:
J k := {j 0 | (s1j 0  tf  k)  (j 0  Wf \ A)};
7:
if J k 6= , then
8:
Set j = arg maxj 0 J k (s1j 0 ), add j to A, and charge its value to f .
9:
end if
10:
end for
11:
end for
12:
for f = F to 1, do
13:
while Wf \ A 6= , do
14:
Set j = arg maxj 0 Wf \A (s1j 0 ), and add j to A;
15:
16:
17:
18:
19:
20:
21:
22:

(j)

if sj  If +hj for some 0  hj  F  f , then
Charge js value to the unsaturated job with smallest completion time in the
set {f + 1, . . . , f + hj };
(j)
else if sj  [tF , +), then
Charge js value to the unsaturated job with smallest completion time in the
set {f + 1, . . . , F };
end if
end while
end for
end while

In Step 3, we consider jobs (in W ) whose values are not charged to any job in the first
(j)
two steps. Consider a job j with s1j located in interval If and sj
located in If +hj (or
[tF , +)). We charge its value to an unsaturated job in the job set {f + 1, . . . , f + hj } (or
{f + 1, . . . , F }). The rule of selecting the unsaturated job follows smallest completion time
first.
We will show that after three steps all jobs in W are charged to some completed jobs in
1 (see Claim 4.9). First, we give two observations below.
Observation 4.7. In the integral charging scheme, for any job f  {1, 2, . . . , F } and any
time t  If , the number of jobs charged to f with their start time in opt being in [t, tf )
(charged at step 2) is no more than btf  tc + 1.
Observation 4.8. In the integral charging scheme, for any job f  {1, 2, . . . , F } completed
by mechanism 1 , the total number of jobs charged to f (excluding f itself ) is at most
btf  tf 1 c + 1.
Observation 4.7 is derived from Lines 5-6 in Scheme 1, and Observation 4.8 is derived
from the restriction that a saturated job can not be charged any more.

448

fiEfficient Mechanism Design for Online Scheduling

Claim 4.9. In the integral charging scheme, all jobs in W have been charged to some jobs
completed by mechanism 1 .
Proof. Suppose on the contrary that there exists i  Wf such that i is not charged to any job
Rt
in {f, f + 1, . . . , f + hi }. Here, we introduce a notation ei (t) = 0 (opt(s) = i)ds to denote
the valid active time of resumable job i at time t in opt. Since the length of every job is at
least 1,15 there exists an allocation segment [s0 , s00 ] of job i such that ei (s0 ) < 1, ei (s00 )  1,
and opt(t) = i for any t  [s0 , s00 ]. Suppose s00 belongs to If +h . By the definition of hi , we
have h  hi .
According to the assumption, we know: (a) i is not charged to f . (b) All jobs in
{f + 1, f + 2, . . . , f + h} have been saturated in the above charging process when we charge
job i.
From point (a), we can deduce that in Step 2, there are at least btf  s1i c + 1 jobs (whose
values are charged to f ) with s1j  (s1i , tf ] (by Observation 4.7). Otherwise i would be
charged to f in Step 2. We denote Ja as the set of these btf  s1i c + 1 jobs.
As for point (b), recall that a job f 0 (f 0  {f + 1, . . . , f + h}) is saturated if there are
bti ti1 c+ 1 jobs whose values are charged to f 0 (see Definition 4.6). Hence, we can deduce
that there are at least (btf +1  tf c + 1) +    + (btf +h  tf +h1 c + 1) jobs (whose values
are charged to {f + 1, . . . , f + h}) with their starting time satisfying s1j  (s1i , tf +h ]. In
particular, among these jobs, there are at most (btf +h  s00 c + 1) jobs with s1j  (s00 , tf +h ]
(whose value must be charged to f + h).16 Therefore, we can deduce that there are at least
(btf +1  tf c + 1) +    + (btf +h  tf +h1 c + 1)  (btf +h  s00 c + 1)
jobs (whose values are charged to {f + 1, . . . , f + h}) with s1j  (s1i , s00 ] (denote Jb as the
set of these jobs).
Note that Ja Jb = , as all jobs in Ja are charged to f , while all jobs in Jb are charged to
{f + 1, . . . , f + h}. Therefore, we deduce that the number of jobs with start time contained
in (s1i , s00 ] is at least |Ja | + |Jb |, i.e.,
(btf  s1i c + 1) + (btf +1  tf c + 1) +    + (btf +h  tf +h1 c + 1)  (btf +h  s00 c + 1)
>(tf +h  s1i )  (btf +h  s00 c + 1)  bs00  s1i c  1.
(6)
So, there are more than bs00  s1i c  1 jobs different from i in [s1i , s00 ]. Recall that we assume
opt is standard, hence, these jobs are entirely scheduled in (s1i , s00 ), i.e., all time segments
of such a job are allocated in (s1i , s00 ) (Claim 4.4). Since the length of every job is at least
1, we reach a contradiction.
According to the integral charging scheme, the charges to a completed job f have three
origins, corresponding to the three steps in Scheme 1. From Step 1, obviously, the charge
to job f is at most vf . We now calculate the maximum total charge from Step 2.
15. As stated in the Problem Formulation section, we assume job lengths are located in [1, ] for simplicity.
However, by scaling, all our results and proofs can be easily generalized to the case of [lmin ,   lmin ],
where lmin is the shortest length of jobs.
16. Because: (i) in Step 2, there might be at most (btf +h  s00 c + 1) jobs with s1j  (s00 , tf +h ] which could
be charged to f + h; (ii) in Step 3, the jobs with s1j  If +h could not be charged to f + h.

449

fiChen, Hu, Liu, Ma, Qin, Tang, Wang & Zheng

Suppose the total number of jobs charged to f from Step 2 is m. We rename them as
1, 2, . . . , m according to 1  2      m , and claim vj  vf  j lj (Lemma 4.2 is used
here), where j := tf  s1j , for 1  j  m. According to the rule of picking jobs in Step 2,
we have j  j  1. So it is clear that the sum of values of all these m jobs is at most
vf

m
X
j=1

 j lj  vf

m
X

 j1 = vf

j=1

m
X

 j .

(7)

j=0

It remains to calculate the maximum total charge from Step 3. According to Observation
4.8, we know that the number of jobs charged to f from Step 3 is at most btf tf 1 c+1m.
Now we need to bound the value of each such job j. The key is to build a relationship
between its value and the value of job f . However, according to the charging rule in Step
3, the start time s1j of job j is not located in the time interval If . In this case, we cannot
use Lemma 4.2 directly to derive an inequality like vj  vf  j lj . Because it remains to
check whether j is feasible at tf 1 (note that tf 1 is the left endpoint of time interval If ).
We define the critical time of a job as tj := dj  lj . If we can prove that tj  tf 1 , then
job j must be feasible at time tf 1 for 1 . Thus, by applying Lemma 4.2, we can easily get
vj  vf  tf tf 1 lj  vf  tf tf 1  .

(8)

Fortunately, the following lemma shows that tj  tf 1 holds.
Lemma 4.10. According to the charging scheme, if j  Wf is charged to a completed job
f + k (where 1  k  hj ), then the critical time of job j satisfies tj  tf +k1 .
Proof. We prove the lemma by contradiction and suppose tj < tf +k1 . Then the total length
(j)

of all the other jobs whose opt allocation is between s1j and sj
which is at most

(j)

is (sj

dj  s1j  lj = (dj  lj )  s1j = tj  s1j < tf +k1  s1j .

(j)

+ lj

)  s1j  lj ,

(9)

Since j is charged to f +k, from Step 3 we know that all jobs in {f +1, f +2, . . . , f +k1}
are saturated. Thus, there are at least
(btf  s1j c + 1) + (btf +1  tf c + 1) +    + (btf +k1  tf +k2 c + 1)  btf +k1  s1j c + 1 (10)
jobs whose start time belongs to the interval (s1j , tf +k1 ).
Recall that opt is standard. Hence, all these jobs allocated time segments are between
the first segment and the last segment of job j (according to Claim 4.4), Equation (9) and
Equation (10) constitute a contradiction since every jobs length is at least 1.
Combining the analysis above, we know that: (1) the total charge to f from Step 1 is
at most vf ; (2) assuming
jobs are charged to f from Step 2, the total charge from these
Pm m j
m jobs is at most vf j=0 
according to Equation (7); (3) the number of jobs charged
to f from Step 3 is at most btf  tf 1 c + 1  m according to Definition 4.6, and the value
450

fiEfficient Mechanism Design for Online Scheduling

of each job is at most vf  tf tf 1  according to Equation (8). Therefore, the total charge
to f is at most
vf + vf

m1
X

btf tf 1 c+1

 j + (btf  tf 1 c + 1  m)vf  tf tf 1   vf (1 +  

j=0

X

 j ),

j=0



which is upper bounded by vf (1 + 1
), indicating that the competitive ratio of mechanism

1 is upper bounded by

 
1

+ 1.

4.2.2 Segmental Charging Scheme
(j)

Recall that we use s1j , s2j , . . . , sj

to denote the starting time of all time segments allocated

(j)
1j , 2j , . . . , j

(j)

to job j in opt. Let
denote those time segments, and lj1 , lj2 , . . . , lj denote
the length of them.
In the segmental charging scheme, each segment kj is given a value j ljk , in which
v
j := ljj is the value density of job j. We describe the segmental charging scheme in
Scheme 2. For simplicity, we refer to Line 2  3 as Type-1 charge, Line 4  5 as Type-2
charge, and Line 6  7 as Type-3 charge.
SCHEME 2: Segmental Charging Scheme
1:
2:
3:
4:
5:
6:
7:
8:
9:

for each segment kj in opt do
if mechanism 1 also completes j by its deadline, then
Charge the value j ljk to j.
else if skj  If for some f  {1, 2, , . . . , F }, and j  vf  j 1 , where j := tf  skj ,
then
Charge the value j ljk to f .
else
Charge j ljk to f  , where f  is the first job completed by 1 from time tj on,
where tj is the critical time of job j.
end if
end for

It is clear that the Type-1 charge received by a job f is at most vf . Next, we bound the
Type-2 and Type-3 charges.
v

Lemma 4.11. The total Type-2 charge that a job f receives is at most   lnf  .
Proof. Let R2 denote the set of job segments whose charges to f are Type-2. For each
kj  R2 , the charge from it is j ljk . And from Line 4 in Scheme 2, we know j  vf  j 1 ,
where j = tf  skj . Thus the total Type-2 charge is at most
X
kj R2

j ljk

 vf

X
kj R2

 j 1 ljk

 vf

X Z
kj R2

j

j ljk



x1

Z
dx  vf
0



 x1 dx  

vf
,
 ln 

where the second inequity holds by  < 1. Therefore, f receives a total Type-2 charge of
v
at most   lnf  .
451

fiChen, Hu, Liu, Ma, Qin, Tang, Wang & Zheng

In the following, we study the Type-3 charge and denote R3 as the set of job segments
which constitute Type-3 charges to f .
First, we claim that, if  satisfies some condition, then we can get [skj , skj + ljk ]  [tf , tf +
lj ]  [tf , tf + ] for each kj  R3 (Claim 4.12).
Claim 4.12. If  satisfies the function: g(x) = x x   for 1  x  ; then we have
[skj , skj + ljk ]  [tf , tf + lj ], for each kj  R3 .
Proof. To prove [skj , skj + ljk ]  [tf , tf + lj ], we only need to prove the inequality below:
tf  skj  tf + lj  ljk .

(11)

The inequality skj  tf + lj  ljk holds because (skj + ljk )  lj  dj  lj = tj  tf .
Next we prove tf  skj . Suppose skj  If 0 for some f 0 (If 0 is not later than If , and might
equal If ). Then according to the Type-3 charging rule, we have j =

vj
lj

0

> vf 0  j 1 , where

j0 = tf  skj .
We now use the condition for : g(x) = x x   for 1  x  . Then we have
0
v
v
l
lj  j  , hence ljj  vj  lj 1 . Combining the above two inequalities ( ljj > vf 0  j 1 and
0

vj
lj

0

 vj  lj 1 ), we have vj  lj > vf 0  j , thus vj > vf 0  j lj , which contradicts the fact
that f 0 is completed at tf 0 with priority vf 0 (Lemma 4.2 is used here). Therefore, we have
tf  skj .
By Claim 4.12, we know the allocation of all the segments P
with Type-3 charges to f are
in a restricted interval [tf , tf + ]. Hence, we can derive that k R3 ljk  .
j

Lemma 4.13. If  satisfies the function: g(x) = x x   for 1  x  ; then the total
 ).
Type-3 charge that a job f receives is at most vf ( 1
ln  + 
Proof. According to the Type-3 charging rule, j is not completed by the mechanism; if we
consider the critical point of j, i.e., tj (in time interval If ), then by applying Lemma 4.2, we

v
v
can deduce that vj  lj  vf  tf tj  vf . Therefore we have ljj  flj . Now we can bound
lj 

the total Type-3 charge that f receives
X
kj R3

j ljk =

X vj
X vf
X ljk
k
ljk 
l
=
v
,
f
lj
g(lj )
lj  lj j
k
k
k

j R3

j R3

Note that the function g(lj ) = lj  lj is increasing for 1  lj 
1
lj  ln
 . So we have
g(lj ) 

(

 

for 1  lj 
for

1
ln 

(12)

j R3

1
ln 

 lj  , if  >

1
ln  .

1
ln 

and decreasing for

(13)

By Claim 4.12, we know [skj , skj + ljk ]  [tf , tf + lj ]  [tf , tf + ] for each kj  R3 .
1
a
Therefore, on the one hand, for each kj  R3 with ln
  lj   (denote this set as R3 ),
452

fiEfficient Mechanism Design for Online Scheduling

k
kj R3a lj

 ; on the other hand, for each kj  R3 with lj 
P
1
set as R3b ), we have k Rb ljk  ln
.
3
j
Then, (12) becomes

we have

P

X
kj R3

X

j ljk  vf

kj R3

X ljk
X ljk
ljk
= vf (
+
)
g(lj )
g(lj )
g(lj )
k
a
k
b
j R3

P
 vf (

1
ln 

kj R3a

 

ljk

P
+

kj R3b



j R3

ljk

)  vf (

which means the Type-3 charge is bounded by vf ( 1
ln  +

(denote this

(14)

1
ln 


+
),
 


1
  ).

Based on Lemmas 4.11 and 4.13, we can obtain that when    ,17 the total charge
to a job f completed by mechanism 1 is at most vf ( 1 + 2
ln  + 1). This implies that the
1
competitive ratio of mechanism 1 is upper bounded by   + 2
ln  + 1.
4.3 Discussions
An advantage of our mechanism is that it can handle the settings with different values of
 in a unified framework. We only need to set parameter  to different values in Theorem
4.1 and Theorem 4.5 so as to adapt to different settings of job lengths (as shown in the
following corollaries).
Corollary 4.14. By setting  = 1(1)2  ln , where  > 0 is an arbitrary small constant,
1

mechanism 1 achieves a competitive ratio ( (1)
2 + o(1))  ln  for the restart model and a
2
competitive ratio ( (1)
2 + o(1)) 


ln 

for the resume model.

The proof can be found in Appendix D. As for Corollary 4.14, we have the following
discussions:
1

(1) For the restart model, mechanism 1 achieves a competitive ratio of ( (1)
2 +o(1)) ln  ,
5

6
6
which improves upon the best-known algorithmic result log
 + O( ) (Ting, 2008) for
the standard online scheduling without strategic behavior.

(2) For the resume model, when  is large, mechanism 1 achieves a competitive ratio of
2

( (1)
2 + o(1))  ln  , which is slightly worse than the result obtained for the restart
model (within a factor of 2). Asymptotically speaking, 1 is near optimal, since
its competitive ratio has the same order (w.r.t. ) as the lower bound shown in
Theorem 2.5. Furthermore, our analysis generalizes the results obtained by Durr et
al. (2012) to the continuous value of time and the strategic setting.
(3) When  is relatively small, the ratios given in Corollary 4.14 will become loose. In
particular, when  approaches 1, the above ratios will approach infinity since ln 
approaches 0. In this case, we need a different setting of  (see Corollary 4.15).
1
1
17. Note that, the function g(x) = x x is increasing for 1  x  ln
and decreasing for x  ln
. Therefore,


we only need to require    , and we can naturally derive g(x) = x x   for 1  x  .

453

fiChen, Hu, Liu, Ma, Qin, Tang, Wang & Zheng


Corollary 4.15. By choosing  = +1
, the competitive ratio of mechanism 1 is  + 2 +
1 
(1 +  ) <  + 2 + e for the restart model and ( + 1)(1 + 1 ) + 1 for the resume model.

Similarly, we have the following discussions:
(1) The competitive ratio of 1 is linear in , since (1 + 1 ) is bounded by e.
(2) In particular, when  = 1, the ratios in the above corollary become 5 for both the
restart and resume model, which matches the lower bound given in Theorem 2.4. In
this regard, we say that 1 is optimal. On the other hand, this also shows that the
lower bound of 5 in Theorem 2.4 is tight.

5. Conclusion and Future Work
In this paper, we studied the online scheduling problem in a strategic setting. As summarized in Table 2, we proved that in both the restart model and the resume model, the
competitive ratio of any IC mechanism cannot be less than 5 when  = 1 and cannot be less
than ln + 1  o(1) for large . We designed a simple IC mechanism 1 to schedule jobs on
a single machine and proved that it has near optimal approximation guarantees (in terms
of social efficiency) in both the restart model and the resume model through competitive
analysis: as shown in Table 2, the mechanism is optimal in terms of competitive ratio in
both the restart model and the resume model when  = 1, and it is near optimal for the
restart model when  is large enough.
Table 2: Summary of bounds on competitive ratio
Restart Model
Resume Model
Model
=1
asymptotic 
=1
asymptotic 


LB for any IC mech.
5
+
1

o(1)
5
ln 
ln  + 1  o(1)
1
2


UB of the proposed mech.
5
( (1)
5
( (1)
2 + o(1))  ln 
2 + o(1))  ln 
In proving the lower bounds, we introduce the shadow job argument which reflects the
IC constraint. This argument is very helpful in extending bounds in non-strategic setting
to strategic setting. The second contribution of this work is that we design several virtual
charging schemes to analyze the competitive ratio of our mechanism. The ideas of these
virtual charging schemes are of methodological significance and may be used to address
other problems.
There are multiple directions to explore in the future.
It is an interesting problem whether an IC competitive mechanism can be designed for
the hybrid model, in which there exist both resumable and non-resumable jobs. Many new
strategic issues may arise in the hybrid model. For example, can a resumable job disguise
as a non-resumable job to get better off?
Another open problem is whether a tighter competitive analysis of 1 can be made for
the resume model. Our conjecture is that the competitive ratio obtained by 1 has an
1
+ 1 + 1, for both the restart model and the resume model.
uniform form: 1
Furthermore, given the popularity of cloud computing in todays IT industry, it is of
practical importance to extend our work to the setting of job scheduling on multiple heterogeneous machines.
454

fiEfficient Mechanism Design for Online Scheduling

Appendix A. Algorithms for the Critical-Value Payment
Please note that the critical time point in Algorithm 3 and Algorithm 4 means the time
point when some new jobs arrive or some existing jobs are completed.
Algorithm 3: Compute the critical-value payment in the restart model
for each job j which is completed do
Run Algorithm 1 without job j. Let T be the set of all critical time points
t  [rj , dj ).
for every t  T do
if there exists job k such that x(t) = k, then define ft = vk  lk ek (t) ;
else ft = 0;
end-for
for every time point t0  T  [rj , dj  lj ) do
0
Define ft0 = max{ft / t t : t  (T  [t0 , t0 + lj ))};
end-for
Let f  = mint0 ft0 .
pj = f  / lj .
end
Algorithm 4: Compute the critical-value payment in the resume model
for each job j which is completed do
Run Algorithm 1 without job j.
Let {t0 , t1 , . . . , tm } be the set (denoted as T ) of all critical time points in [rj , dj ),
and t0 = rj .
Denote the period between two critical time point as zi = ti  ti1 , where
i = 1, 2, . . . , m.
for every ti  T do
if there exists job k such that x(ti ) = k, then define fti = vk  lk ek (ti ) ;
else fti = 0;
end-for
Initially, T   , h = 0.
while h < lj do
t0 = arg minti T \T  fti , ties are broken in favor of smaller ti ;
Initially, e0 = 0;
0
for every time point ti  t0 that satisfies fti  ft0  e do
e0 = e0 + zi ; and
if ti 
/ T ,
then add ti to T  , and h = h + zi ;
end-for
end-while
Let t01 be the earliest critical time point in T  . Let t = arg maxti T  fti .
Denote the critical time points in T  and between t01 and t as t02 , t03 , . . . , t0k .
Denote the relevant periods of those critical time points as z10 , z20 , . . . , zk0 , and z  .
0
0
pj = ft / lj (z1 ++zk ) .
end
455

fiChen, Hu, Liu, Ma, Qin, Tang, Wang & Zheng

Appendix B. An Example for Analysis Tightness
Example B.1. There are two types of jobs: long and short. The length of long jobs is ,
while the length of short jobs is 1. Let p be a large integer, and the number of long and short
jobs are p + 1 and p  1 respectively. The first long job J0l is released at time 0, and its type
is 0l = (0, , , 1). For p  2  i  1, job Jil has type il = (i(  ), (i + 1)  i, ,  i ).
l
l
Long job Jp1
has type p1
= ((p  1)(  ), (p + 2), ,  (p1) + ). Job Jpl has type
l
p = (p(), (p+1)p, ,  p+ ). Here,  and  are small constants satisfying p  1
and   . In the meanwhile, we have short jobs as follows. For j = 1, . . . , p1, we denote
Jjs as the jth short job, whose type is js = (j (p1), j +1(p1), 1,  (j+1)+(p1)   ).
for j = 1, . . . , p  1.
l
It can be verified that only one job Jp1
can be completed in mechanism 1 , with
(p1)
a social welfare  
. While in the optimal solution, all the short jobs will be
l
l
will be completed successively, with a social welfare
completed, and after that, Jp and Jp1
2
3
(p1)
 (
+
+ ... + 
) +  (p1) +  p . Therefore, the competitive ratio of
p1
mechanism 1 is at least ( p2 + . . . +  + 1) + 1 +   = 1
+ 1 +   , which tends
1
1
to 1
+ 1 + 1, when p  .

Appendix C. Proof of Claim 4.3
Proof. Suppose an optimal allocation opt is not standard, i.e., there exist a completed job
i with two segments beginning at time sai and sci and a completed job j with two segments
beginning at time sbj and sdj such that sai < sbj < sci < sdj . We now do the following process
to obtain a standard optimal allocation: if the length of job js b-th segment (denote as ljb )
is larger than that of is c-th segment (denote as lic ), we exchange is c-th segment with js
b-th segment located in [sbj , sbj + lic ]; otherwise, we exchange js b-th segment with is c-th
segment located in [sci + lic  ljb , scj + lic ]. For all the other segments, their order remains
unchanged. It is easy to see that the new allocation is still feasible and obtains the same
social welfare. We do such kind of exchanges until there is no violation, and then obtain a
standard optimal allocation.

Appendix D. Proof of Corollary 4.14
Proof. For every constant c < 1 and large enough x, we have (1  xc )x  e. When  is
large enough, by choosing  = 1  (1  )2  ln , we have   1, and
(1  )2 ln   (1) ln  (1) ln 

)
 e(1) ln   (1) = o(
).

ln 
By using Taylors theorem, we know
  = (1 

 ln  = (1 + o(1))(1  ) = (1 + o(1)) 
Thus the competitive ratio is

1
1

c2 ln 
.


1

+ 1 + 1 = ( (1)
2 + o(1))  ln  for the restart model, and

2
 ln 

2

+ 1 + 1 = ( c2 ln  (2 + o(1)) + o( ln )) + 1 = ( (1)
2 + o(1))  ln  for the resume model,
respectively.

456

fiEfficient Mechanism Design for Online Scheduling

Appendix E. The Multiple Machines Extension
Suppose there are C identical machines, and each of them can process at most one job at
any given time. Similar to the work of Lucier et al. (2013), we assume that at most h
machines can be allocated to a single job at any given time. This parameter stands for a
common parallelism bound of the system.
The notion of preemption is specified as follow: A job may be processed on any number of
machines between 1 and h, and the number of machines allocated to this job may fluctuate,
and only if the number decreases to 0, we treat this job as preempted. Thus, the notation
of preemption-restart and preemption-resume can be defined accordingly.
Each job j  J is characterized by a private type j = (rj , dj , sj , vj ). Instead of lj , where
we use sj to denote jobs size (e.g., the number of machine hours required to complete the
job). Without causing any confusion, we let  be the maximum ratio between the sizes of
any two jobs:  = maxi,jJ ssji . For simplicity, we assume all job sizes fall in [1, ]. If  = 1,
all the jobs have the identical size; otherwise they have different sizes.
E.1 A Simple Case: h = 1
In this case, we design a new mechanism 2 based on the single-machine mechanism 1 .
The payment rule of 2 is exactly the same as 1 , and its allocation rule is shown in
Algorithm 2, which is also similar to that of 1 . Since each job can be processed on at
most one machine, the mechanism will choose the C jobs (if any) in JF (t) with the highest
priorities vi   si ei (,t) to execute. Note that here the valid active time of job j until time
t is computed as
C Z t
X
ej (t) =
(xi (s) = j)ds.
(15)
i=1

t0

P
where () is an indicator function, and t0 = arg maxst [ C
i=1 (xi (s) = j)] = 0. That is
to say, we treating resumable jobs as non-resumable jobs for simple. We summarize the
theoretical properties of 2 in Theorem E.1.
Algorithm 5: The allocation rule of Mechanism 2
for all t do
if |JF (t)|  C then
process the C jobs with highest priorities in JF (t);
else process all the jobs in JF (t).
end
Theorem E.1. Mechanism 2 is IC and has the following properties:

(+1) ,
1  (1  )2

 In the restart model, by setting  =
1 
)

we can get a competitive ratio of  + 2 +

(1 +
for 2 ; by setting  =
 ln for arbitrary small  > 0, we can get
1
another competitive ratio of ( (1)2 + o(1))  ln .
 In the resume model, by setting  = 1  (1  )2  ln for arbitrary small  > 0, we
2

can get a competitive ration of ( (1)
2 + o(1))  ln  .
As for the above theorem, we have the following discussions.
457

fiChen, Hu, Liu, Ma, Qin, Tang, Wang & Zheng

(1) Similar to what we have done in the single-machine setting, for the restart model,
we give two competitive ratios for 2 . When  is small, the first ratio is better
(in particular, when  = 1, this competitive ratio becomes 5 and is thus optimal
according to Theorem 2.4). When  is large, the second ratio is better instead and is
near optimal according to Theorem 2.5.
(2) Different from what we have obtained in the single-machine setting, for the resume
model, we cannot match the lower bound 5 when  = 1 in the multi-machine setting.
Proof. The proof of Theorem E.1 is essentially the same as the proof of single machine
setting, in our virtual charging scheme, we charge a completed job in the optimal allocation
to some job completed by 2 on the exactly same machine. The difference is that the
integral charging scheme for the resume model will not apply to the multiple machines
setting any more. We only use the segment charging scheme for the resume model.
E.2 General Case: h  1
To handle this general case, we design a new mechanism 3 , which divides the C machines
into bC/hc equally-sized virtual machines (each consisting of h machines), and treats every
virtual machine as a single machine when performing the scheduling. That is, each virtual
machine will be used to process one job, and the remaining C  bC/hc  h machines will be
idle.
Algorithm 6: The allocation rule of Mechanism 3
(1) Divide the C machines into bC/hc equal-sized virtual machines.
(2) Run mechanism 2 under the following modification:
 Capacity: bC/hc.
 Demand size: sj /h for each job j.
As compared to the case of h = 1, the setting h  1 imposes more flexibilities to the
optimal offline allocation. For example, a job may be processed on any number of machines
between 1 and h in the optimal allocation and it might not always be executed on exactly
h machines. Fortunately, we can use the similar segmental charging idea as h = 1 case to
resolve the challenge and get the competitive ratio as shown in the following theorem.
4

Theorem E.2. Mechanism 3 is IC and has a competitive ratio of ( (1)
2 + o(1))  ln  for

3 by setting  = 1  (1  )2 
resume model.

ln 


for arbitrary small  > 0, no matter restart model or

We have the following discussions for the above theorem. The setting of h  1 is more
complicated and we could not always obtain the same results as in the setting of h = 1.
In particular, if h divides C, there will be no idle machine and we may obtain the same
competitive ratio as in the setting of h = 1. However, when h does not divide C, the idle
machines will introduce an additional factor of at most 2 to the competitive ratio. Besides,
the competitive ratio for the restart model is no better than that for the resume model, and
the competitive ratio cannot reach 5 when  = 1.
458

fiEfficient Mechanism Design for Online Scheduling

Proof. Here we only need to show that there exists an optimal allocation (we can view
all jobs as resumable jobs in the optimal allocation) such that at any time every job is
processed on either exactly h machines or no machine (assuming h divides C). Then we
can directly use the results obtained for the special case h = 1. Suppose opt is an optimal
offline allocation and J  is the set of jobs completed under opt. For each j  J  , we use
mj (t) to denote the number of machines processing j at time t under opt. Then we can
divide the time into intervals [tk , tk+1 ), where k = 0, 1, 2,    , such that at any time interval
[tk , tk+1 ), mj (t) does not change for any j  J  . Now we show how to allocate the jobs at
any time interval [tk , tk+1 ). For the bC/hc virtual machines, we allocate the jobs on them
one by one, i.e., only if the previous virtual machine is full, we start to allocate jobs on
another empty virtual machine from tk (empty is only with respect to [tk ,Rtk+1 )). Besides,
t
every job is allocated continuously one by one and the size of allocation is tkk+1 mj (t)dt. It
can be easily verified that under this allocation every job j  J  is allocated legitimately
(j is allocated during [rj , dj ] and processed by at most h machines at any time) and can
complete before its deadline since j is legitimately completed under opt.

References
Azar, Y., Ben-Aroya, N., Devanur, N. R., & Jain, N. (2013). Cloud scheduling with setup
cost. In Proceedings of the twenty-fifth annual ACM symposium on Parallelism in
algorithms and architectures, pp. 298304. ACM.
Bar-Noy, A., Guha, S., Naor, J., & Schieber, B. (2001). Approximating the throughput
of multiple machines in real-time scheduling. SIAM Journal on Computing, 31 (2),
331352.
Baruah, S., Koren, G., Mao, D., Mishra, B., Raghunathan, A., Rosier, L., Shasha, D., &
Wang, F. (1992). On the competitiveness of on-line real-time task scheduling. RealTime Systems, 4 (2), 125144.
Baruah, S. K., Haritsa, J., & Sharma, N. (1994). On-line scheduling to maximize task
completions. In Proceedings of Real-Time Systems Symposium, pp. 228236. IEEE.
Borodin, A., & El-Yaniv, R. (1998). Online computation and competitive analysis, Vol. 2.
Cambridge University Press Cambridge.
Chin, F. Y., & Fung, S. P. (2003). Online scheduling with partial job values: Does timesharing or randomization help?. Algorithmica, 37 (3), 149164.
Ding, J., Ebenlendr, T., Sgall, J., & Zhang, G. (2007). Online scheduling of equal-length
jobs on parallel machines. In Proceedings of the 15th annual European conference on
Algorithms, pp. 427438. Springer-Verlag.
Ding, J., & Zhang, G. (2006). Online scheduling with hard deadlines on parallel machines.
In Algorithmic Aspects in Information and Management, pp. 3242. Springer.
Durr, C., Jez, L., & Nguyen, K. T. (2012). Online scheduling of bounded length jobs to
maximize throughput. Journal of Scheduling, 15 (5), 653664.
459

fiChen, Hu, Liu, Ma, Qin, Tang, Wang & Zheng

Ebenlendr, T., & Sgall, J. (2009). A lower bound for scheduling of unit jobs with immediate
decision on parallel machines. In Approximation and Online Algorithms, pp. 4352.
Springer-Verlag.
Friedman, E. J., & Parkes, D. C. (2003). Pricing wifi at starbucks: issues in online mechanism
design. In Proceedings of the 4th ACM conference on Electronic commerce, pp. 240
241. ACM.
Goldman, S. A., Parwatikar, J., & Suri, S. (2000). Online scheduling with hard deadlines.
Journal of Algorithms, 34 (2), 370389.
Goldwasser, M. H. (2003). Patience is a virtue: The effect of slack on competitiveness for
admission control. Journal of Scheduling, 6 (2), 183211.
Hajek, B. (2001). On the competitiveness of on-line scheduling of unit-length packets with
hard deadlines in slotted time. In Proceedings of the 35th annual Conference on
Information Sciences and Systems.
Hajiaghayi, M., Kleinberg, R., Mahdian, M., & Parkes, D. C. (2005). Online auctions with
re-usable goods. In Proceedings of the 6th ACM conference on Electronic commerce,
pp. 165174. ACM.
Kolen, A. W., Lenstra, J. K., Papadimitriou, C. H., & Spieksma, F. C. (2007). Interval
scheduling: A survey. Naval Research Logistics (NRL), 54 (5), 530543.
Lavi, R., & Nisan, N. (2004). Competitive analysis of incentive compatible on-line auctions.
Theoretical Computer Science, 310, 159180.
Lavi, R., & Nisan, N. (2015). Online ascending auctions for gradually expiring items.
Journal of Economic Theory, 156, 4576.
Lipton, R. J., & Tomkins, A. (1994). Online interval scheduling. In In Proceedings of the
Fifth Annual ACM-SIAM Symposium on Discrete Algorithms, Vol. 94, pp. 302311.
Lucier, B., Menache, I., Naor, J. S., & Yaniv, J. (2013). Efficient online scheduling for
deadline-sensitive jobs. In Proceedings of the 25th ACM symposium on Parallelism in
algorithms and architectures, pp. 305314. ACM.
Ma, W., Zheng, B., Qin, T., Tang, P., & Liu, T. (2014). Online mechanism design for cloud
computing. CoRR, abs/1403.1896.
Mashayekhy, L., Nejad, M. M., Grosu, D., & Vasilakos, A. V. (2014). Incentive-compatible
online mechanisms for resource provisioning and allocation in clouds. In Cloud Computing (CLOUD), 2014 IEEE 7th International Conference on, pp. 312319. IEEE.
Nguyen, K. T. (2011). Improved online scheduling in maximizing throughput of equal length
jobs. In Computer ScienceTheory and Applications, pp. 429442. Springer.
Nisan, N. (2007). Introduction to mechanism design (for computer scientists). Algorithmic
game theory, 209, 242.
Nisan, N., & Ronen, A. (2001). Algorithmic mechanism design. Games and Economic
Behavior, 35, 166196.
Parkes, D. C. (2007). Online mechanisms. Algorithmic Game Theory, ed. N. Nisan, T.
Roughgarden, E. Tardos, and V. Vazirani, Cambridge University Press, 411439.
460

fiEfficient Mechanism Design for Online Scheduling

Porter, R. (2004). Mechanism design for online real-time scheduling. In Proceedings of the
5th ACM conference on Electronic commerce, pp. 6170. ACM.
Ting, H.-F. (2008). A near optimal scheduler for on-demand data broadcasts. Theoretical
Computer Science, 401 (1), 7784.
Wu, X., Gu, Y., Li, G., Tao, J., Chen, J., & Ma, X. (2014). Online mechanism design for
VMS allocation in private cloud. In Network and Parallel Computing, pp. 234246.
Springer.
Zaman, S., & Grosu, D. (2012). An online mechanism for dynamic vm provisioning and
allocation in clouds. In 5th International Conference on Cloud Computing (CLOUD),
pp. 253260. IEEE.
Zhang, H., Li, B., Jiang, H., Liu, F., Vasilakos, A. V., & Liu, J. (2013). A framework for
truthful online auctions in cloud computing with heterogeneous user demands. In
Proceedings of INFOCOM, pp. 15101518. IEEE.
Zheng, F., Fung, S. P., Chan, W.-T., Chin, F. Y., Poon, C. K., & Wong, P. W. (2006). Improved on-line broadcast scheduling with deadlines. In Computing and Combinatorics,
pp. 320329. Springer.

461

fi