Journal of Artificial Intelligence Research 56 (2016) 463-515

Submitted 12/15; published 07/16

Computing Repairs of Inconsistent DL-Programs over EL Ontologies
EITER @ KR . TUWIEN . AC . AT

Thomas Eiter
Michael Fink
Daria Stepanova

FINK @ KR . TUWIEN . AC . AT
DASHA @ KR . TUWIEN . AC . AT

Institut fr Informationssysteme, TU Wien,
Favoritenstrae 9-11, 1040 Vienna, Austria

Abstract
Description Logic (DL) ontologies and non-monotonic rules are two prominent Knowledge
Representation (KR) formalisms with complementary features that are essential for various applications. Nonmonotonic Description Logic (DL) programs combine these formalisms thus providing support for rule-based reasoning on top of DL ontologies using a well-defined query interface
represented by so-called DL-atoms. Unfortunately, interaction of the rules and the ontology may
incur inconsistencies such that a DL-program lacks answer sets (i.e., models), and thus yields no
information. This issue is addressed by recently defined repair answer sets, for computing which
an effective practical algorithm was proposed for DL-Lite A ontologies that reduces a repair computation to constraint matching based on so-called support sets. However, the algorithm exploits
particular features of DL-Lite A and can not be readily applied to repairing DL-programs over
other prominent DLs like EL. Compared to DL-Lite A , in EL support sets may neither be small
nor only few support sets might exist, and completeness of the algorithm may need to be given
up when the support information is bounded. We thus provide an approach for computing repairs
for DL-programs over EL ontologies based on partial (incomplete) support families. The latter are
constructed using datalog query rewriting techniques as well as ontology approximation based on
logical difference between EL-terminologies. We show how the maximal size and number of support sets for a given DL-atom can be estimated by analyzing the properties of a support hypergraph,
which characterizes a relevant set of TBox axioms needed for query derivation. We present a declarative implementation of the repair approach and experimentally evaluate it on a set of benchmark
problems; the promising results witness practical feasibility of our repair approach.

1. Introduction
Description Logics (DLs) are a powerful formalism for Knowledge Representation (KR) that is
used to formalize domains of interest by describing the meaning of terms and relationships between
them. They are well-suited for terminological modelling in contexts such as, the Semantic Web, data
integration and ontology-based data access (Calvanese, De Giacomo, Lenzerini, Lembo, Poggi, &
Rosati, 2007b; Calvanese, De Giacomo, Lembo, Lenzerini, Poggi, & Rosati, 2007a), reasoning
about actions (Baader, Lutz, Milicic, Sattler, & Wolter, 2005), spatial reasoning (zccep & Mller,
2012), or runtime verification and program analysis (Baader, Bauer, & Lippmann, 2009; Kotek,
Simkus, Veith, & Zuleger, 2014), to mention a few.
As most DLs are fragments of classical first-order logic, they have some shortcomings for modelling application settings, where nonmonotonicity or closed-world reasoning needs to be expressed.
Rules as in nonmonotonic logic programming offer these features. In addition, they serve well as
a tool for declaring knowledge and reasoning about individuals, and for modelling nondeterminism in model generation as possible in Answer Set Programming. To get the best out of the two
c
2016
AI Access Foundation. All rights reserved.

fiE ITER , F INK & S TEPANOVA



(1) Blacklisted  Staff




 (2) StaffRequest  hasAction.Action  hasSubject.Staff  hasTarget.Project
O = (3) BlacklistedStaffRequest  StaffRequest  hasSubject.Blacklisted



(4) StaffRequest(r1 ) (5) hasSubject(r1 , john) (6) Blacklisted (john)



(7) hasTarget(r1 , p1 ) (8) hasAction(r1 , read ) (9) Action(read )


(10) projfile(p1 ); (11) hasowner (p1 , john);






 (12) chief (Y )  hasowner (Z , Y ), projfile(Z );









(13) grant(X)  DL[Project  projfile; StaffRequest](X), not deny(X);
P=




 (14) deny(X)  DL[Staff  chief ; BlacklistedStaffRequest](X);





(15)


hasowner
(Y,
Z),
not
grant(X),






DL[; hasTarget](X, Y ), DL[; hasSubject](X, Z).















Figure 1: DL-program  over a policy ontology
worlds of DLs and nonmonotonic rules, the natural idea of combining them led to a number of
approaches for such a combination, which are often called hybrid knowledge bases; see the work
of Motik and Rosati (2010) and references therein. Among them, Nonmonotonic Description Logic
(DL-)programs (Eiter, Ianni, Lukasiewicz, Schindlauer, & Tompits, 2008) are a prominent approach
in which so-called DL-atoms serve as query interfaces to the ontology in a loose coupling and enable a bidirectional information flow between the rules and the ontology. The possibility to add
information from the rules part prior to query evaluation allows for adaptive combinations. However, the loose interaction between rules and ontology can easily lead to inconsistency, that is to a
lack of models or answer sets.
Example 1 Consider the DL-program  = hO, Pi in Figure 1 formalizing an access policy over
an ontology O = hT , Ai (Bonatti, Faella, & Sauro, 2010), whose taxonomy (TBox) T is given
by (1)-(3), while (4)-(9) is a sample data part (ABox) A. Besides facts (10), (11) and a simple
rule (12), the rule part P contains defaults (13), (14) expressing that staff members are granted
access to project files unless they are blacklisted, and a constraint (15), which forbids that owners of project information lack access to it. Both parts, P and O, interact via DL-atoms such as
DL[Project  projfile; StaffRequest](X). The latter specifies a temporary update of O via the operator , prior to querying it; i.e. additional assertions Project(c) are considered for each individual c, such that projfile(c) is true in an interpretation of P, before all instances X of StaffRequest
are retrieved from O. Inconsistency arises as john, the chief of project p1 and owner of its files,
has no access to them.
Inconsistency is a well-known problem in logic-based and data intensive systems, and the problem of treating logically contradicting information has been studied in various fields, e.g. belief
revision (Alchourrn, Grdenfors, & Makinson, 1985; Grdenfors & Rott, 1995), knowledge base
updates (Eiter, Erdem, Fink, & Senko, 2005), diagnosis (Reiter, 1987), ontology based data access (Lembo, Lanzerini, Rosati, Ruzzi, & Savo, 2015), nonmonotonic reasoning (Brewka, 1989;
Sakama & Inoue, 2003), and many others; (cf. Bertossi, Hunter, & Schaub, 2005; Nguyen, 2008;
Martinez, Molinaro, Subrahmanian, & Amgoud, 2013; Bertossi, 2011). In hybrid formalisms so
far inconsistency management has concentrated mostly on inconsistency tolerance. For instance,
464

fiC OMPUTING R EPAIRS OF I NCONSISTENT DL-P ROGRAMS OVER EL O NTOLOGIES

for MKNF knowledge bases paraconsistent semantics was developed by Knorr, Alferes, and Hitzler
(2008), Huang, Li, and Hitzler (2013) and Kaminski, Knorr, and Leite (2015). For DL-programs inconsistency tolerance issues were targeted by Fink (2012), where a paraconsistent semantics based
on the Logic of Here and There was introduced. Furthermore, Phrer, Heymans, and Eiter (2010)
considered suppressing certain problematic DL-atoms. These approaches aimed at reasoning in
an inconsistent system rather then making required changes to the system to arrive at a consistent
state. This is in contrast to repair techniques that have been recently developed by Eiter, Fink, and
Stepanova (2013, 2014d).
In the theoretical framework for repairing inconsistent DL-programs proposed by Eiter et al.
(2013), the ontology ABox (a likely source of errors) is changed such that the modified DL-program
has answer sets, called repair answer sets. Different repair options including deletion of ABox formulas and various restricted forms of addition have been considered together with a naive algorithm
for computing repair answer sets which lacked practicality.
An effective repair algorithm in which all DL-atoms can be decided without dynamic ontology
access was presented by Eiter, Fink, and Stepanova (2015). It is based on support sets (Eiter, Fink,
Redl, & Stepanova, 2014b) for DL-atoms, the portions of the input that together with the ABox
determine the truth value of the DL-atom. The algorithm exploits complete support families, i.e.
stocks of support sets from which the value of a DL-atom under every interpretation can be determined, such that an (repeated) ontology access can be avoided. The approach works well for
DL-Lite A , which is a prominent tractable DL, since complete support families are small and easy
to compute.
However, unfortunately, for other DLs this approach is not readily usable, because in general
there can be large or infinite support families. This applies even for EL, which is another wellknown important DL that offers tractable reasoning and is widely applied in many domains, including biology, (cf. e.g., Schulz, Cornet, & Spackman, 2011; Aranguren, Bechhofer, Lord, Sattler, &
Stevens, 2007), medicine (Steve, Gangemi, & Mori, 1995), chemistry, policy management, etc. Due
to the features of EL that include range restrictions and concept conjunctions on the left-hand side
of inclusion axioms, a DL-atom accessing an EL ontology can have arbitrarily large and infinitely
many support sets in general. While the latter is excluded for acyclic TBoxes, often occurring in
practice (Gardiner, Tsarkov, & Horrocks, 2006), complete support families can be still very large,
and constructing as well as managing them might be impractical. This obstructs the deployment of
the approach proposed by Eiter et al. (2014d) to EL ontologies. In this paper we tackle this issue and
develop repair computation techniques for DL-programs over ontologies in EL. We focus on EL,
since apart from being simple and widely used, this DL is well-researched, and available effective
algorithms for query rewriting and other important reasoning can be readily used.
More specifically, we introduce here a more general algorithm for repair answer set computation that operates on partial (incomplete) support families along with techniques how such families
can be effectively computed. The problem of computing repair answer sets for DL-programs over
EL ontologies is P2 -complete (in its formulation as a decision problem; we refer to the work of
Stepanova (2015) for details on the complexity).
Our contributions and advances over previous works by Eiter et al. (2014b, 2014d, 2015) are
summarized as follows:
 For effective computation of repair answer sets we exploit the support sets of Eiter et al.
(2014d). In contrast to the approaches of Eiter et al. (2014d, 2015), however, where TBox
classification is invoked, we use datalog rewritings of queries for computing support sets
465

fiE ITER , F INK & S TEPANOVA

(see also Hansen, Lutz, Seylan, & Wolter, 2014). We introduce the notion of partial support
families, with which ontology reasoning access can be completely eliminated.
 As in general constructing complete support families is not always feasible for EL ontologies, we provide novel methods for computing partial support families by exploiting ontology
approximation techniques based on the logical difference between EL-terminologies as considered by Konev, Ludwig, Walther, and Wolter (2012) and Ludwig and Walther (2014).
 To capture restricted classes of TBoxes, for which complete support families can still be
effectively computed, we consider a support hypergraph for DL-atoms, which is inspired
by ontology hypergraphs (Nortje, Britz, & Meyer, 2013; Ecke, Ludwig, & Walther, 2013).
The support hypergraph serves to characterize the TBox parts that are relevant for deriving
the query. The analysis of support hypergraphs allows us to estimate the maximal size and
number of support sets that is needed to form a complete support family.
 We generalize the algorithm for repair answer set computation proposed by Eiter et al. (2014d)
such that EL ontologies can be handled. The novel algorithm operates on partial support
families, and in principle can be applied to the ontologies in any DLs beyond EL. It uses
hitting sets to disable known support sets of negative DL-atoms and performs evaluation
postchecks if needed to compensate incompleteness of support families. Moreover, it trades
answer completeness for scalability by using minimal hitting sets; however completeness may
be ensured by a simple extension.
 We provide a system prototype with a declarative realization of the novel algorithm for repair
answer set computation. Our repair approach has been evaluated using some novel benchmarks; the results show very promising potential of the proposed approach.
Organization. The rest of the paper is organized as follows. In Section 2, we recall basic notions
and preliminary results. Section 3 deals with support sets and their computation, while Section 4
discusses partial support family construction based on TBox approximation techniques. In Section 5
we analyze properties of a support hypergraph for estimating the maximal size and number of support sets in a complete support family for a DL-atom. In Section 6, the algorithm for repair answer
set computation and its declarative implementation are presented. Experiments are presented in Section 7, followed by a discussion of related work in Section 8 and concluding remarks in Section 9.

2. Preliminaries
In this section, we recall basic notions of Description Logics, where we focus on EL (Baader,
Brandt, & Lutz, 2005), and DL-programs (Eiter et al., 2008). For more background on Description
Logics, (see Baader, Calvanese, McGuinness, Nardi, & Patel-Schneider, 2003).
2.1 Description Logic Knowledge Bases
We consider Description Logic (DL) knowledge bases (KBs) over a signature O = hI, C, Ri with
a set I of individuals (constants), a set C of concept names (unary predicates), and a set R of role
names (binary predicates) as usual. A DL knowledge base (or ontology) is a pair O = hT , Ai
of a TBox T and an ABox A, which are finite sets of formulas capturing taxonomic resp. factual
466

fiC OMPUTING R EPAIRS OF I NCONSISTENT DL-P ROGRAMS OVER EL O NTOLOGIES

Tnorm


(1) StaffRequest  hasAction.Action




(2)
StaffRequest  hasSubject.Staff




(3)
StaffRequest
 hasTarget.Project



(4) hasAction.Action  ChasA.A
=
(5) hasSubject.Staff  ChasS .St




(6) hasTarget.Project  ChasT .P




(7) ChasA.A  ChasS .St  ChasA.AhasS .St



(8) ChasA.AhasS .St  ChasT .P  StaffRequest

Figure 2: Normalized TBox

























knowledge, whose form depends on the underlying DL. In abuse of notation, we also write O =
T  A viewing O as a set of formulas.
Syntax. In EL, concepts C, denoting sets of objects, and roles R, denoting binary relations
between objects, obey the following syntax, where A  C is an atomic concept and R  R an
atomic role:
C  A |  | C  C | R.C
In EL, TBox axioms are of the form C1  C2 (also called generalized concept inclusion axioms,
GCIs), where C1 , C2 are EL-concepts. ABox formulas are of the form A(c) or R(c, d), where
A  C, R  R, and c, d  I. In the sequel, we use P as a generic predicate from C  R (if the
distinction is immaterial).
An example of an EL ontology is given in Figure 1.
Definition 2 (normalized TBox) A TBox is normalized, if all of its axioms have one of the following forms:
A1  A2
A1  A2  A3
R.A1  A2
A1  R.A2 ,
where A1 , A2 , A3 are atomic concepts.
E.g., the axiom (1) in Example 1 is in normal form, while the axioms (2) and (3) are not. For
any EL TBox, an equivalent TBox in normal form is constructible in linear time (Stuckenschmidt,
Parent, & Spaccapietra, 2009) (over an extended signature)1 (Baader et al., 2005).
A special class of TBoxes widely studied in literature are EL-terminologies, defined as follows:
Definition 3 (EL-terminology) An EL-terminology is an EL TBox T , satisfying the following conditions:
(1) T consists of axioms of the forms A  C and A  C, where A is atomic and C is an
arbitrary EL concept;
(2) no concept name occurs more then once on the left hand side of axioms in T .
For example, the TBox of the ontology in Figure 1 is an EL-terminology.
Semantics. The semantics of DL ontologies is based on first-order interpretations (Baader et al.,
2005). An interpretation is a pair I = hI , I i of a non-empty domain I and an interpretation
1. Linear complexity results are obtained under the standard assumption in DLs that each of the atomic concepts is of
constant size, i.e., the length of a binary string representing an atomic concept does not depend on the particular
knowledge base.

467

fiE ITER , F INK & S TEPANOVA

function I that assigns to each individual c  I an object cI  I , to each concept name C a subset
C I of I , and to each role name R a binary relation RI over I . The interpretation I extends
inductively to non-atomic concepts C and roles R according to the concept resp. role constructors;
as for EL, (R.C)I = {o1 | ho1 , o2 i  RI , o2  C I } and (C  D)I = {o1 | o1  C I , o1  DI }.
Satisfaction of an axiom resp. assertion  w.r.t. an interpretation I, i.e. I |= , is as follows:
(i) I |= C  D, if C I  DI ; (ii) I |= C(a), if aI  C I ; (iii) I |= R(a, b), if (aI , bI )  RI .
Furthermore, I satisfies a set of formulas , denoted I |= , if I |=  for each   .
A TBox T (respectively an ABox A, an ontology O) is satisfiable (or consistent), if some
interpretation I satisfies it. We call an ABox A consistent with a TBox T , if T  A is consistent.
Since negation is neither available nor expressible in EL, all EL ontologies are consistent.
Example 4 The ontology O in Figure 1 is consistent; a satisfying interpretation I = hI , I i
exists, where I = {john, read , p1 , r1 }, Action I = {read }, Blacklisted I = Staff I = {john},
hasSubject I = {r1 , john}, StaffRequest I = BlacklistedStaffRequest I = {r1 }, hasAction I =
{r1 , read }, hasTarget I = {r1 , p1 }.
Throughout the paper, we consider ontologies in EL under the unique name assumption (UNA),
i.e., o1 I 6= o2 I whenever o1 6= o2 holds in any interpretation. However, our results carry over
to ontologies without UNA, as it is not hard to see that the UNA has for EL no effect on query
answering, (cf. Lutz, Toman, & Wolter, 2009).
2.2 DL-Programs
A DL-program  = hO, Pi is a pair of a DL ontology O and a set P of DL-rules, which extend
rules in non-monotonic logic programs with special DL-atoms. They are formed over a signature
 = hC, P, I, C, Ri, where P = hC, Pi is a signature of the rule part P with a set C of constant
symbols and a (finite) set P of predicate symbols (called lp predicates) of non-negative arities, and
O = hI, C, Ri is a DL signature. The set P is disjoint with C, R. For simplicity, we assume
C = I.
Syntax. A (disjunctive) DL-program  = hO, Pi consists of a DL ontology O and a finite set P
of DL-rules r of the form
a1  . . .  an  b1 , . . . , bk , not bk+1 , . . . , not bm

(1)

where not is negation as failure (NAF)2 and each ai , 0  i  n, is a first-order atom p(~t) with
predicate p  P (called ordinary or lp-atom) and each bi , 1  i  m, is either an lp-atom or a DLatom. The rule is a constraint, if n = 0, and normal, if n  1. We call H(r) = {a1 , . . . , an } the
head of r, and B(r) = {b1 , . . . , bk , not bk+1 , . . . , not bm } the body of r. B + (r) = {b1 , . . . , bk }
and B  (r) = {bk+1 , . . . , bm } denote the positive and the negative parts of B(r) respectively.
A DL-atom d(~t) is of the form
DL[; Q](~t),
(2)
where
(a)  = S1 op 1 p1 , . . . , Sm op m pm , m  0 is the input list and for each i, 1  i  m, Si 
C  R, op i  {} is an update operator, and pi  P is an input predicate of the same arity
as Si ; intuitively, op i =  increases Si by the extension of pi ;
2. Strong negation a can be added resp. emulated as usual (Eiter et al., 2008).

468

fiC OMPUTING R EPAIRS OF I NCONSISTENT DL-P ROGRAMS OVER EL O NTOLOGIES

(b) Q(~t) is a DL-query, which has one of the forms (i) C(t), where C is a concept and t is a
term; (ii) R(t1 , t2 ), where R is a role and t1 , t2 are terms; (iii) C1  C2 and ~t = .
Note that inclusion DL-queries of the form C1  C2 can be easily reduced to instance queries.3
Thus for simplicity, we consider in this work only instance DL-queries.
Example 5 Consider a DL-atom DL[Project  projfile; StaffRequest](X ) in the rule (13) of 
in Figure 1 for X = r1 . It has a DL-query StaffRequest(r1 ); its list  = Project  projfile
contains an input predicate projfile which extends the ontology predicate Project via an update
operator .
Semantics. The semantics of a DL-program
S  = hO, Pi is given in terms of its grounding
gr() = hO, gr(P)i over C, i.e., gr(P) = rP gr(r) contains all possible ground instances of
all rules r in P over C. In the remainder, by default we assume that  is ground.
A (Herbrand) interpretation of  is a set I  HB  of ground atoms, where HB  is the Herbrand base for P =hC, Pi, i.e. the set of all ground atoms over P ; I satisfies an lp- or DL-atom a,
if
(i) a  I, if a is an lp-atom, and
(ii) O  I (a) |= Q(~t) where O = hT , Ai, if a is a DL-atom of form (2), where
I (d) =

m
[

Ai (I) and Ai (I) = {Si (~t) | pi (~t)  I}, 1  i  m.

(3)

i=1

Satisfaction of a DL-rule r (resp. a set P of rules) by a Herbrand interpretation I of  = hP, Oi
is then as usual, where I satisfies not bj , if I does not satisfy bj ; I satisfies , if it satisfies each
r  P. By I |=O  we denote that I satisfies (is a model of) an object , where  can be an (DL)atom, a rule or a set of rules; the superscript O of |= specifies the ontology on which DL-atoms are
evaluated. A model I of  is minimal, if no model I  of  exists such that I   I.
Example 6 The DL-atom d = DL[Project  projfile; StaffRequest](r1 ) is satisfied by the interpretation I = {projfile(p1 ), hasowner (p1 , john)}, since O |= StaffRequest(r1 ). For O =

O\{StaffReqeust(r1 )} it still holds that I |=O d, as O  I (d) |= StaffRequest(r1 ).
Repair Answer Sets. Various semantics for DL-programs extend the answer set semantics of logic
programs (Gelfond & Lifschitz, 1991) to DL-programs, (e.g., Eiter et al., 2008; Lukasiewicz, 2010;
Wang, You, Yuan, & Shen, 2010; Shen, 2011). We concentrate here on weak answer sets (Eiter
et al., 2008), which treat DL-atoms like atoms under NAF, and flp-answer sets (Eiter, Ianni, Schindlauer, & Tompits, 2005), which obey a stronger foundedness condition. Both are like answer sets
of an ordinary logic program interpretations that are minimal models of a program reduct, which
intuitively captures that assumption-based application of the rules can reconstruct the interpretation.
I,O
of P relative to O and to I  HB results from gr(P) by deleting
The weak -reduct Pweak
(i) all rules r such that either I 6|=O d for some DL-atom d  B + (r), or I |=O l for some l  B  (r);
(ii) all DL-atoms in B + (r) and all literals in B  (r).
3. Evaluating d = DL[; C1  C2 ]() over O = T  A reduces to evaluating d = DL[; AC2 ](a) over O =
T  {AC1  C1 , C2  AC2 }  A  {AC1 (a)}, where a is a fresh constant and AC1 , AC2 are fresh concepts (similar
as in TBox normalization).

469

fiE ITER , F INK & S TEPANOVA

I,O
The flp-reduct Pflp
of P results from gr(P) by deleting all rules r, whose bodies are not
O
satisfied by I, i.e. I 6|= bi , for some bi , 1  i  k or I |=O bj , for some bj , k < j  m. We
illustrate the notions on an example.

Example 7 Let O be as in Figure 1, and let the rule set P contain the facts (10), (11) and the rules
(12), (13) with X, Y, Z instantiated to r1 , john, p1 respectively. Consider the interpretation I =
I,O
{projfile(p1 ), hasowner (p1 , john), chief (john), grant(r1 )}. While the flp-reduct Pflp
contains
I,O
all rules of P, in the weak -reduct Pweak
the rule (13) is replaced by the fact grant(r1 ).

Definition 8 (x-deletion repair answer set) An interpretation I is an x-deletion repair answer set

of  = hT  A, Pi for x  {flp, weak }, if it is a minimal model of PxI,T A , where A  A; any
such A is called an x-deletion repair of . If A = A, then I is a standard x-answer set.
Example 9 I = {projfile(p1 ), chief (john), hasowner (p1 , john), grant(john)} is both a weak
and flp-repair answer set of  in Example 1 with a repair A = A\{Blacklisted (john)}.
Notation. We denote for any normal logic program P by AS (P) the set of all answer sets of P,
and for any DL-program  by AS x () (resp. RAS x ()) the set of all x-answer sets (resp. x-repair
answer sets) of .
In general an flp-answer set is a weak -answer set, but not vice versa, i.e. flp-answer sets are
a more restrictive notion; however, in many cases weak and flp answer sets coincide. For more
information on the reducts, see works by Eiter et al. (2008) and Wang et al. (2010).
Shifting Lemma. To simplify matters and avoid dealing with the logic program predicates separately, we shall shift as Eiter et al. (2014d) the lp-input of DL-atoms to the ontology. Given a
DL-atom d = DL[; Q](~t) and P  p  , we call Pp (c) an input assertion for d, where Pp
is a fresh ontology predicate and c  C; Ad is the set of all such assertions. For a TBox T and
a DL-atom d, we let Td = T  {Pp  P | P  p  }, and for an interpretation I, we let
OdI = Td  A  {Pp (~t)  Ad | p(~t)  I}. We then have:
Proposition 10 (Eiter et al., 2014d) For every O = T  A, DL-atom d = DL[; Q](~t) and interI
pretation I, it holds that I |=O d iff I |=Od DL[; Q](~t) iff OdI |= Q(~t).
Unlike OI (d), in OdI there is a clear distinction between native assertions and input assertions
for d w.r.t. I (via facts Pp and axioms Pp  P ), mirroring its lp-input. Note that if T is in normal
form, then also Td is in normal form.

3. Support Sets for DL-Atoms
In this section, we recall support sets for DL-atoms by Eiter et al. (2014b), which are an effective
optimization means for (repair) answer set computation (Eiter et al., 2014d). Intuitively, a support
set for a DL-atom d = DL[; Q](~t) is a portion of its input that, together with ABox assertions,
is sufficient to conclude that the query Q(~t) evaluates to true; i.e., given a subset I   I of an
interpretation I and a set A  A of ABox assertions from the ontology O, we can conclude
that I |=O Q(~t). Basically, our method suggests precomputing support sets for each DL-atom at the
nonground level. During DL-program evaluation, for each candidate interpretation ground instances
of support sets are computed, which help to prune the search space for (repair) answer sets.
470

fiC OMPUTING R EPAIRS OF I NCONSISTENT DL-P ROGRAMS OVER EL O NTOLOGIES

Exploiting Proposition 10 we have the following definition of support sets using only ontology
predicates.
Definition 11 (ground support sets) Given a ground DL-atom d = DL[; Q](~t), a set S  AAd
is a support set for d w.r.t. an ontology O = hT , Ai, if Td  S |= Q(~t). By Supp O (d) we denote the
set of all support sets S for d w.r.t. O.
Support sets are grouped into families of support sets or simply support families. More formally,
Definition 12 (support family) Any collection S  Supp O (d) of support sets for a DL-atom d
w.r.t. an ontology O is a support family of d w.r.t. O.
In general and for EL in particular, even -minimal support sets can be arbitrarily large and
infinitely many support sets may exist (not for acyclic TBoxes T , where still exponentially many
support sets are possible). However, we nonetheless can exploit them for the repair answer set
computation algorithms in Section 6.
Support sets are linked to interpretations by the following notion.
Definition 13 (coherence) A support set S of a DL-atom d is coherent with an interpretation I, if
for each Pp (~c)  S it holds that p(c)  I.
Example 14 The DL-atom d = DL[Project  Projfile; StaffRequest](r1 ) from Figure 1 has two
support sets: S1 = {StaffRequest(r1 )} and S2 = {hasSubject(r1 , john),Projectprojfile (p1 ),
Staff (john),hasAction(r1 , read ), Action(read )}. S1 is coherent with any interpretation, while
S2 is coherent only with interpretations I  {projfile(p1 )}.
The evaluation of d w.r.t. I then reduces to the search for coherent support sets.
Proposition 15 Let d = DL[; Q](~t) be a ground DL-atom, let O = hT , Ai be an ontology, and
let I be an interpretation. Then, I |=O d iff some S  Supp O (d) exists s.t. S is coherent with I.
Using a sufficient portion of support sets, we can completely eliminate the ontology access for
the evaluation of DL-atoms. In a naive approach, one precomputes all support sets for all ground DLatoms with respect to relevant ABoxes, and then uses them during the repair answer set computation.
This does not scale in practice, since support sets may be computed that are incoherent with all
candidate repair answer sets.
An alternative is to fully interleave the support set computation with the search for repair answer
sets. Here we construct coherent ground support sets for each DL-atom and interpretation on the
fly. As the input to a DL-atom may change in different interpretations, its support sets must be
recomputed, however, since reuse may not be possible; effective optimizations are not immediate.
A better solution is to precompute support sets at the nonground level, that is, schematic support
sets, prior to repair computation. Furthermore, in that we may leave the concrete ABox open; the
support sets for a DL-atom instance are then easily obtained by syntactic matching.
~ = DL[; Q](X)
~ be a
Definition 16 (nonground support sets) Let T be a TBox, and let d(X)
~
nonground DL-atom. Suppose V  X is a set of distinct variables and C is a set of constants. A
nonground support set for d w.r.t. T is a set S = {P1 (Y~1 ), . . . , Pk (Y~k )} of atoms such that
471

fiE ITER , F INK & S TEPANOVA

(i) Y~1 , . . . , Y~k  V and
~k )} is a support set
(ii) for each substitution  : V  C, the instance S = {P1 (Y~1 ), . . . , Pk (Y
~
for d(X) w.r.t. OC = T  AC , where AC is the set of all possible ABox assertions over C.
For any ontology O = T  AC , we denote by SuppO (d) the set of all nonground support sets for
d w.r.t. T .
Here AC takes care of any possible ABox, by considering the largest ABox (since O  O
implies that Supp O (d)  Supp O (d)).
Example 17 For d = DL[Project  projfile; StaffRequest](X ) the set S1 = {StaffRequest(X )}
is a nonground support set, and likewise the set S2 = {Action(W ), Staff (Y ), hasSubject(X , Y ),
hasTarget(X , Z ), Projectprojfile (Z ), hasAction(X , W )}.
If a sufficiently large portion of nonground support sets is precomputed, then the ontology access
can be fully avoided. We call such a portion a complete support family.
Definition 18 (complete support family) A family S  SuppO (d) of nonground support sets for
~ w.r.t. an ontology O is complete, if for every support set S 
a (non-ground) DL-atom d(X)
~
~
~ exist
Supp O (d(X)), where : X  C, some S   S and an extension  : V  C of  to V  X


such that S = S  .
Example 19 Consider the DL-atom d(X) = DL[Project  projfile; StaffRequest](X) from Figure 1. The family S = {S1 , S2 , S3 , S4 , S5 , S6 } is complete for d w.r.t. O, where hT = hasTarget,
hS = hasSubject and hA = hasAction:







S1
S2
S3
S4
S5
S6

= {StaffRequest(X )};
= {Project(Y ), hT (X , Y ), hS (X , Z ), Staff (Z ), hA(X , Z  ), Action(Z  )};
= {Projectprojfile (Y ), hT (X , Y ), hS (X , Z ), Staff (Z ), hA(X , Z  ), Action(Z  )};
= {Project(Y ), hT (X , Y ), hS (X , Z ), Blacklisted (Z ), hA(X , Z  ), Action(Z  )};
= {Projectprojfile (Y ), hT (X , Y ), hS (X , Z ), Blacklisted (Z ), hA(X , Z  ), Action(Z  )};
= {BlacklistedStaffRequest(X )}.


We say that two nonground support sets (resp. support families) are ground-identical, if their
groundings coincide. E.g., the support sets S1 = {P (X), r(X, Y )} and S2 = {P (X), r(X, Z)} are
ground-identical for a DL-atom d(X) = DL[; Q](X), and so are the respective support families
{S1 } and {S2 }.
Definition 20 (subsumption) A nonground support set S is subsumed by S  , denoted by S   S,
if for every ground instance S of S some ground instance S   of S  exists such that S    S.
For nonground support families, we say that S1 is subsumed by S2 , denoted S2  S1 , if for each
instance S of S  S1 some instance S   of S  in S2 exists such that S    S holds.
Example 21 S = {BlacklistedStaffRequest(X ),hasSubject(X , Y ),Blacklisted (Y )} is a support
set for the DL-atom d(X) = DL[Staff  chief ; BlacklistedStaffRequest](X) w.r.t. T from Figure 1, which is subsumed by S  = {BlacklistedStaffRequest(X )}, i.e. S   S. Moreover,
S  S, where S = {S  } and S ={S}, while the support families S = {S, S  } and S = {S,
{BlacklistedStaffRequest(X ),hasSubject(X , Z ),Blacklisted (Z )}} mutually subsume each other.
472

fiC OMPUTING R EPAIRS OF I NCONSISTENT DL-P ROGRAMS OVER EL O NTOLOGIES

Axiom
Datalog rule
A1  A2
A2 (X)  A1 (X)
A1  A2  A3 A3 (X)  A1 (X), A2 (X)
R.A2  A1 A1 (X)  R(X, Y ), A2 (Y )
A1  R.A2
R(X, oA2 )  A1 (X)
A2 (oA2 )  A1 (X)

Table 1: EL TBox Rewriting
Definition 22 (maximal support set size, maxsup) The maximal support set size of a DL-atom d
w.r.t. T , denoted by maxsup(d ), is the smallest integer n  0 such that for every complete nonground support family S for d w.r.t. T and support set S  S with |S| > n, a support set S   S
exists for d w.r.t. T in Suppd (O) with |S  |  n.
For instance, for the DL-atom d and the TBox T from Example 19, the maximal support set
size is 6, i.e., maxsup(d) = 6.
3.1 Computing Support Sets
In this section, we provide methods for constructing nonground support sets. A natural approach
for the computation of nonground support sets is to exploit (conjunctive) query answering methods
in EL (e.g., Rosati, 2007; Lutz et al., 2009; Kontchakov, Lutz, Toman, Wolter, & Zakharyaschev,
2010; Stefanoni, Motik, & Horrocks, 2012).
Suppose we are given a DL-program  = hO, Pi, where O = hT , Ai is an EL ontology, and
~ = DL[; Q](X).
~ Our method to construct nonground support sets for d(X)
~ has
a DL-atom d(X)
the following three steps.
Step 1. DL-query Rewriting over the TBox. The first step exploits the rewriting of the DL~ over the TBox Td = T  {Pp  P | P  p  } into a set of datalog rules.
query Q of d(X)
At a preprocessing stage, the TBox Td is normalized. This technique restricts the syntactic form
of TBoxes by decomposing complex into simpler axioms. For this purpose, a set of fresh concept
symbols is introduced. Once the normalized form Td norm of Td is computed, we rewrite the part of
the TBox that is relevant for the query Q into a datalog program Prog Q,Tdnorm using the translation
given in Table 1, which is a variant of a translation by Prez-Urbina, Motik, and Horrocks (2010)
and Zhao, Pan, and Ren (2009). When rewriting axioms of the form A1  R.A2 (fourth axiom
in Table 1), we introduce fresh constants (oA2 ) to represent unknown objects. A similar rewriting
is exploited in the R EQUIEM system (Prez-Urbina et al., 2010), where function symbols are used
instead of fresh constants. As a result we obtain:
Lemma 23 For every data part, i.e., ABox A, and every ground assertion Q(~c), deciding whether
Prog Q,Tdnorm  A |= Q(~c) is equivalent to checking Td norm  A |= Q(~c).
Step 2. Query Unfolding. The second step proceeds with the standard unfolding of the rules of
Prog Q,Td norm w.r.t. the target DL-query Q. We start with a rule that has Q in the head and expand
its body using other rules of the program Prog Q,Tdnorm . By applying this procedure exhaustively,
we get a number of rules which correspond to the rewritings of the query Q over Td norm . Note
that it is not always possible to obtain all of the rewritings effectively, since in general there might
473

fiE ITER , F INK & S TEPANOVA

Prog Q,Td norm

 
(4 ) ChasA.A (X )  hasAction(X , Y ), Action(Y ).




(5 ) ChasS .St (X )  hasSubject(X , Y ), Staff (Y ).


 
(6 ) ChasT .P (X )  hasTarget(X , Y ), Project(Y ).
=

(7
) ChasA.AhasS .St (X )  ChasA.A (X ), ChasS .St (X ).





(8
)
StaffRequest(X )  ChasA.AhasS .St (X ), ChasT .P (X ).



(9) Project(X )  Projectprojfile (X ).

















Figure 3: DL-query Rewriting for DL[Project  projfile; StaffRequest](X) over Td norm
be infinitely many of them if T is cyclic, and still exponentially many for acyclic T ; we discuss
techniques for computing partial support families in the next section.
Step 3. Support Set Extraction. The last step extracts nonground support sets from the rewritings
of Step 2. We select those containing only predicates from Td and obtain rules r of the form
~  P1 (Y~1 ), . . . , Pk (Y~k ), Pk+1
~k+1 ), . . . , Pnp (Y~n ),
Q(X)
(Y
(4)
pk+1

n

where each Pi is a native ontology predicate if 1  i  k, and a predicate mirroring lp-input of d
otherwise. The bodies of such rules correspond to the support sets for a given DL-atom, i.e.
~k+1 ), . . . , Pnp (Y
~n )}
S = {P1 (Y~1 ), . . . , Pk (Y~k ), Pk+1
(Y
(5)
pk+1

n

Now the following holds.
~ = DL[; Q](X)
~ be a DL-atom of a program  = hO, Pi with an EL
Proposition 24 Let d(X)
~
ontology O = hT , Ai. Every set S constructed in Steps 1-3 is a nonground support set for d(X).
By the Shifting Lemma, when working with support sets we can focus on the ontology predicates
and operate only on them. More specifically, rules of the form (4) for k  n fully reflect nonground
support sets as of Definition 16, and ground instantiations of such a rule over constants from C
implicitly correspond to ground support sets.
We now illustrate the computation of nonground support sets for DL-atoms over EL ontologies.
Example 25 Consider a DL-atom DL[Project  projfile; StaffRequest](X) accessing an EL ontology O = hT , Ai from Figure 1. The datalog rewriting for d computed at Step 1 is given in
Figure 3. In Step 2 we obtain the following query unfoldings for StaffRequest:
(1) StaffRequest(X)  StaffRequest(X);
(2) StaffRequest(X)  hasAction(X, Y ), Action(Y ), hasSubject(X, Y  ),
Staff (Y  ), hasTarget(X, Y  ), Projectprojfile (Y  );
(3) StaffRequest(X)  hasAction(X, Y ), Action(Y ), hasSubject(X, Y  ),
Staff (Y  ), hasTarget(X, Y  ), Project(Y  );
(4) StaffRequest(X)  hasAction(X, Y ), Action(Y ), hasSubject(X, Y  ),
Blacklisted (Y  ), hasTarget(X, Y  ), Project(Y  );
(5) StaffRequest(X)  hasAction(X, Y ), Action(Y ), hasSubject(X, Y  ),
Blacklisted (Y  ), hasTarget(X, Y  ), Projectprojfile (Y  ).
In Step 3 we thus get from the rule (2) S2 = {hasAction(X, Y ), Action(Y ), Staff (Y  ),
hasSubject(X, Y  ), hasTarget(X, Y  ), Projectprojfile (Y  )} and from rule (3) S3 ={Action(Y ),
hasAction(X, Y ),Staff (Y  ),hasSubject(X, Y  ), Project(Y  ),hasTarget(X, Y  )}. From (1), (4)
and (5) the remaining support sets are similarly obtained.

474

fiC OMPUTING R EPAIRS OF I NCONSISTENT DL-P ROGRAMS OVER EL O NTOLOGIES

3.2 Partial Support Families
Finding all support sets for a DL-atom is tightly related to computing all solutions to a logic-based
abduction problem. Abduction is an important mode of reasoning widely applied in different areas
of AI including planning, diagnosis, natural language understanding and many others (Console,
Sapino, & Dupr, 1995). Various variants of this problem were actively studied, e.g. by Eiter,
Gottlob, and Leone (1997) and Bienvenu (2008). Unfortunately, most of the practically important
problems in the context of abduction are intractable even for restricted propositional theories (Eiter
& Makino, 2007). The abduction problem for EL TBoxes has been considered by Bienvenu (2008),
represented by a tuple hT , H, Oi, with a TBox T , a set of atomic concepts H and an atomic concept
O. An explanation is a set {A1 , . . . , An }  H, such that T |= A1  . . .  An  O. If the
ABox A  Ad contains only atomic concepts, then computing all nonground support sets for d =
DL[; Q](X) accessing O = hT , Ai corresponds to an abduction problem hTd , sig(A  Ad ), Qi.
If roles occur in A  Ad , then one has to introduce new fresh concepts to construct the complex
concepts as hypothesis, e.g., for R.A an inclusion CR.A  R.A can be added to Td , and CR.A
to H, where CR.A is a fresh concept.
Unlike for DL-Lite A , support families for DL-atoms over EL ontologies have no particular
structure; they can be large, and maximal support set size can be exponential in the size of T .
Example 26 Consider the following acyclic TBox T , which contains the axioms:
(1) r.B0  s.B0  B1
(2) r.B1  s.B1  B2
...
(n) r.Bn1  s.Bn1  Bn
For d1 = DL[; B1 ](X1 ), the maximal support set size is 4, which is witnessed by
S1 = {r(X1 , X2 ), B0 (X2 ), s(X1 , X3 ), B0 (X3 )}.

For the DL-atom d2 = DL[; B2 ](X1 ), we have maxsup(d2 ) = 10, due to S2 = {r(X1 , X2 ),
r(X2 , X3 ), B0 (X3 ), s(X2 , X4 ), B0 (X4 ), s(X1 , X5 ), r(X5 , X6 ), B0 (X6 ), s(X5 , X7 ), B0 (X7 )}.
Moreover, for di = DL[; Bi ](X), we have maxsup(di ) = maxsup(di1 )  2 + 2, 1  i  n.
Note that the maximal support set for dn involves n + 3 predicates. Therefore, if the TBox is
of the above form, and |sig(T )|= k, a lower bound for the worst case support set size for d is
2k1 + 2 = (2k ), which is single exponential in the size of T .

While in general many unfoldings can be produced at Step 2, according to recent results of
Hansen et al. (2014), complete support families for EL can be computed for large classes of ontologies. Therefore, we still exploit support families, but unlike Eiter et al. (2014d) we do not require
them to be complete, and develop techniques for computing partial (i.e. incomplete) support families for DL-atoms. A natural approach in this context is to aim at finding support sets of bounded
size. In general, due to cyclic dependencies such as r.C  C, which are possible in EL but not
in DL-Lite A , support sets can be arbitrary large. An analysis of a vast number of ontologies has
revealed that in many realistic cases ontologies do not contain (nor imply) cyclic axioms (Gardiner
et al., 2006); we thus assume for practical considerations that the TBox of the ontology in a given
DL-program is acyclic, i.e., it does not entail inclusion axioms of form r.C  C. However, even
under this restriction support sets can be large as Example 26 shows.
475

fiE ITER , F INK & S TEPANOVA

If computing complete support families is computationally too expensive, a natural approach
is to produce only support sets of a certain size k using e.g. limited program unfolding. When an
unfolding branch reaches the depth k, we stop and expand a different branch. Similarly, we can compute a limited number k of support sets by stopping the rule unfolding of the program Prog Q,Tdnorm
once the k-th support set is produced. An alternative approach, based on TBox approximation
techniques, is pursued in the next section.

4. Partial Support Family Construction via TBox Approximation
We now provide practical methods to construct partial support families using TBox approximation.
4.1 TBox Approximation
The approximation of DL ontologies over a source language L in a different target language L
is a well-known and important technique in ontology management. Existing approaches for such
approximation are roughly divided into syntactic approaches and semantic approaches. The former,
e.g. those by Tserendorj, Rudolph, Krtzsch, and Hitzler (2008) and Wache, Groot, and Stuckenschmidt (2005), focus on the syntactic form of the axioms of the original ontology and appropriately
rewrite the axioms that do not comply with the syntax of the target language. They are rather effective in general but can produce unsound answers (Pan & Thomas, 2007). Semantic approaches
focus on the model-based entailment from the original ontology, rather than on its syntactic structure.
They aim at preserving these entailments as much as possible while transforming the ontology into
the target language; in general they are sound, but they might be computationally more expensive
(Console, Mora, Rosati, Santarelli, & Savo, 2014).
For our task of computing partial support families, sound ontology approximation techniques
are relevant. We choose DL-Lite core as the target approximation language, as it lies in the intersection of EL and DL-Lite A , for which complete support families can be effectively identified (Eiter
et al., 2014d). Our approach for approximating a TBox in EL to DL-Lite core exploits the logical
difference between EL TBoxes considered by Konev et al. (2012). The idea behind it is to decide
whether two ontologies give the same answers to queries over a given vocabulary (called signature)
, and compute a succinct representation of the difference if it is not empty. Typical queries include
subsumption between concepts, instance queries and conjunctive queries. In our setting subsumption queries are of particular interest, as based on them nonground support families are constructed.
~ and an ontology O = hT , Ai,
Our approach is as follows. Given a DL-atom d = DL[; Q](X)
we eliminate from the TBox Td axioms outside the DL-Lite core language, and obtain a simplified
TBox Td . We then compute a succinct representation of the logical difference between Td and Td
w.r.t.  = {sig(Ad  A)  Q}; the axioms in the logical difference that fall into DL-Lite core are
then added to Td . By restricting  to predicates that can potentially appear in support sets we avoid
redundant computations and we approximate only the relevant part of the TBox. This approach
is particularly attractive, as the logical difference for EL was intensively studied, e.g. by Lutz,
Walther, and Wolter (2007) and Konev et al. (2012), and polynomial algorithms are available for
EL-terminologies; we thus confine ourselves here to the latter.
To present our approximation approach formally, we first recall some notions introduced by
Konev et al. (2012).
476

fiC OMPUTING R EPAIRS OF I NCONSISTENT DL-P ROGRAMS OVER EL O NTOLOGIES

Definition 27 (-concept difference) The -concept difference between EL-terminologies T1
and T2 is the set cDiff (T1 , T2 ) of all EL-inclusions  over  such that T1 |=  and T2 6|= .
Example 28 For the terminologies T1 = {B  E, E  r., C  A  B} and T2 =
{C  A, D  B, D  C} it holds that cDiff (T1 , T2 ) =  for  = {A, B, C}, while

cDiff (T1 , T2 ) = {B  r.} for  = {B, r}.
If two EL-terminologies entail the same concept subsumptions over the signature , i.e. it holds
that cDiff (T1 , T2 ) = cDiff (T2 , T1 ) = , then they are called -concept inseparable, which is
C
C
denoted by T1 C
 T2 . E.g. in Example 28 we have that T1  T2 and T1 6 T2 .
The logical difference in terms of instance queries is defined as follows.
Definition 29 (-instance difference) The -instance difference between terminologies T1 and T2
is the set iDiff (T1 , T2 ) of pairs of the form (A, ), where A is a -ABox and  a -instance
assertion, such that T1  A |=  and T2  A 6|= . We say that T1 and T2 are -instance inseparable,
in symbols T1 i T2 if iDiff (T1 , T2 ) = iDiff (T2 , T1 ) = .
As easily seen, T1 i T2 implies T1 C
 T2 . The converse is not obvious but also holds.
Theorem 30 (cf. Lutz & Wolter, 2010) For any EL-terminologies T1 and T2 and signature , T1 C

T2 iff T1 i T2 .
4.2 Partial Support Family Construction
We now show that a DL-atom has the same set of support sets under -concept inseparable terminologies. Prior to that, we establish the following lemma.
Lemma 31 Let d = DL[; Q](~t) be a DL-atom, let O = hT1 , Ai be an EL ontology, and let T2 be
C
a TBox. If T1 C
 T2 , where  =sig(A)  sig(Q)  {P | P  p  }, then T1 d  T2 d , where

 =   sig(Ad ).
Armed with this, we obtain the following result on equivalence of nonground support families.
~ be a DL-atom and let T1 , T2 be EL-terminologies such that
Proposition 32 Let d = DL[; Q](X)
C
T1  T2 where  = sig(A  Ad  Q)  {P | P  p  }. If S1 and S2 are complete nonground
support families for d w.r.t. O1 = hT1 , Ai and O2 = hT2 , Ai, respectively, then S1 and S2 are
ground-identical.
Given two EL-terminologies T1 and T2 , the inclusions C  A  cDiff (T1 , T2 ) (resp. A 
C  cDiff (T1 , T2 )) are following Konev et al. (2012) called left (resp. right) witnesses and denoted
lhs
as cWTnrhs
 (T1 , T2 ) (resp. cWTn (T1 , T2 )). It was shown that every inclusion C  D in the concept difference of T1 and T2 contains either a left or a right witness.
Theorem 33 (cf. Konev et al., 2012) Let T1 and T2 be EL-terminologies and  a signature. If
  cDiff (T1 , T2 ), then either C  A or A  D is a member of cDiff (T1 , T2 ), where A  sig()
is a concept name and C and D are EL-concepts occurring in .
477

fiE ITER , F INK & S TEPANOVA

Algorithm 1: PartSupFam: compute partial support family
~ ontology O = hT , Ai
Input: DL-atom d = DL[; Q](X),
Output: Partial nonground support family S  SuppO (d) for d
(a)   {sig(A  Ad )  Q}
(b) Td  T  {Pp  P | P  p  }
(c) Td  Td \{C  D | C 6 {A, r.} or D 6 {A, r.}}
rhs
lhs
(d) lrw  cWTn (Td , Td )  cWTn (Td , Td )


(e) Td  Td  {C  D  lrw | C, D  {A, r.}}
(f) S  {ComplSupF am(d, Td )}
return S
The logical difference between two EL-terminologies in its compact representation consists
only of inclusions with an atomic concept name on either the left or the right hand side. Some may
have inclusions with atomic concepts on both sides or role restrictions of the form r., which fall
into our target language of DL-Lite core DL, and can be therefore reintroduced.
We are now ready to describe the algorithm P artSupF am (see Algorithm 1) to compute partial
~ and an ontology
families of support sets. As input we are given a DL-atom d = DL[; Q](X)
O = hT , Ai, where T is an EL-terminology. We first set the signature  in (a) to predicates
relevant for support set computation for d. We then construct the TBox Td in (b) and its simplified
version Td in (c) by removing from Td all axioms of the form C  D, where C or D is a complex
concept, i.e. all axioms that are not in the DL-Lite core fragment. In (d) we compute right-hand side
and left-hand side witnesses between Td and Td for  and store them in lrw . After that, in (e) we
construct the TBox Td by extending Td with all axioms from lrw , having concepts of the form A or
r on both sides of inclusions. Based on the support set construction method for DL-Lite A of Eiter
et al. (2014d), we then obtain a complete support family S for Td in (f), which is a partial support
family for T .
Proposition 34 The family S computed by Algorithm 1 fulfills S  SuppO (d), i.e., S is a partial
support family for a given DL-atom d w.r.t. T where O = T  A.
If lwr =  in (d) or cDiff (Td , Td ) =  in (e), then S is guaranteed to be complete by Proposition 32. While in general Algorithm 1 can be used for computing support families for DL-atoms
accessing arbitrary TBoxes4 , practically efficient procedures for (d) are available only for acyclic
EL-terminologies (Konev et al., 2012).

5. Bounded Support Sets
In this section, we analyze the size and the number of support sets that a given DL-atom can have.
With bounds on these quantities at hand, one can limit the search space of support sets. More
precisely, we aim at support set families that are sufficient for evaluating the DL-atom. As support
sets S  that are (properly) subsumed by another support set S (i.e., S  S  ) can be dropped, we
consider non-ground support families that subsume any other (in particular, any complete) support
family. More formally,
4. For computing logical difference between arbitrary TBoxes recent results by Feng, Ludwig, and Walther (2015) might
be exploited.

478

fiC OMPUTING R EPAIRS OF I NCONSISTENT DL-P ROGRAMS OVER EL O NTOLOGIES

Definition 35 (-complete support family) We say a nonground support family S for a DL-atom
d is -complete w.r.t. an ontology O, if S  S for S  SuppO (d).
Thus the question are bounds on the size of support sets in S and the cardinality of a smallest S.
Throughout this section, we tacitly assume that TBoxes are acyclic, i.e. they do not entail inclusions of the form R.C  C.
5.1 Estimation of Support Set Size Bounds
We first consider an estimate on the maximal size of support sets in the smallest -complete support
family by analyzing the syntactic properties of a given TBox. To start with, we recall from the work
of Konev et al. (2012) that an atomic concept A is primitive in a terminology T , if it occurs in no
axiom of T on the left-hand side, and pseudo-primitive, if it is either primitive or occurs only on the
left-hand side of axioms A  C, where C is an arbitrary EL concept.
For an EL-terminology T and every pseudo-primitive A such that T |= D  A, where D =
A1  . . .  An  r1 .C1 . . . rm .Cm , some (atomic) conjunct Ai in D exists such that T |= Ai  A
(Konev et al., 2012, Lemma 15). From this we obtain:
Proposition 36 Let d = DL[; Q](~t) be a DL-atom, and let T be an EL-terminology. If Q is
pseudo-primitive in T , then maxsup(d) = 1.
Proposition 36 exploits a specific case, in which the support set size bound is 1. For providing
more liberal syntactic conditions on T that ensure bounded size of support sets, we use ontology hypergraphs (Nortje et al., 2013; Ecke et al., 2013). The latter have been widely studied for extracting
modules of ontologies (Nortje et al., 2013), determining concept difference between EL terminologies (Ecke et al., 2013), efficient reasoning in OWL 2 QL (Lembo, Santarelli, & Savo, 2013), and
other important tasks.
First let us recall the notion of a directed hypergraph, which is a natural generalization of a
directed graph, proposed by Ausiello, DAtri, and Sacc (1983) in the context of databases to represent functional dependencies.
Definition 37 (directed hypergraph) A directed hypergraph is a pair G = (V, E), where V is a
set of nodes of the graph and E is a set of directed hyperedges of the form e = (H, H  ), where
H, H   V are nonempty sets called hypernodes.
Given a hyperedge e = (H, H  ), we call H the tail of e and H  the head of e, denoted by
tail (e) and head (e), respectively. A hypernode is a singleton, if |H| = 1, and a binary hypernode,
if |H| = 2; in abuse of notation, for a singleton {v}, we also simply write v. The notion of an
ontology hypergraph for DL EL introduced by Ecke et al. (2013) is as follows.
Definition 38 (ontology hypergraph) Let T be an EL TBox in normal form, and let   C  R.
The ontology hypergraph GT of T is a directed hypergraph GT = (V, E), where
V = {xA | A  C  (  sig(T ))}  {xr | r  R  (  sig(T ))}  {x }, and
E = {({xA }, {xB }) | A  B  T } 
{({xA }, {xr , xY }) | A  r.Y  T , Y  C  {}}
{({xr , xY }, {xA }) | r.Y  A  T , Y  C  {}} 
{({xB1 , xB2 }, {xA }) | B1  B2  A  T }.
479

fiE ITER , F INK & S TEPANOVA

xr1

xr3

xA3

xA1

x C2

xr2

xA2

xA4

x C1

xD

xr4

Figure 4: Hypergraph GT from Example 39
Example 39 Consider the following TBox in normal form:

(4) C1  C2  D

 (1) r1 .A1  C1
(2) r2 .A2  C2
(5) A3  A2
T =

 (3) r .A  A
(6)
D  r4 .A4
3
3
1

The ontology hypergraph GT for =sig(T ) is depicted in Figure 4.







.



We now define the notions of directed path between two nodes and incoming path to a singleton
node in an ontology hypergraph; both are natural generalizations of a path in a standard graph.
Definition 40 (directed path, incoming path) Suppose that T is an EL TBox in a normal form,
GT = (V, E) is an ontology hypergraph, and x, y  V are singleton nodes occurring in GT . Then a
directed path between x and y in GT is a sequence  = e1 , e2 , . . . , en of (hyper) edges, such that:
(i) tail (e1 )  x;
(ii) head (en )  y;
(iii) for every ei , i < n, some successor s(ei ) = ej of ei exists in GT such that j > i, head (ei ) 
tail (ej ), and s(ei ) = s(ei ) implies head (ei ) 6= head (ei ) for i 6= i .
An incoming path to a singleton node x  V in GT = (V, E) is a directed path  = e1 , . . . , en
from any node y  V to x, such that head (en ) = x. The set of all incoming paths to a node x in a
hypergraph G is denoted by Paths(x , G).
Intuitively, hyperedges in an ontology hypergraph GT model inclusion relations between (complex)
concepts over  in T . Consequently, an incoming path to a singleton node xC in GT models a chain
of inclusions that logically follow from T , such that C is the rightmost element of the chain.
Example 41 Let us look at the ontology hypergraph GT in Figure 4. The sequence of edges
1 = ({xr3 , xA3 }, xA1 ), ({xr1 , xA1 }, xC1 )
480

fiC OMPUTING R EPAIRS OF I NCONSISTENT DL-P ROGRAMS OVER EL O NTOLOGIES

x A 3p

xr1

3

xr3

xA3

xA1

x C2

xr2

xA2

xD

xC

xA

x C1

xB

xD

xQ


(a) Gsupp(d),T
from Example 43


(b) Gsupp(d),T
from Example 45

Figure 5: Examples of support hypergraphs
is an incoming path to xC1 in GT that reflects the inclusions r1 .A1  C1 and r1 .(r3 .A3 )  C1 ;
the sequence
2 = ({xr3 , xA3 }, xA1 ), ({xr1 , xA1 }, xC1 ), ({xr2 , xA2 }, xC2 ), ({xC1 , xC2 }, xD )
is an incoming path to the singleton xD , from which the following set of inclusions can be extracted:
(1) C1 C2 D, (2) r2 .A2 C1 D, (3) r2 .A2 r1 .A1 D, and (4) r2 .A2 r1 .(r3 .A3 )  D.

We now introduce our notion of a support hypergraph for a DL-atom.
Definition 42 (support hypergraph) A support hypergraph for a DL-atom d=DL[; Q](~t) over a

constructed as follows:
normal ontology O = hT , Ai is a hypergraph Gsupp(d),T
1. build the ontology hypergraph GTd = (V, E), where  = sig(A  Ad )  {Q};
2. leave all nodes and edges in Paths(xQ , GTd ) and remove all other nodes and edges;
3. for xC  GTd with C 6 , if in Paths(xC , GTd ) a (hyper) node N exists such that {P | xP 
N }   then leave xC , otherwise remove it and all of its corresponding edges;
4. for xr  GTd , such that r 6 , leave e = ({xr , y}, xC  ) if (xC , {xr , y}) exists in GTd , where
y  {xD , }, otherwise remove e.
Let us illustrate the notion of a support hypergraph on the following example:
~ and
Example 43 Let T from Example 39 be accessed by the DL-atom d = DL[A3  p3 ; D](X),

Td = T  {A3p3  A3 }. The support hypergraph Gsupp(d),T for d with  = sig(Td ) is shown in Figure 5a. The node xD colored in blue corresponds to the DL-query of d. The edge ({xD }, {xr4 , xA4 })

, as it does not lie on the incoming path to xD .

is not in Gsupp(d),T
481

fiE ITER , F INK & S TEPANOVA

Before describing the approach of extracting support sets for a DL-atom from a hypergraph, we
introduce the notion of tree-acyclicity. For alternative definitions we refer the reader to the works,
e.g. by Ausiello, DAtri, and Sacc (1986), Gallo, Longo, and Pallottino (1993) and Thakur and
Tripathi (2009).
Definition 44 (tree-acyclicity) A hypergraph G = (V, E) is called tree-acyclic, if (i) at most one
directed path exists in G between any singleton nodes x, y  V, and (ii) G has no paths  =
e1 , . . . , ek such that tail (e1 )  head (ek ) 6= .
We refer to hypergraphs that are not tree-acyclic as tree-cyclic.




 = T  {B 
Example 45 Gsupp(d),T
in Figure 5a is tree-acyclic, while G  = Gsupp(d),T
 with T

 = T  {A 
A3 , B  A2 } and  =   {B} is not, and neither is G  = Gsupp(d),T
 , where T
1
C2 }.

The hypergraph Gsupp(d),T
for d = DL[; Q](X), T = {D  C; C  A; C  B; A  B  Q}
and  = sig(T ) given in Figure 5b is tree-cyclic, since it contains two paths between xD and xQ ,
namely 1 = xD , xC , xA , {xA , xB }, xQ and 2 = xD , xC , xB , {xA , xB }, xQ .


The support hypergraph Gsupp(d),T
= (V, E) for a DL-atom d = DL[; Q](X) contains all
incoming paths to xQ that start from nodes corresponding to predicates in A  Ad by construction,
i.e. it reflects all inclusions with Q on the right-hand side and predicates over A  Ad on the left
hand-side that are entailed from Td . Hence, by traversing edges of all incoming paths to xQ , we can
construct sufficiently many query rewritings of Q over the TBox Td corresponding to nonground
support sets that allow to subsume every nonground support family w.r.t. O.
If a support hypergraph for a given DL-atom is tree-acyclic, then support sets can be conveniently constructed from it by annotating nodes with variables Xi , i  N in a way as described
hX i
below. We use subscripts for annotations, e.g. xC i means that the node xC is annotated with the
hX ,X i

variable Xi , while xr i j states that xr is annotated with the ordered pair of variables Xi , Xj .
The approach proceeds as follows. We start from the node xQ , which we annotate with X0 ,
hX i
i.e. xQ 0 ; then we traverse the hypergraph backwards, going from a head of an edge to its tail.
For every edge e that we encounter we annotate tail (e) based on its form and on the annotation of
head (e), with variable names that occur in annotation of head (e) and/or fresh variable names Xi ,
i  N, in the following way:
(1) if |tail (e)| = 1, then
hX i

(1.1) if head (e) = {xC1 i }, then tail (e) is annotated with hXi i;
hXi1 ,Xi2 i

(1.2) if head (e) = {xr1
hXi i

hXi i

, xC1 3 }, then tail (e) = xC2 is annotated with hXi1 i, i.e. we

obtain xC2 1 ;
hXi i

(2) if |tail (e)| = 2 and head (e) = {xC

}, then
hX i

hX i

(2.1) if tail (e)={xC1 ,xC2 }, then both xC1 and xC2 are annotated with Xi , i.e. {xC1 i ,xC2 i };
hXi ,Xi1 i

(2.2) if tail (e)={xr1 , xC1 }, then we get {xr1
482

hXi i

, xC1 1 },

fiC OMPUTING R EPAIRS OF I NCONSISTENT DL-P ROGRAMS OVER EL O NTOLOGIES

From every annotated hypernode N , one can create a set of nonground atoms with predicate names
extracted from labels of hypernodes and variable names from their annotations. The nonground
support sets for d = DL[; Q](X0 ) are then constructed from the incoming paths to xQ .
We pick some incoming path 1 to xQ containing n edges, and start traversing it from the
edge en with head (en ) = {xQ }. The first immediate support set is S1 = {Q(X0 )}; the next
one, S2 , is extracted from the annotated tail of en by taking nonground predicates of labels and
variables. We then pick an edge ek such that head (ek )  tail (en ), and obtain further support
sets by substituting nonground atoms that correspond to head (ek )  tail (en ) in S2 with the atoms
extracted from tail (ek ); this is repeated. One can in fact construct the incoming path backwards
along with the support set extraction, until a maximal path is obtained.

Example 46 Consider the maximal incoming path to xD of Gsupp(d),T
from Figure 5a:

 = (xA3 p3 , xA3 ), ({xr3 , xA3 }, xA1 ), ({xr1 , xA1 }, xC1 ), ({xr2 , xA2 }, xC2 ), ({xC1 , xC2 }, xD ).
{z
} |
{z
} |
{z
} |
{z
}
|
{z
} |
e1

e2

e3

e4

e5

hX3 i
3i
Traversing the path backwards, i.e. edges in the order e5 , e4 , e3 , e2 , e1 , we obtain: (xhX
A3 p ,xA3 )e ,

{z
}1
hX i
hX i
hX i
hX i
hX i hX i
hX i
hX i
hX i
0 ,X2 i
0 ,X1 i
2 ,X3 i
,xA1 2 },xC1 0 ) ,({xhX
,xA2 1 },xC2 0 ) ,({xC1 0 ,xC2 0 },xD 0 ).
({xhX
,xA3 3 },{xA1 2 }) ,({xhX
r1
r2
r3
{z
} |
{z
} |
{z
} |
{z
}
|
|

e2

e3

e4

3

e5

The nonground support sets for d are extracted from the resulting annotated path as follows:

 S0 = {D(X0 )} is immediately obtained from head (xD );
 the first incoming path to consider is 1 = e5 , from which we get S1 = {C1 (X0 ), C2 (X0 )};
 next is the path 2 = e4 , e5 as head (e4 )  tail (e5 ), yielding the support set S2 = {C1 (X0 ),
r2 (X0 , X1 ), A2 (X0 , X1 )};
 then, from 3 = e3 , e5 we get S3 = {C1 (X0 ), r1 (X0 , X2 ), A1 (X2 )};
 4 = e3 , e4 , e5 yields S4 = {r2 (X0 , X1 ), A2 (X1 ), r1 (X0 , X2 ), A1 (X2 )};
 from 5 = e2 , e3 , e5 , we extract S5 = {r1 (X0 , X2 ), r3 (X2 , X3 ), A3 (X3 ), C2 (X0 )};
 6 = e2 , e3 , e4 , e5 yields S6 = {r1 (X0 , X2 ), r3 (X2 , X3 ), A3 (X3 ), r2 (X0 , X1 ), A2 (X1 )};
 from 7 = e1 , e2 , e3 , e5 , we extract S7 = {r1 (X0 , X2 ), r3 (X2 , X3 ), A3p3 (X3 ), C2 (X0 )};
 finally, from 8 = e1 , e2 , e3 , e4 , e5 we get S8 = {r1 (X0 , X2 ), r3 (X2 , X3 ), A3p3 (X3 ),
r2 (X0 , X1 ), A2 (X1 )}.

The following lemma formally asserts the correctness of the procedure.

Lemma 47 Let SG be the support family constructed from a tree-acyclic hypergraph G=Gsupp(d),T
~ Then SG is -complete for d w.r.t. O, i.e., SG  S for every S  SuppO (d).
for d = DL[; Q](X).

In particular, Lemma 47 holds for each complete S for d w.r.t. the ontology O = hT , Ai. Thus
we can determine sufficiently many nonground support sets for d by just looking at its support hypergraph. Note that the restriction to tree-acyclic TBoxes is crucial for correctness of the procedure
from above, as it ensures that every node of a hypergraph is annotated only once.
Lemma 47 allows us to reason about the structure and size of support sets by analyzing only
parameters of the support hypergraph. One such parameter, for instance, is the maximal number
n(, G) of hyperedges with a singleton head node excluding ({xr , }, xA ), occurring on some
incoming path  to xQ of a hypergraph G.
483

fiE ITER , F INK & S TEPANOVA

xQ

xL

xE
xF

xD

xM

xB

xA

xK
xC


Figure 6: Support hypergraph Gsupp(d),T
from Example 49

Proposition 48 Let O = hT , Ai be an EL ontology with T in a normal form, and let d =
~ be a DL-atom with a tree-acyclic support hypergraph G 
DL[; Q](X)
. Then
supp(d),T

maxsup(d)  maxG 

supp(d),T


(n(, Gsupp(d),T
)) + 1.

(6)

For tree-cyclic hypergraphs, the bound from above is not tight, which we illustrate next.
Example 49 Consider the DL-atom d(X) = DL[; Q](X) accessing the TBox Td :


(4) E  F  L 


 (1) A  D  F
(2) A  C  K
(5) E  K  M
.
Td =



 (3) A  B  E
(6) M  L  Q

The support hypergraph for d is depicted in Figure 6, where  = sig(Td ). There are six hyperedges with singleton head nodes, but the maximal support set size for d(X) is 4, e.g. S =
{A(X), B(X), D(X), K(X)}.

We next define out- and in-degrees of nodes in a hypergraph.
Definition 50 (hyper-outdegree and -indegree) Given a directed hypergraph G = (V, E), the
hyper-outdegree denoted by hd+ (x) (resp., hyper-indegree hd (x)) of a singleton node x  V is
the number of hyperedges e  E such that tail (e)  x (resp., head (e)  x) and either |tail (e)| = 2
or |head (e)| = 2. Similarly, the outdegree d+ (x) (resp., indegree d (x)) of x is the number of
edges e  E such that tail (e) = {x} (resp., head (e) = {x}) and |head (e)| = |tail (e)| = 1.


Example 51 All nodes X  V\{xA3p , xD } in the hypergraph Gsupp(d),T
of Figure 5a have hyper+
+
outdegree 1, while for xAp3 and xD we have hd (xAp3 ) = hd (xD ) = 0, moreover, d+ (xAp3 ) = 1.
For hyper-indegrees we have hd (xA3 ) = hd (xA1 ) = hd (xC1 ) = hd (xC2 ) = 1. In the graph

 ({xC2 , xA2 }, xD ), it holds that hd+ (xC2 ) = hd+ (xA2 ) = hd (xD ) = 2,
G  = Gsupp(d),T
moreover, d (xA3 ) = 1.


484

fiC OMPUTING R EPAIRS OF I NCONSISTENT DL-P ROGRAMS OVER EL O NTOLOGIES

Now let us define that
smax (x, G) = maxPaths(x,G) (n(, G)  m(, G) + 1),
(7)
P
where m(, G) = xA  (hdc+ (xA )  1), and hdc+ (xA ) is the number of hyperedges of form
({xA , xB }, xC ) on .


Example 52 Consider Gsupp(d),T
in Figure 5a, where Paths(xD , Gsupp(d),T
) contains a single maximal path to xD , viz.  = (xA3p3 , xA3 ), ({xr3 , xA3 }, xA1 ), ({xr2 , xA2 }, xC2 ), ({xr1 , xA1 }, xC1 ),
({xC1 , xC2 }, xD ). We have n(, G) = 4, as four hyperedges on  have a singleton head node, and
m(, G) = 0, as all nodes have hyper-outdegree at most 1; hence smax (xQ , G) = 4  0 + 1 =
5. The hypergraph in Figure 6 has a single maximal incoming path  to xQ , and n(, G) = 6,
m(, G) = (hdc+ (xA )  1) + (hdc+ (xE )  1) = 3; thus smax (xQ , G) = 6  3 + 1 = 4.


We generalize the bound on the maximal support set size for d from Proposition 48 using the
parameter smax (xQ , G) for a node corresponding to the DL-query Q of a DL-atom d, and obtain
the following result for hypergraphs that are possibly tree-cyclic:
Proposition 53 Let O = hT , Ai be an EL ontology with T in a normal form, and let d =
~ be a DL-atom with support hypergraph G 
DL[; Q](X)
supp(d),T , such that  has no role predi
cates. Then maxsup(d )  smax (xQ , Gsupp(d),T ).

) = 4, and
Example 54 For the tree-cyclic hypergraph in Figure 6 we have smax (xQ , Gsupp(d),T
4 is indeed the maximal support set size for d = DL[; Q](X). The hypergraph in Figure 5a has

3 hyperedges, and for every node x  V, hd+ (x)  1. Thus, smax (xQ , Gsupp(d),T
) = 4, which
coincides with maxsup(d ), where d = DL[A3  p3 ; Q](X).


Note that in Proposition 53, we take in computing m(, G) only outgoing hyperedges of the
form ({xC , xD }, xE ) into account, where C, D, E are concepts, and moreover, no roles occur in .
Multiple outgoing hyperedges involving roles r with r   do not influence the support set size.
Example 55 Let a support hypergraph for d = DL[; Q](X) have the hyperedges ({xr , xC }, xD ),
({xC , xs }, xM ), ({xD , xM }, xQ ) where r  , reflecting the axioms r.C  D, s.C  M and
M  DQ. A largest minimal support set for d is S={r(X, Y ), C(Y ), s(X, Z), C(Z)}; its size is
n + 1, where n is the number of hyperedges with a singleton head node, while hd+ (xC ) = 2. 
5.2 Number of Support Sets
Orthogonal to the question considered in the previous section is under which conditions a given
number n of support sets is sufficient to obtain a -complete support family. This problem is tightly
related to counting minimal solutions for an abduction problem, which was analyzed by Hermann
and Pichler (2010) for propositional theories under various restrictions. In particular, counting minimal explanations was shown to be #  coNP-complete for general propositional theories and
#P -complete for Horn propositional theories; as EL subsumes propositional Horn logic, determining the size of a smallest -complete support family is at least #P -hard and thus intractable.
Like for the size of support sets, the support hypergraph can be fruitfully exploited for estimating
the maximal number of support sets for a given DL-atom. To provide such an estimate, we traverse
the support hypergraph forward starting at the leaves and label every node xP with the number of
rewritings for P . To conveniently compute the labels, we introduce support weight functions.
485

fiE ITER , F INK & S TEPANOVA


Definition 56 (support weight function) Let Gsupp(d),T
= (V, E) be a support hypergraph for a
DL-atom d. A support weight function ws : V  N assigns to every node xA  V the number
ws(xA ) of rewritings of A over T w.r.t. .

For every node in a tree-acyclic support hypergraph, the value of ws can be conveniently computed in a recursive manner.

Proposition 57 Let Gsupp(d),T
be a tree-acyclic support hypergraph for a DL-atom d over a (normalized) ontology O = hT , Ai. Then ws is given as follows, where VC  V is the set of nodes for
concepts:



1, P
Q
ws(x) = 1 + T T  (x) x T ws(x )

P
P

+ T T  (x),T 6VC ({x },T )E ws(x ),

if hd (x) = 0 and d (x) = 0 or x 
/ VC ,
otherwise.
(8)

where T  (x) = {T | (T, {x})  E}.

We demonstrate the usage of Proposition 57 by the following examples.

Example 58 To compute ws(x) for the nodes of Gsupp(d),T
in Figure 5a, we traverse the graph from
leaves to the root, and for x  {xr1 , xA2 , xC2 , xr2 , xA3p3 , xr3 } we obtain ws(x) = 1; furthermore,
ws(xA3 ) = ws(xC2 ) = 2, ws(xA1 ) = 3, ws(xC1 ) = 4. Finally, ws(xD ) = 1 + ws(xC1 ) 
ws(xC2 ) = 1 + 4  2 = 9, which is the number of rewritings for D(X) (and hence support sets for
d(X) = DL[A3  p3 ; D](X)) identified in Example 46.

Example 59 Consider the TBox T = {A  B  Q; C  A; D  A; E  A; F  B; G  B; H 
B; A  L} and a DL-atom d = DL[; Q](X), whose support hypergraph for  = sig(T ) is in
Figure 7. We have that ws(xQ ) = 1 + ws(xB )  ws(xA ) = 1 + 4  4 = 17, and indeed there are 17
rewritings for Q(X), namely S1 = {A(X), B(X)}, S2 = {C(X), B(X)}, S3 = {D(X), B(X)},
S4 = {E(X), B(X)}, S5 = {A(X), F (X)}, S6 = {A(X), G(X)}, S7 = {A(X), H(X)}, S8 =
{C(X), F (X)}, S9 = {C(X), G(X)}, S10 = {C(X), H(X)}, S11 = {D(X), F (X)}, S12 =
{D(X), G(X)}, S13 = {D(X), H(X)}, S14 = {E(X), F (X)}, S15 = {E(X), G(X)}, S16 =
{E(X), H(X)}, and S17 = {Q(X)}.
As an immediate corollary of Proposition 57, we obtain

= (V, E) be a tree-acyclic support hypergraph for the DL-atom d =
Corollary 60 Let Gsupp(d),T
~ over an EL ontology O = hT , Ai. If each edge e  E satisfies |tail (e)|=|head (e)|=1,
DL[; Q](X)
then
X
ws(tail (e)) + 1.
(9)
ws(v) =
eE | head(e)=v

Thus for the query node xQ , we get ws(xQ ) = |E| + 1. In fact, Proposition 57 leads to this
simple bound on the size of  -minimal complete support families in more general cases.
486

fiC OMPUTING R EPAIRS OF I NCONSISTENT DL-P ROGRAMS OVER EL O NTOLOGIES

xC

xD

xE

xF

xA

xG

xH

xB

xQ

Figure 7: Hypergraph Gsupp(d),T


= (V, E) be a tree-acyclic support hypergraph for the DL-atom
Proposition 61 Let Gsupp(d),T
~ over an EL ontology, such that for every edge e = ({x, y}, z)  E and edges
d = DL[; Q](X)
e1 , e2  E such that head (ei )  {x, y}, i  {1, 2}, it holds that head (e1 ) = head (e2 ). Then
|SG 
| = |E| + 1.
supp(d),T


Example 62 The hypergraph Gsupp(d),T
in Figure 5a has a single maximal path of length 5, and its
hyperedges satisfy the condition of Corollary 61. As d has 6 support sets, |S| = |E| + 1 holds. 

If the condition of Proposition 61 on e and e1 , e2 is violated, then the maximal size of a  minimal complete support family can not be assessed that easily. For instance, the support hyper
from Figure 7 contains 7 edges, but d has 17 support sets. It can be shown that if k
graph Gsupp(d),T

nodes in Gsupp(d),T violate the condition, then SG 
contains at most |E|k+1 + 1 support sets;
supp(d),T

for the considered example, this yields a bound of 72 + 1 = 50, which is far from tight.
We note that Proposition 57 can not be applied for tree-cyclic support hypergraphs.

for d = DL[; Q](X), T =
Example 63 Consider a tree-cyclic support hypergraph Gsupp(d),T
{D  C; C  A; C  B; A  B  Q} and  = sig(T ), which is shown in Figure 5b. Using
Proposition 57 we get ws(xD ) = 1, ws(xC ) = 2, ws(xA ) = 3, ws(xB ) = 3, ws(xQ ) =
33+1 = 10. However, Q(X) has only 4 rewritings: (1) S1 = {Q(X)}, (2) S2 = {A(X), B(X)},
(3) S3 = {C(X)}, and (4) S4 = {D(X)}.
Intuitively, for tree-cyclic hypergraphs the support weight function ws may also account for nonminimal rewritings {B(X), C(X)}, {A(X), C(X)}, {A(X), D(X)}, {B(X), D(X)}, and some
rewritings can be counted multiple times. Thus in general, ws(x) provides only an upper bound
for the number of rewriting. Likewise, the bound in Proposition 61 is not tight even for simple treecyclic support hypergraphs; e.g., the one for the DL-atom d = DL[; Q](X) w.r.t. the TBox A  Bi ,
Bi  Q, 1  i  n, contains 2  n edges, but d has only n + 2 support sets.


6. Repair Computation Based on Partial Support Families
In this section, we present our algorithm SoundRAnsSet for computing deletion repair answer
sets. As shown by Stepanova (2015), deciding whether a given DL-program  = hT  A, Pi over
an EL ontology has some deletion repair answer set is P2 -complete in the general case, where the
membership part is established by guessing a candidate repair ABox A  A along with a candidate
487

fiE ITER , F INK & S TEPANOVA

answer set I for  = hT  A , Pi, and the suitability of the guess is checked using an NP oracle.
Clearly this is not efficient, as there are |2n | candidate repair ABoxes for n = |A|, even if finding
an answer set I of  would be cheap.
We restrict the search space of repairs in our approach as in the work of Eiter et al. (2014d) by
exploiting support families for DL-atoms; however, in contrast to the results by Eiter et al. (2014d),
the support families are not required to be complete. If the families are complete (which may
be known or asserted in their construction), then SoundRAnsSet is guaranteed to be complete;
otherwise, it may miss repair answer set, but an easy extension ensures completeness.
Our algorithm for repair answer set computation, shown as Algorithm 2, proceeds as follows.
 We start at (a) by computing a family S of nonground support sets for each DL-atom.
 Next in (b) the so-called replacement program  is constructed.
The replacement program is obtained by a simple rewriting of gr(), where each DL-atom d
is replaced by an ordinary atom ed (called replacement atom), and a disjunctive choice rule
ed  ned  is added that informally guesses the truth value of d, where ed (respectively ned )
stands for the value true (respectively false). Each repair answer set of  augmented with the
proper choice of ed resp. ned is an answer set of  (Eiter et al., 2013, Proposition 13); thus
the search can be confined to answer sets I of , which can be found using a standard ASP
solver.
 In (c) the answer sets I of  are computed one by one.
 we determine in (d) the sets Dp (resp. Dn ) of DL-atoms that are guessed true (resp.
 For I,
 A) which instantiates S for the DL-atoms in
false) in it and then use the function Gr(S, I,

Dp  Dn to relevant ground support sets, i.e., those compatible with I.
 In (e) we loop through all minimal hitting sets H  A of the support sets for DL-atoms in Dn
that only consist of ABox assertions, and in (f) we construct for each H the set Dp of atoms
from Dp that have at least one support set which is disjoint from H (thus removing H from
A does not affect the values of atoms in Dp ).

 Then in (g) we evaluate in a postcheck the atoms in Dn and Dp \Dp over T  A\H w.r.t. I.
A Boolean flag rep stores the evaluation result of a function eval n (resp. eval p ). More specifically, given Dn (resp. Dp ), I and T  A\H, the function eval n (resp. eval p ) returns true, if
all atoms in Dn (resp. Dp ) evaluate to false (resp. true).
 T  A \ H, P) succeeds, then in (h) the
 If rep is true and the foundedness check flpFND(I,


restriction I| of I to the original language of  is output as repair answer set.
We remark that in many cases, the foundedness check might be trivial or superfluous (Eiter,
Fink, Krennwallner, Redl, & Schller, 2014a), e.g., when there are no loops through DL-atoms; if
we consider weak answer sets (Eiter et al., 2013), it can be entirely skipped.
Example 64 Let  be the DL-program from Example 1 with equivalence () in the axioms (2)
and (3) weakened to , and with further assertions Project(p1 ) and BlacklistedStaffRequest(r1 )
added to the ABox A. Moreover, assume that d1 (r1 ) = DL[Project  projfile; Staffrequest](r1 ),
d2 (r1 )=DL[Staff  chief ; BlacklistedStaffRequest](r1 ), d3 (r1 ,p1 )=DL[; hasTarget](r1 ,p1 )
488

fiC OMPUTING R EPAIRS OF I NCONSISTENT DL-P ROGRAMS OVER EL O NTOLOGIES

Algorithm 2: SoundRAnsSet: compute deletion repair answer sets
Input: =hT  A, Pi
Output: a set of repair answer sets of 
(a) compute a set S of nonground support families for the DL-atoms in 
(b) construct the replacement program 
(c) for I  AS () do

 Dn  {d | ned  I};
 SIgr
 A);
(d)
Dp  {d | ed  I};
 Gr(S, I,
S

(e)
for all minimal hitting sets H  A of d Dn SIgr (d ) do

(f)
Dp  {d  Dp | S  SIgr (d) s.t. S  H = }
 T  A\H)  evalp (Dp \Dp , I,
 T  A\H)
(g)
rep  evaln (Dn , I,
 hT  A\H, Pi) then output I|

(h)
if rep and flpFND(I,
end
end

and d4 (r1 ,john) = DL[; hasSubject](r1 ,john). Then in (b) the following replacement program
 is constructed:



(1) ed1 (r1 )  ned1 (r1 ); (2) ed2 (r1 )  ned2 (r1 ); (3) ed3 (r1 , p1 )  ned3 (r1 , p1 ); 








(4)
e
(r1
,
john)

ne
(r1
,
john);
(5)
projfile(p1
);
(6)
hasowner
(p1
,
john);


d4
d4






(7) chief (john)  hasowner (p1 , john), projfile(p1 );
 =
.


(8) grant(r1 )  ed1 (r1 ), not deny(r1 );










 (9) deny(r1 )  ed2 (r1 );





(10)   hasowner (p1 , john), not grant(r1 ), ed3 (r1 , p1 ), ed4 (r1 , john).

Suppose that I = {ed1 , ned2 , ed3 , ed4 , hasowner (p1 , john), projfile(p1 ), chief (john)} is returned
at (c) and that the following partial support families are obtained in (d):


 SIgr (d1 ) = {S1 , S2 }, where S1 = {hasAction(r1 , read ), hasSubject(r1 , john), Action(read ),
Staff (john), hasTarget(r1 , p1 ), Projectprojfile (p1 )} and S2 = {StaffRequest(r1 )};


 SIgr (d2 ) = {S1 ,S2 }, where S1 = {StaffRequest(r1 ),hasSubject(r1 , john),Blacklisted (john)}
and S2 = {BlacklistedStaffRequest(r1 )}.


 SIgr (d3 ) = {S1 }, where S1 = {hasTarget(r1 , p1 )};


 SIgr (d4 ) = {S1 }, where S1 = {hasSubject(r1 , john)}.
At (e) we get a hitting set H = {StaffRequest(r1 ), BlacklistedStaffRequest(r1 )}, which is disjoint
with S1 , S1 and S1 . Thus in (f) we obtain Dp = {d1 , d3 , d4 } and then in (g) we check whether
d2 is false under A\H. As this is not true, rep = false and we pick a different hitting set H  , e.g.
{Blacklisted (john), BlacklistedStaffRequest(r1 )}. Proceeding with H  , we get to (g), and as
 T  A  H) = true and the flp-check succeeds at (f), the interpretation I|
  is output.
eval n (d2 , I,

The following results state that our algorithm works properly.
489

fiE ITER , F INK & S TEPANOVA

Theorem 65 Algorithm SoundRAnsSet is sound, i.e., given a program  = hT  A, Pi, every
output I is a deletion repair answer set of .
If we know in addition that the support families are complete, then the postchecks at (g) are
redundant. If Dp = Dp , then we set rep = true, otherwise rep = false.
Theorem 66 Suppose that for the input program  = hT  A, Pi of Algorithm SoundRAnsSet, it
holds that for each DL-atom in  the support family in S computed in Step (a) of SoundRAnsSet
is -complete. Then Algorithm SoundRAnsSet is complete, i.e., it outputs every deletion repair
answer set of .
We can easily turn SoundRAnsSet into a complete algorithm, by modifying (e) to consider all
hitting sets, but not only minimal ones. In the worst case, this means a fallback to almost the naive
algorithm (note that all hitting sets can be enumerated efficiently relative to their number).
6.1 Optimizations and Extensions
Research in repairing databases (see the work by Bertossi, 2011, for overview) suggests several
techniques, which are of potential interest for DL-programs, and could be exploited for optimizing
and extending our repair approach. Localization of repairs proposed by Eiter, Fink, Greco, and
Lembo (2008) is one such technique, where cautiously a part of the data that is affected by inconsistency is identified and the search of repairs is narrowed down to this part. Using localization, in
our setting the ontology ABox can be split into a safe set of facts, which will not be touched by any
repair, and a set of facts that are (probably) affected. After the affected part is repaired, the result is
then combined with the safe ABox part to get the final solution. To find a suitable ABox split, meta
knowledge about the ontology (e.g. modules, additional domain information) can be used.
Another common approach for tackling an inconsistency problem, which proved to be effective
for databases, is decomposition (Eiter et al., 2008). Here, the available knowledge is decomposed
into parts, such that the reasons for inconsistency are identified in each part separately, and then
the respective repairs are conveniently merged. While for databases decomposition is natural, it
is in general unclear how an inconsistent DL-program can be effectively decomposed. One way
to approach this problem is by determining DL-atoms whose replacement atoms are guessed true
(resp. false) in all answer sets of . Given a set of such DL-atoms, one can aim at first searching
for a repair under which every such DL-atom has the desired value, and then extend the solution
to get the final result. Modules of DL-programs (as identified by the DLVHEX solver) can also be
exploited for program decomposition.
As not all repairs are equally useful for a certain setting, various filterings on repairs can be applied to get the most plausible candidates. Here, qualitative and domain-specific aspects of repairs
are of crucial importance for their practicability. These can be formulated in terms of additional local constraints that express for instance that facts involving certain predicates or constants must be
preserved (resp. should be checked for removal). Furthermore, the number of facts/predicates/constants allowed for deletion can be bounded. These filterings are incorporated in our repair approach.
Yet there are several further extensions possible like conditional predicate dependence. For example, a user might be willing to express the condition that StaffRequest(r ) can only be eliminated if
hasAction(r , read ) holds in the data part, or Blacklisted staff members can not be removed, if they
own files, for modifying which a separate StaffRequest has been issued by a non-blacklisted staff
member.
490

fiC OMPUTING R EPAIRS OF I NCONSISTENT DL-P ROGRAMS OVER EL O NTOLOGIES

~  S P (Y
~)
(r1 ) Supd (X)
d
A,P

~ S
~)
(Y
(r2 ) Supd (X)
d

~ S P (Y
~)
(r5 )   ned (X),
d

~ )  . . .  Pnd (Y
~ )  ned (X),
~ S A,P (Y
~)
(r6 ) P1d (Y
d

~ )  rb(S p (Y
~ ))
(r3 ) SdP (Y
d
A,P ~
A,P ~

~ ))
(r4 ) Sd (Y )  rb(Sd (Y )), nd(SdA,P (Y

~  ed (X),
~ not Cd , not Supd (X)
~
(r7 ) eval d (X)

~
~
(r8 ) eval d (X)  ned (X), not Cd

~ Cd , not Supd (X)
~
(r9 )   ed (X),

Figure 8: Rules Rd for declarative implementation
6.2 Implementation
We have implemented our repair approach in C++ in a system prototype (dlliteplugin of the DLVHEX
system, 2015).
As discussed, the support sets for EL ontologies are of a rich structure, and thus for their computation, TBox classification as in the work of Eiter et al. (2014d) is insufficient. Indeed, we need
to identify not only inclusions between atomic concepts, but also all inclusions of the form C  B,
where C is an arbitrarily complex concept and B is atomic. For constructing support sets we thus exploit the R EQUIEM tool (Prez-Urbina et al., 2010), which rewrites the target query over the TBox
using datalog rewriting techniques. By limiting the number (resp. size) of the rewritings, partial
support families can be computed.
In principle some support sets may be subsumed by smaller support sets (e.g., {R(c, d),A(c)}
by {A(c)}). These support sets are redundant and thus we eliminate them in our implementation.
After the support families are constructed, we use a declarative approach for determining repair
answer sets, in which the minimal hitting set computation is accomplished by rules. To this end,
~ the three fresh predicates (i) Supd (X),
~ (ii) S P (Y
~ ), and (iii) S A,P (Y
~ ) are
for each DL-atom d(X)
d
d
~  , which intuitively say that d(X)
~ = XX
~ has (i) some support set, (ii) some
introduced, where Y
support set involving only rule predicates, and (iii) some support set involving ABox predicates (and
possibly rule predicates), called mixed support set. Furthermore, for every DL-atom d(X), the rules
Rd in Figure 8 are added to the replacement program .
~ is known to be
In these rules, the atom Cd informally says that the support family for d(X)
complete. Information about completeness of support families for certain DL-atoms can be added
to the declarative program in the form of facts Cd . The rules (r1 )-(r4 ) reflect information about
~ under a potential repair; rb(S) stands for a rule body representing a support
support sets of d(X)
~ ), . . . , not pPnd (Y
~ ),
set S, i.e. rb(S) = A1 , . . . Ak if S = {A1 , . . . , Ak }; nd(S) = not pP1d (Y
~ ), . . . , pPnd (Y
~ )}, encodes the ontology part of S and pP (Y
~ ) states that the assertion
where {pP1d (Y
id

~
~
Pi d (Y ) is marked for deletion. The constraint (r5 ) forbids that d(X), if guessed false has a matching
~ has a matching
support set that consists only of input assertions; (r6 ) means that if instead d(X)
mixed support set, then some assertion from its ontology part must be eliminated. The rule (r7 )
~ is guessed true, completeness of its support family is unknown and no matching
says that if d(X)
~
support set is available, then an evaluation postcheck is necessary (eval d (X));
rule (r8 ) is similar

~
for d(X) guessed false. The rule (r9 ) states that a DL-atom guessed true must have some support
set, if its support family is known to be complete.
The set of facts f acts(A) = {pP (~c) | P (~c)  A}, encoding the ABox assertions and COMP 
{Cd | Sd is a complete support family for d} are added to the program , and then its answer sets
491

fiE ITER , F INK & S TEPANOVA


(1) projfile(p1 ); (2) hasowner (p1 , john); (3) issued (john, r1 );





(4) chief (john)  hasowner (p1 , john), projfile(p1 );





 (5) deny(r1 )  ed (r1 );



(6)   hasowner (p1 , john), issued (john, r1 ), deny(r1 );




(7) ed (r1 )  ned (r1 );





(8) supd (X )  pBlacklistedStaffRequest (X ), not pBlacklistedStaffRequest (X);




 (9) pBlacklistedStaffRequest (X )  ned (X ), pBlacklistedStaffRequest (X );
  R = (10) supd (X )  pStaffRequest (X ), not pStaffRequest (X ), phasSubject (X , Y ),



not phasSubject (X, Y ), pBlacklisted (Y ), not pBlacklisted (Y );





(11)
p
(X
)  phasSubject (X , Y )  pBlacklisted (Y )  ned (X), pBlacklisted (Y ),
StaffRequest




pStaffRequest (X ),





phasSubject (X , Y );




(12)
eval
(X)

e
(X),
not
C
,
not
sup
(X);

d
d
d
d



(13) eval d (X)  ned (X), not Cd ;



(14)   ed (X), Cd , not supd (X).



























































Figure 9: Program   R from Example 68
 we proceed with an evaluation postcheck for all atoms
are computed. For each such answer set I,
d(~c) for which the fact eval d (~c) is in the answer set. If all evaluation postchecks succeed, then we
  of the original program  from I.
 This way one identifies
extract the repair answer set I = I|
weak repair answer sets; for flp-repair answer sets, an additional minimality check is needed. In
many cases, however, the flp and weak answer sets coincide (cf. Eiter et al., 2014a); in particular,
this holds for the example and benchmark programs that we consider.
We now formally show that the described approach indeed correctly computes weak repair answer sets.
Proposition 67 Let  = hO, Pi be a ground DL-program, where O is an EL ontology, let for each
DL-atom d of  be Sd  SuppO (d), and let Rd be the set of rules (r1 )-(r9 ) for d. Define
1 =   R  f acts(A)  COMP,
S
where R = d Rd , f acts(A) = {pP (~c) | P (~c)  A} and COMP  {Cd | Sd is -complete for
d w.r.t. O}. Suppose I  AS (1 ) is such that the evaluation postcheck succeeds for every DL-atom
   RAS weak (). Moreover, if Cd  COMP for every DL-atom d,
d with Cd 6 COMP. Then I|

then RAS weak () = {I| | I  AS (1 )}.
Let us demonstrate the usage of the declarative implementation through an example.
Example 68 Consider in Figure 9 the replacement program  and the rules R of  = hP, Oi,
where O is as in Example 1, and P is as follows:

(1) projfile(p1 ); (2) hasowner (p1 , john); (3) issued (john, r1 );




(4) chief (john)  hasowner (p1 , john), projfile(p1 );
P=

(5) deny(r1 )  DL[Staff  chief ; BlacklistedStaffRequest](r1 );



(6)   hasowner (p1 , john), issued (john, r1 ), deny(r1 ).
492











.

fiC OMPUTING R EPAIRS OF I NCONSISTENT DL-P ROGRAMS OVER EL O NTOLOGIES

Assume that for d(X) = DL[Staff  chief ; BlacklistedStaffRequest](X) we are given an
incomplete support family Sd = {S1 , S2 }, where S1 = {BlackListedStaffRequest(X )} and S2 =
{StaffRequest(X ), hasSubject(X , Y ), Blacklisted (Y )}. Then the interpretation I  {ned (r1 ),
pStaffRequest (r1 ), pBlacklisted (john), evald } is among the answer sets of   R  facts(A). As
 a post-check is needed for d(r1 ); this test succeeds, and thus I|
  is a repair answer set.
eval d  I,


7. Evaluation
The repair answer set computation approach is implemented within the DLVHEX system; the details
can be found in the work of Stepanova (2015), and the software is freely online available (dlliteplugin, 2015). Our approach was evaluated on a multi-core Linux server running DLVHEX 2.4.0 under
the HTCondor load distribution system (HTCondor, 2012), which is a specialized workload management system for compute-intensive tasks, using two cores (AMD 6176 SE CPUs) and 8GB
RAM.
To the best of our knowledge, no similar system for repairing inconsistent DL-programs exists. The list of systems for evaluating DL-programs includes the DR E W system (DReW, 2012;
Xiao, 2014) and the dlplugin of the DLVHEX system (dlplugin, 2007). The DR E W system exploits
datalog rewritings for evaluating DL-programs over EL ontologies; however, it can not handle inconsistencies, which are the focus of our work. Thus DR E W per se could not be used as a baseline
for experiments. To facilitate a comparison, we have thus extended DR E W with a naive repair
technique, where a guess of a repair ABox is followed by a check of its suitability. However, this
immediate implementation turned out to be infeasible even on small instances, as in general the
search space for repairs is ways too large for its full exploitation; guided search is needed to ensure
scalability. The dlplugin of the DLVHEX system invokes R ACER P RO reasoner (RacerPro, 2007) as
a back-end for evaluating calls to the ontology. However, for lightweight ontologies even in the
standard evaluation mode without any repair extensions, it scales worse than the dlliteplugin (Eiter
et al., 2014b); thus we focus on the latter in our experiments.
7.1 Evaluation Workflow
The general workflow of the experimental evaluation was as follows. In the first step, we constructed benchmarks by building rules and constraints on top of existing ontologies such that for
some data parts the constructed programs become inconsistent. The instances were generated using
shell scripts (DL-program benchmark generation scripts, 2015) with the size of the conflicting data
part as a parameter. The benchmarks were then run using the HTCondor system, and the times were
extracted from the log files of the runs. In each run, we measured the time for computing the first
repair answer set, including support set computation, with a timeout of 300 seconds.
For each benchmark, we present our experimental results in tables. The first column p specifies
the size of the instance (varied according to certain parameters specific for each benchmark), and
in parentheses the number of generated instances. E.g., the value 10(20) in the first column states
that a set of 20 instances of size 10 were tested. The other columns represent particular repair
configurations, grouped into three sets.
The first set refers to the settings where -complete support families were exploited, while the
second and the third refer to the settings in which the size, respectively the number of computed sup493

fiE ITER , F INK & S TEPANOVA

port sets was restricted. For the -complete setting, we in addition limit the number of facts (lim_f ),
predicates (lim_p) and constants (lim_c) involved in facts that can be removed; e.g., lim_p = 2
states that the set of removed facts can involve at most two predicates. The parameter del _p stores
predicates that can be deleted; e.g., del _p = StaffRequest means that repairs can be obtained by
removing only facts over StaffRequest.
In the restricted configurations, the column size = n (resp. num = n) states that in the
computed partial support families the size (resp. number) of support sets is at most n; if n = ,
then in fact all support sets were computed, but the system is not aware of the -completeness. We
exploit partial -completeness for the number and size restriction cases, i.e. if no more support sets
for an atom are computed and the number/size limits were not yet reached, then the support family
for the considered atom is -complete.
In an entry t(m)[n], t is the total average running time (including support set generation and
timeouts), m is the number of timeouts and n is the number of found repair answer sets.
7.2 Benchmarks
For the evaluation of the developed algorithms, we considered the following benchmarks.
(1) The policy benchmark is a variant of Example 1, in which the rule (14) of P is changed
to deny(X )  DL[Staff chief ; UnauthorizedStaffRequest](X), and two further axioms,
namely UnauthorizedStaffRequest  StaffRequest  hasSubject.Unauthorized and
Blacklisted  Unauthorized are added to T .
(2) The OpenStreetMap benchmark contains a set of rules over the ontology for enhanced personalized route planning with semantic information (MyITS ontology, 2012) extended by an
ABox containing data from the OpenStreetMap project (OSM, 2012).
(3) The LUBM benchmark comprises rules on top of the well-known LUBM ontology (LUBM,
2005) in EL.
We now describe the benchmark results in details. All experimental data are online available
(Experimental data, 2015).
7.2.1 ACCESS P OLICY C ONTROL
We considered ABoxes An with n staff members, for n  {10, 250, 500}. Each data set has 5
projects and 3 possible actions; furthermore 20% of the staff members are unauthorized and 40% are
blacklisted. For generating instances, we used the probability p/100 (with p from column 1) that a
fact hasowner (pi , si ) is added to the rules part P for each si , pi , such that Staff (si ), Project(pi ) 
A (i.e., instances vary only on facts hasowner (pi , si ) in P.) as a parameter. Here, p ranges from 20,
30, etc. to 90 for A10 and from 5, 10 etc. to 40 for A250 and A500 . The total average running times
for these settings are shown in Tables 24, where SR stands for StaffRequest. The experiments
were performed for the ABoxes of the chosen size (i.e., A10 , A250 , A500 ) to demonstrate how our
approach works on small, medium and large data.
As regards A10 , limiting in the -complete setting the number of predicates for removal slightly
increases the running times. Restricting repairs to removing facts only over StaffRequest does
not slow down the repair computation compared to the unrestricted case, as many of the actual
repairs indeed satisfy this condition. The results for bounded number and size of support sets are
494

fiC OMPUTING R EPAIRS OF I NCONSISTENT DL-P ROGRAMS OVER EL O NTOLOGIES

p
20 (20)
30 (20)
40 (20)
50 (20)
60 (20)
70 (20)
80 (20)
90 (19)

-complete support families
no restr .
lim_p = 2
del_p = SR
1.92 (0)[20] 2.70 (0)[20]
1.91 (0)[20]
1.94 (0)[20] 2.72 (0)[20]
1.94 (0)[20]
1.93 (0)[20] 2.71 (0)[20]
1.93 (0)[20]
1.92 (0)[20] 2.70 (0)[20]
1.92 (0)[20]
1.94 (0)[20] 2.72 (0)[20]
1.95 (0)[20]
1.95 (0)[20] 2.73 (0)[20]
1.95 (0)[20]
1.94 (0)[20] 2.72 (0)[20]
1.95 (0)[20]
1.96 (0)[19] 2.74 (0)[19]
1.96 (0)[19]

Incomplete support families
size = 3
size = 5
num = 3
38.51 (0)[20]
33.86 (0)[20] 1.93 (0)[20]
86.35 (1)[19]
80.52 (1)[19] 1.95 (0)[20]
98.69 (1)[19]
96.45 (1)[19] 1.94 (0)[20]
100.46 (2)[18]
98.06 (2)[18] 1.93 (0)[20]
182.16 (3)[17] 186.20 (3)[17] 1.96 (0)[20]
153.66 (2)[18] 152.66 (2)[18] 1.96 (0)[20]
227.81 (6)[14] 223.24 (6)[14] 1.96 (0)[20]
267.52 (11)[8] 267.89 (12)[8] 1.96 (0)[19]

num = 
1.92 (0)[20]
1.93 (0)[20]
1.93 (0)[20]
1.91 (0)[20]
1.94 (0)[20]
1.94 (0)[20]
1.95 (0)[20]
1.95 (0)[19]

Table 2: Policy benchmark, A10
p
5(20)
10(20)
15(20)
20(20)
25(20)
30(20)
35(20)
40(20)

-complete support families
no restr .
lim_p = 2
del_p = SR
6.06(0)[20]
8.28 (0)[20]
6.05 (0)[20]
6.68(0)[20]
8.90 (0)[20]
6.68 (0)[20]
8.37(0)[20] 10.56 (0)[20]
8.35 (0)[20]
9.39(0)[20] 11.61 (0)[20]
9.40 (0)[20]
11.41(0)[20] 13.62 (0)[20]
11.41 (0)[20]
14.04(0)[20] 16.24 (0)[20]
14.09 (0)[20]
15.17(0)[20] 17.32 (0)[20]
15.19 (0)[20]
17.49(0)[20] 19.64 (0)[20]
17.47 (0)[20]

Incomplete support families
size = 6
num = 3
6.06 (0)[20]
6.07 (0)[20]
6.67 (0)[20]
6.69 (0)[20]
8.33 (0)[20]
8.34 (0)[20]
9.40 (0)[20]
9.43 (0)[20]
11.46 (0)[20] 11.40 (0)[20]
14.10 (0)[20] 14.05 (0)[20]
15.12 (0)[20] 15.16 (0)[20]
17.46 (0)[20] 17.45 (0)[20]

num = 
6.05 (0)[20]
6.67 (0)[20]
8.34 (0)[20]
9.41 (0)[20]
11.40 (0)[20]
14.04 (0)[20]
15.17 (0)[20]
17.43 (0)[20]

Table 3: Policy benchmark, A250
p
5 (20)
10 (20)
15 (20)
20 (20)
25 (20)
30 (20)
35 (20)
40 (20)

-complete support families
no restr .
lim_p = 2
del_p = SR
14.99 (0)[20]
18.71 (0)[20]
14.98 (0)[20]
23.57 (0)[20]
27.14 (0)[20]
23.52 (0)[20]
35.07 (0)[20]
38.85 (0)[20]
35.09 (0)[20]
73.43 (2)[18]
53.27 (0)[20]
73.29 (2)[18]
152.29 (8)[12]
64.91 (0)[20] 152.33 (8)[12]
288.06 (19)[1]
97.32 (1)[19] 288.08 (19)[1]
300.00 (20)[0]
153.03 (5)[15] 300.00 (20)[0]
300.00 (20)[0] 206.96 (10)[10] 300.00 (20)[0]

Incomplete support families
size = 6
num = 3
15.00 (0)[20]
14.97 (0)[20]
23.50 (0)[20]
23.51 (0)[20]
35.02 (0)[20]
35.12 (0)[20]
73.50 (2)[18]
73.32 (2)[18]
164.34 (9)[11] 152.25 (8)[12]
276.11 (18)[2] 288.05 (19)[1]
300.00 (20)[0] 300.00 (20)[0]
300.00 (20)[0] 300.00 (20)[0]

num = 
14.97 (0)[20]
23.43 (0)[20]
35.13 (0)[20]
85.33 (3)[17]
164.32 (9)[11]
300.00 (20)[0]
300.00 (20)[0]
300.00 (20)[0]

Table 4: Policy benchmark, A500
almost constant, except when the size is limited to 5 or smaller (just size 3 and size 5 are shown).
Here support sets exceed the bound and post-evaluation checks often fail, which visibly impacts the
running times. While the support sets are large, there are just few of them; this can be seen from the
insignificant difference between the times for num = 3 and num = .
For the significantly larger ABox A250 , we get that for each value of p the considered settings
perform almost identical except that lim_p = 2 is a bit slower. Moreover, the running times increase
gracefully with the value of p. While bounding the support set size to 5 produces only timeouts (thus
the column is omitted), computing support sets of size 6 is always sufficient to identify repairs.
For the largest setting A500 , in the -complete case finding an arbitrary repair is faster than
under the restriction lim_p = 2 , but only up to p = 15. From p = 20 the results for lim_p = 2
495

fiE ITER , F INK & S TEPANOVA

p
10 (20)
20 (20)
30 (20)
40 (20)
50 (20)
60 (20)
70 (20)
80 (20)
90 (20)

-complete support families
no restr .
lim_f = 5
lim_c = 10
13.01 (0)[20]
13.04 (0)[20]
13.05 (0)[20]
13.10 (0)[20]
13.04 (0)[20]
13.08 (0)[20]
13.11 (0)[20]
13.07 (0)[20]
13.12 (0)[20]

16.50 (0)[20]
16.49 (0)[20]
16.54 (0)[20]
16.58 (0)[20]
16.60 (0)[20]
16.61 (0)[20]
16.68 (0)[20]
16.70 (0)[20]
16.81 (0)[20]

16.46 (0)[20]
16.48 (0)[20]
16.49 (0)[20]
16.47 (0)[20]
16.51 (0)[20]
16.55 (0)[20]
16.58 (0)[20]
16.53 (0)[20]
16.59 (0)[20]

size = 1
16.39 (0)[11]
20.98 (0)[5]
24.56 (0)[0]
59.26 (0)[1]
123.80 (0)[0]
106.63 (1)[0]
139.08 (2)[0]
211.33 (5)[0]
260.36 (11)[0]

Incomplete support families
size = 3
num = 1
13.03 (0)[20]
13.04 (0)[20]
13.06 (0)[20]
13.07 (0)[20]
13.10 (0)[20]
13.06 (0)[20]
13.07 (0)[20]
13.06 (0)[20]
13.10 (0)[20]

13.23 (0)[20]
13.35 (0)[20]
13.51 (0)[20]
13.55 (0)[20]
13.56 (0)[20]
13.60 (0)[20]
13.61 (0)[20]
13.61 (0)[20]
13.67 (0)[20]

num = 3
13.06 (0)[20]
13.01 (0)[20]
13.02 (0)[20]
13.09 (0)[20]
13.04 (0)[20]
13.08 (0)[20]
13.07 (0)[20]
13.06 (0)[20]
13.10 (0)[20]

num = 
12.99 (0)[20]
13.02 (0)[20]
13.05 (0)[20]
13.05 (0)[20]
13.06 (0)[20]
13.08 (0)[20]
13.13 (0)[20]
13.08 (0)[20]
13.08 (0)[20]

Table 5: Open Street Map benchmark results

outperform the unrestricted setting, as the posed limitation restricts the search space of repairs effectively. Removing only facts over StaffRequest is no longer always sufficient, which is witnessed
by the decreased number of identified repairs for del _p = StaffRequest compared to lim_p = 2 .
Again the time increases rather gracefully with p as long as repair answer sets are found.
7.2.2 O PEN S TREET M AP
For the second benchmark, we added rules on top of the ontology developed in the MyITS project.
The fixed ontology contains 4601 axioms, where 406 axioms are in the TBox and 4195 are in the
ABox. The fragment T  of T relevant for our scenario and the rules P are shown in Figure 10.
Intuitively, T  states that building features located inside private areas are not publicly accessible
and a covered bus stop is a bus stop with a roof. The rules P check that public stations do not lack
public access, using CWA on private areas.
We used the method introduced by Eiter, Schneider, imkus, and Xiao (2014) to extract data
from the OpenStreetMap repository (OSM, 2012). We constructed an ABox A by extracting the
sets of all bus stops (285) and leisure areas (682) of the Irish city Cork, as well as isLocatedInside
relations between them (9) (i.e., bus stops located in leisure areas). As the data has been gathered
by many volunteers, chances of inaccuracies may be high (e.g. imprecise GPS data). Since the
data about roofed bus stops and private areas was yet unavailable, we randomly made 80% of
the bus stops roofed and 60% of leisure areas private. Finally, we added for each bsi such that
isLocatedInside(bsi , laj )  A the fact busstop(bsi ) to P with probability p/100. Some instances
are inconsistent since in our data set there are roofed bus stops located inside private areas.
The results are shown in Table 5. For the -complete setting arbitrary repairs are computed
about 3.5 seconds faster than the repairs with bounded changes. For the restricted configuration
the times do not vary much except for size = 1, where a significant time increase is observed, and
repairs are found only for smaller instances. Like in the previous benchmark computing a small
number of support sets is often sufficient, but the configuration num = 1 is as expected slightly
slower than num = 3 (computing support sets is here cheap, while postchecks take some time).
496

fiC OMPUTING R EPAIRS OF I NCONSISTENT DL-P ROGRAMS OVER EL O NTOLOGIES



T =



(1) BuildingFeature  isLocatedInside.Private  NoPublicAccess
(2) BusStop  Roofed  CoveredBusStop




(9) publicstation(X)  DL[BusStop  busstop; CoveredBusStop](X),



not DL[; Private](X);
P=
(10)


DL[BuildingFeature
 publicstation; NoPublicAccess](X),



publicstation(X ).









Figure 10: DL-program over OpenStreetMap ontology
p
5 (20)
15 (20)
25 (20)
35 (20)
45 (20)
55 (20)
65 (20)
75 (20)
85 (20)
95 (20)

no restr .
37.14 (0)[20]
35.74 (0)[20]
35.71 (0)[20]
36.07 (0)[20]
35.98 (0)[20]
35.92 (0)[20]
36.13 (0)[20]
36.07 (0)[20]
36.11 (0)[20]
36.38 (0)[20]

-complete support families
lim_f = 5
lim_p = 2
47.77 (0)[20] 43.74 (0)[20]
34.93 (0)[11] 42.74 (0)[20]
26.94 (0)[5] 42.80 (0)[20]
20.53 (0)[0] 43.04 (0)[20]
20.50 (0)[0] 43.11 (0)[20]
20.51 (0)[0] 43.11 (0)[20]
20.43 (0)[0] 43.44 (0)[20]
20.63 (0)[0] 43.45 (0)[20]
20.30 (0)[0] 43.35 (0)[20]
20.55 (0)[0] 43.24 (0)[20]

lim_c = 20
43.88 (0)[20]
41.51 (0)[19]
41.71 (0)[19]
26.91 (0)[7]
19.54 (0)[1]
18.47 (0)[0]
18.33 (0)[0]
18.28 (0)[0]
18.04 (0)[0]
18.20 (0)[0]

Incomplete support families
size = 1
size = 3
42.57 (0)[20] 36.52 (0)[20]
42.02 (0)[20] 35.96 (0)[20]
41.91 (0)[20] 35.80 (0)[20]
42.22 (0)[20] 36.00 (0)[20]
41.94 (0)[20] 36.40 (0)[20]
42.31 (0)[20] 35.98 (0)[20]
41.81 (0)[20] 36.02 (0)[20]
42.09 (0)[20] 36.21 (0)[20]
42.22 (0)[20] 36.15 (0)[20]
42.52 (0)[20] 36.17 (0)[20]

num = 
36.26 (0)[20]
35.49 (0)[20]
35.49 (0)[20]
35.65 (0)[20]
35.66 (0)[20]
35.60 (0)[20]
35.92 (0)[20]
35.85 (0)[20]
35.83 (0)[20]
35.62 (0)[20]

Table 6: LUBM benchmark results
7.2.3 LUBM
We have also tested our approach on DL-programs  = hP, Oi built over an EL version of the
LUBM ontology, whose TBox was extended with the following axioms:
(1) GraduateStudent  assists.Lecturer  TA
(2) GraduateStudent  teaches.UndergraduateStudent  TA
The rules of  are as follows:


(3) stud (X )  not DL[; Employee](X ), DL[; TA](X );
;
P=
(4)   DL[Student  stud ; TAof ](X , Y ), takesexam(X , Y )
here (3) states that unless a teaching assistant (TA) is known to be an employee, he/she is a student,
while (4) forbids teaching assistants to take exams in the courses they teach.
The ABox contains information about one university with more then 600 students, 29 teaching
assistants, constructed by a dedicated ABox generator (LUBM data generator, 2013). For pairs of
constants t, c, such that teachingAssistantOf (t, c) is in A, the facts takesexam(t, c) are randomly
added to the rules part with probability p/100, thus the contradicting part in the DL-program is
growing with respect to p.
The results for this benchmark are provided in Table 6. Bounding in the -complete setting
the number of removed facts to 5 slows down the computation, if repairs satisfying the condition
exist. For instances with p  35 (i.e., inconsistency is more entrenched), more than 5 facts must
be dropped to obtain a repair; moreover, they often involve more than 20 constants according to
497

fiE ITER , F INK & S TEPANOVA

column 5. The absence of repairs for lim_f = 5 and lim_c = 20 is found faster than a repair in the
unrestricted mode.
Limiting the support set size to 1 allows one to find repairs for all instances with a delay of less
than 10 seconds compared to the -complete setting. However, there are many support sets for this
benchmark, and thus bounding their number is less effective.
7.3 General Results Discussion
One can observe that for -complete settings and settings where post-evaluation checks are fast, the
running times vary only slightly with growing p. This is due to our declarative implementation, in
which computing repairs is reduced to finding answer sets of the program 1 =   R  facts(A) 
COMP followed by possible evaluation postchecks. In our benchmarks the difference between
instances of size pi and pi+1 is the data part of the logic program, which is small compared to the
part facts(A) of 1 that is constant for all p. Thus as long as postchecks are not needed, the times
required for repairing  do not differ much even though the programs become more inconsistent.
As expected, using -complete support families works well in practice. Naturally, it takes more
time to compute restricted repairs rather than arbitrary repairs; however, when the imposed restrictions are too strong such that no repair can satisfy them, the solver may recognize this faster.
As reported by Hansen et al. (2014), EL-TBoxes that originate from real-world applications
admit FO-rewritings (of reasonable size) in almost all cases. This provides some evidence that realworld EL-TBoxes hardly contain involving constraints on the conceptual level, and that hence either
the size or number of support sets for DL-atoms often turn out to be limited. The novel algorithms
for deletion repair answer set computation demonstrated their applicability for DL-programs over
some real world data (Open Street Map benchmark results in Table 5).
While most of the other benchmarks that we have run are synthetic, they still vary w.r.t. TBox
and ABox sizes. The capability of our algorithms for handling such diverse DL-programs confirms
the potential of our approach.

8. Related Work
Inconsistencies in DL-programs were studied in several works (Phrer et al., 2010; Fink, 2012;
Eiter et al., 2013, 2014d). Phrer et al. proposed an inconsistency tolerant semantics. Keeping the
ontology untouched, the DL-atoms that introduce inconsistency as well as rules involving them are
deactivated. The repair problem, outlined as an open issue by Phrer et al., was formalized by Eiter
et al. (2013), where the notions of repair and repair answer sets together with a naive algorithm
for their computation were proposed. The latter was then optimized by Eiter et al. (2014d, 2015)
for DL-Lite A by effectively exploiting complete support families for DL-atoms. Our approach is
more general, and it differs from the one of Eiter et al. (2014d, 2015) in that it uses partial (not
necessarily complete) support families and can be applied to ontologies in any DL, though with a
possible impact on complexity.
In other hybrid formalisms, inconsistency management has concentrated on inconsistency tolerance rather than on repair. For instance, Huang et al. (2013) presented a four-valued paraconsistent
semantics based on Belnaps logic (Belnap, 1977) for hybrid MKNF knowledge bases (Motik &
Rosati, 2010), which are the most prominent tightly coupled combination of rules and ontologies.
Inspired by the paracoherent stable semantics of Sakama and Inoue (1995), the work of Huang
et al. (2013) was extended by Huang, Hao, and Luo (2014) to handle also incoherent MKNF KBs,
498

fiC OMPUTING R EPAIRS OF I NCONSISTENT DL-P ROGRAMS OVER EL O NTOLOGIES

i.e. programs in which inconsistency arises as a result of the dependency of an atom on its default
negation in analogy to the work of Fink (2012). Another direction of inconsistency handling for
hybrid MKNF KBs is using the three-valued (well-founded) semantics of Knorr, Alferes, and Hitzler (2011), which avoids incoherence for disjunction-free stratified programs. Most recently, this
has been extended by Kaminski et al. (2015) with additional truth values to evaluate contradictory
pieces of knowledge. These works aim at inconsistency tolerance rather than repair, and are geared
in spirit to query answering that is inherent to well-founded semantics; as such, it is limited to
normal logic programs, while DL-programs allow for disjunctive rule heads.
In the context of Description Logics, repairing ontologies has been studied intensively, foremost
to handle inconsistency. Our DL-program repair is related to ABox cleaning (Masotti, Rosati, &
Ruzzi, 2011; Rosati, Ruzzi, Graziosi, & Masotti, 2012). However, the latter differs in various
respects: it aims at restoring consistency of an inconsistent ontology by deleting -minimal sets
of assertions (i.e., computing -maximal deletion repairs); we deal with inconsistency incurred
on top of a consistent ontology, by arbitrary (non-monotonic) rules which access it with a query
interface. Furthermore, we must consider multiple ABoxes at once (via updates), and use EL instead
of DL-Lite. Refining our algorithm to compute -maximal deletion repairs is possible.
The problem of computing support families is tightly related to finding solutions to an abduction
problem, which was considered by Bienvenu (2008) for theories T expressed in EL-terminologies.
A hypothesis H = {A1 , . . . , An } is a set of atomic concepts, and an observation is another atomic
concept. A solution to the abduction problem is any set S  H, such that T |= Ai S Ai  O.
Our setting is more general and involves also roles along with atomic concepts. Abduction has
been studied in various related areas e.g., for DL-Lite ontologies by Calvanese, Ortiz, Simkus, and
Stefanoni (2013), for propositional logic by Eiter and Makino (2007), for datalog by Eiter et al.
(1997) and Gottlob, Pichler, and Wei (2007), etc. Using incomplete support families for DL-atoms
is related in spirit to approximate inconsistency-tolerant reasoning in DLs using restricted support
sets as considered by Bienvenu and Rosati (2013); however, we focus on repair computation and
model generation while Bienvenu and Rosati target inference from all repairs.
Our methods for constructing partial support families exploit the results on the logical difference
between EL terminologies presented by Konev et al. (2012) and Ecke et al. (2013); recently they
were extended to ELHR by Ludwig and Walther (2014) and to general TBoxes by Feng et al.
(2015).
Repairing inconsistent non-monotonic logic programs has been investigated in the work of
Sakama and Inoue (2003), where an approach for deleting rules based on extended abduction was
studied; however, to restore consistency addition of rules is also possible. The latter was considered
by Balduccini and Gelfond (2003), where under Occams razor consistency-restoring rules may be
added. Methods for explaining why the inconsistency arises in a logic program were studied, e.g.,
by Syrjnen (2006), who exploited model-based diagnosis of Reiter (1987) to debug a logic program. Generalized debugging of logic programs was investigated e.g., by Gebser, Phrer, Schaub,
and Tompits (2008). Most recently, Schulz, Satoh, and Toni (2015) considered a characterization
of reasons for inconsistency in extended logic programs (i.e., disjunction-free logic programs with
both strong (classical) negation and weak negation) in terms of culprit sets of literals, based on
the well-founded and maximal partial stable model semantics, and a derivation-based method to explain such culprits has been described; however, it remains open how debugging of logic programs
based on culprit sets could be done and whether this could be fruitfully extended to debugging DLprograms. The latter has been addressed by Oetsch, Phrer, and Tompits (2012) and is related to
F

499

fiE ITER , F INK & S TEPANOVA

the challenging but, to the best of our knowledge, unexplored problem of repairing the rule part of
a DL-program.

9. Conclusion
We have considered computing repair answer sets of DL-programs over EL ontologies, for which
we generalized the support set approach of Eiter et al. (2014d, 2014b) for DL-Lite A to work with
incomplete families of supports sets; this advance is needed since in EL complete support families can be large or even infinite. We discussed how to generate support sets, by exploiting query
rewriting over ontologies to datalog (Lutz et al., 2009; Rosati, 2007; Stefanoni et al., 2012), which
is in contrast to the work by Eiter et al. (2014d), where TBox classification is invoked. Moreover,
we have developed alternative techniques for effective computation of partial support families. Our
approach is to approximate a relevant part of the TBox to DL-Lite core exploiting a notion of logical
difference between EL-terminologies, and then compute complete support families over an approximated TBox using methods of Eiter et al. (2014d). The obtained support family is complete, if the
approximated TBox is logically equivalent to the original one.
To estimate the maximal size of support sets, we have analyzed the properties of a novel support hypergraph, which corresponds to a subgraph of an ontology hypergraph (Nortje et al., 2013;
Ecke et al., 2013), where nodes encode ontology predicates (or pairs of them), while (hyper) edges
reflect TBox inclusions. We have shown how traversing a support hypergraph one can conveniently
compute an upper bound for the number of support sets for a given DL-atom. If, in addition, the
support hypergraph satisfies certain conditions (e.g. tree-acyclicity), then an exact estimate can be
obtained.
We developed a sound algorithm for computing deletion repair answer sets for DL-programs
over EL ontologies, which is complete in case all support families are also known to be complete.
The algorithm trades answer completeness for scalability (a simple variant ensures completeness).
We have implemented the novel algorithm using declarative means within a system prototype, that
invokes a R EQUIEM reasoner for partial support family computation. For an experimental assessment of our repair approach, a set of novel benchmarks has been constructed including real
world data. While the availability of complete support families adds to the scalability of the repair
computation, partial support families work surprisingly well in practice due to the structure of the
benchmark instances: the support sets are either small or there are just few of them, and thus postevaluation checks do not cause much overhead. Overall, our experimental evaluation has revealed a
promising potential of the novel repair methodology for practical applications.
9.1 Outlook
The directions for future work in the considered area are manifold. They cover both theoretical and
practical aspects of our inconsistency handling approach. On the theoretical side, a relevant open
issue are sufficient conditions under which computing all nonground support sets for a DL-atom
accessing an EL ontology becomes tractable. Like in the work of Gebser et al. (2008) bounded
tree-width might be considered, but also other parameters like density of a support hypergraph or
various acyclicity properties. Analyzing the complexity of counting support sets in a complete
support family might give hints to possible restricted settings, in which support family computation
is efficient, but such a complexity analysis is also an interesting problem as such. On the practical
500

fiC OMPUTING R EPAIRS OF I NCONSISTENT DL-P ROGRAMS OVER EL O NTOLOGIES

side, optimization of the current implementation and extending the range of applications to real use
cases is another issue.
Repair may be intermingled with stepping techniques used for debugging DL-programs (Oetsch
et al., 2012). We considered the DL-programs as monolithic structures when applying our repair
techniques, that is the repair computation was performed on a DL-program taken as a whole. It is
an interesting and a relevant quest to extend the approach for dealing with modular DL-programs.
Splitting a program into separate components that can be individually evaluated is a well-known
programming technique, which has been studied in the context of DL-programs (Eiter et al., 2008).
It is not clear, however, to which extent and for which program classes the repair methods can be
adapted for the modular setting.
While we have considered EL in this paper, the basic algorithm and approach is applicable also
to other DLs. Extensions of our work to EL+ and EL++ are easily possible. The main difference
is negation, which is expressible via the  concept; the ontology can get inconsistent through the
updates of DL-atoms, leading to an increased number of support sets that need to be effectively
computed and appropriately handled. The extension to expressive DLs such as SHIQ, SHOIN
or even SROIQ is more challenging, as efficient methods for support set construction remain to
be developed; by the relatively high complexity of these DLs, this comes at a computational cost.
On the other hand, the computation may be done once (even offline) and can be reused; fortunately,
support families need not be complete, but we may expect a return of investment of time in support
set construction for the overall running time.
Orthogonal to other DLs, one can study various additional repair possibilities, e.g. bounded
addition; for overview of repair possibilities see the work of Eiter et al. (2013). Here we have
concentrated on repairing the data part of the ontology, but it is also natural to allow changes in
rules and interfaces. For repairing rules, the works on ASP debugging by Frhstck, Phrer, and
Friedrich (2013), Gebser et al. (2008), and Syrjnen (2006) can be used as a starting point, but
the problem is challenging as the search space of possible changes is large. Priorities on the rules
and atoms involving them might be applied to ensure high quality of rule repairs. The interfaces
similarly admit numerous modifications, which makes this type of repair as difficult; user interaction
is most probably required.
Last but not least one could develop methods for repairing other hybrid formalisms including
tightly-coupled hybrid KBs or even more general representations like HEX-programs (Eiter et al.,
2005), where instead of an ontology arbitrary sources of computation can be accessed from a logic
program. Heterogeneity of external sources in HEX-programs makes both repair and paraconsistent
reasoning a very challenging task.

Acknowledgments
We thank the anonymous reviewers for their detailed and constructive suggestions which helped to
improve this work. This article significantly extends preliminary work of Eiter, Fink, and Stepanova
(2014c). The research has been supported by the Austrian Science Fund (FWF) projects P24090 and
P27730.
501

fiE ITER , F INK & S TEPANOVA

Appendix A. Proofs for Section 3
A.1 Proof of Proposition 15
() By Proposition 10, I |=O d iff Td  A  AI |= Q(~t), where AI = {Pp (~t)  Ad | p(~t)  I}.
Thus, S = A  AI is a support set of d w.r.t. O, and it is coherent with I by construction.
() If S  Supp O (d) is coherent with I, then S is of the form S = A  AI where A  A
and AI  AI , and thus S  A  AI . As Td  S |= Q(~t), by monotonicity Td  A  AI |= Q(~t),
hence by Proposition 10 I |=O d.
A.2 Proof of Proposition 24
~ where
Consider any instance S = {P1 (Y1 ), . . . , Pk (Yk )} of a set S of form (5) for d(X),
 : V  C. We show that S is a support set w.r.t. OC = hT , AC i (recall that AC is the set of all
~
possible ABox assertions over C), i.e., S  AC  Ad (which clearly holds) and Td  S |= Q(X).
~
The latter is equivalent to Tdnorm  S |= Q(X),
which in turn by Lemma 23 is equivalent to
0
~
Prog Q,Td norm  S |= Q(X). Let Prog = Prog Q,Td norm , and let Prog i+1 , for each i  0,
~
be the program that results from Prog i by unfolding a rule w.r.t. the target query Q(X).
Then
i+1
i
~
~
Prog
 S |= Q(X) iff Prog  S |= Q(X) holds. Now by construction of S, there is a rule
~ and thus Prog i  S |= Q(X).
~
r of the form (4) in some Prog i . Clearly {r}  S |= Q(X)
It
0
~
~
~
follows that Prog  S |= Q(X) and hence Td norm  S |= Q(X) and Td  S |= Q(X).

Appendix B. Proofs for Section 4
B.1 Proof of Lemma 31
Towards a contradiction, assume T1d 6C
 T2d . Then w.l.o.g. T1d |= P1  P2 but T2d 6|= P1  P2 ,

where P1 , P2   . Observe that  and  differ only on predicates Pp , such that P  p occurs in
, and that T  = T1d \T1 = T2d \T2 consists only of axioms Pp  P where Pp does not occur in
T1 or T2 . We first show that P2   must hold. Indeed, otherwise P2   \  and thus P2 =
Pp  sig(Ad ) for some P  p from . Now let A = {P1 (c)} if P1  , and A = {P1 (c), P1p (c)}
otherwise (i.e., P1   \ ), for an arbitrary c  I. Then T1d  A has a model I in which cI  P1I
(resp. cI  P1I and cI  P1 Ip ) and Pp I =  (thus P1 6= P2 ), as EL is negation-free and Pp occurs
in axioms only on the left. As I 6|= P1  Pp , it follows T1d 6|= P1  P2 , which is a contradiction.
This proves P2   \ . Now there are two cases.
(i) P1  : T1 C
 T2 implies T2 |= P1  P2 ; by monotonicity T2d |= P1  P2 , a contradiction.
(ii) P1   \ : then P1 = Pp , where P  p occurs in , and P  . We claim that T1 |= P  P2 .
Indeed, otherwise T1 has a model I such that P I 6 P2 I . Then as easily seen the interpretation I 


that coincides with I on  and has Pp I = P I \ P2 I and Pp I =  for each Pp   \  is a model
of T1 d ; however, I  6|= Pp  P2 , which would be a contradiction. This proves the claim. Now
from the claim and T1 C
 T2 , it follows T2 |= P  P2 and by monotonicity T2d |= P  P2 . As
Pp  P  T2 d , it follows T2 d |= P1  P2 ; this is a contradiction.
B.2 Proof of Proposition 32
Suppose that S1 is a complete nonground support family w.r.t. O1 and let S be any instance of any
i
S  S1 ; then S = A  Ad  AC  Ad . By Lemma 31, T1d C
 T2d ; thus by Theorem 30, T1d 
502

fiC OMPUTING R EPAIRS OF I NCONSISTENT DL-P ROGRAMS OVER EL O NTOLOGIES

T2 d as well. By definition of -instance inseparability, for all -ABoxes A and -assertions 
such that T1d  A |= , it holds that T2d  A |= ; hence T2d  A  Ad |= Q(~c). Consequently,
S = A  Ad is a (ground) support set of d w.r.t. O2 . If S2 is a complete nonground support family
w.r.t. O2 , it follows that S is an instance of some S   S2 . The converse membership is symmetric.
Hence, S1 and S2 are ground-identical.
B.3 Proof of Proposition 34
Towards a contradiction, assume some S   S \ SuppO (d) exists. Then a grounding  exists such
that S    Td 6|= d(X). However, S    Td |= d(X), as according to (f), S  is a nonground
support set for d w.r.t. Td = Td  lrw . Consequently, Td 6|= Td , which is a contradiction, because
Td  Td by construction in (c) and lrw = {C   D | Td |= C   D , Td 6|= C   D }  Td by
lhs
(d) and definition of cWTnrhs
 and cWTn .

Appendix C. Proofs for Section 5
C.1 Proof of Lemma 47

for d w.r.t. the ontology O =
The construction of support sets from a given hypergraph Gsupp(d),T
hT , Ai that we have presented mimics the DL-query unfolding over the TBox Td . We now formally
show that (i) each set S extracted in the described way is indeed a nonground support sets for d,
and (ii) for each ground instance S of a nonground support set S for d, a (nonground) support
set S  can be constructed following our procedure such that S    S for some suitable ground
substitution  . This proves that SG  S holds.
We first prove (i) by induction on the length n of incoming paths, from which the support sets
are extracted.

Base: n=1. Consider any path  in the hypergraph Gsupp(d),T
. Assume that there is a single
(hyper-) edge e in . By construction, this hyperedge must have xQ as a head node, i.e. head (e) =
xQ . There are four possibilities: (1) tail (e) = {xC }, (2) tail (e) = {xr , xC }, (3) tail (e) =
{xC , xD } or (4) tail (e) = {xr , }. We annotate the nodes of a path by variables as described
above, and extract the nonground atoms from labels and annotations of the nodes. As a result for
the case (1) we obtain {C(X0 )}, for (2): {r(X0 , X1 ), C(X1 )}, for (3): {C(X0 ), D(X0 )}, and for
(4): {r(X0 , X1 )}, where X1 is a fresh variable. By construction of the hypergraph the edges of the
forms (1)-(4) correspond to the TBox axioms C  Q, r.C  Q, C  D  Q and r.  Q
respectively. Therefore, the sets that have been constructed in all of the considered cases reflect the
DL-query unfoldings of d, and hence they represent nonground support sets for d by Proposition 24.
Induction step: Suppose that the statement is true for n, i.e. from a path with n edges all sets extracted in the way described above are nonground support sets for d. Consider a path  = e0 , . . . , en
with n+1 edges, and let e = e0 be the first edge of . By the induction hypothesis, all sets extracted
from the path  \ e = e1 , . . . , en following our approach are support sets for d. There are several
possibilities for the form of e: (1) tail (e) = {xC } and head (e) = {xD }, (2) tail (e) = {xr , xC }
and head (e) = {xD }, (3) tail (e) = {xC , xD } and head (e) = {xB }, (4) tail (e) = {xr , } and
head (e) = {xC }, or (5) tail (e) = {xC } and head (e) = {xr , xD }.
As for (1), by construction both xC and xD are annotated with Xi . Let S be a family of sets
extracted from \e. We pick a set S in which C(Xi ) occurs. We substitute C(Xi ) in S with D(Xi ),
and obtain a set S  . By the induction hypothesis S must be a support set for d. However, then

503

fiE ITER , F INK & S TEPANOVA

clearly S  is also a support set, as it mimics an additional unfolding step that accounts for the rule
C(X)  D(X) of the datalog rewriting of Td .
Let us look at (2). Assume a set S  D(Xi ) of nonground atoms has been constructed using
our procedure. Then Xi must be an annotation for xD . According to our construction {xr , xD } is
annotated with {hXi , Xj i, hXj i}, where Xj is a fresh variable. The sets S  that we get from  result
by substituting D(Xi ) in some S with {r(Xi , Xj ), C(Xj )}. The latter mimics the unfolding step
for Q that accounts for the rule D(Xi )  r(Xi , Xj ), C(Xj ) of the rewriting Td . As S is a support
set for d by the induction hypothesis, S  must be a support set for d as well. The cases (3)-(5) can
be analyzed analogously. Thus all sets of size n + 1 extracted from  are support sets for d.
It remains to prove (ii). Towards a contradiction, assume that some ground instance S of
some S  SuppO (d) exists, such that for each ground instance S   of every S   SuppO (d)
constructed by our procedure we have S   6 S. As S is a support set, by definition Td norm 
S |= Q(~c), thus by Lemma 23 Prog Q,Tdnorm  S |= Q(~c). This in turn means that Q(~c) has a
~ 0 and Sm = ,
backchaining proof S0 , S1 , . . . , Sm from Prog Q,Td norm S of the form S0 = Q(X)
~ 7 ~c, and Si = (Si1  Hi + Bi )i , i  1, where Hi  Bi is a
where 0 is the substitution X
rule resp. fact in Prog Q,Td norm  S and i is the most general unifier of Hi with some atom in Si1 .
Without loss of generality, we have Hi = A2 (oA2 ) if Hi1 = R2 (X, oA2 ) and all i such that Bi is
empty are at the end, i.e. at the positions k, k + 1, . . . , m. Then each Sj resp. Sj+1 , 0  j  k


amounts to an instance of a support set Sj resp. Sj+1
of d generated from Gsupp(d),T
. In particular,


Sk1 is an instance of Sk1 and consequently {Hk , Hk+1 , . . . , Hm } ( S) is an instance of Sk1





as well. But this means S   S for some instance S  of S = Sk1 , a contradiction.
C.2 Proof of Proposition 48
We prove the statement by induction on the number n of hyperedges with a singleton head node in

G = Gsupp(d),T
for the DL-atom DL[; Q](X).
Base: n = 0. We show that maxsup(d ) = 1 if no hyperedges of the required form exist in G.
Several cases are possible: (i) G contains only hyperedges of the form (xC , {xr , xD }); (ii) G has
only hyperedges of the form ({xr , }, xC ) or (xC , {xr , }); or (iii) G has no hyperedges.
(i) Consider some hyperedge in . Then some ej must exist in , such that head (ei )  tail (ej ).
The latter implies that ej is of the form ({xr , xD }, xD ) but then n 6= 0, i.e. contradiction.
For (ii) and (iii), by construction T contains only GCIs C  D such that C, D are either atomic
or of the form r.. These axioms fall into the DL-Lite core fragment, for which all  -minimal
support sets S have size at most 2; moreover, |S| = 2 reflects in DL-Lite core inconsistency arising
in the updated ontology (Eiter et al., 2014d). As negation is not available nor expressible in EL, no
such S exists and thus the maximal support set size for d is 1.
Induction Step: Suppose that the statement is true for n; we prove it for n+1. Let  = e1 , . . . , ek

with a maximal number n+1 of hyperedges with a singleton
be an incoming path to xQ in Gsupp(d),T
head node. Assume that ei is the first hyperedge of the required form occurring in . Let us
split  into two parts: e1 , . . . , ei and ei+1 , . . . , ek . Consider the hypergraph G  = (V, E  ), where
E  = E \ {e1 , . . . , ei }, and the TBox T  reconstructed from it. By the induction hypothesis,
maxsup(d ) w.r.t. O = hT  , Ai is bounded by n + 1. Now let the hypergraph G  = (V, E  ) with
E  = E   {ei } correspond to the TBox T  . By our assumption head (ei ) = xA , i.e. ei either
reflects B  C  A or r.B  A. Two cases are possible: either A = Q or A 6= Q. In the
504

fiC OMPUTING R EPAIRS OF I NCONSISTENT DL-P ROGRAMS OVER EL O NTOLOGIES

x C n1

x Cn

x C nk

xCn

...

xCn

1

..
.

k

..
.
...
xQ

Figure 11: Fragment of a hypergraph used for illustration in the proof of Proposition 53
former case, ei is a single hyperedge on , i.e. n = 1. Support sets obtained from rewriting Q over
B  C  Q or r.B  Q are of size at most 2. The other support sets are constructed by combining
query rewritings of predicates occurring on the left hand side of GCIs reflected by ei ; each of these
rewritings has size at most 1 as shown in the base case. Thus the overall support set size for d w.r.t.
T  is bounded by 2  n + 1.
Suppose now that A 6= Q, i.e. ei reflects either B  C  A or r.B  A. By definition of an
incoming path a (hyper) edge ej must exist, such that head (ei )  tail (ej ). Moreover, note that ej
is a unique (hyper) edge connected to ei on , as otherwise the given hypergraph is tree-cyclic, i.e.
contradiction. We distinguish two cases: (1) head (ei ) = tail (ej ) and ej corresponds to A  . . . ;
(2) head (ei )  tail (ej ) and ej reflects A  B  . . . .
1. Consider a maximal support set S for d w.r.t. T  , and suppose A(Y )  S holds. By induction

hypothesis |S|  n. As G  = Gsupp(d),T
 is tree-acyclic, only a single atom over A might

occur in S. Adding the edge ei to G from S we obtain a support set S  with the atom A(Y )
substituted with atoms B(Y ) and C(Y ), or r(Z, Y ) and B(Z) as a result of an additional
query unfolding step. Hence the support set size of S  will be bounded by n + 2.
2. If ej reflects A  B  . . . , then a support set S  {A(Y ), B(Y )} must exist. By unfolding
the respective datalog rule, we get the bound n + 2 on the support set S  for d w.r.t. T  . 

C.3 Proof Sketch of Proposition 53
Observe that in tree-acyclic hypergraphs all nodes have a hyper out-degree at most 1, and hence
m(, G) = 0. Thus, if G is tree-acyclic, then by Proposition 48 the support set size for a given
DL-atom is bounded by n(, G)  0 + 1, which equals smax . We now show that the claimed bound
is also correct for tree-cyclic hypergraphs. Intuitively, m(, G) must be subtracted from n(, G) to
avoid that certain atoms in a support set are counted multiple times. Regarding the structure of the
support hypergraph we distinguish two cases: (i) no roles appear in a hypergraph; (ii) for all xr  G,
it holds that r 6 .
505

fiE ITER , F INK & S TEPANOVA

First we consider (i). Since only concepts appear in the support hypergraph by our assumption, all support sets will contain atoms in which only a single variable X0 occurs. Consider some
node xCn in  such that hdc+ (xCn ) = k, where k > 1, i.e., there are k outgoing hyperedges
from xCn containing nodes corresponding to concepts: ({xCn1 , xCn }, xCn ). . .({xCnk ,xCn }, xCn )
1
k
(see Figure 11). From support sets S  {Cn 1 (X0 ), . . . , Cn k (X0 )} we will get support sets S  
{Cn1 (X0 ), . . . , Cnk (X0 ), Cn (X0 )}. Estimating the maximal support set size as the number of hyperedges in the hypergraph, Cn (X0 ) is counted k times, but it appears only once (as its variable is
guaranteed to be X0 ). To avoid such multiple countings, m(, G) must be subtracted from n(, G).
Consider now (ii). By construction of G, for every hypernode {xr , xC }   edges e1 =
(xA , {xr , xC }) and e2 = ({xr , xC }, xB ) exist in G. Thus if xr occurs in , then consider a
support set S  {B(X)}. Rewriting the TBox axiom reflected by e2 , we get a datalog rule
B(X)  r(X, Y ), C(Y ). Then the axiom r.C  A reflected by e1 is rewritten to datalog rules
r(X, oC )  A(X); C(oC )  A(X). Unifying Y with oC we obtain an unfolding A(X). This
essentially shows that if no role occurring in a support hypergraph is in , then all support sets
involve only a single variable; in this case, as shown in (i), the provided bound is correct.
C.4 Proof of Proposition 57

The proof is by induction on the number n of (hyper) edges in G = Gsupp(d),T
. Base: n=0. If G has
no (hyper) edges, each node has one support set.
Induction step: Suppose the statement holds for n; we show it holds for G with n + 1 (hyper)
edges. Obviously, it holds for x  VR . As G is tree-acyclic and T is in normal form, G has a
node x such that hd+ (x) = d+ (x) = 0, i.e., there are no outgoing (hyper) edges, and hd (x) 6= 0
or d (x) 6= 0, i.e., there is some incoming (hyper) edge. As G is tree-acyclic, the rewriting of
the set Qx = {A(X)}, where x = xA consists of Qx and the rewritings of all sets Qtail(e) of
(hyper) nodes tail (e) such that head (e) = x. If tail (e) is {xB } (resp., {xB , xC }, {xr , xC }) these
are all rewritings of {B(X)} (resp. {B(X), C(X)}, {R(X, Y ), C(Y )}). That is, ws(xA ) is the
sum of the number of all rewritings of each Qtail(e) denoted Qtail(e) , plus 1. Consider now an
arbitrary e with head (e) = xA and let G  = G\e. As G  has n edges and is tree-acyclic, by the
induction hypothesis for each node x  V in G  , the value of ws(x), denoted wsG  (x), is as in (8).
Furthermore, ws(Qtail(e) ) and ws(x ), x 6= xA is in G  the same as in G. We thus get for x = xA :

wsG (x) = wsG  (x) + ws(Qtail(e) )
X Y
wsG  (x ) +
= 1+
T T

= 1+



(x)

x T

X

Y

wsG (x ) +

X

Y

wsG (x ) +

T T  (x) x T

X

ws(x ) + ws(Qtail(e) )

X

X

ws(x ) + ws(Qtail(e) )



(x),T 6VC ({x },T )E 

T T   (x),T 6VC ({x },T )E 

T T   (x) x T

= 1+

T T

X

X

X

ws(x )

T T  (x),T 6VC ({x },T )E



where T  (x) = {T | (T, {x})  E  } and E  = E \ {e}, and T  (x) is as above. To obtain
ws(Qtail (e)), we simply need to count the combinations of the rewritings of each node in tail (e),
and in case tail (e) = {xr , xB } (where ws(xr ) = 1), we need to add the number of rewritings of
the tail of each hyperedge (T, {xr , xB }) (as T is in normal form, T must be of the form {xC }).
506

fiC OMPUTING R EPAIRS OF I NCONSISTENT DL-P ROGRAMS OVER EL O NTOLOGIES

C.5 Proof of Corollary 60
This Q
is immediate from Proposition 57: under the hypothesis, in (8) each T is of form {y}  VC ;
thus x T ws(x ) = ws(y), i.e., ws(tail (e)) and the rightmost term is 0.
C.6 Proof Sketch of Proposition 61
Under the condition on e and e1 , e2 , every set T  T  (x) in Equation (8)
Q such that |T| = {x, y} > 1
contains (at least) one element, say x, such that ws(x) = 1, and thus x T wsG (x ) equals ws(y)

. By an inductive argument, we then obtain that for every node xA  VC ,
in G = Gsupp(d),T
ws(xA )  1 is the number of distinct edges in G that occur on incoming paths to xA and any
xB  VC such that an edge ({xB }, {xr , xA }) is in E, plus the number of all such edges. This in
turn implies that for the query node xQ , ws(xq ) = |E| + 1 holds, as by construction each edge e  E
is among the respective edges for xQ . From this the result follows immediately.

Appendix D. Proofs for Section 6
D.1 Proof of Theorem 65
  . We can get to (h) only if I is an answer set of , and
Suppose SupRAnsSet outputs I = I|
if the foundedness check of I w.r.t. the ontology T  A , where A = A\H succeeded. It thus
remains to show that I is a compatible set for T  A , i.e., that for each DL-atom d in , d  Dp


iff I |=O d and d  Dn iff I 6|=O d. Towards a contradiction, suppose that this is not the case. In
(d) we partitioned the DL-atoms into two sets: Dp and Dn , corresponding to DL-atoms d guessed

 respectively, and set SIgr
 A). Since we assume that I is not
to be true and false in I,
to Gr(S, I,
compatible, one of the following must hold:

(1) For some DL-atom d in Dn , we have I |=O d. There are two possibilities: (i) either there is

a support set S  SIgr (d) or (ii) no support sets for d were identified. In case (i), we are guaranteed
that all support sets S for d are such that S  A 6= , since otherwise no hitting sets H are found in
(e). Hence there must exist some support set S such that S  A =
6 . According to (e) S  H 6= 
and thus S 6 Suppd (O ). Now as rep = true at (h), a post-check of d must have succeeded in (g),

i.e. I 6|=O d must hold. This is a contradiction. In case (ii), likewise post-evaluation of d must have
succeeded in (h), which again raises a contradiction.




(2) For some DL-atom d in Dp , we have I 6|=O d. Hence SIgr (d) = , d 6 Dp , and post-evaluation
is performed for d in (g). The latter, however, must have succeeded, as rep = true at (h); this is a
contradiction. Hence I is a compatible set for  , and thus a deletion repair answer set of .
D.2 Proof of Theorem 66
The following lemmas are useful to prove Theorem 66.
Lemma 69 Let I  ASx () where x  {flp, weak } and  = hT , A, Pi is a ground DL-program.
Then I = I  {ed | d  DL , I |=T A d}  {ned | d  DL , I 6|=T A d} is an answer set of ,
where DL is the set of all DL-atoms occurring in .
This lemma follows from a more general result on compatible sets as the basis of the evaluation
approach of HEX-programs in the DLVHEX-solver (cf. (Eiter et al., 2014a)).
507

fiE ITER , F INK & S TEPANOVA

 
Lemma 70 Let  = hT , A, Pi be a ground DL-program and let I  AS () such that I = I|

ASx (), where x  {flp, weak }. Suppose A  A is such that for each DL-atom d occurring in P,

it holds that I |=T A d iff I |=T A d. Then I  ASx ( ) where  = hT , A , Pi.
  , PxI,T A and PxI,T A coincide; as I  ASx (), it is a minimal
Proof. We note that for I = I|

model of PxI,T A . Consequently, I is also a model of PxI,T A . Moreover, I is minimal, as if some

J  I satisfies PxI,T A , then J |= PxI,T A ; hence I is not an answer set of PxI,T A , a contradiction.

Suppose I  RAS x (). This implies that I  ASx ( ) where  = hT  A , Pi, for some
 A. By Lemma 69 I is an answer set of  and thus is considered in (c). In (d), Dp and

Dn are set to the (correct) guess for I |=O d for each DL-atom d, where O = T  A . From
 A )(d) 6=  and
Proposition 15 and -completeness of S, we obtain for each d  Dp that Gr(S, I,


 A )(d) = . As Gr(S, I,
 A )(d)  Gr(S, I,
 A)(d) holds for each
for each d  Dn that Gr(S, I,

I

DL-atom d, it follows for each d  Dn and S  Sgr (d) that S  (A \ A ) 6= ; this means that
S

H  = A \ A is a hitting set of d Dn SIgr (d ), and hence some minimal hitting set H  H  will

A



be considered in (e). In (f), Dp will be set to Dp as for each d  Dp some S  SIgr (d) exists
such that S  H  = , and hence S  H = . Thus in (g) the call eval p (   ) yields true, and
 A \ H)(d) = ; thus rep is true. Eventually, in (h) the
likewise the call eval n (   ) as Gr(S, I,

test flpFND(I, hT  A\H, Pi) will succeed, as I is an x-answer set of  = hT  A , Pi, and by
  is output. 
Lemma 70 also of  = hT  A \ H, Pi, as A  A \ H. Thus in step (h) I = I|
D.3 Proof of Proposition 67
   RAS weak (). Towards a contradiction,
We first show that for every I  AS (1 ), it holds that I|


suppose some I  AS (1 ) exists such that I| 6 RAS weak (). Then for every A  A we have
  6 AS weak ( ) with  = hT , A , Pi. In particular, for A = A\{P (~c) | pP (~c)  I}
that I|
  6 AS weak ( ) with  = hT , A , Pi There are several possibilities: (i) no
it holds that I|
c ; (ii) no such
  with a guess for the replacement atoms ed , ned is a model of 
extension of I|
  ,O
  is a compatible set for  ; (iii) some interpretation J  I|
  is a model of P I|
.
extension of I|
weak

c and hence it follows that I|
c .
 |= 
The case (i) is impossible:  = 

 . Towards a contradiction, assume that
Assume that (ii) is true. Consider the interpretation I|

 , or
  |=O d and ned  I|
it is not compatible for  . Then for some DL-atom d either (1) I|



O
O
 holds. In case (1), as I|
  |=
d, and ed  I|
d, some support set S for d that is
(2) I 6|=

 exists. Now consider whether S  Sd or S 6 Sd . In the former case, S must
coherent with I|

contain ABox assertions SdA , as otherwise some constraint of the form (r5 ) is violated. Due to the
rule (r6 ) at least one assertion Pid in SdA must be marked for deletion. Note that then Pid is not
present in A , and S is not a relevant support set for d w.r.t. A . If Sd is known to be complete, then
we immediately arrive at a contradiction. Otherwise, the rule of the form (r8 ) is applied, and as the
evaluation postcheck for d succeeded by our assumption, we get a contradiction. If S 6 Sd , then
Sd is not known to be complete, and again the rule of the form (r8 ) is applied; due to the successful
  6|=O d, no
evaluation postcheck, a contradiction is obtained. Now suppose that (2) is true. As I|
  . If Sd is known to be complete, then the
support set for d exists w.r.t. O that is coherent with I|
508

fiC OMPUTING R EPAIRS OF I NCONSISTENT DL-P ROGRAMS OVER EL O NTOLOGIES

constraint (r9 ) is violated; but this contradicts I |= 1 . Thus, the body of the rule (r7 ) is satisfied,
and an evaluation postcheck is issued for d that fails; hence we get a contradiction.
  ,O
  is a model of P I|
Finally, assume that (iii) holds, i.e. some interpretation J  I|
weak . The
  \J contains only atoms over the signature of . Let us consider IM = I \ M .
set M = I|



We know that I  AS (1 ); Hence some rule rI must exist in 1 I such that IM |= B(rI ),
gl

gl

gl

I
but IM 6|=
Recall that 1 = (  R  f acts(A)  COMP). Now rgl can not be in
  ,O
  ,O
  ,O

I|
I  P I|
I  P I|

(  f acts(A)  COMP)Igl , as rgl
iff rgl
weak
weak and J 6|= Pweak by construction
I must be in RI . However, the
of the GL and weak reducts, which is a contradiction. Therefore, rgl
gl

I
latter also raises a contradiction: no rule in Rgl has atoms over the signature of  in its head and IM

and I coincide on the rule head; thus it follows I 6|= B(RIgl ), which is a contradiction. Therefore,
   AS ( ) holds, and we have a global contradiction, i.e. I|
   RAS weak () follows.
I|
I ).
H(rgl

We now consider the case where each support family Sd is known to be complete, and prove
that then AS| (1 ) = RAS weak (). From what has been shown above, it remains to check that
AS| (1 )  RAS weak (). Towards a contradiction, assume some I  RAS weak () exists such
that I 
/ AS (1 ) for every extension I of I. As I  RAS weak (), some ABox A  A exists such
that I  AS ( ) with  = hT , A , Pi. We construct an extension I of I as follows:


I = I  {ed | I |=O d}  {ned | I 6|=O d} 

{pP (~c) | P (~c)  A\A }  f acts(A)  COMP 
{Supd (~c) | d(~c) has some support set from Sd coherent with I} 
{S P (~c) | I |= rb(S A,P (~c))}  {S A,P (~c) | I |= rb(S A,P (~c)), nd(S A,P (~c))}.
d

d

d

d

Since by our assumption I 6 AS (1 ), one of the following must hold:

(i) I |6 = (  R  f acts(A)  COMP)Igl or

(ii) some J  I exists, such that J |= (  R  f acts(A)  COMP)Igl .

 it satisfies  and all rules of the forms (r )-(r ).
First assume that (i) is true. By construction of I,
1
4
Moreover, constraints of the form (r5 ) can not be violated, as no DL-atom d(~c) with I 6|=O d(~c)
can have a support set that consists only of input assertions. The rules (r7 ) and (r8 ) are not present

in the reduct 1 Igl , as I |= Cd for each DL-atom d(~c).

Thus the rule r from 1 such that I 6|= rI could only be of the form (r ) or (r ). In case of
gl



6

9

form (r6 ), some DL-atom d(~c) would exist such that I 6|=O d(~c). By Proposition 15 no support set
 Hence, r must be of
for d(~c) would exist that is coherent with I, and by construction SdA,P (~c) 
/ I.

the form (r9 ); however, as I |=O d(~c) by completeness of Sd and Proposition 15, by construction
 which implies that r can not be violated.
we have Supd (~c)  I,

Now let (ii) hold, i.e. some J  I exists s.t. J |= 1 Igl . As J contains for each DL-atom
d(~c) exactly one out of ed (~c) and ned (~c) and 1 contains ed (~c)  ned (~c), the interpretations J and
I coincide on all replacement atoms ed (~c) and ned (~c). Suppose that I \ J contains some atoms
  6|= P I,O ; hence some rule rI,O  P I,O , exists such that
from the language of . Then J|
weak
weak
weak
  6|= H(rI,O ). Consider the respective rule rI in I . As J 6|= H(rJ ),
  |= B(rI,O ), but J|
J|
gl
gl
gl
weak
weak
509

fiE ITER , F INK & S TEPANOVA

I ). By construction of the weak and GL reduct, respectively, the positive
we must have J 6|= B(rgl






J ) and in B(r I,O ) are the same. Hence, some replacement atom e (~
normal atoms in B(rgl
d c) (resp.
weak

I




ned (~c)) must occur positively in B(rgl ), such that ed (~c)  I \ J (resp. ned (~c)  I \ J). As we have
already argued, the latter is not possible, leading to a contradiction.
I of
Consequently, I \ J must contain only atoms from the language of R. For every rule rgl


form (r ) or (r ) we have J |= B(rI ) iff I |= B(rI ), thus I and J agree on all atoms S P (~c) and
3
A,P
Sd (~c).

4

gl

gl

d

Similarly, via (r1 ) and (r2 ) we must have that I and J agree on all atoms Supd (~c). Finally,
 In conclusion,
the same holds for all pP (~c) and pP (~c) by the rules (r6 ) and the construction of I.


J = I holds, which violates (ii).
Thus, it follows that I  AS (1 ). Consequently, AS (1 )  RAS weak (1 ) holds; this proves
the result.

References
Alchourrn, C. E., Grdenfors, P., & Makinson, D. (1985). On the logic of theory change: Partial
meet contraction and revision functions. J. Symbolic Logic, 50(2), 510530.
Aranguren, M. E., Bechhofer, S., Lord, P. W., Sattler, U., & Stevens, R. D. (2007). Understanding
and using the meaning of statements in a bio-ontology: recasting the gene ontology in OWL.
BMC Bioinformatics, 8(1), 113.
Ausiello, G., DAtri, A., & Sacc, D. (1983). Graph algorithms for functional dependency manipulation. J. of the ACM, 30(4), 752766.
Ausiello, G., DAtri, A., & Sacc, D. (1986). Minimal representation of directed hypergraphs. SIAM
J. on Computing, 15(2), 418431.
Baader, F., Bauer, A., & Lippmann, M. (2009). Runtime verification using a temporal description
logic. In Proc. 7th Intl Symp. on Frontiers of Combining Systems, FroCoS 2009, pp. 149164.
Baader, F., Brandt, S., & Lutz, C. (2005). Pushing the EL envelope. In Proc. 19th Intl Joint Conf.
on Artificial Intelligence, IJCAI 2005, pp. 364369.
Baader, F., Calvanese, D., McGuinness, D., Nardi, D., & Patel-Schneider, P. F. (Eds.). (2003). The
Description Logic Handbook: Theory, Implementation and Applications. Cambridge University Press, 2003.
Baader, F., Lutz, C., Milicic, M., Sattler, U., & Wolter, F. (2005). Integrating description logics and
action formalisms: First results. In Proc. 20th National Conf. Artificial Intelligence and 17th
Conf. Innovative Applications of Artificial Intelligence, pp. 572577.
Balduccini, M., & Gelfond, M. (2003). Logic programs with consistency-restoring rules. In Intl
Symp. Logical Formalization of Commonsense Reasoning, AAAI 2003 Spring Symposium Series, pp. 918.
Belnap, N. (1977). A useful four-valued logic. In Modern Uses of Multiple-Valued Logic, pp. 737.
Reidel Publishing Company, Boston.
Bertossi, L. E. (2011). Database Repairing and Consistent Query Answering. Morgan & Claypool
Publishers, Ottawa, Canada.
510

fiC OMPUTING R EPAIRS OF I NCONSISTENT DL-P ROGRAMS OVER EL O NTOLOGIES

Bertossi, L. E., Hunter, A., & Schaub, T. (2005). Introduction to inconsistency tolerance. In Inconsistency Tolerance [result from a Dagstuhl seminar], pp. 114.
Bienvenu, M. (2008). Complexity of abduction in the EL family of lightweight description logics.
In Proc. 11th Intl Conf. on Principles of Knowledge Representation and Reasoning, KR 2008,
pp. 220230.
Bienvenu, M., & Rosati, R. (2013). New inconsistency-tolerant semantics for robust ontology-based
data access. In Proc. 26th Intl Workshop on Description Logics, pp. 5364.
Bonatti, P. A., Faella, M., & Sauro, L. (2010). EL with default attributes and overriding. In Proceedings of the 9th Intl Semantic Web Conf., ISWC 2010, pp. 6479.
Brewka, G. (1989). Preferred subtheories: An extended logical framework for default reasoning. In
Proc. 11th Intl Joint Conf. on Artificial Intelligence, IJCAI 1989, pp. 10431048.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., Poggi, A., & Rosati, R. (2007a).
Ontology-based database access. In Proc. 15th Italian Symposium on Advanced Database
Systems, SEBD 2007, pp. 324331.
Calvanese, D., De Giacomo, G., Lenzerini, M., Lembo, D., Poggi, A., & Rosati, R. (2007b).
MASTRO-I: efficient integration of relational data through DL ontologies. In Proc. 20th
Intl Workshop on Description Logics.
Calvanese, D., Ortiz, M., Simkus, M., & Stefanoni, G. (2013). Reasoning about explanations for
negative query answers in DL-Lite. J. Artificial Intelligence Research, 48, 635669.
Console, L., Sapino, M. L., & Dupr, D. T. (1995). The role of abduction in database view updating.
J. of Intelligent Information Systems, 4(3), 261280.
Console, M., Mora, J., Rosati, R., Santarelli, V., & Savo, D. F. (2014). Effective computation of
maximal sound approximations of description logic ontologies. In Proc. 13th Intl Semantic
Web Conf., ISWC 2014, Part II, pp. 164179.
dlliteplugin of DLVHEX system (2015). https://github.com/hexhex/dlliteplugin.
Scripts for DL-program benchmark generation (2015).
dlliteplugin/benchmarks.

https://github.com/hexhex/

dlplugin of the DLVHEX system (2015). https://github.com/hexhex/dlplugin.
DR E W reasoner for DL-Programs over Datalog-rewritable Description Logics (2012). http://
www.kr.tuwien.ac.at/research/systems/drew/.
Ecke, A., Ludwig, M., & Walther, D. (2013). The concept difference for EL-terminologies using
hypergraphs. In Proc. Intl Workshop on Document Changes: Modeling, Detection, Storage
and Visualization.
Eiter, T., Erdem, E., Fink, M., & Senko, J. (2005). Updating action domain descriptions. In Proc.
19th Intl Joint Conf. on Artificial Intelligence, IJCAI 2005, pp. 418423.
Eiter, T., Fink, M., Greco, G., & Lembo, D. (2008). Repair localization for query answering from
inconsistent databases. ACM Transactions on Database Systems, 33(2).
Eiter, T., Fink, M., Krennwallner, T., Redl, C., & Schller, P. (2014a). Efficient HEX-program
evaluation based on unfounded sets. J. Artificial Intelligence Research, 49, 269321.
511

fiE ITER , F INK & S TEPANOVA

Eiter, T., Fink, M., Redl, C., & Stepanova, D. (2014b). Exploiting support sets for answer set
programs with external evaluations. In Proc. 28th Conf. Artificial Intelligence, AAAI 2014,
pp. 10411048.
Eiter, T., Fink, M., & Stepanova, D. (2013). Data repair of inconsistent DL-programs. In Proc. 23rd
Intl Joint Conf. on Artificial Intelligence, IJCAI 2013, pp. 869876.
Eiter, T., Fink, M., & Stepanova, D. (2014c). Computing repairs for inconsistent DL-programs over
EL ontologies. In Proc. 14th Joint European Conf. Logics in Artificial Intelligence, JELIA
2014, pp. 426441.
Eiter, T., Fink, M., & Stepanova, D. (2014d). Towards practical deletion repair of inconsistent
DL-programs. In Proc. 21st European Conf. Artificial Intelligence, ECAI 2014, pp. 285290.
Eiter, T., Fink, M., & Stepanova, D. (2014d). Data repair of inconsistent DL-programs. Tech. rep.
INFSYS RR-1843-15-03, Institut f. Informationssysteme, TU Wien, A-1040 Vienna, Austria.
Eiter, T., Gottlob, G., & Leone, N. (1997). Abduction from logic programs: Semantics and complexity. Theoretical Computer Science, 189(1-2), 129177.
Eiter, T., Ianni, G., Lukasiewicz, T., Schindlauer, R., & Tompits, H. (2008). Combining answer
set programming with description logics for the Semantic Web. J. Artificial Intelligence,
172(12-13), 14951539.
Eiter, T., Ianni, G., Schindlauer, R., & Tompits, H. (2005). A uniform integration of higher-order
reasoning and external evaluations in answer-set programming. In Proc. 19th Intl Joint Conf.
on Artificial Intelligence, IJCAI 2005, pp. 9096.
Eiter, T., & Makino, K. (2007). On computing all abductive explanations from a propositional Horn
theory. J. of the ACM, 54(5).
Eiter, T., Schneider, P., imkus, M., & Xiao, G. (2014). Using OpenStreetMap data to create benchmarks for description logic reasoners. In Proc. 2nd Intl Workshop on OWL Reasoner Evaluation, ORE 2014, Vol. 1207, pp. 5157.
Experimental data with inconsistent DL-programs (2015). http://www.kr.tuwien.ac.at/
staff/dasha/jair_el/benchmark_instances.zip.
Feng, S., Ludwig, M., & Walther, D. (2015). The logical difference for EL: From terminologies
towards tboxes. In Proc. 1st Intl Workshop on Sem. Technologies, IWOST 2015, pp. 3141.
Fink, M. (2012). Paraconsistent hybrid theories. In Proc. 13th Intl Conf. on Principles of Knowledge Representation and Reasoning, KR 2012, pp. 141151.
Frhstck, M., Phrer, J., & Friedrich, G. (2013). Debugging answer-set programs with ouroboros extending the sealion plugin. In Proc. 12th Intl Conf. Logic Programming and Nonmonotonic
Reasoning, LPNMR 2013, pp. 323328.
Gallo, G., Longo, G., & Pallottino, S. (1993). Directed hypergraphs and applications. Discrete
Applied Mathematics, 42(2), 177201.
Grdenfors, P., & Rott, H. (1995). Belief revision. Handbook of Logic in Artificial Intelligence and
Logic Programming, 4, 35132.
Gardiner, T., Tsarkov, D., & Horrocks, I. (2006). Framework for an automated comparison of
description logic reasoners. In Proc. 5th Intl Semantic Web Conf., ISWC 2006, pp. 654667.
512

fiC OMPUTING R EPAIRS OF I NCONSISTENT DL-P ROGRAMS OVER EL O NTOLOGIES

Gebser, M., Phrer, J., Schaub, T., & Tompits, H. (2008). A meta-programming technique for
debugging answer-set programs. In Proc. 23rd Conf. Artificial Intelligence, AAAI 2008, pp.
448453.
Gelfond, M., & Lifschitz, V. (1991). Classical negation in logic programs and disjunctive databases.
New Generation Computing, 9, 365385.
Gottlob, G., Pichler, R., & Wei, F. (2007). Efficient datalog abduction through bounded treewidth.
In Proc. 22nd Intl Conf. on Artificial Intelligence, AAAI 2007, pp. 16261631.
Grau, B. C., Horrocks, I., Kazakov, Y., & Sattler, U. (2007). Just the right amount: extracting
modules from ontologies. In Proc. 16th Intl Conf. World Wide Web, WWW 2007, pp. 717
726.
Hansen, P., Lutz, C., Seylan, I., & Wolter, F. (2014). Query rewriting under EL TBoxes: Efficient
algorithms. In Proc. 27th Intl Workshop on Description Logics, pp. 197208.
Hermann, M., & Pichler, R. (2010). Counting complexity of propositional abduction. J. Computer
and System Sciences, 76(7), 634649.
HTCondor load distribution system, version 7.8.7 (2012). http://research.cs.wisc.edu/
htcondor/.
Huang, S., Hao, J., & Luo, D. (2014). Incoherency problems in a combination of description logics
and rules. J. Applied Mathematics, 604753:16.
Huang, S., Li, Q., & Hitzler, P. (2013). Reasoning with inconsistencies in hybrid MKNF knowledge
bases. Logic J. of the IGPL, 21(2), 263290.
Kaminski, T., Knorr, M., & Leite, J. (2015). Efficient paraconsistent reasoning with ontologies and
rules. In Proc. 24th Intl Joint Conf. on Artificial Intelligence, IJCAI 2015, pp. 30983105.
Knorr, M., Alferes, J. J., & Hitzler, P. (2008). A coherent well-founded model for hybrid MKNF
knowledge bases. In Proc. 18th European Conf. on Artificial Intelligence, ECAI 2008, pp.
99103.
Knorr, M., Alferes, J. J., & Hitzler, P. (2011). Local closed world reasoning with description logics
under the well-founded semantics. Artificial Intelligence, 175(9-10), 15281554.
Konev, B., Ludwig, M., Walther, D., & Wolter, F. (2012). The logical difference for the lightweight
description logic EL. J. Artificial Intelligence Research, 44, 633708.
Kontchakov, R., Lutz, C., Toman, D., Wolter, F., & Zakharyaschev, M. (2010). The combined
approach to query answering in DL-Lite. In Proc. 12th Intl Conf. on Principles of Knowledge
Representation, KR 2010, pp. 247257.
Kotek, T., Simkus, M., Veith, H., & Zuleger, F. (2014). Towards a description logic for program
analysis: Extending ALCQIO with reachability. In Proc. 27th Intl Workshop on Description
Logics, pp. 591594.
Lembo, D., Lenzerini, M., Rosati, R., Ruzzi, M., Savo, D. F. (2015). Inconsistency-tolerant query
answering in ontology-based data access. J. Web Sem., 33, 329.
Lembo, D., Santarelli, V., & Savo, D. F. (2013). A graph-based approach for classifying OWL 2 QL
ontologies. In Proc. 26th Intl Workshop on Description Logics, pp. 747759.
LUBM benchmark (2005). http://swat.cse.lehigh.edu/projects/lubm/.
513

fiE ITER , F INK & S TEPANOVA

LUBM data generator (2013). http://code.google.com/p/combo-obda/.
Ludwig, M., & Walther, D. (2014). The logical difference for ELHr-terminologies using hypergraphs. In Proc. 21st European Conf. Artifical Intelligence, ECAI 2014, pp. 555560.
Lukasiewicz, T. (2010). A novel combination of answer set programming with description logics
for the semantic web. IEEE Trans. Knowledge and Data Engineering, 22(11), 15771592.
Lutz, C., Toman, D., & Wolter, F. (2009). Conjunctive query answering in the description logic EL
using a relational database system. In Boutilier, C. (Ed.), Proc. 21st Joint Intl Conf. Artificial
Intelligence, IJCAI 2009, pp. 20702075.
Lutz, C., Walther, D., & Wolter, F. (2007). Conservative extensions in expressive description logics.
In Proc. 20th Intl Joint Conf. Artificial Intelligence, IJCAI 2007, pp. 453458.
Lutz, C., & Wolter, F. (2010). Deciding inseparability and conservative extensions in the description
logic EL. J. of Symbolic Computation, 45(2), 194228.
Martinez, M. V., Molinaro, C., Subrahmanian, V. S., & Amgoud, L. (2013). A General Framework
for Reasoning On Inconsistency. Springer Briefs in Computer Science. Springer, 2013.
Masotti, G., Rosati, R., & Ruzzi, M. (2011). Practical abox cleaning in DL-Lite (progress report).
In Proc. of Description Logics Workshop.
Motik, B., & Rosati, R. (2010). Reconciling Description Logics and Rules. J. of the ACM, 57(5),
162.
MyITS - Personalized Intelligent Mobility Service (2012). http://www.kr.tuwien.ac.at/
research/projects/myits/GeoConceptsMyITS-v0.9-Lite.owl/.
Nguyen, N. T. (2008). Advanced Methods for Inconsistent Knowledge Management. Advanced
Information and Knowledge Processing. Springer.
Nortje, R., Britz, A., & Meyer, T. (2013). Module-theoretic properties of reachability modules for
SRIQ. In Proc. 26th Intl Workshop on Description Logics, pp. 868884.
Oetsch, J., Phrer, J., & Tompits, H. (2012). Stepwise debugging of description-logic programs. In
J. of Correct Reasoning, pp. 492508.
Open Street Map project (2012). http://www.openstreetmap.org/.
zccep, . L., & Mller, R. (2012). Combining DL  Lite with spatial calculi for feasible geothematic query answering. In Proc. 25th Intl Workshop on Description Logics.
Pan, J. Z., & Thomas, E. (2007). Approximating OWL-DL ontologies. In Proc. 22nd Intl Conf. on
Artificial Intelligence, AAAI 2007, pp. 14341439.
Prez-Urbina, H., Motik, B., & Horrocks, I. (2010). Tractable query answering and rewriting under
description logic constraints. J. of Applied Logic, 8(2), 186209.
Phrer, J., Heymans, S., & Eiter, T. (2010). Dealing with inconsistency when combining ontologies
and rules using DL-programs . In Proc. 7th Extended Semantic Web Conf., ESWC 2010, part
I, pp. 183197.
R ACER P RO reasoner for OWL ontologies (2007). http://franz.com/agraph/racer/.
Reiter, R. (1987). A theory of diagnosis from first principles. J. Artificial Intelligence, 32(1), 5795.
514

fiC OMPUTING R EPAIRS OF I NCONSISTENT DL-P ROGRAMS OVER EL O NTOLOGIES

Rosati, R. (2007). On conjunctive query answering in EL. In proceedings of the 20th Intl Workshop
on Description Logics.
Rosati, R., Ruzzi, M., Graziosi, M., & Masotti, G. (2012). Evaluation of techniques for inconsistency handling in OWL 2 QL ontologies. In Proc. 11th Intl Semantic Web Conf., ISWC 2012,
pp. 337349.
Sakama, C., & Inoue, K. (1995). Paraconsistent stable semantics for extended disjunctive programs.
J. of Logic and Computation, 5(3), 265285.
Sakama, C., & Inoue, K. (2003). An abductive framework for computing knowledge base updates.
Theory and Practice of Logic Programming, 3(6), 671713.
Schulz, C., Satoh, K., & Toni, F. (2015). Characterising and explaining inconsistency in logic
programs. In Proc. 13th Intl Conf., LPNMR 2015, pp. 467479.
Schulz, S., Cornet, R., & Spackman, K. A. (2011). Consolidating SNOMED CTs ontological
commitment. Applied Ontology, 6(1), 111.
Shen, Y.-D. (2011). Well-supported semantics for description logic programs. In Proc. 22nd Intl
Joint Conf. on Artificial Intelligence, IJCAI 2011, pp. 10811086.
Stefanoni, G., Motik, B., & Horrocks, I. (2012). Small datalog query rewritings for EL. In Proc.
25th Intl Workshop on Description Logics.
Stepanova, D. (2015). Inconsistencies in Hybrid Knowledge Bases. PhD thesis, Vienna University
of Technology.
Steve, G., Gangemi, A., & Mori, A. R. (1995). Modelling a sharable medical concept system:
Ontological foundation in galen. In AIME, pp. 411412.
Stuckenschmidt, H., Parent, C., & Spaccapietra, S. (Eds.). (2009). Modular Ontologies: Concepts,
Theories and Techniques for Knowledge Modularization, Vol. 5445 of Lecture Notes in Computer Science. Springer.
Syrjnen, T. (2006). Debugging Inconsistent Answer-Set Programs. In Proc. 11th Intl Workshop
on Nonmonotonic Reasoning, NMR 2006, pp. 7783.
Thakur, M., & Tripathi, R. (2009). Linear connectivity problems in directed hypergraphs. Theoretical Computer Science, 410(27-29), 25922618.
Tserendorj, T., Rudolph, S., Krtzsch, M., & Hitzler, P. (2008). Approximate OWL-reasoning with
Screech. In Proc. 2nd Intl Conf. Web Reasoning and Rule Systems, RR 2008, pp. 165180.
Wache, H., Groot, P., & Stuckenschmidt, H. (2005). Scalable instance retrieval for the semantic web
by approximation. In Proc. 1st Intl Workshops on Web Information Systems Engineering,
WISE 2005, pp. 245254.
Wang, Y., You, J.-H., Yuan, L.-Y., & Shen, Y.-D. (2010). Loop formulas for description logic
programs. Theory and Practice of Logic Programming, 10(4-6), 531545.
Xiao, G. (2014). Inline Evaluation of Hybrid Knowledge Bases. Ph.D. thesis, Vienna University of
Technology, Austria.
Zhao, Y., Pan, J. Z., & Ren, Y. (2009). Implementing and evaluating a rule-based approach to
querying regular EL+ ontologies. In Proc. 9th Intl Conf. Hybrid Intelligent Systems, HIS
2009, pp. 493498.

515

fi