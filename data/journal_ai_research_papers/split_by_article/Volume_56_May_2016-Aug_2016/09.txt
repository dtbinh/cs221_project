Journal of Artificial Intelligence Research 56 (2016) 379-402

Submitted 09/15; published 06/16

Generating Models of a Matched Formula
With a Polynomial Delay
Petr Savicky

savicky@cs.cas.cz

Institute of Computer Science, The Czech Academy of Sciences
Pod Vodarenskou Vez 2, 182 07 Praha 8, Czech Republic

Petr Kucera

kucerap@ktiml.mff.cuni.cz
Department of Theoretical Computer Science and Mathematical Logic
Faculty of Mathematics and Physics, Charles University in Prague,
Malostranske nam. 25, 118 00 Praha 1, Czech Republic

Abstract
A matched formula is a CNF formula whose incidence graph admits a matching which
matches a distinct variable to every clause. Such a formula is always satisfiable. Matched
formulas are used, for example, in the area of parametrized complexity. We prove that
the problem of counting the number of the models (satisfying assignments) of a matched
formula is #P-complete. On the other hand, we define a class of formulas generalizing the
matched formulas and prove that for a formula in this class one can choose in polynomial
time a variable suitable for splitting the tree for the search of the models of the formula.
As a consequence, the models of a formula from this class, in particular of any matched
formula, can be generated sequentially with a delay polynomial in the size of the input.
On the other hand, we prove that this task cannot be performed efficiently for linearly
satisfiable formulas, which is a generalization of matched formulas containing the class
considered above.

1. Introduction
In this paper, we consider the problem of counting the models (satisfying assignments) and
generating subsets of the models of a given formula in conjunctive normal form (CNF). It is
well known that the problem of counting the models of a general CNF is #P-complete (Sipser,
2006). The problem of generating the models of a general CNF formula is clearly also hard,
because checking whether there is at least one satisfying assignment of the formula, the
SAT problem, is NP-complete (Garey & Johnson, 1979).
In this paper, we mostly deal with the problem of enumerating models of a formula.
This problem is important in areas of research and applications, such as unbounded model
checking (Kang & Park, 2005; McMillan, 2002) or data mining (Coquery, Jabbour, Sais,
Salhi, et al., 2012). The success of modern SAT solvers inspired design of model counting
and enumeration algorithms as well (see e.g. Jabbour, Lonlac, Sais, & Salhi, 2014; Morgado
& Marques-Silva, 2005a, 2005b). In addition to the basic enumeration problem in which we
do not require the models to be generated in any prescribed order, other versions have been
considered, e.g. generating models by non-decreasing weight (Creignou, Olive, & Schmidt,
2011).
Another line of research concentrated on studying special classes of boolean formulas
for which an enumeration algorithm with guaranteed complexity could be devised. One can
c
2016
AI Access Foundation. All rights reserved.

fiSavicky & Kucera

easily find an example of a formula for which the set of models is exponentially larger than
the size of the formula itself. In such a case it is reasonable to include the size of the output
into the bound on the running time of an enumeration algorithm. More specifically we say
that an algorithm which enumerates models of a formula runs in output polynomial time
if its running time can be bounded by a polynomial in two variables, the size of the input
(i.e. the input formula ) and the size of the output (i.e. the number of models of ). In
this paper, we consider more restrictive setting as follows. The algorithm receives as input
a formula and generates a sequence of all its models in such a way that the time needed for
generating the first model and the time between generating any two consecutive models in
the sequence is polynomial in the length of the formula. This type of complexity bound is
called a polynomial delay. It should be clear that if we can enumerate models of a formula
with a polynomial delay, then we can construct an output polynomial algorithm for this
task as well. On the other hand, it can be much harder to get an enumeration algorithm
with polynomial delay than an output polynomial algorithm. For an overview of various
notions of enumeration complexity (see Johnson, Yannakakis, & Papadimitriou, 1988).
There are special classes of formulas for which polynomial delay enumeration algorithms
have been described, this includes 2-CNF formulas, Horn formulas, generalized satisfiability
problems and others (see e.g. Aceto, Monica, Ingolfsdottir, Montanari, & Sciavicco, 2013;
Creignou & Hebrard, 1997; Dechter & Itai, 1992; Kavvadias, Sideri, & Stavropoulos, 2000).
In this paper, we describe another class of formulas for which a polynomial delay enumeration algorithm based on backtrack-free search can be described. On the contrary to such
algorithms known for 2-CNF or Horn formulas, the splitting variable in each step cannot
be chosen arbitrarily, however, the existence of a suitable variable is guaranteed and it can
be efficiently identified.
In particular we consider the class of matched formulas introduced by Franco and
Van Gelder (2003). Given a CNF formula , we consider its incidence graph I() defined as follows. I() is a bipartite graph with one part consisting of clauses of  and the
other part containing the variables of . An edge {x, C} for a variable x and a clause C is
in I() if x or x appears in C. It was observed by Aharoni and Linial (1986) and Tovey
(1984) that if I() admits a matching (i.e. a set of pairwise disjoint edges) of size m (where
m is the number of clauses in ), then  is satisfiable. Later the formulas satisfying this
condition were called matched formulas by Franco and Van Gelder. Since a matching of
maximum size in a bipartite graph can be found in polynomial time (see e.g. Lovasz &
Plummer, 1986), one can check efficiently whether a given formula is matched.
Given a general formula , we can measure how far it is from being matched by considering its maximum deficiency  (), the number of clauses which remain unmatched in a
maximum matching of I(). A formula  is thus matched iff  () = 0. A weaker notion
of deficiency () = m  n, where m is the number of clauses and n the number of the
variables in , is also often being considered.
Matched formulas play a significant role in the theory of satisfiability solving. Since
their introduction matched formulas have been considered as a base class in parameterized
algorithms for satisfiability, see e.g. the book of Flum and Grohe (2006) for an overview of
parameterized algorithms theory. In particular, Fleischner, Kullmann, and Szeider (2002)
show that satisfiability of formulas with maximum deficiency bounded by a constant k can
be decided in time O(kknO(k) ) where kk is the length of the input formula  and n
380

fiGenerating Models of a Matched Formula

denotes the number of its variables. This result was later improved by Szeider (2003) to
an algorithm for satisfiability parameterized with maximum deficiency of a formula with
complexity O(2k n3 ). Parameterization based on backdoor sets with respect to matched
formulas were considered by Szeider (2007).
Since all matched formulas are trivially satisfiable, we ask a stronger question: How
hard is it to count or enumerate the models of a matched formula? We prove that counting
the models of a matched formula is a #P-complete problem, and turn our attention to
generating models of a matched formula. The main result of the paper is an algorithm
which generates models of a matched formula with a polynomial delay. The algorithm
constructs a splitting tree whose nodes correspond to either a matched or an unsatisfiable
formula. However, in some cases this strategy is not sufficient since some nodes of the tree
cannot be split in this way. We prove that such a node corresponds to a formula which
can be satisfied by iterated elimination of pure literals. Formulas with this property will
be called pure literal satisfiable. These formulas were studied by Kullmann (2000) as a
subclass of linearly satisfiable formulas. If a node with a pure literal satisfiable formula is
reached, the algorithm switches to a simpler strategy. We prove that the models of a pure
literal satisfiable formula can be generated with a delay linear in the length of the formula.
On the other hand, the #SAT problem for pure literal satisfiable formulas is #P-complete,
because this problem is #P-complete for monotone 2CNFs (Valiant, 1979a, 1979b), which
are pure literal satisfiable.
Several generalizations of matched formulas have also been considered in the literature. Kullmann (2000) generalized matched formulas into the class of linearly satisfiable
formulas. Autarkies based on matchings were studied by Kullmann (2003). Szeider (2005)
considered another generalization of matched formulas, the classes of biclique satisfiable
and var-satisfiable formulas. Unfortunately, for both biclique satisfiable and var-satisfiable
formulas it is hard to check if a formula falls into one of these classes (Szeider, 2005).
We show in this paper that our result does not transfer to the class of linearly satisfiable
formulas by demonstrating that it is not possible to generate models of a linearly satisfiable
formula with a polynomial delay unless P=NP.
The paper is organized as follows. After giving basic definitions in Section 2, we describe
in Section 3 a specific simple splitting property of a class of formulas, which allows to
generate the models of a formula from the class efficiently. In Section 4, we consider pure
literal satisfiable formulas and prove that this class has the required splitting property. In
Section 5, we consider the matched formulas and prove the required splitting property of a
class of formulas, which generalizes both the matched and pure literal satisfiable formulas
in a natural way. This implies an algorithm for generating all models of a matched formula
or a formula from the more general class with a polynomial delay. In Section 6, we present
complexity bounds for efficient versions of the algorithms from the previous sections. In
Section 7, we show the negative result concerning linearly satisfiable formulas. Section 8
contains concluding remarks and some directions for further research.

2. Definitions
In this section, we give the necessary definitions and summarize the results we use in this
paper.
381

fiSavicky & Kucera

2.1 Boolean Functions
A Boolean function of n variables is a mapping f : {0, 1}n  {0, 1}. A literal is either
a variable, called positive literal, or its negation, called negative literal. The negation of
the variable x will be denoted x or x. A clause is a disjunction of a set of literals, which
contains at most one literal for each variable. Formula  is in conjunctive normal form
(CNF) or, equivalently,  is a CNF formula, if it is a conjuction of clauses. We often treat
a clause as a set of its literals and a CNF formula as a set of its clauses. It is a well known
fact that every Boolean function can be represented by a CNF formula (see e.g. Genesereth
& Nilsson, 1987). The size of a formula  is the number of the clauses in  and will be
denoted as ||. The length of a formula  is the total number of occurrences of literals in ,
i.e. the sum of the sizes of the clauses in , and will be denoted as kk. Given a variable x
and a value a  {0, 1}, [x = a] denotes a formula originating from  by substituting x with
value a and the obvious simplifications consisting in removing falsified literals and satisfied
clauses. We extend this notation to negative literals as well by setting [x = a] = [x = a].
The formula obtained from  by assigning the values a1 , . . . , ak  {0, 1} to the variables
x1 , . . . , xk is denoted as [x1 = a1 , x2 = a2 , . . . , xk = ak ]. We say that a literal l is pure in
a CNF formula, if it occurs in the formula and the negated literal l does not. A literal
is irrelevant in a formula, if neither the literal nor its negation occurs in the formula. A
variable is pure, if it appears only positively, or only negatively in , i.e. it appears in a
literal, which is pure in .
Let  be a formula defining a Boolean function f on n variables. An assignment of
values v  {0, 1}n is a model of  (also a satisfying assignment, or a true point of ), if
it satisfies f , i.e. if f (v) = 1. The set of models of  is denoted as T (). The models in
T () are defined on the variables which have an occurrence in . The set of the variables
of the function defined by a formula can be larger, however, we do not introduce a special
notation for this more general case. For algorithmic purposes, this is also not necessary,
since adding an irrelevant variable to a formula changes the set of the models by adding
this variable with both possible values to each element of the original set of models.
A partial assignment assigns values only to a subset of the variables. For a formula
of the variables x1 , . . . , xn , it can be represented as a ternary vector v  {0, 1, }n , where
vi =  denotes the fact that xi is not assigned a value by v.
Note that an empty clause does not admit a satisfying assignment and an empty CNF
is satisfied by any assignment.
2.2 Matched Formulas
In this paper we use standard graph terminology, (see e.g. Bollobas, 1998). Given an
undirected graph G = (V, E), a subset of edges M  E is a matching in G if the edges
in M are pairwise disjoint. A bipartite graph G = (A, B, E) is an undirected graph with
disjoint sets of vertices A and B, and the set of edges E satisfying E  A  B. For a set
W of vertices of G, let (W ) denote the neighborhood of W in G, i.e. the set of all vertices
adjacent to some element of W . We shall use the following well-known result on matchings
in bipartite graphs:
Theorem 2.1 (Halls Theorem). Let G = (A, B, E) be a bipartite graph. A matching M
of size |M | = |A| exists if and only if for every subset S of A we have that |S|  |(S)|.
382

fiGenerating Models of a Matched Formula

Let  = C1  . . .  Cm be a CNF formula on n variables X = {x1 , . . . , xn }. We associate
a bipartite graph I() = (, X, E) with  (also called the incidence graph of ), where
the vertices correspond to clauses in  and the variables X. A clause Ci is connected to a
variable xj (i.e. {Ci , xj }  E) if Ci contains xj or xj . A CNF formula  is matched if I()
has a matching of size m, i.e. if there is a matching which pairs each clause with a unique
variable, we shall call such matching as clause saturated matching. Note that a matched
CNF is trivially satisfiable, since each clause can be satisfied by the literal containing the
variable matched to the given clause. A variable, which is matched to some clause in a
given matching M , is called matched in M , it is free in M otherwise.
2.3 Generating Models With a Polynomial Delay
The main goal of this paper is to describe an algorithm which, given a matched formula ,
generates the set T () of models of  with a polynomial delay. Let us state more formally
what we require of such an algorithm.
We say that an algorithm generates the models of a Boolean formula  with a polynomial
delay, if there is a polynomial p, such that the algorithm, given a formula  as an input,
satisfies the following properties.
1. It works in steps, each of which takes time O(p(kk)).
2. In each step, it either finds a model of  different from the models obtained in the
previous steps (in particular, any model in the first step) or determines that that there
is no such model, so the previous steps already found all the models of .
If an algorithm with the properties above exists, it follows that we can construct the
set T () of all models in time O((|T ()| + 1)  p(kk)), which means that the algorithm is
output polynomial. Note that since T () may be of exponential size with respect to kk,
efficiency with respect to the size of the input and output is the best we can hope for when
constructing T ().

3. Efficient Splitting Tree Algorithm
The idea of the algorithm is to construct a decision tree for the function represented by a
given satisfiable CNF, such that every subtree larger than a single leaf contains a 1-leaf.
The depth of the tree is at most the number of the variables. If this tree is searched in
a DFS order, then the time needed in an arbitrary moment to reach a 1-leaf is at most n
times the time needed to split a node. In the following, we show that for some classes of
formulas including the matched formulas it is possible to find a splitting procedure which
yields a tree as described above.
A decision tree for a Boolean function f is a labeled binary tree, where each inner node is
labeled with a variable, while leaves and edges have labels 0 or 1. A decision tree computes
f (x) for a given assignment x by a process which starts at the root and in each visited
node follows the edge labeled by the value of the variable, which is the label of the node.
The output is the label of the leaf reached by this process. If a computation path tests a
variable, which was tested in the previous part of the path, then this test is redundant. We
consider only trees without such redundant tests.
383

fiSavicky & Kucera

A decision tree representing the same function as a given CNF formula  can be constructed top down as follows. The root of the tree is assigned to . For each non-leaf node
of the tree assigned to a formula , we choose an arbitrary split variable x which has an
occurrence in  and assign the restricted formulas [x = 0] and [x = 1] to the successors.
A node assigned to an empty formula becomes a 1-leaf and a node assigned to a formula,
which contains an empty clause, becomes a 0-leaf. The resulting decision tree represents
the function given by , although it can be too large for practical purposes. Each path from
the root to an inner node u of the tree corresponds to a partial assignment which changes
 to a formula representing the function computed by the subtree whose root is u. The
depth of a tree for a function of n variables is at most n.
Each leaf node labeled with 1 represents a set of models of , more precisely, a leaf
in depth d represents 2nd models of . Moreover, different leaves of the tree represent
disjoint sets of models. Given a decision tree for the function represented by , we can, by
traversing it, generate all models of  in time proportional to its size. This process leads to
a large delay between generating successive models, if the tree contains large subtrees with
only 0-leaves. The following condition on a class of formulas describes a situation when this
can be avoided.
Definition 3.1. Let U be a class of formulas, let   U and let x be a variable with
an occurrence in . We say that x is a splitting variable for  relative to U , if for every
a  {0, 1}, such that [x = a] is satisfiable, we have [x = a]  U .
A class of formulas U has the splitting property, if every formula in U containing a
variable contains a splitting variable relative to U .
We shall associate a splitting problem with a class of formulas U having splitting property.
Definition 3.2. Let U be a class of formulas with splitting property. The splitting problem
relative to U is the following problem: Given a formula   U , find a splitting variable for
 relative to U and the results of satisfiability tests for the formulas [x = 0] and [x = 1].
Note that the complexity of the splitting problem relative to U is also an upper bound on
the time of a satisfiability test for formulas in U . This is because a formula  is satisfiable,
if and only if for any variable x we have that at least one of the formulas [x = 0] and
[x = 1] is satisfiable. The result of these satisfiability checks for a splitting variable x is a
required part of solution to the splitting problem.
Theorem 3.3. If a class of formulas U has the splitting property and the splitting problem
relative to U can be solved in time c(), where c()  kk for each formula   U , then
the models of a formula   U with n variables can be generated with a delay O(n  c()).
Proof. Construct a tree for  in a DFS order using a splitting variable for every formula
assigned to a non-leaf node. If a non-leaf node is labeled by  and x is the splitting
variable, the successors are labeled by [x = 0] and [x = 1]. If some of these formulas
is unsatisfiable, the corresponding successor becomes a 0 leaf. If some of these formulas is
empty, the corresponding successor becomes a 1 leaf. The root of the tree is split even if
 is unsatisfiable, however, other nodes labeled by an unsatisfiable formula are not split.
384

fiGenerating Models of a Matched Formula

Hence, except possibly of the root, there is no other node with two 0-leaves as successors.
Since the length of every formula in the tree is at most kk, in each node, time O(c())
is sufficient to choose a splitting variable, determine which of the successors is a leaf, and
construct the formulas for the successors of the node.
Let us assume that u is a non-leaf node of the constructed tree different from the root.
One of the successors of u can be labeled by an unsatisfiable formula. This is recognized
by the splitting algorithm and this successor is a 0-leaf. Consequently, in time at most
O(c()), the construction of the tree continues at a satisfiable successor of u. Hence, in at
most n splitting steps and time at most O(n  c()), a 1-leaf is reached. 2
Remark 3.4. If  contains a unit clause and U is closed under unit propagation, then a
variable x contained in a unit clause is a splitting variable which can be identified efficiently.
The reason is that if  is known to be satisfiable, then one of the formulas [x = a] contains
an empty clause and, hence, the other is satisfiable.
Remark 3.5. If a class U satisfies that
1. the satisfiability of formulas in U can be tested in polynomial time, and
2. U is closed under partial assignments,
then the splitting problem relative to U has polynomial complexity. Indeed, in this case
any variable in a formula  from U is a splitting variable and the satisfiability tests for the
corresponding restrictions can be obtained in polynomial time. Class U with this property
is sometimes also conservative. We can also say that this property is a particular form
of self-reducibility (in a sense considered e.g. by Khuller & Vazirani, 1991). All classes
of generalized satisfiability problem described by Creignou and Hebrard (1997) have this
property in addition to other classes, consider, for instance, Horn formulas, SLUR formulas,
2CNFs, q-Horn formulas, etc. As an immediate corollary of Theorem 3.3, it is possible to
generate the models of formulas in these classes with a polynomial delay.
The main result of this paper is that the splitting problem relative to a slight generalization of matched formulas also has polynomial complexity although the class of matched
formulas is not closed under partial assignments.

4. Pure Literal Satisfiable Formulas
Before considering matched formulas, let us make a small detour to the class of formulas
which are satisfiable by iterated elimination of pure literals, which we call pure literal
satisfiable. These formulas have already been considered by Kullmann (2000) as a special
case of linearly satisfiable formulas.
A set of literals is called consistent, if it does not contain contradictory literals. If l
is a literal, let assign(l) be the assignment to the variable contained in l, which satisfies
l. For a consistent set or sequence of literals L, let assign(L) be the partial assignment
of the variables satisfying the literals in L. For a formula , [L] is an abbreviation for
[assign(L)].
385

fiSavicky & Kucera

Definition 4.1. A pure literal sequence for a formula  is a consistent sequence of literals
(l1 , . . . , lk ), such that for every i = 1, . . . , k, the literal li is either pure or irrelevant in the
formula [l1 , . . . , li1 ]. In particular, l1 is pure or irrelevant in . A pure literal sequence is
called strict, if each of the literals li is pure in [l1 , . . . , li1 ].
If L is a pure literal sequence for , the formula [L] will be called the reduced formula
corresponding to  and L. If [L] does not contain a pure literal, L will be called a maximal
pure literal sequence for .
Definition 4.2. A formula  is pure literal satisfiable, if there is a pure literal sequence L
for , such that the reduced formula [L] is empty or, equivalently, assign(L) is a satisfying
assignment of .
An autarky for a formula  is a partial assignment v of the variables, such that every
clause is either satisfied or unchanged by v. Autarkies were studied e.g. by Kullmann
(2000). Note that every initial segment of a pure literal sequence defines an assignment
to the variables, which is an autarky. Moreover, one can easily verify that this property
characterizes pure literal sequences.
Let us note that pure literal satisfiable formulas are not closed under partial assignments.
Consider a formula , which does not contain a pure literal. Let  be the formula obtained
from  by adding a new variable x as a positive literal to every clause. Formula  is
pure literal satisfiable, but [x = 0] =  is not pure literal satisfiable. It follows that
pure literal satisfiable formulas do not satisfy the second property required in Remark 3.5
and we have to put more effort into showing that pure literal satisfiable formulas have the
splitting property and that the splitting problem relative to pure literal satisfiable formulas
has polynomial complexity.
For every CNF formula, it may be tested in polynomial time, whether it is pure literal
satisfiable. In order to find a pure literal sequence witnessing this fact, the procedure
FindPLS in Algorithm 1 uses a greedy approach, which at each step chooses and satisfies
any pure literal in the current formula. This approach is meaningful, since if a literal
is pure at some stage of the procedure, it either remains pure or becomes irrelevant in
the following stages. The pure literal sequence obtained by the procedure depends on the
nondeterministic choices made by the procedure, however, by Corollary 4.4, the resulting
reduced formula is uniquely determined by the input.
Lemma 4.3. If a clause C of a CNF  is removed by some run of FindPLS, then it is
removed by every run of FindPLS with input .
Proof. Let L and K be pure literal sequences produced by different runs of FindPLS for
. The formulas [L] and [K] are the corresponding reduced formulas and let C be a
clause of  not contained in [L]. Hence, L contains some of the literals of C. Since [K]
is a subset of , L is a pure literal sequence for [K]. If some literal of L is contained in
[K], then the first of such literals is pure in [K]. Since [K] does not contain a pure
literal, no literal of L is contained in [K]. In particular, C is not contained in [K]. 2
The following is an immediate corollary.
386

fiGenerating Models of a Matched Formula

Algorithm 1 Constructing pure literal sequence
Require: A CNF formula .
Ensure: A maximal strict pure literal sequence L for  and the corresponding reduced
formula.
1: procedure FindPLS()
2:

3:
Initialize a new empty list of literals L.
4:
Initialize Pure() as a set of pure literals in .
5:
while Pure() 6=  do
6:
Choose a literal l from Pure().
7:
Add l to L.
8:
  [l].
9:
Update Pure() to consist of pure literals in .
10:
end while
11: end procedure

Corollary 4.4. Let  be a CNF formula and let L be a pure literal sequence obtained by
FindPLS for .
1. The formula [L] is uniquely determined by .
2. The formula  is pure literal satisfiable, if and only if [L] is empty.
Since the running time of procedure FindPLS is polynomial in the length of the input
formula, a maximal pure literal sequence for a formula can be constructed in polynomial
time. The complexity of constructing a maximal pure literal sequence for a formula  is, in
fact, O(kk) by Lemma 6.1.
Lemma 4.5. Let L = (l1 , . . . , ln ) be a pure literal sequence for a formula , which contains
a literal for each variable of . For i = 1, . . . , n, denote by xi the variable contained in li .
If xi is the variable with the largest index i among the variables, which have an occurence in
, then xi is a splitting variable for  relative to pure literal satisfiable formulas and each
of the formulas [xi = 0] and [xi = 1] is satisfiable, if and only if it does not contain an
empty clause.
Proof. Let  be one of the formulas [xi = 0] and [xi = 1] and let L = (l1 , . . . , li1 ).
Clearly, L is a pure literal sequence for . Moreover, if  does not contain an empty clause,
then L assigns a value to some of the literals in every clause of  and hence, satisfies it. 2
For now it is sufficient to show that the splitting problem relative to class of pure literal
satisfiable formulas has polynomial complexity. Later in Theorem 6.2 we shall show that
the splitting problem can in this case be solved in time O(kk).
Lemma 4.6. The splitting problem relative to class of pure literal satisfiable formulas has
polynomial complexity.
387

fiSavicky & Kucera

Proof. If  is pure literal satisfiable, then a pure literal sequence, which satisfies it, can be
obtained by FindPLS in polynomial time. If the sequence does not contain literals for all
variables, it is extended in polynomial time by appending arbitrary literals for the missing
variables to obtain a pure literal sequence satisfying the assumption of Lemma 4.5. Then,
this lemma implies a method to select a splitting variable and obtain the results of the
satisfiability test for the corresponding restrictions in polynomial time. 2
If a pure literal sequence satisfies the assumption of Lemma 4.5 for a formula , then
the same sequence can be used to find a splitting variable for all formulas in a splitting tree
for . Using this, the models of a pure literal satisfiable formula can be generated with a
delay smaller than the general bound from Theorem 3.3, see Corollary 6.2.
Remark 4.7. The sign of a literal for a given variable, which occurs in a strict pure literal
sequence, is not uniquely determined. Each of the variables y1 and y2 can occur both
positively and negatively in a strict pure literal sequence for the formula
(x1  y1 )  (x2  y1 )  (x3  y2 )  (x4  y2 )  (y1  y2 ) .
For example, (x2 , y1 , x3 , y2 ) and (x4 , y2 , x1 , y1 ) are strict pure literal sequences for this formula.

5. Matched Formulas
In this section we concentrate on matched formulas. Let us start with showing that the
problem of determining the number of models of a matched formula , i.e. the size |T ()|,
is as hard as a general #SAT problem.
Theorem 5.1. The problem of determining |T ()| given a matched formula  is #Pcomplete.
Proof. Let  = C1  C2  . . .  Cm be an arbitrary CNF formula on n variables. Let
y1 , . . . , ym be new variables not appearing in  and let D = (y1  y2  . . .  ym ) be a clause.
Let us define a CNF formula of n + m variables  equivalent to   D as
 = (C1  D)  (C2  D)  . . .  (Cm  D) .
Clearly,  is a matched formula and one can also observe that |T ()| = |T ()|  2n (2m  1).
We have thus reduced the problem of counting the models of a general CNF formula 
(i.e. the general #SAT problem) to the problem of counting the models of a matched CNF
formula  (i.e. the #SAT problem restricted to the matched formulas). 2
Our goal is to show that we can generate the models of a matched formula with a
polynomial delay. Theorem 3.3 cannot be used for this directly, since the class of the
matched formulas does not have the splitting property as can be seen from the following
example. Consider the formula
(x1  x2 )  (x1  x3 )  (x2  x3 ) .
388

fiGenerating Models of a Matched Formula

This formula is matched, but it has no splitting variable. Indeed, setting x1 to 0 leads to
a satisfiable, yet not matched formula (x2 )(x3 )(x2  x3 ) and by symmetry this is true for
variables x2 and x3 as well. In order to achieve our objective, we have to consider a richer
class of formulas. The class we consider generalizes matched and pure literal satisfiable
formulas as follows. Note that an empty formula is matched, since it corresponds to an
empty graph and we can formally assume that an empty graph possesses the required
matching.
Definition 5.2. A formula  is called pure literal matched, if the reduced formula obtained
by procedure FindPLS for  is matched.
Elimination of a pure literal preserves the property of being matched, since a pure literal
is an autarky. Hence, a matched formula is pure literal matched. Clearly, every pure literal
satisfiable formula is pure literal matched, since its reduced formula is empty and, hence,
matched.
The basic idea of an efficient splitting algorithm for the matched formulas is presented
in the following theorem. Later we shall show in Corollary 6.4 that the splitting problem
relative to pure literal matched formulas can be solved in time O(n2  kk).
Theorem 5.3. The class of pure literal matched formulas has the splitting property and
the splitting problem relative to pure literal matched formulas has polynomial complexity.
In order to prove Theorem 5.3, we have to show several statements concerning the
structure of a matched formula. If V is a set of variables, we say that a clause is limited to
V , if it contains only literals with variables from V .
Definition 5.4. Let V be a subset of the variables of a matched formula  and let C denote
the set of clauses in  which are limited to V . The set V will be called a critical block , if
|C| = |V |. Formally, if V is empty, it is also a critical block.
Note that if  is a matched formula, V is a subset of its variables, and C is the set
of the clauses in  limited to V , then by Halls theorem (Theorem 2.1 above) we have
|C|  (C)  |V |. Critical blocks are those achieving the equality. These blocks have the
following property.
Lemma 5.5. Let V be a critical block of a matched formula . Then, in every clause
saturated matching of I(), the variables from V are matched to clauses limited to V .
Proof. Let  be a matched formula with a fixed clause saturated matching between the
variables and the clauses of . If V is a critical block, then there are |V | clauses limited
to V and these clauses are matched to the variables in V . Since the variables matched to
these clauses are different, each of the variables in V is matched to one of these clauses. 2
Another useful property of the set of the critical blocks is as follows.
Lemma 5.6. The set of the critical blocks of a matched formula is closed under intersection.
Proof. Let  be a matched formula and let V1 , V2 be critical blocks. If the intersection
V1  V2 is empty, the conclusion of the lemma is satisfied. If there is a variable x  V1  V2 ,
389

fiSavicky & Kucera

then by Lemma 5.5, in every clause saturated matching of I(), this variable is matched to
a clause, which is limited to V1 and also to V2 . Hence, the number of the clauses, which are
limited to V1  V2 , is at least |V1  V2 |. Since  is matched, the number of these clauses is
equal to |V1  V2 | by Halls theorem. Hence, V1  V2 is a critical block as required. 2
If  is a formula and x is a variable contained in at least one critical block, then
Lemma 5.6 implies that there is a unique inclusion minimal critical block of  containing
x, which is equal to the intersection of all critical blocks of  containing x. If a matched
formula has the same number of clauses and variables, then every variable is contained in
a critical block, since the set of all the variables of the formula is a critical block.
Definition 5.7. If  is a matched formula with the same number of clauses and variables and x is one of its variables, then let Bx denote the inclusion minimal critical block
containing x.
The notation Bx does not specify the formula, since it will always be clear from the
context. Our aim is to show that if a formula  is matched, then either we can find a
splitting variable for  relative to matched formulas, or  is actually pure literal satisfiable.
In order to show this property which is at the basis of our algorithm, we shall first investigate
the structure of critical blocks with respect to matchings.
Lemma 5.8. Let  be a matched formula with the same number of clauses and variables.
Let l be a literal containing a variable x and let us assume that the formula [l] is not
matched. Then
1. the literal l is pure or irrelevant in the clauses of  limited to Bx ,
2. if a clause C of  contains l, then in every matching for , C is matched to a
variable y, such that Bx  By (where  denotes strict inclusion).
Proof. By symmetry, we shall consider only the case l = x. Hence, by the assumptions,
[x = 0] is not a matched formula.
1. The critical block Bx is a subset of every critical block containing x. Hence, in order
to prove the first part of the lemma, it is sufficient to show that there is at least one
critical block B containing x, such that x does not occur negatively in the clauses
limited to B. Let C be any set of the clauses for which the Halls condition for the
formula [x = 0] is not satisfied so we have |(C)| < |C|. Let V = (C) be the set of
the variables, which have an occurrence in some of the clauses of C, and let k = |V |.
There are at least k + 1 clauses in C. Since every clause of C is limited to V , there
are at least k + 1 clauses of [x = 0] limited to V . Each of these clauses is either a
clause of  or is obtained from a clause of  by removing the literal x. Consider the
set of the clauses of  limited to V  {x}. Since  is matched, the Halls condition
is satisfied for this set. Hence,  contains at most k + 1 clauses limited to V  {x}.
Setting x = 0 leads to at least k + 1 clauses limited to V . Hence,  contains precisely
k + 1 clauses limited to V  {x} and none of them contains the literal x. Hence,
V  {x} is a critical block with the required property and the proof of the first part
of the lemma is finished.
390

fiGenerating Models of a Matched Formula

2. Let us fix a clause saturated matching M of clauses to variables in I() and let D
be a clause in  which is matched to x. Since [x = 0] is not matched, it follows
that D contains the positive literal x, otherwise the same matching would work for
[x = 0] as well. Let C be a clause containing x and let y be a variable to which C
is matched in M . Since C is different from D, we have y 6= x. By the assumptions,
the set of all variables is a critical block for  and, hence, the critical block By is
well-defined. Since C is matched to y, we have that C is limited to By by Lemma 5.5.
This implies x  By , because x  C. Since By is a critical block containing x and
Bx is the inclusion minimal critical block containing x, Bx  By . By the first part of
the lemma, no clause limited to Bx contains x which implies that C is not limited
to Bx and thus Bx 6= By . Together we get that Bx  By .
2
The structure of the critical blocks will be used to show the following proposition needed
to prove Theorem 5.3.
Theorem 5.9. Let  be a matched formula. If for every variable x, which has an occurence
in , there is a  {0, 1}, such that [x = a] is not matched, then  is pure literal satisfiable.
Proof. Let  be a matched formula satisfying the assumptions and let us fix a clause
saturated matching M of I(). If there is a variable x in  which is not matched to a
clause, then assigning any value to x yields a matched formula. By assumption we can
therefore suppose that such variable does not exist in  and that each variable is matched
to a clause. In this case, the numbers of clauses and variables of  are equal and for each
variable x in , Bx is well-defined.
Let n be the number of the variables and the clauses of . For each i = 1, . . . , n, let li
be the literal containing the variable xi in the clause matched to this variable. For every
i = 1, . . . , n, the formula [li ] is matched and the formula [li ] is not matched. Consider
the strict partial order on the variables defined by
x < y  Bx  By

(1)

where  means a strict inclusion. By Lemma 5.8, the variables which are maximal in this
partial order are pure in . Let us consider a total ordering of the variables, which is
consistent with the strict partial order (1). Using an appropriate renaming of the variables,
we may assume that this ordering is x1 , . . . , xn , so for every i, j, if xi < xj , then i < j.
Let us verify that using this ordering, the sequence ln , ln1 , . . . , l1 is a satisfying pure literal
sequence for . Let us show by induction on i = n, . . . , 1 that xi is pure or irrelevant in
the formula [ln , . . . , li+1 ]. It is true for i = n by Lemma 5.8, because xn is maximal in the
order of variables induced by the inclusion of their critical blocks. Let us now fix some i and
consider the partial assignment assign(ln , . . . , li+1 ). By Lemma 5.8, each clause containing
li is matched to a variable xj satisfying xi < xj . Hence, these clauses are eliminated by
the considered partial assignment and the variable xi is pure or irrelevant in the formula
[ln , . . . , li+1 ]. 2
Proof of Theorem 5.3. Assume,  is a pure literal matched formula. Let L be a pure
literal sequence obtained by FindPLS procedure for  and let  = [L], which is, by the
391

fiSavicky & Kucera

assumption, a matched formula. Since L is maximal,  does not contain a pure literal. If 
is empty, then  is itself a pure literal satisfiable formula and we can find a splitting variable
for  by the method from Lemma 4.6. If  is not empty, then it is matched and not pure
literal satisfiable. Hence, by Theorem 5.9, there is a variable x of , such that [x = 0]
and [x = 1] are both matched. Since L does not contain a literal with the variable x, the
application of assign(L) and x = a commute for each a  {0, 1}. Hence, L is a pure literal
sequence for the formula [x = a] and the application of assign(L) to [x = a] leads to
[x = a], which is matched. Hence, for each a  {0, 1}, the formula [x = a] is pure literal
matched and the variable x is a splitting variable for the formula .
A time polynomial in the length of the formula is sufficient to select a splitting variable
x as in the proof above. If  is nonempty, the satisfiability of [x = 0] and [x = 1] is
guaranteed by the choice of x. If  is empty,  is pure literal satisfiable and the method from
Lemma 4.6 is used. Hence, a splitting variable and the results of the required satisfiability
tests can be obtained in polynomial time. 2
Similarly as the class of matched formulas, also the class of pure literal matched formulas
is closed under unit propagation. This implies that unit propagation can be used as part
of the construction of the splitting tree, in particular by Remark 3.4 we can always select a
variable in a unit clause as a splitting variable.
Proposition 5.10. The class of pure literal matched formulas is closed under unit propagation.
Proof. Assume,  is a pure literal matched formula containing a unit clause C = (l) where
l is a literal. Let us prove that [l] is a pure literal matched formula.
Let L be a pure literal sequence for . Observe that l cannot be contained in L, because
[l] is unsatisfiable. In the rest of the proof, we distinguish, whether l is contained in L
or not.
If l is contained in L, let L1 denote the sequence of literals in L before l and let L2 be the
sequence of literals in L after l. For simplicity, this can be written as L = (L1 , l, L2 ). Some
of the clauses of  are missing in [l] and some are changed by removing l. Since l is not
contained in L1 , the sequence L1 is a pure literal sequence for [l]. Since any assignments
to disjoint sets of variables commute, we have [L1 , l] = [l, L1 ] and, hence, the sequence
L2 is a pure literal sequence for both these formulas. Hence, the sequence L = (L1 , L2 ) is
a pure literal sequence for [l]. Since, moreover, [L1 , l, L2 ] = [l, L1 , L2 ], the application
of L to [l] leads to a matched formula. Consequently, [l] is pure literal matched.
Let us now consider the case when l is not contained in L. In this case [L] is a matched
formula which contains a unit clause C = (l), since this clause cannot be eliminated by
satisfying any of the literals in L. In every maximum matching of [L], clause C is matched
to l. Thus satisfying l gives a matched formula [L, l]. Since [L, l] = [l, L] and L is a
pure literal sequence for [l], this formula is pure literal matched. 2

6. Algorithms and Complexity
In this section, we prove specific complexity bounds for the algorithms presented in the
previous sections. The complexity bounds are derived for the RAM model with the unit cost
392

fiGenerating Models of a Matched Formula

measure and the word size O(log kk), where  is the input formula. The data structures
used in the algorithms are similar to those described by Minoux (1988) or Murakami and
Uno (2014). Let us first concentrate on the pure literal satisfiable formulas.
Lemma 6.1. A maximal pure literal sequence L for a CNF formula  can be constructed
in time O(kk).
Proof. We use the approach presented in the linear time algorithm for unit propagation
by Minoux (1988) to obtain an efficient version of procedure FindPLS in Algorithm 1. In
addition to the initializations in Algorithm 1, we initialize some auxiliary data structures.
These data structures are similar to those described by Murakami and Uno (2014). In
particular, the occurences of the literals in the formula are represented as nodes arranged as
a sparse matrix, whose rows correspond to literals and columns correspond to clauses. Each
node contains an identification of the clause and the literal, whose occurence it represents.
All the auxiliary data structures and their names are as follows:
 For each literal l we denote cl(l) the row of the matrix, which is a doubly-linked list
of nodes representing the occurences of l in .
 For each clause C   we denote lit(C) the column of the matrix, which is a doublylinked list of nodes corresponding to the occurences of literals in C.
 For each literal l we denote cnt(l) a counter, which contains the size of list lit(C) that
is the number of clauses in which l appears.
 We initialize the set Pure() as a queue which always contains pure literals in .
These are the literals l for which cnt(l) > 0 and cnt(l) = 0.
All these data structures can be initialized by traversing  in linear time. It is important
to note that each node represents an occurence of a literal l in a clause C. As such the
structure representing the node contains four pointers, two for doubly-linked list lit(C) and
two for double-linked list cl(l). Thus removing this node from any of these lists can be
performed in constant time.
In procedure FindPLS we repeat the following steps  find a pure literal l in , add l to
L and apply assign(l) to . Finding a pure literal amounts to dequeueing it from Pure().
When applying assign(l) we remove all clauses containing l (these are now satisfied) and
remove l from the remaining clauses. Let 1 consist of clauses in  which contain l and
let 0 consist of clauses in  which contain l. We claim that assign(l) can be applied to
 in time O(k1 k + |0 |).
1. Removing clauses in 1 means going through the list cl(l) and for each clause C in
this list and each literal l in lit(C) (including l), remove the corresponding node from
cl(l ) and make the list lit(C) inaccessible. This requires time O(1) for each literal l .
During this operation we also decrement the counters cnt(l ) of literals in lit(C) and
if any of their negated counterparts becomes pure, we add it to queue Pure().
2. Removing all occurrences of l means going through the list cl(l) and for each clause
C in this list, remove the corresponding node from cl(l) and from lit(C). This can
be done in time O(1) for each occurrence of l.
393

fiSavicky & Kucera

Repeating these steps for all literals which are included into L requires a constant number
of operations on each occurrence of a literal in the input formula  which implies the total
time O(kk). 2

Theorem 6.2. The splitting problem relative to pure literal satisfiable formulas can be
solved in time O(kk) where  is the input pure literal satisfiable formula. Moreover, the
set T () of the models of a pure literal satisfiable formula  can be generated with a delay
of O(kk).
Proof. Using the efficient version of FindPLS guaranteed by Lemma 6.1, all the operations
used in the proof of Lemma 4.6 can be done in time O(kk). This implies the first statement
of the theorem. The same procedure will be used as a preprocessing step for the algorithm
proving the second statement. In time O(kk), the preprocessing produces a pure literal
sequence L = (l1 , . . . , ln ), which contains a literal for each variable of . The auxiliary data
structures cl(l), lit(C) and cnt(l) used in the preprocessing will be used also later, so they
can be stored or reconstructed when needed.
By construction of L, the assumption of Lemma 4.5 is satisfied for  and L. If the method
from Lemma 4.5 is used to find a splitting variable for such a formula, then each of the
corresponding restrictions either contains an empty clause or also satisfies the assumption
of Lemma 4.5 with L. Hence, the sequence L can be used for selecting a splitting variable
in all nodes of a splitting tree for .
The DFS search is controlled by a stack of postponed nodes, which is initialized with
the root before the search starts. The search is split into a sequence of descending branches.
Each of the descending branches starts by removing a node from the stack and resuming
the search from this node. If a visited node has two satisfiable successors, DFS continues to
one of them and the other is put onto the stack. If a node has a single satisfiable successor,
then the stack is not modified. Each descending branch ends when a 1-leaf is found. For an
estimate of the delay, we estimate the total time needed to construct nodes in one of these
descending branches as follows.
The indices in L of the splitting variables chosen in a descending branch are monotonically decreasing. Hence, the total time needed to search for all the splitting variables in
one descending branch is O(n) and, hence, O(kk).
The time needed for manipulations with the formula in one descending branch is as
follows. When a node is removed from the stack, the auxiliary data structures cl(l), lit(C)
and cnt(l) are computed for the original formula  and then modified according to the
sequence of settings of the variables along the path from the root to the current node. This
can be done in time O(kk). Then, in each node of the descending branch, both assignments
of the chosen variable are computed and a satisfiable successor is selected. In one node, this
can be done in time O(k), where k is the number of the occurrences of the chosen variable in
. When a satisfiable successor is selected, the auxiliary structures are updated according
to it. The total time needed for these operations in one descending branch is O(kk) using
a similar argument as in the proof of Corollary 6.1.
By combining the above estimates, the total time for constructing a descending branch
and, hence, the delay between generating two consecutive models, is O(kk). 2
394

fiGenerating Models of a Matched Formula

Now let us concentrate on the time complexity of selecting a splitting variable of a pure
literal matched formula.
Lemma 6.3. The splitting problem relative to pure literal matched formulas can be solved
in time O(n  kk) where  is the input formula on n variables.
Proof. Following the proof of Theorem 5.3, we first find a pure literal sequence L for 
which can be done in time O(kk) by Lemma 6.1. If  = [L] is an empty formula, the
last variable in L is a splitting variable. Otherwise  is matched and we find a maximum

matching M for . This step can be performed in time O(kk  n) (see Hopcroft & Karp,
1973). Then, we search for a variable x in , such that both [x = 0] and [x = 1] are
matched. Such a variable exists by Theorem 5.9. If the number of the clauses of  is less
than n, any variable not used in the matching has this property. Otherwise, we check for
every variable, whether [x = a] is matched for a  {0, 1}. If the assignment x = a satisfies
the matched literal containing x, then [x = a] is matched. In the rest of the proof, we
estimate the complexity of each of the at most n checks for the assignments falsifying a
matched literal.
Partial assignment can be performed in time O(kk) = O(kk). During partial assignment the satisfied clauses are removed and the occurences of variable x are removed from
the remaining clauses. We modify matching M into a matching N for [x = a] accordingly, that is we remove pairs containing a satisfied clause and the pair containing x. If in
|N | = m (where m is the number of clauses in [x = a]), we are done. Otherwise we know
that |N | = m  1, since at most one pair containing a clause of [x = a], specifically, the
pair containing a literal on x, was removed from M when forming N . It remains to check
whether N is already a maximum matching or whether there is a better matching. This
can be tested by looking for a single augmentating path in I([x = a]) for matching N . An
augmentating path can be found using a breadth first search in time linear in the size of
the graph I([x = a]) (see e.g. Hopcroft & Karp, 1973; Lovasz & Plummer, 1986). Hence,
the test, whether [x = a] is matched can be done in time O(kk) = O(kk). 2
As a corollary of Lemma 6.3 and the general bound from Theorem 3.3, we get the
following.
Corollary 6.4. Models of a pure literal matched formula  on n variables can be generated
with a delay O(n2  kk).
Proof. By Lemma 6.3 we can find a splitting variable for a pure literal matched formula 
in time O(n  kk), in the same time we can determine the satisfiability of formulas [x = 0]
and [x = 1] as well. By Theorem 3.3 we thus get that the delay is O(n2  kk). 2

7. Linearly Satisfiable Formulas
In this section we consider the class of linearly satisfiable formulas. By results of Kullmann
(2000), this class generalizes both the matched formulas and the pure literal satisfiable
formulas and, by combining the proofs, also the class of pure literal matched formulas. In
this section, we show that it is not possible to generate models of linearly satisfiable formulas
with a polynomial delay unless P=NP.
395

fiSavicky & Kucera

As a consequence, the splitting problem relative to linearly satisfiable formulas does not
have polynomial complexity unless P=NP. This consequence follows also unconditionally
from Example 7.10, which presents a linearly satisfiable formula of 4 variables, which does
not have a splitting variable with respect to the class of linearly satisfiable formulas.
Let us recall the notation introduced by Kullmann, which is used below to present the
definition and basic facts concerning the linearly satisfiable formulas. If l is a literal, then
var(l) is the variable in this literal. If v is a partial assignment, then v(l) is the value of this
assignment on literal l.
Definition 7.1 (Kullmann, 2000). Let  be a CNF formula and let v be a non-empty
partial assignment of the variables of . We say that v is a simple linear autarky, if there
is an associated weight function w which assigns each variable x evaluated by v a positive
real number w(x) such that for all clauses C of  we have
X
X
w(var(l)) 
w(var(l)) .
(2)
lC,v(l)=1

lC,v(l)=0

Clearly, if any literal in C is falsified by v, then there must be a literal satisfied by v as
well. Therefore a simple linear autarky is an autarky. Kullmann showed that we can check
whether there is a simple linear autarky v for a CNF formula  and find one, if it exists,
by solving several linear programs.
If a literal l is pure in a formula, then the partial assignment v(l) = 1 with the weight
w(var(l)) = 1 is a simple linear autarky for the formula. As another example, consider any
satisfying assignment of a satisfiable 2-CNFs. Such an assignment with the same weight
for all variables forms a simple linear autarky. Similarly, pure Horn CNFs without unit
clauses are satisfiable by a simple linear autarky which assigns value 0 and equal weight to
all variables. On the other hand, if a pure Horn CNF formula contains a unit clause, it can
be satisfiable and have no simple linear autarky. An example is the formula
(x1 )  (x1  x2 )  (x1  x3 )  (x1  x2  x3 ) ,
which has no simple linear autarky by Theorem 7.8 and Lemma 7.9 below.
By considering iterative application of simple linear autarkies to a formula we can get
the class of linearly satisfiable formulas defined as follows.
Definition 7.2 (Kullmann, 2000). The class of linearly satisfiable formulas is defined as
the smallest class satisfying the following two properties:
1. An empty CNF is linearly satisfiable.
2. Let  be a CNF, such that there is a simple linear autarky v for  and [v] is linearly
satisfiable. Then so is .
In other words, a CNF formula  is linearly satisfiable if by subsequent applications
of linear autarkies we obtain an empty formula. A composition of simple linear autarkies
is called linear autarky by Kullmann (2000) and the class of linearly satisfiable formulas
therefore consists of formulas which are satisfiable by a linear autarky. Kullmann showed
that all matched formulas are linearly satisfiable. Since a pure literal is a simple linear
396

fiGenerating Models of a Matched Formula

autarky, any pure literal satisfiable formula is linearly satisfiable. Similarly, any pure literal
matched formula defined in Section 5 is linearly satisfiable by simple linear autarkies for
the pure literals concatenated with the linear autarky for the resulting matched formula.
While for matched and pure literal satisfiable formulas we have presented algorithms
which generate models of these formulas with polynomial delay, it is not possible to extend
this result to linearly satisfiable formulas unless P=NP. Let us first present a construction,
which is used in a reduction argument.
Let  be an arbitrary 3-CNF formula with variables x1 , . . . , xn and clauses c1 , . . . , cm .
Consider new variables y1 , y2 , y3 and let  be the formula consisting of the clauses
(y1  y2 ), (y2  y3 ), (y3  y1 ),
(cj  y1  y2  y3 ),
j = 1, . . . , m
(xi  y1 )
i = 1, . . . , n .
Recall that the number of the models of a formula is the number of the satisfying assignments
of the variables, which have an occurrence in it. Hence, in the next lemma, T () and T ()
are defined on different sets of the variables.
Lemma 7.3. Formula  is linearly satisfiable and the number of its models is |T ()| =
|T ()| + 1.

Proof. Each clause ci of  contains three literals. Hence, in each clause of , the number
of the positive literals is at least the number of the negative literals. It follows that the
assignment of all variables to 1 with equal weight for all variables defines a simple linear
autarky, which satisfies . Hence, this formula is linearly satisfiable.
Any model of  satisfies y1 = y2 = y3 . An assignment containing y1 = y2 = y3 = 1 is a
model of  if and only if xi = 1 for i = 1, . . . , n. An assignment containing y1 = y2 = y3 = 0
is a model of  if and only if the assignment of the variables xi is a model of . This implies
the second part of the statement of the lemma. 2
Since the formula  can be constructed for every 3-CNF formula , the lemma implies
the following immediate corollary.

Corollary 7.4. It is an NP-complete problem to determine, whether a general linearly
satisfiable formula has at least 2 models.
Note that this implies NP-hardness of #SAT problem restricted to the linearly satisfiable formulas. This problem is, in fact, also #P-complete, since it is #P-complete to
count models of monotone formulas, which are pure literal satisfiable and, hence, linearly
satisfiable.
In Example 7.10 below, we present a linearly satisfiable formula, which has no splitting
variable relative to the class of linearly satisfiable formulas. For analysis of this example, we
use a characterization of simple linear autarkies obtained using the clause-variable matrix.
Definition 7.5. Let  be a CNF formula with clauses c1 , . . . , cm and variables x1 , . . . , xn .
The clause-variable matrix of this formula is the matrix A = {aj,i } of the dimension m  n
defined as

 1 xi  cj
1 xi  cj
aj,i =

0 otherwise .
397

fiSavicky & Kucera

If u  Rm , then u  0 means uj  0 for all j = 1, . . . , m. Kullmann showed the following
proposition.
Lemma 7.6 (Kullmann, 2000). A formula  with the clause-variable matrix A has a simple
linear autarky, if and only if there is a nonzero z  Rn , such that Az  0. Moreover, a
linear autarky can be obtained from such a vector z using the assignment

 1 if zi > 0
v(xi ) =
0 if zi < 0

 if zi = 0
and the weight function w(xi ) = |zi |.
Let us present the well-known Farkas lemma in the form used in the proof of Theorem
7.8.
Theorem 7.7 (Farkas lemma). Let A be an m  n real matrix and b  Rn . Then, exactly
one of the following statements is true.
1. There is a vector y  Rm , such that y  0 and y t A = bt .
2. There is a vector z  Rn , such that Az  0 and bt z < 0.
A linear combination of real vectors with non-negative coefficients will be called, for
simplicity, a non-negative combination.
Theorem 7.8. Assume,  is a formula of n variables and m clauses and A is its clausevariable matrix of the dimension m  n. Then, exactly one of the following statements is
true:
(a)  has a linear autarky,
(b) every vector in Rn is a non-negative combination of the rows of A.
Proof. First, assume, both (a) and (b) are satisfied. Lemma 7.6 implies that there is a
non-zero z  Rn , such that Az  0. By (b), there is a non-negative vector y  Rm , such
that y t A = z t . Multiplying this by z from the right, we get
y t Az = z t z < 0 .
This is a contradiction, since both y and Az are non-negative.
Assume, (b) is not satisfied. Hence, there is a vector b  Rn , which is not a non-negative
combination of the rows of A. By Farkas lemma, there is a vector z  Rn , such that Az  0
and bt z < 0. Since the latter condition implies that z is non-zero, there is a simple linear
autarky for  by Lemma 7.6 which means that (a) is satisfied. 2
Lemma 7.9. Assume, A is a matrix of dimension m  n, such that rank(A) = n and there
is a vector u  Rm with all components positive, such that ut A = 0. Then, every vector in
Rn is a non-negative combination of the rows of A.
398

fiGenerating Models of a Matched Formula

Proof. By the assumption, the linear space generated by the rows of A is Rn . Hence, for
every z  Rn , there is v  Rm , such that v t A = z. For a sufficiently large real number s,
the vector v + su has all components non-negative and (v + su)t A = z. 2
Note that every linearly satisfiable CNF formula of at most 3 variables has a splitting
variable relative to the class of linearly satisfiable CNF formulas, since setting any variable
to a constant leads to a formula of at most 2 variables, which is at most quadratic and,
hence, is satisfiable if and only if it is linearly satisfiable.
Example 7.10. Denote E = {a  {0, 1}4 | 2  a1 + a2 + a3 + a4  3} and for every Boolean
variable x, let x1 = x and x0 = x. The formula
(x1 , x2 , x3 , x4 ) =

4
^ _

xai i

aE i=1

is linearly satisfiable, but has no splitting variable relative to the class of linearly satisfiable
formulas.
Proof. In every clause, the number of positive literals is at least the number of negative
literals. Hence, the formula  is linearly satisfiable by Lemma 7.6 with z = (1, 1, 1, 1).
Since  is invariant under any permutation of the variables, it is sufficient to prove that
x4 is not a splitting variable. Since every clause of  contains a negative literal, we have
(0, 0, 0, 0) = 1. It follows that the formula [x4 = 0] is satisfiable. One can verify that
[x4 = 0] =

3
^ _

xai i ,

aE  i=1

where E  = {a  {0, 1}3 | 1  a1 + a2 + a3  2}. In order to prove that [x4 = 0] is not
linearly satisfiable, consider its clause-variable matrix with the columns corresponding to
x1 , x2 , x3 , which is


1
1 1
 1 1
1 


 1

1
1


 1 1 1  .


 1
1 1 
1 1

1

This matrix has rank 3, since each of the vectors (2, 0, 0), (0, 2, 0), (0, 0, 2) is a sum of two
rows out of the first three. Moreover, the sum of all the rows of this matrix is the zero
vector. Hence, the formula [x4 = 0] does not have a linear autarky by Lemma 7.9 and
Theorem 7.8. 2

8. Conclusion and Directions for Further Research
In this paper, we have shown that it is possible to generate the models of a matched formula
 of n variables with delay O(n2  kk). As a byproduct we have shown that the models
399

fiSavicky & Kucera

of a pure literal satisfiable formula  (i.e. a formula satisfiable by iterated pure literal
elimination) can be generated with delay O(kk). We have also shown that this result
cannot be generalized for the class of linearly satisfiable formulas since it is not possible to
generate models of linearly satisfiable formulas with a polynomial delay unless P=NP.
Let us mention that the procedure for generating the models with a bounded delay can
be extended to formulas for which a small strong backdoor set with respect to the class
of matched formulas with empty clause detection can be found. Let us assume that B is
such a backdoor set for a formula , i.e. B is a set of variables satisfying that any partial
assignment to variables in B leads to a matched formula, or to a formula containing an
empty clause. Then we can generate the decision tree for  (and thus generate its models)
in time O(2|B| kk + T (f ) n2 kk). Unfortunately, searching for strong backdoor sets with
respect to the class of matched formulas is hard (Szeider, 2007).
The algorithms described in this paper for the cases of pure literal satisfiable and pure
literal matched formulas can be used in a general algorithm for model enumeration which
is based on splitting tree. This, in turn, is any DPLL based enumeration algorithm. To
this end, a similar approach to the one described by Stefan Szeider (2003) can be used.
Together with a formula  we would keep a maximum matching M of I(). This maximum
matching can then be maintained through the reduction and assignment steps performed
in the enumeration algorithm. Once the algorithm arrives at a matched formula, it can
select splitting variables in the way we have described in this paper which has guaranteed
polynomial delay.
An interesting question is whether our approach could be used with the parameterized
satisfiability algorithm based on maximum deficiency (see Szeider, 2003) in order to get a
parameterized algorithm for generating the models of a general formula.

Acknowledgments
Petr Savicky was supported by CE-ITI and GACR under the grant number GBP202/12/G061
and by the institutional research plan RVO:67985807. Petr Kucera was supported by the
Czech Science Foundation (grant GA15-15511S).

References
Aceto, L., Monica, D., Ingolfsdottir, A., Montanari, A., & Sciavicco, G. (2013). Logic for
Programming, Artificial Intelligence, and Reasoning: 19th International Conference,
LPAR-19, Stellenbosch, South Africa, December 14-19, 2013. Proceedings, chap. An
Algorithm for Enumerating Maximal Models of Horn Theories with an Application
to Modal Logics, pp. 117. Springer Berlin Heidelberg, Berlin, Heidelberg.
Aharoni, R., & Linial, N. (1986). Minimal non-two-colorable hypergraphs and minimal
unsatisfiable formulas. Journal of Combinatorial Theory, Series A, 43 (2), 196  204.
Bollobas, B. (1998). Modern Graph Theory, Vol. 184 of Graduate Texts in Mathematics.
Springer.
400

fiGenerating Models of a Matched Formula

Coquery, E., Jabbour, S., Sais, L., Salhi, Y., et al. (2012). A SAT-based approach for
discovering frequent, closed and maximal patterns in a sequence. In Proceedings of
ECAI.
Creignou, N., & Hebrard, J.-J. (1997). On generating all solutions of generalized satisfiability
problems. Informatique theorique et applications, 31 (6), 499511.
Creignou, N., Olive, F., & Schmidt, J. (2011). Theory and Applications of Satisfiability
Testing - SAT 2011: 14th International Conference, SAT 2011, Ann Arbor, MI, USA,
June 19-22, 2011. Proceedings, chap. Enumerating All Solutions of a Boolean CSP by
Non-decreasing Weight, pp. 120133. Springer Berlin Heidelberg, Berlin, Heidelberg.
Dechter, R., & Itai, A. (1992). Finding all solutions if you can find one. In AAAI-92
Workshop on Tractable Reasoning, pp. 3539.
Fleischner, H., Kullmann, O., & Szeider, S. (2002). Polynomial-time recognition of minimal unsatisfiable formulas with fixed clause-variable difference. Theoretical Computer
Science, 289 (1), 503  516.
Flum, J., & Grohe, M. (2006). Parameterized complexity theory (1st edition)., Vol. 3 of
Texts in Theoretical Computer Science. An EATCS Series. Springer-Verlag Berlin
Heidelberg.
Franco, J., & Van Gelder, A. (2003). A perspective on certain polynomial-time solvable
classes of satisfiability. Discrete Appl. Math., 125 (2-3), 177214.
Garey, M., & Johnson, D. (1979). Computers and Intractability: A Guide to the Theory of
NP-Completeness. W.H. Freeman and Company, San Francisco.
Genesereth, M., & Nilsson, N. (1987). Logical Foundations of Artificial Intelligence. Morgan
Kaufmann, Los Altos, CA.
Hopcroft, J. E., & Karp, R. M. (1973). An n5/2 algorithm for maximum matchings in
bipartite graphs. SIAM Journal on computing, 2 (4), 225231.
Jabbour, S., Lonlac, J., Sais, L., & Salhi, Y. (2014). Extending modern sat solvers for
models enumeration. In IEEE 15th International Conference on Information Reuse
and Integration (IRI), 2014, pp. 803810. IEEE.
Johnson, D. S., Yannakakis, M., & Papadimitriou, C. H. (1988). On generating all maximal
independent sets. Information Processing Letters, 27 (3), 119  123.
Kang, H.-J., & Park, I.-C. (2005). Sat-based unbounded symbolic model checking.
Computer-Aided Design of Integrated Circuits and Systems, IEEE Transactions on,
24 (2), 129140.
Kavvadias, D. J., Sideri, M., & Stavropoulos, E. C. (2000). Generating all maximal models
of a Boolean expression. Information Processing Letters, 74 (34), 157162.
Khuller, S., & Vazirani, V. V. (1991). Planar graph coloring is not self-reducible, assuming
P 6= N P . Theoretical Computer Science, 88 (1), 183  189.
Kullmann, O. (2000). Investigations on autark assignments. Discrete Applied Mathematics,
107 (13), 99  137.
401

fiSavicky & Kucera

Kullmann, O. (2003). Lean clause-sets: generalizations of minimally unsatisfiable clausesets. Discrete Applied Mathematics, 130 (2), 209  249. The Renesse Issue on Satisfiability.
Lovasz, L., & Plummer, M. D. (1986). Matching Theory. North-Holland.
McMillan, K. L. (2002). Computer Aided Verification: 14th International Conference,
CAV 2002 Copenhagen, Denmark, July 2731, 2002 Proceedings, chap. Applying SAT
Methods in Unbounded Symbolic Model Checking, pp. 250264. Springer Berlin Heidelberg, Berlin, Heidelberg.
Minoux, M. (1988). LTUR: A simplified linear time unit resolution algorithm for Horn
formulae and computer implementation. Information Processing Letters, 29, 1  12.
Morgado, A., & Marques-Silva, J. (2005a). Algorithms for propositional model enumeration and counting. Tech. rep., Instituto de Engenharia de Sistemas e Computadores,
Investigacao e Desenvolvimento, Lisboa.
Morgado, A., & Marques-Silva, J. (2005b). Good learning and implicit model enumeration. In Tools with Artificial Intelligence, 2005. ICTAI 05. 17th IEEE International
Conference on, pp. 6 pp.136.
Murakami, K., & Uno, T. (2014). Efficient algorithms for dualizing large-scale hypergraphs.
Discrete Applied Mathematics, 170, 8394.
Sipser, M. (2006). Introduction to the Theory of Computation, Vol. 2. Thomson Course
Technology Boston.
Szeider, S. (2003). Minimal unsatisfiable formulas with bounded clause-variable difference
are fixed-parameter tractable. In Warnow, T., & Zhu, B. (Eds.), Computing and
Combinatorics, Vol. 2697 of Lecture Notes in Computer Science, pp. 548558. Springer
Berlin Heidelberg.
Szeider, S. (2005). Generalizations of matched CNF formulas. Annals of Mathematics and
Artificial Intelligence, 43 (1-4), 223238.
Szeider, S. (2007). Matched formulas and backdoor sets. In Marques-Silva, J., & Sakallah,
K. A. (Eds.), Theory and Applications of Satisfiability Testing  SAT 2007, Vol. 4501
of Lecture Notes in Computer Science, pp. 9499. Springer Berlin Heidelberg.
Tovey, C. A. (1984). A simplified NP-complete satisfiability problem. Discrete Applied
Mathematics, 8 (1), 85  89.
Valiant, L. (1979a). The complexity of computing the permanent. Theoretical Computer
Science, 8 (2), 189  201.
Valiant, L. (1979b). The complexity of enumeration and reliability problems. SIAM Journal
on Computing, 8 (3), 410421.

402

fi