Journal of Artificial Intelligence Research 56 (2016) 693-745

Submitted 03/16; published 08/16

Qualitative Spatial Logics for Buffered Geometries
Heshan Du

H.Du@leeds.ac.uk

University of Leeds, UK

Natasha Alechina

Natasha.Alechina@nottingham.ac.uk

University of Nottingham, UK

Abstract
This paper describes a series of new qualitative spatial logics for checking consistency
of sameAs and partOf matches between spatial objects from different geospatial datasets,
especially from crowd-sourced datasets. Since geometries in crowd-sourced data are usually not very accurate or precise, we buffer geometries by a margin of error or a level of
tolerance   R0 , and define spatial relations for buffered geometries. The spatial logics
formalize the notions of buffered equal (intuitively corresponding to possibly sameAs),
buffered part of (possibly partOf), near (possibly connected) and far (definitely disconnected). A sound and complete axiomatisation of each logic is provided with respect to
models based on metric spaces. For each of the logics, the satisfiability problem is shown
to be NP-complete. Finally, we briefly describe how the logics are used in a system for generating and debugging matches between spatial objects, and report positive experimental
evaluation results for the system.

1. Introduction
The motivation for our work on qualitative spatial logics comes from the needs of integrating
disparate geospatial datasets, especially crowd-sourced geospatial datasets. Crowd-sourced
data involves non-specialists in data collection, sharing and maintenance. Compared to
authoritative geospatial data, which is collected by surveyors or other geodata professionals, crowd-sourced data is less accurate and less well structured, but often provides richer
user-based information and reflects real world changes more quickly at a much lower cost
(Jackson, Rahemtulla, & Morley, 2010). It is in the interests of national mapping agencies,
government organisations, and all other users of geospatial data to be able to integrate and
use different geospatial data synergistically.
Geospatial data matching refers to the problem of establishing correspondences (matches)
between spatial objects represented in different geospatial datasets. It is an essential step
for data comparison, data integration or enrichment, change detection and data update.
Matching authoritative geospatial data and crowd-sourced geospatial data is a non-trivial
task. Geometry representations of the same location or place in different datasets are usually not exactly the same. Objects are also sometimes represented at different levels of
granularity. For example, consider geometries of objects in Nottingham city centre given by
Ordnance Survey of Great Britain (OSGB) (2012) and by OpenStreetMap (OSM) (2012)
in Figure 1. The position and shape of the Prezzo Ristorante are represented differently in
OSGB data (dotted) and OSM data (solid). The Victoria Shopping Centre is represented
as a whole in OSM, and as several shops in OSGB.
c
2016
AI Access Foundation. All rights reserved.

fiDu & Alechina

Figure 1: Prezzo Ristorante and Victoria Shopping Centre represented in OSGB (dotted)
and OSM (solid)

In order to integrate the datasets, we need to determine which objects are the same
(represent the same entity) and sometimes which objects in one dataset are parts of objects
in the other dataset (as in the example of Victoria Shopping Centre). The statements
representing these two types of relations are referred to as sameAs matches and partOf
matches respectively. One way to produce such matches is to use locations and geometries
of objects, although of course we also use any lexical labels associated with the objects, such
as names of restaurants etc. In our previous work (Du, Alechina, Jackson, & Hart, 2016),
we present a method which generates matches using both location and lexical information
about spatial objects. As generated matches may contain errors, they are seen as retractable
assumptions and require further validation and checking. One way is to use logical reasoning
to check the consistency of matches with respect to statements in input datasets. By
using description logic reasoning, the correctness of matches can be checked with respect
to classification information. For example, it is wrong to state that spatial objects a and
b are the same, if a is a Bank and b is a Clinic, because the concepts Bank and Clinic
are disjoint, containing no common elements. However, this is not sufficient for validating
matches between spatial objects1 . For example, two spatial objects which are close to each
other in one dataset cannot be matched to two spatial objects which are far away apart in
the other dataset, no matter whether they are of the same type or not. Therefore, spatial
reasoning is required to validate matches with regard to location information, in addition
to description logic reasoning.
Spatial logic studies relations between geometrical structures and spatial languages describing them (Aiello, Pratt-Hartmann, & van Benthem, 2007). There are a variety of
spatial relations, such as topological connectedness of regions, relations based on distances,
relations for expressing orientations or directions, etc. In a spatial logic, spatial relations
are represented in a formal language, such as first order logic or its fragments, and inter1. There are works (Lutz & Milicic, 2007) on extending description logics with concrete domains or constraint systems, such as the region connection calculus (RCC) (Randell, Cui, & Cohn, 1992) and Allens
Interval Algebra (Allen, 1983). The description logic reasoner Pellet (Sirin, Parsia, Grau, Kalyanpur,
& Katz, 2007) was extended to PelletSpatial (Stocker & Sirin, 2009), which supports qualitative spatial
reasoning in RCC. However, later we will show that it is not appropriate to use RCC in our application.

694

fiQualitative Spatial Logics for Buffered Geometries

preted over some structures based on geometrical spaces, such as topological spaces, metric
spaces and Euclidean spaces. In the field of qualitative spatial reasoning, several spatial
formalisms have been developed for representing and reasoning about topological relations,
such as the Region Connection Calculus (RCC) (Randell et al., 1992), the 9-intersection
model (Egenhofer & Franzosa, 1991) and their extensions (Clementini & Felice, 1997; Roy
& Stell, 2001; Schockaert, Cock, Cornelis, & Kerre, 2008b, 2008a; Schockaert, Cock, &
Kerre, 2009). In addition, there are formalisms for representing and reasoning about directional relations (Frank, 1991, 1996; Ligozat, 1998; Balbiani, Condotta, & del Cerro,
1999; Goyal & Egenhofer, 2001; Skiadopoulos & Koubarakis, 2004), as well as relative or
absolute distances (Zimmermann, 1995; Clementini, Felice, & Hernandez, 1997; Wolter &
Zakharyaschev, 2003, 2005). Recent comprehensive surveys on qualitative spatial representations and reasoning are provided by Cohn and Renz (2008) and Chen, Cohn, Liu, Wang,
OuYang, and Yu (2015).
Qualitative spatial reasoning has been shown to be applicable to geospatial data (Bennett, 1996; Bennett, Cohn, & Isli, 1997; Guesgen & Albrecht, 2000; Mallenby, 2007; Mallenby & Bennett, 2007; Li, Liu, & Wang, 2013), where location information of spatial
objects comes from a single data source. The application described in this paper is different, as location representations about the same spatial object come from different sources
and are usually not exactly the same. Rather than treating all the differences in geometric
representations as logical contradictions, we would tolerate slight geometric differences and
only treat qualitatively defined large differences as logical contradictions used for detecting
wrong matches. More specifically, after establishing matches between two sets of spatial
objects, if the set of matches gives rise to a contradiction, then some match must be wrong
and should be retracted. In addition, we would provide explanations to help users understand why a contradiction exists and why some matches are wrong. In the following, we
assess the appropriateness of several existing spatial formalisms for these purposes.
The Region Connection Calculus (RCC) (Randell et al., 1992) is a first order formalism
based on regions and the connection relation C, which is axiomatised to be reflexive and
symmetric. Two regions x, y are connected (i.e. C(x, y) holds), if their closures share a
point. Based on the connection relation, several spatial relations are defined for regions.
Among them, eight jointly exhaustive and pairwise disjoint (JEPD) relations are identified:
DC (Disconnected), EC (Externally Connected), P O (Partially Overlap), T P P (Tangential
Proper Part), N T P P (Non-Tangential Proper Part), T P P i (Inverse Tangential Proper
Part), N T P P i (Inverse Non-Tangential Proper Part) and EQ (Equal). They are referred
to as RCC8, which is well-known in the field of qualitative spatial reasoning.
The 9-intersection model is developed by Egenhofer and Franzosa (1991) and Egenhofer
and Herring (1991) based on the point-set interpretation of geometries. By comparing the
nine intersections between interiors, boundaries and exteriors of point-sets, it identifies 29
mutually exclusive topological relations. The 9-intersection model provides a comprehensive
formal categorization of binary topological relations between points, lines and regions. Only
a small number of these 29 relations are realisable in a particular space (Egenhofer &
Herring, 1991). Restricting point-sets to simple regions (regions homeomorphic to disks),
the 512 relations collapse to the RCC8 relations.
For the described application, we found it difficult to use spatial formalisms such as the
Region Connection Calculus (Randell et al., 1992) and the 9-intersection model (Egenhofer
695

fiDu & Alechina

& Franzosa, 1991), since they presuppose accurate geometries or regions with sharp boundaries and define spatial relations based on the connection relation. This is too strict for
crowd-sourced geospatial data. As shown in Figure 2, a1 is sameAs a2 , both representing a
Prezzo Ristorante; b1 is sameAs b2 , both referring to a Blue Bell Inn. Though the sameAs
matches are correct, a topological inconsistency still exists, since a1 and b1 are disconnected
(DC), a2 and b2 are externally connected (EC), and the spatial relations DC and EC are
disjoint. Therefore, relations based on connection are too strict for crowd-sourced geospatial
data which is possibly inaccurate and may contain errors.

Figure 2: In OSGB data, the Prezzo Ristorante (a1 ) and the Blue Bell Inn (b1 ) are disconnected, whilst in OSM data, they (a2 and b2 ) are externally connected.
The egg-yolk theory is independently developed by Lehmann and Cohn (1994), Cohn
and Gotts (1996b, 1996a), and Roy and Stell (2001) extending the RCC theory and by
Clementini and Felice (1996, 1997) extending the 9-intersection model, in order to represent and reason about regions with indeterminate boundaries. In this theory, a region with
an indeterminate boundary (an indeterminate region) is represented by a pair of regions,
an egg and a yolk, which are the maximum extension and the minimum extension of
the indeterminate region respectively (similar to the upper approximation and lower approximation in the rough set theory, Pawlak, Polkowski, & Skowron, 2007). The yolk is
not empty and it is always a proper part of the egg. The egg-yolk theory presupposes the
existence of a core part of a region and a more vague part. For the described application,
the same location can be represented using two disconnected polygons from an authoritative geospatial dataset and a crowd-sourced geospatial dataset respectively. In this case, we
could not define a certain inner region for any of the disconnected polygons, otherwise, it
is inconsistent to treat them as different representations for the same location.
We are aware that there are several approaches (Fine, 1975; Zadeh, 1975; Smith, 2008)
to representing vague concepts and relations, which have been adopted to extend classical
theories such as RCC and the 9-intersection model. A main approach is to assign a degree of
truth or a degree of membership to concepts and relations. For example, in the fuzzy region
connection calculus (fuzzy RCC) (Schockaert et al., 2008b, 2008a, 2009), the connection
relation C is defined as a reflexive and symmetric fuzzy relation. For regions a, b, C(a, b)
denotes the degree to which a and b are connected. Using C as the primitive relation,
every RCC relation R can be redefined to calculate the degree to which R holds. The
fuzzy RCC or other similar formalisms may be applied in the case shown in Figure 2. For
example, with an appropriate membership function for the relation EC, EC(a1 , b1 ) = 0.8
696

fiQualitative Spatial Logics for Buffered Geometries

Figure 3: Buffering the geometry X by a distance ; three dashed circles are buffered part
of (BPT) the solid circle; the dashed circle and the solid circle are buffered equal
(BEQ)

and EC(a2 , b2 ) = 1, then no contradiction will arise. We did not adopt this approach in the
matching problem, mainly because there is no good way to define the degree of membership,
and it is difficult to generate user-friendly explanations for why the matches are wrong if
the underlying reasoning is numerical and relatively obscure.
The logic M S(M ) was proposed and developed by Sturm, Suzuki, Wolter, and Zakharyaschev (2000), Kutz, Sturm, Suzuki, Wolter, and Zakharyaschev (2002), Kutz, Wolter,
Sturm, Suzuki, and Zakharyaschev (2003), Wolter and Zakharyaschev (2003, 2005), and
Kutz (2007) for reasoning about distances. The logic M S(M ) makes it possible to define
concepts such as an object within the distance of 100 meters from a School. M in M S(M )
is a parameter set. A typical example of M is Q0 . The satisfiability problem for a finite set
of M S(Q0 ) formulas in a metric space is EXPTIME-complete (Wolter & Zakharyaschev,
2003). M S(M ) was not developed for the problem of geospatial data matching. However, after we designed the logics introduced in this paper, we discovered that they form a
proper fragment of M S(Q0 ). To detect problematic matches, we also reason about distances between objects, but this reasoning is of a more restricted and qualitative kind. The
complexity of the satisfiability problem of our logics is NP-complete, which makes them
somewhat more suitable for automatic debugging of matches than the full M S(Q0 ). The
syntax and semantics of M S(M ) and the proofs for the proper fragment relations are
provided later in this paper (see Section 3).
In this paper, we present a series of new qualitative spatial logics developed for validating
matches between spatial objects: a logic of NEAR and FAR for buffered points (LNF) (Du,
Alechina, Stock, & Jackson, 2013), a logic of NEAR and FAR for buffered geometries
(LNFS) and a logic of part and whole for buffered geometries (LBPT) (Du & Alechina,
2014a, 2014b). The notion of buffer (ISO Technical Committee 211, 2003) is used to model
the uncertainty in geometry representations, tolerating slight differences up to a margin of
error or a level of tolerance   R0 . As shown in Figure 3, the buffer of a geometry X is
a geometry which contains exactly all the points within  distance from X. The buffer of
X is denoted as buffer (X , ). For a geometry X which is possibly represented inaccurately
within the margin of error  in one dataset, its corresponding representation in the other
dataset is assumed to be somewhere within buffer (X , ).
The spatial logics involve four spatial relations BufferedPartOf (BPT), BufferedEqual
(BEQ), NEAR and FAR. They formalize the notions of possibly partOf, possibly sameAs,
possibly connected (given a possible displacement by ) and definitely disconnected
(even if displaced by ) respectively. A geometry X is BufferedPartOf a geometry X 0 , if
X is within buffer (X 0 , ); two geometries are BufferedEqual, if they are BufferedPartOf
697

fiDu & Alechina

Figure 4: NEAR and FAR
each other (Figure 3). We assume that two geometries X and X 0 from two diferent
datasets may correspond to the same object if they are BufferedEqual. The parameter
 captures the margin of error in representation of geometries. Two geometries X, Y are
NEAR, if the corresponding geometries X 0 , Y 0 in the other dataset could be connected,
i.e. distance(X, Y )  [0, 2] (Figure 4). Clearly, if FAR(X , Y ) holds, then NEAR(X , Y )
should be false for X and Y from the same dataset. In addition, we want to exclude the
possibility that NEAR(X 0 , Y 0 ) may hold for X 0 , Y 0 (corresponding to X, Y respectively)
in the other dataset. Therefore we define FAR(X , Y ) as distance(X, Y )  (4, +) (Figure 4). It is possible that two geometries X, Y are not NEAR and not FAR, this is,
distance(X, Y )  (2, 4].
The way of defining BEQ, N EAR and F AR is similar to that for defining distance
relations between points by Moratz and Wallgrun (2012), where each point is assigned one
or more reference distances. The distance relations between two points X, Y are defined
by comparing the distance between X, Y to the reference distances of X and those of Y .
As different points can have different reference distances for indicating nearness, distance
relations may not be symmetric. Differing from the work by Moratz and Wallgrun (2012),
the relations we defined are not only for points but also for general geometries, and every
geometry has the same reference distances (, 2 and 4), which leads to the symmetric
definitions of BEQ, N EAR and F AR. We provide sound and complete sets of axioms to
support reasoning about BEQ, BP T , N EAR and F AR relations (see Section 4). This reasoning is useful for verifying matches between spatial representations from different sources.
As explained in our previous work (Du et al., 2013), though the relations are named
N EAR and F AR, we do not attempt to model human notions of nearness or proximity,
which is influenced by several factors, such as absolute distance, relative distance, frame of
reference, object size, travelling costs and reachability, travelling distance and attractiveness
of objects (Guesgen & Albrecht, 2000). In this work, we provide a strict mathematical
definition for the calculation of whether two objects are to be considered as being N EAR
or F AR, based on a margin of error . While this makes our approach less likely to be
suitable for the simulation of human notions of nearness, it provides a useful tool for verifying
consistency of matches. The following arguments are formalized for checking consistency of
sameAs and partOf matches: if spatial objects a1 , b1 are sameAs or partOf spatial objects
a2 , b2 respectively, a1 , b1 are N EAR, a2 , b2 are F AR, then a contradiction exists.
The rest of this paper is structured as follows. Section 2, Section 3 and Section 4 provide
an introduction to the new spatial logics: their syntax and semantics, their relationships
with the logic M S(M ), their axioms and theorems. Section 5 and Section 6 present the
proofs of the soundness, completeness, decidability and complexity theorems for LBPT, as
the proofs for LNF and LNFS are similar and LBPT is more expressive than LNF and
LNFS. Section 7 describes how LBPT is used for debugging matches between objects from
698

fiQualitative Spatial Logics for Buffered Geometries

different geospatial datasets. Section 8 discusses the generality and limitations of the spatial
logics. Section 9 concludes the paper.

2. Syntax and Semantics
The language L(LN F ) is defined as
,  := BEQ(a, b) | N EAR(a, b) | F AR(a, b) |  |   
where a, b are individual names.    def (  ). The language L(LN F S) is
exactly the same as L(LN F ). The language L(LBP T ) is almost the same as L(LN F ) and
L(LN F S), except that it has BP T instead of BEQ as a predicate. L(LBP T ) is defined as
,  := BP T (a, b) | N EAR(a, b) | F AR(a, b) |  |   .
L(LN F ), L(LN F S) and L(LBP T ) are all interpreted over models based on a metric
space. Every individual name involved in an LNF formula is mapped to a point, whilst
each of those involved in an LNFS/LBPT formula is mapped to an arbitrary geometry or
a non-empty set of points.
Definition 1 (Metric Space) A metric space is a pair (, d), where  is a non-empty
set (of points) and d is a metric on , i.e. a function d :     R0 , such that for
any x, y, z  , the following axioms are satisfied:
1. identity of indiscernibles: d(x, y) = 0 iff x = y;
2. symmetry: d(x, y) = d(y, x);
3. triangle inequality: d(x, z)  d(x, y) + d(y, z).
Definition 2 (Metric Model of LNF) A metric model M of LNF is a tuple (, d, I, ),
where (, d) is a metric space, I is an interpretation function which maps each individual
name to an element in , and   R0 is a margin of error. The notion of M |=  ( is
true in the model M ) is defined as follows:
M |= BEQ(a, b) iff d (I (a), I (b))  [0 , ];
M |= N EAR(a, b) iff d (I (a), I (b))  [0 , 2 ];
M |= F AR(a, b) iff d (I (a), I (b))  (4 , );
M |=  iff M 6|= ;
M |=    iff M |=  and M |= ,
where a, b are individual names, ,  are formulas in L(LN F ).
Definition 3 (Metric Model of LNFS/LBPT) A metric model M of LNFS/LBPT is
a tuple (, d, I, ), where (, d) is a metric space, I is an interpretation function which
maps each individual name to a non-empty set of elements in , and   R0 is a margin
of error. The notion of M |=  ( is true in the model M ) is defined as follows:
699

fiDu & Alechina

M |= BP T (a, b) iff pa  I (a) pb  I (b) : d (pa , pb )  [0 , ];
M |= N EAR(a, b) iff pa  I (a) pb  I (b) : d (pa , pb )  [0 , 2 ];
M |= F AR(a, b) iff pa  I (a) pb  I (b) : d (pa , pb )  (4 , );
M |=  iff M 6|= ;
M |=    iff M |=  and M |= ,
where a, b are individual names, ,  are formulas in L(LN F S)/L(LBP T ). BEQ(a, b) is
defined as BP T (a, b)  BP T (b, a).
The notions of validity and satisfiability in metric models are standard. A formula is
satisfiable if it is true in some metric model. A formula  is valid (|= ) if it is true in all
metric models (hence if its negation is not satisfiable). The logic LNF/LNFS/LBPT is the
set of all valid formulas in the language L(LN F )/L(LN F S)/L(LBP T ) respectively.

3. Relationship with the logic M S(M )
The logic M S(M ), as well as its variations, was developed by Sturm et al. (2000), Kutz
et al. (2002, 2003), Wolter and Zakharyaschev (2003, 2005), and Kutz (2007) for reasoning
about distances.
M S(M ) is a family of logics defined relative to the parameter set M  Q0 . M is
subject to the following two conditions: if a, b  M and a + b  r, then a + b  M , where
r = sup M if M is bounded, otherwise r = ; if a, b  M and a  b > 0, then a  b  M .
The alphabet of M S(M ) consists of
 an infinite list of region variables X1 , X2 ,...;
 an infinite list of location constants c1 , c2 ,...;
 a set constant {ci } for every location constant ci ;
.
 binary distance (), equality (=) and membership () predicates;
 the boolean operators u,  (and their derivatives t, > and );
 two distance quantifiers <a , a and their duals <a , a , for every a  M ;
 two universal quantifiers  and .
M S(M ) terms are defined as:
s, t := Xi | {ci } | > |  | s | s u t | <a s | a s | s.
In addition to standard description logic concept constructions, M S(M ) can define a
concept of objects which are at a distance less than a from instances of some other concept
s: <a s, and similarly for a distance at most a. <a s and a s are defined as <a (s)
and a (s) respectively.
700

fiQualitative Spatial Logics for Buffered Geometries

M S(M ) formulas are defined as
.
,  := c  s | s = t | (c1 , c2 ) < a | (c1 , c2 )  a |  |   .
.
.
.
Further, s v t is an abbreviation for (s u t) = s and s =
6 t is an abbreviation for (s = t).
(c1 , c2 ) > a and (c1 , c2 )  a are defined as ((c1 , c2 )  a) and ((c1 , c2 ) < a) respectively.
An M S(M )-model B is a structure of the form:
B
B = hW, d, X1B , X2B , ..., cB
1 , c2 , ...i

where hW, di is a metric space (Definition 1), each XiB is a subset of W , and each cB
i is
an element of W . The value of any other M S(M )-term in B is computed inductively as
follows:
 >B = W , B = ;
 {ci }B = {cB
i };
 (s)B = W  sB ;
B
 (s1 u s2 )B = sB
1  s2 ;

 (<a s)B = {x  W | y  sB : d(x, y) < a};
 (a s)B = {x  W | y  sB : d(x, y)  a};
 (s)B = {x  W | y  sB }.
<a , a and  are dual to <a , a and  respectively. For instance,
(<a s)B = {x  W | y  W : (d(x, y) < a  y  sB )}.
The truth condition of B |= , where  is an M S(M )-formula, is defined as follows:
 B |= c  s iff cB  sB ;
.
B
 B |= s1 = s2 iff sB
1 = s2 ;
 B |= (k, l) < a iff d(k B , lB ) < a;
 B |= (k, l)  a iff d(k B , lB )  a;
 B |=  iff B 6|= ;
 B |=    iff B |=  and B |= .
A set of M S(M ) formulas  is satisfiable, if there exists an M S(M )-model B such that
B |=  for every   . This is denoted as B |= .
It is proved below that LNF/LNFS/LBPT are proper fragments of the logic M S(Q0 ).
Strictly speaking, this only holds when   Q0 , but later we will show that a finite set of
LNF/LNFS/LBPT formulas is satisfiable where   R0 , if it is satisfiable when  = 1. In
other words,  acts as a scaling factor (see the proof of Lemma 43).
701

fiDu & Alechina

Lemma 1 For individual names a, b, the M S(M ) formula {a} v {b} is not expressible
in LNF.
Proof. Let M1 , M2 be metric models2 . M1 = (1 , d, I1 , ), M2 = (2 , d, I2 , ).
In M1 , 1 = {o1 , o2 }, d(o1 , o2 ) = . I1 (a) = o1 , I1 (b) = o2 . For any individual name x
differing from a, b, I1 (x) = o1 .
In M2 , 2 = {o}. I2 (a) = o, I2 (b) = o. For any individual name x differing from a, b,
I2 (x) = o. For any individual name y, Ii ({y}) = {Ii (y)}, i  {1, 2}.
By the definitions of M1 , M2 , for any individual names x, y, d(I1 (x), I1 (y))  [0, ],
d(I2 (x), I2 (y)) = 0. If  is an atomic LNF formula about x, y, then by Definition 2, M1 |= 
iff M2 |= . By an easy induction on logical connectives, for any LNF formula , M1 |= 
iff M2 |= .
Since I1 ({a}) = {o1 }, I1 ({b}) = {o2 } and I2 ({a}) = I2 ({b}) = {o}, by the truth definition of M S(M ) formulas, M1 |= ({a} v {b}), M2 6|= ({a} v {b}). Hence, {a} v {b} is
not equivalent to any LNF formula. 
Lemma 2 The logic LNF is a proper fragment of the logic M S(Q0 ).
Proof. Every atomic LNF formula is expressible in M S(Q0 ):
 BEQ(a, b)  ((a, b)  0)  ((a, b)  );
 N EAR(a, b)  ((a, b)  0)  ((a, b)  2);
 F AR(a, b)  ((a, b) > 4).
This means that all LNF formulas can be expressed in a fragment of M S(Q0 ) (the image
of LNF under the translation above) which only contains location constants, binary distance predicate and boolean connectives , . By Lemma 1, LNF is a proper fragment of
M S(M ). 
Lemma 3 For individual names a, b, the M S(M ) formula a v b is not expressible in
LNFS/LBPT.
Proof. Let M1 , M2 be metric models3 . M1 = (1 , d, I1 , ), M2 = (2 , d, I2 , ).
In M1 , 1 = {o1 , o2 }, d(o1 , o2 ) = . I1 (a) = {o1 }, I1 (b) = {o2 }. For any individual
name x differing from a, b, I1 (x) = {o1 }.
In M2 , 2 = {o}. I2 (a) = {o}, I2 (b) = {o}. For any individual name x differing from
a, b, I2 (x) = {o}.
If  is an atomic LNFS/LBPT formula about x, y, then by Definition 3, M1 |=  iff
M2 |= . By an easy induction on logical connectives, for any LNFS/LBPT formula ,
M1 |=  iff M2 |= .
2. Note that we can construct models in a one-dimensional or two-dimensional Euclidean space in a similar
way and prove the lemma.
3. Note that we can construct models in a one-dimensional or two-dimensional Euclidean space in a similar
way and prove the lemma.

702

fiQualitative Spatial Logics for Buffered Geometries

By the truth definition of M S(M ) formulas, M1 |= (a v b) and M2 6|= (a v b).
Hence, a v b is not equivalent to any LNFS/LBPT formula. 
Lemma 4 The logic LNFS/LBPT is a proper fragment of M S(Q0 ).
Proof. Every atomic LNFS/LBPT formula is expressible in M S(Q0 ):
 (For LNFS) BEQ(a, b) iff (a v ( b))  (b v ( a));
 (For LBPT) BP T (a, b) iff (a v ( b));
.
 N EAR(a, b) iff (a u (2 b) =
6 );
.
 F AR(a, b) iff (a u (4 b) = ).
Note that the formulas on the right belong to a fragment of M S(Q0 ) which is the image
of LNFS/LBPT under the translation above.
The correctness of translation of BEQ(a, b) and BP T (a, b) into M S(Q0 ) follows directly from the truth definition of BEQ and BP T (Definition 3). To show that the translation of N EAR and F AR are correct, consider that the truth definition of N EAR(a, b)
is equivalent to 0  dmin (a, b)  2 and F AR(a, b) to dmin (a, b) > 4, where dmin (a, b) =
inf{d(pa , pb ) | pa  I(a), pb  I(b)}. It was shown by Wolter and Zakharyaschev (2005) that
.
dmin (a, b)  m iff a u (m b) =
6 . This makes the translation of the formulas have the
same truth conditions as defined in Definition 3. By Lemma 3, LNFS/LBPT is a proper
fragment of M S(Q0 ). 
Wolter and Zakharyaschev (2003) proved that the satisfiability problem for a finite set
of M S(Q0 ) formulas in a metric space is EXPTIME-complete, which provides an upper
bound on the complexity of the satisfiability problems of LNF, LNFS and LBPT in a metric
space.
Kutz et al. (2002) and Kutz (2007) gave axioms or inference rules connecting M S(M )
terms (e.g. 0 s  s) for M S(M ) and its variants. However, the axiomatisation we are
going to present is for LNF, LNFS and LBPT formulas (corresponding to M S(M ) formulas
rather than M S(M ) terms).

4. Axioms and Theorems
This section presents a sound and complete axiomatisation for the logic LNF/LNFS/LBPT
respectively. The axiomatic systems have been used as a basis for a rule-based reasoner
described later in Section 7 4 .
The following calculus (which we will also refer to as LNF) is sound and complete for
LNF:
Axiom 0 All tautologies of classical propositional logic
4. It is important to have a complete axiomatisation. Otherwise, the reasoner can not detect all the
LNF/LNFS/LBPT inconsistencies caused by problematic matches.

703

fiDu & Alechina

Axiom 1 BEQ(a, a);
Axiom 2 BEQ(a, b)  BEQ(b, a);
Axiom 3 N EAR(a, b)  N EAR(b, a);
Axiom 4 F AR(a, b)  F AR(b, a);
Axiom 5 BEQ(a, b)  BEQ(b, c)  N EAR(c, a);
Axiom 6 BEQ(a, b)  N EAR(b, c)  BEQ(c, d)  F AR(d, a);
Axiom 7 N EAR(a, b)  N EAR(b, c)  F AR(c, a);
MP Modus ponens: ,    ` .
The following calculus (which we will also refer to as LNFS) is sound and complete for
LNFS:
Axiom 0 All tautologies of classical propositional logic
Axiom 1 BEQ(a, a);
Axiom 2 BEQ(a, b)  BEQ(b, a);
Axiom 3 N EAR(a, b)  N EAR(b, a);
Axiom 4 F AR(a, b)  F AR(b, a);
Axiom 5 BEQ(a, b)  BEQ(b, c)  N EAR(c, a);
Axiom 6 BEQ(a, b)  N EAR(b, c)  BEQ(c, d)  F AR(d, a);
Axiom 8 N EAR(a, b)  BEQ(b, c)  BEQ(c, d)  F AR(d, a);
MP Modus ponens: ,    ` .
Axiom 7 of the calculus LNF only holds for points, but not for arbitrary geometries,
because two points within the same line or polygon can be far from each other. Axiom 7 is
replaced by Axiom 8 in LNFS. All other axioms in LNFS are the same as those in LNF.
The following calculus (which we will also refer to as LBPT) is sound and complete for
LBPT:
Axiom 0 All tautologies of classical propositional logic
Axiom 3 NEAR(a, b)  NEAR(b, a);
Axiom 4 FAR(a, b)  FAR(b, a);
Axiom 9 BPT (a, a);
Axiom 10 BPT (a, b)  BPT (b, c)  NEAR(c, a);
704

fiQualitative Spatial Logics for Buffered Geometries

Axiom 11 BPT (b, a)  BPT (b, c)  NEAR(c, a);
Axiom 12 BPT (b, a)  NEAR(b, c)  BPT (c, d )  FAR(d , a);
Axiom 13 NEAR(a, b)  BPT (b, c)  BPT (c, d )  FAR(d , a);
MP Modus ponens: ,    ` .
The calculus LBPT is similar to the calculus LNFS. Changing predicates from BEQ to
BP T , LNFS Axioms 1, 6, 8 are replaced by Axioms 9, 12, 13 respectively in LBPT. Since
BP T is not symmetric, LNFS Axiom 2 does not have a corresponding axiom in LBPT, and
LNFS Axiom 5 is replaced by two LBPT axioms, Axiom 10 and Axiom 11.
The notion of derivability  `  in LNF/LNFS/LBPT calculus is standard. A formula
 is derivable if ` . A set  is LNF/LNFS/LBPT-inconsistent if for some formula  it
derives both  and .
We proved the following theorems for LNF, LNFS and LBPT.
Theorem 1 (Soundness and Completeness) The LNF/LNFS/LBPT calculus is sound
and complete for metric models, namely that
`   |= 
(every derivable formula is valid and every valid formula is derivable).
Theorem 2 (Decidability and Complexity) The satisfiability problem for a finite set
of LNF/LNFS/LBPT formulas in a metric space is NP-complete.
In the following sections, we give proofs of the results above for the case of LBPT. The
proofs for LNF and LNFS are similar. For LBPT, we have the following derivable formulas,
which we will refer to as facts in the completeness proof:
Fact 14 BP T (a, b)  N EAR(a, b);
Fact 15 N EAR(a, b)  F AR(a, b);
Fact 16 N EAR(a, b)  BP T (b, c)  F AR(c, a);
Fact 17 BP T (a, b)  F AR(a, b);
Fact 18 BP T (a, b)  BP T (b, c)  F AR(c, a);
Fact 19 BP T (b, a)  BP T (b, c)  F AR(c, a);
Fact 20 BP T (a, b)  BP T (b, c)  BP T (c, d)  F AR(d, a);
Fact 21 BP T (b, a)  BP T (b, c)  BP T (c, d)  F AR(d, a);
Fact 22 BP T (a, b)  BP T (b, c)  BP T (c, d)  BP T (d, e)  F AR(e, a);
Fact 23 BP T (b, a)  BP T (b, c)  BP T (c, d)  BP T (d, e)  F AR(e, a);
Fact 24 BP T (b, a)  BP T (c, b)  BP T (c, d)  BP T (d, e)  F AR(e, a).
As shown by Facts 17-24, a chain of at most four BP T s implies the negation of F AR,
because F AR is defined as being > 4 distance away in Definition 3.
705

fiDu & Alechina

5. Soundness and Completeness of LBPT
This section shows that the LBPT calculus is sound and complete for metric models.
Though several definitions and lemmas have been presented in our previous work (Du et al.,
2013; Du & Alechina, 2014b), the proofs presented here are more complete, structured, accurate (small errors are corrected) and simplified.
The proof of soundness (every LBPT derivable formula is valid: `   |= ) is by an
easy induction on the length of the derivation of . Axioms 3, 4, 9-13 are valid (by the
truth definition of BP T , N EAR and F AR) and modus ponens preserves validity.
In the rest of this section, we prove completeness (every LBPT valid formula is derivable):
|=   ` 
We will actually prove that if a finite set of LBPT formulas  is consistent, then there
is a metric model satisfying it. Any finite set of formulas  can be rewritten as a formula
 which is the conjunction of all formulas in .  is consistent, iff  is consistent (6` ).
If there is a metric model M satisfying , then M satisfies , thus 6|= . Therefore, if
we show that if  is consistent, then there exists a metric model satisfying it, then we
show that if 6` , then 6|= . This shows that 6`  6|=  and by contraposition we get
completeness.
The completeness theorem is proved by constructing a metric model for a maximal
consistent set (Definition 4) of any finite consistent set of LBPT formulas (Lemma 5).
Definition 4 (MCS) A set of formulas  in the language L(LBP T ) is maximal consistent, if  is consistent, and any set of LBPT formulas over the same set of individual names
properly containing  is inconsistent. If  is a maximal consistent set of formulas, then we
call it an M CS.
Proposition 1 (Properties of MCSs) If  is an M CS, then,
  is closed under modus ponens: if ,     , then   ;
 if  is derivable, then   ;
 for all formulas :    or   ;
 for all formulas , :      iff    and   ;
 for all formulas , :      iff    or   .
Lemma 5 (Lindenbaums Lemma) If  is a consistent set of formulas in the language
L(LBP T ), then there is an M CS + over the same set of individual names such that
  + .
Let 0 , 1 , 2 , ... be an enumeration of LBPT formulas over the same set of individual names
as that in . + can be defined as follows:
 0 = ;
 n+1 = n  {n }, if it is consistent, otherwise, n+1 = n  {n };
706

fiQualitative Spatial Logics for Buffered Geometries

 + =

S

n0 n .

For a finite consistent set of formulas , we construct a metric model satisfying a
maximal consistent set + , which contains  and is over the same set of individual names
as , as follows. Firstly, we equivalently transform + to B(+ ), which is a set of basic
quantified formulas. Then we construct a set of distance constraints D(+ ) from B(+ ).
A key concept here is path-consistency for a set of distance constraints.
Definition 5 (Non-negative Interval) An interval h is non-negative, if h  [0, +).
Definition 6 (Distance Constraint, Distance Range) A distance constraint is a statement of the form d(p, q)  g, where p, q are constants representing points, d(p, q) stands for
the distance between p, q, and g is a non-negative interval, which stands for the distance
range for p, q.
Definition 7 (Composition) If d1 , d2 are non-negative real numbers, then the composition of {d1 } and {d2 } is defined as: {d1 }  {d2 } = [|d1  d2 |, d1 + d2 ] 5 . If g1 , g2 are nonnegative intervals, then their composition is an interval which is the union of all {d1 }{d2 },
where d1  g1 , d2  g2 , this is,
S
g1  g2 = d1 g1 ,d2 g2 {d1 }  {d2 }.
It is assumed that a set of distance constraints D contains at most one distance range for
each pair of constants p, q involved in D, and D is closed under symmetry, i.e. if d(p, q)  g
is in D, then d(q, p)  g is in D.
Definition 8 (Path-Consistency) For a set of distance constraints D, for every pair of
different constants p, q involved in D, their distance range is strengthened by successively
applying the following operation until a fixed point is reached:
s : g(p, q)  g(p, q)  (g(p, s)  g(s, q))
where s is a constant in D, s 6= p, s 6= q, and g(p, q) denotes the distance range for p, q.
This process is called enforcing path-consistency on D. If at a fixed point, for every pair of
constants p, q, g(p, q) 6= , then D is called path-consistent.
In this paper, we say an interval is referred to in the process of enforcing path-consistency
on D, if it occurs in D or is involved in the enforcement of the operation g(p, q)  g(p, q) 
(g(p, s)g(s, q)). In other words, it is used as g(p, q), g(p, s) or g(s, q). A distance constraint
appears in the process of enforcing path-consistency on D, if its distance range (an interval)
is referred to in the process of enforcing path-consistency on D.
The way of enforcing path-consistency on a set of distance constraints defined above is
almost the same as that of enforcing path-consistency on a binary constraint satisfaction
problem (CSP) (Renz & Nebel, 2007; van Beek, 1992), except that the operation s :
g(p, q)  g(p, q)  (g(p, s)  g(s, q)) ( is the composition operator for non-negative intervals,
Definition 7) is applied instead of k : Rij  Rij (Rik Rkj ) ( is the composition operator
5. Based on d(x, z)  d(x, y) + d(y, z) (Property 3 of Definition 1).

707

fiDu & Alechina

for relations). The time complexity of the path-consistency algorithm for CSP is O(n3 ) (van
Beek, 1992; Mackworth & Freuder, 1985), where n is the number of variables involved in
the input set of binary constraints. The path-consistency algorithm for CSP can be adapted
easily for enforcing path-consistency on a set of distance constraints. The time complexity of
the resulting path-consistency algorithm is also O(n3 ), where n is the number of constants
involved in the input set of distance constraints. Later in this paper, we will show that
the process of enforcing path-consistency on D(+ ) terminates, and a fixed point can be
reached in O(n3 ) (see Lemma 33).
After constructing a set of distance constraints D(+ ) from + , we prove the Metric
Model Lemma, Metric Space Lemma and Path-Consistency Lemma which are stated below.
The notion of path-consistency acts as a bridge between the lemmas.
Lemma 6 (Metric Model Lemma) Let  be a finite consistent set of formulas, and +
be an M CS which contains  and is over the same set of individual names as . If a
metric space satisfies D(+ ), then it can be extended to a metric model satisfying + .
Lemma 7 (Metric Space Lemma) Let  be a finite consistent set of formulas, and +
be an M CS which contains  and is over the same set of individual names as . If D(+ )
is path-consistent, then there is a metric space (, d) such that all distance constraints in
D(+ ) are satisfied.
Lemma 8 (Path-Consistency Lemma) Let  be a finite consistent set of formulas, and
+ be an M CS which contains  and is over the same set of individual names as . Then,
D(+ ) is path-consistent.
Using these three lemmas, we prove the completeness of LBPT: if a finite set of formulas
 is LBPT-consistent, then there exists a metric model satisfying it.
Proof. If  is LBPT-consistent, by the Lindenbaums Lemma (Lemma 5), there is an M CS
+ over the same set of individual names such that   + . By the Path-Consistency
Lemma (Lemma 8) and the Metric Space Lemma (Lemma 7), there is a metric space (, d)
such that all distance constraints in D(+ ) are satisfied. By the Metric Model Lemma
(Lemma 6), the metric space can be extended to a metric model M satisfying + . Since
  + , M satisfies . 
The detailed proofs of the Metric Model Lemma, Metric Space Lemma and PathConsistency Lemma are provided in Section 5.1, Section 5.2 and Section 5.3 respectively.
Note that, in this paper, + denotes an M CS which contains a given finite consistent set
of formulas  and is over the same set of individual names as .
5.1 Metric Model Lemma
This section shows how to construct a set of distance constraints D(+ ) from + , and
presents the proof of the Metric Model Lemma.
By the definition and properties of MCSs (Definition 4 and Proposition 1), the following
lemma holds.
708

fiQualitative Spatial Logics for Buffered Geometries

Lemma 9 If + is an M CS, then for any pair of individual names a, b occurring in ,
exactly one of the following cases holds in + :
1. case(a, b) = BP T (a, b)  BP T (b, a);
2. case(a, b) = BP T (a, b)  BP T (b, a);
3. case(a, b) = BP T (a, b)  BP T (b, a);
4. case(a, b) = BP T (a, b)  BP T (b, a)  N EAR(a, b);
5. case(a, b) = N EAR(a, b)  F AR(a, b);
6. case(a, b) = F AR(a, b),
where case(a, b) denotes the formula which holds between a, b in each case.
Lemma 9 is proved using LBPT axioms and facts (such as Axiom 3, Facts 14, 15) in the
same way as proving the lemma for LNF (see Du et al., 2013). The full proof of Lemma 9
is provided in Appendix A.
The construction of a set of distance constraints D(+ ) from + has two main steps:
Step 1 For every pair of individual names a, b occurring in , we translate case(a, b) into
a set of first order formulas which is equi-satisfiable to case(a, b). The union of all
such sets of first order formulas is B(+ ) (hence, B(+ ) and  are equi-satisfiable.).
This step is described by Definition 9 and Definition 10.
Step 2 We construct a set of distance constraints D(+ ) from B(+ ). This step is described by Definitions 11-13.
For LBPT formulas, there are first order formulas corresponding to their truth definition
in Definition 3. We use formulas of the form d(p, q)  g as abbreviations of their equivalent
first order formulas. For example, d(p, q)  [0, ] abbreviates d(p, q)  0  d(p, q)  .
Observe that6
 BP T (a, b) and pa  a pb  b : d (pa , pb )  [0 , ] are equi-satisfiable ;
 N EAR(a, b) and pa  a pb  b : d (pa , pb )  [0 , 2 ] are equi-satisfiable;
 F AR(a, b) and pa  a pb  b : d (pa , pb )  (4 , ) are equi-satisfiable.
Definition 9 (Basic Quantified Formula) We refer to the first order formulas of the
following forms as basic quantified formulas:
 pa  a pb  b : d (pa , pb )  g;
 pa  a pb  b : d (pa , pb )  g;
6. Note that by pa  a pb  b : d (pa , pb )  [0 , ], we are actually quantifying over a metric space. In
such sense, it is more precise to say, for example, BP T (a, b) is satisfiable in a metric model, iff
pa  a pb  b : d (pa , pb )  [0 , ] is satisfiable over a metric space.

709

fiDu & Alechina

 pa  a pb  b : d (pa , pb )  g;
 pa  a pb  b : d (pa , pb )  g,
where g is a non-negative interval. The abbreviations of these four forms are defined
as (a, b, g), (a, b, g), (a, b, g) and (a, b, g) respectively. In other words, for example,
(a, b, g)  (pa  a pb  b : d (pa , pb )  g).
Now we translate the formula in each case listed in Lemma 9 into basic quantified
formulas, which will be used to count the number of points needed for interpreting individual
names occurring in  later.
Definition 10 (B(+ )) For an M CS + over the same set of individual names as , its
corresponding set of basic quantified formulas B(+ ) is constructed as follows. For every
pair of individual names a, b, we translate case(a, b) into basic quantified formulas:
 translate(BP T (a, b)  BP T (b, a)) = {(a, b, [0, ]), (b, a, [0, ])};
 translate(BP T (a, b)  BP T (b, a)) = {(a, b, [0, ]), (b, a, (, ))};
 translate(BP T (a, b)  BP T (b, a)) = {(a, b, (, )), (b, a, [0, ])};
 translate(BP T (a, b)  BP T (b, a)  N EAR(a, b)) = {(a, b, (, )),
(b, a, (, )), (a, b, [0, 2]), (b, a, [0, 2])};
 translate(N EAR(a, b)  F AR(a, b)) = {(a, b, (2, )), (b, a, (2, )),
(a, b, [0, 4]), (b, a, [0, 4])};
 translate(F AR(a, b)) = {(a, b, (4, )), (b, a, (4, ))},
where   R0 is a fixed margin of error. Let names() be the set of individual names
occurring in . Then,
S
B(+ ) = anames(),bnames() translate(case(a, b)).
In the following, for a set of basic quantified formulas B(+ ), we construct a set of
distance constraints D(+ ), and then show that if there is a metric space satisfying D(+ ),
then it can be extended to a model of + . In other words, we are constructing a metric
over a set of points used to interpret individual names.
The number of points needed for interpreting each individual name depends on the
numbers of different forms of formulas in B(+ ). For any individual name a, let us predict
how many particular constants in points(a) (points assigned to an individual name a) can
be specified by the finite set of formulas about a in B(+ ). points(a) contains at least
one constant. If a formula in B(+ ) says there exists a constant in points(a), then this
constant is a particular constant within points(a). For any pair of different individual names
a, b, if both (a, b, g) and (b, a, g) are in B(+ ), we only count one of them; if (a, b, g)
is in B(+ ), we map all the constants in points(a) to the same constant in points(b). By
Lemma 9 and Definition 10, in B(+ ), for any pair of different individual names a, b and
R  {, , } we never have R(a, b, g1 ) and R(a, b, g2 ), where g1 6= g2 , at the same time.
The cardinality of points(a) is specified as follows.
710

fiQualitative Spatial Logics for Buffered Geometries

Definition 11 (num(a, B(+ )) and points(a)) Let names() be the set of individual names
occurring in  7 . For any individual name a  names(),
num(a, B ( + )) = |{b  names( ) | g : (a, b, g)  B ( + )}|
num(a, B ( + )) = |{b  names( ) | g : (a, b, g)  B ( + )}|
num(a, B ( + )) = |{b  names( ) | g : (b, a, g)  B ( + )}|
Then num(a, B ( + )) = num(a, B ( + )) + num(a, B ( + )) + num(a, B ( + )).
points(a) is a set of constants {p1a , . . . , pna }, where n = num(a, B(+ )).
Definition 12 (Witness for a formula) A witness for a formula (a, b, g) is a pair of
constants pa  points(a), pb  points(b) such that d(pa , pb )  g. A witness for a formula
(a, b, g) or (b, a, g) is a constant pa  points(a), such that for any constant pb  points(b),
d(pa , pb )  g. A constant is clean for a formula, if it is not a witness for any other formula.
Definition 13 (D(+ )) Let B(+ ) be the corresponding set of basic quantified formulas
of an M CS + . For every individual name a in , we assign a fixed set of new constants points(a) to it. We construct a set of distance constraints D(+ ) as follows, by
iterating through the basic quantified formulas in B(+ ) and eliminating quantifiers on new
constants. Initially, D(+ ) = {}. For every individual name a in , for every constant
pa  points(a), we add d(pa , pa )  {0} to D(+ ). For every pair of different individual
names a, b, if
 (a, b, g)  B ( + ), then we take clean constants pa  points(a), pb  points(b), and
add d (pa , pb ) = d (pb , pa )  g to D(+ ), so pa , pb become a witness for (a, b, g);
 (a, b, g)  B ( + ), then we take a clean constant pa  points(a), for every pb  points(b),
we add d (pa , pb ) = d (pb , pa )  g to D(+ ), so pa becomes a witness for (a, b, g);
 (b, a, g)  B ( + ), then we take a clean constant pb  points(b), for every pa  points(a),
we add d (pa , pb ) = d (pb , pa )  g to D(+ ), so pb becomes a witness for (b, a, g);
 (a, b, g)  B ( + ), then we take a clean constant pb  points(b), for every pa  points(a),
we add d (pa , pb ) = d (pb , pa )  g to D(+ ), so pb becomes a witness for (a, b, g);
 (b, a, g)  B ( + ), then we take a clean constant pa  points(a), for every pb  points(b),
we add d (pa , pb ) = d (pb , pa )  g to D(+ ), so pa becomes a witness for (b, a, g);
 (a, b, g)  B ( + ), then for every pair of constants pa  points(a), pb  points(b),
we add d (pa , pb ) = d (pb , pa )  g to D(+ ).
For every pair of different constants p, q in D(+ ), we add d (p, q) = d (q, p)  [0 , )
to D(+ ), then repeatedly replace d (p, q) = d (q, p)  g1 and d (p, q) = d (q, p)  g2 with
d (p, q) = d (q, p)  (g1  g2 ), until there is only one distance range for each pair of p, q in
D(+ ).
7. By the definition of + , + contains the same set of individual names as .

711

fiDu & Alechina

In Definition 13, for every pair of different individual names a, b, we check whether
(a, b, g)  B ( + ) holds and check whether (b, a, g)  B ( + ) holds, because it is possible only one of them holds. For the same reason, we check (a, b, g)  B ( + ) and
(b, a, g)  B ( + ) separately. By Definition 10, (a, b, g)  B ( + ) iff (b, a, g)  B ( + ).
Hence we only need to check any one of them. We only check whether (a, b, g)  B ( + )
holds, as (a, b, g)  B ( + ) iff (b, a, g)  B ( + ).
Lemma 10 When constructing D(+ ), for any individual name a, the number of clean
constants needed from points(a) is no larger than num(a, B(+ )).
Proof. By Definition 10, for any individual name a, (a, a, [0, ]) is in B(+ ). By Definition 11, num(a, B(+ ))  1.
If a is not involved in any formula of the form (a, b, g), (a, b, g) or (b, a, g), for any
other individual name b, then by Definition 11, num(a, B(+ )) = 1. By Definition 13, we
need no clean constants from points(a).
Otherwise, by Lemma 9 and Definition 10, in B(+ ), for any pair of different individual
names a, b and R  {, , }, we never have R(a, b, g1 ) and R(a, b, g2 ), where g1 6= g2 , at the
same time. By Definition 13, for each (a, b, g)  B(+ ), we take one clean constant from
points(a), so num(a, B(+ )) clean constants are needed in total for all formulas of this
form. Similarly, num(a, B(+ )) and (num(a, B(+ ))  1) clean constants are needed
for formulas of forms (a, b, g) and (b, a, g) respectively, where a, b are different individual
names. We do not need any other clean constant from points(a) for formulas in other forms.
By Definition 11, num(a, B(+ )) is enough. 
D(+ ) and B(+ ) are not equi-satisfiable because of the way we assign witnesses for 
formulas. More specifically, for any pair of different individual names a, b, if (a, b, g) is in
B(+ ), we map all the constants in points(a) to the same constant in points(b). In other
words, if B 0 (+ ) is the set of formulas resulting from replacing every (a, b, g) in B(+ )
with (b, a, g), then D(+ ) and B 0 (+ ) are equi-satisfiable. Since every individual name is
interpreted as a non-empty set of constants, if a model satisfies (b, a, g), then it satisfies
(a, b, g), but not vice versa. Hence, constructing D(+ ) for B 0 (+ ) rather than B(+ )
imposes stronger restrictions (i.e. (a, b, g) in B(+ ) is replaced with (b, a, g) in B 0 (+ ))
on the metric space compared to that required by + . However, later we will show that
if + is consistent, then D(+ ) can be satisfied in a metric space by proving the Metric
Space Lemma and Path-Consistency Lemma in the following sections.
Before proving the Metric Model Lemma, let us look at some important properties of
D(+ ), as shown by Lemmas 11-13. The proof of Lemma 11 is provided in Appendix A.
Lemma 12 follows from the proof of Lemma 11.
Lemma 11 For any distance range g occurring in D(+ ),
g  {{0}, [0, ], (, ), [0, 2], (2, ), (2, 4], (4, ), [0, )}.
Lemma 12 If p  points(a), q  points(b), and a 6= b, then d(p, q)  {0} is not in D(+ ).
Lemma 13 The number of constants in D(+ ) is finite.
712

fiQualitative Spatial Logics for Buffered Geometries

Proof. It is assumed that  is a finite consistent set of formulas over n (a finite number) individual names. By Lemma 9 and Definition 10, B(+ ) contains at most f =
(n + 2n(n  1)) formulas over n individual names. By Definition 11, for any individual
name a, num(a, B(+ ))  f . By Definition 13, the number of constants in D(+ ) is at
most nf . 
The Metric Model Lemma is proved as follows.
Lemma 14 If a metric model satisfies B(+ ), then it satisfies + .
Proof. The lemma follows from two observations. First, by Lemma 9, + is entailed by
the set C(+ ) = {case(a, b) : a  names(+ ), b  names(+ )}. Second, by Definition 10,
B(+ ) is a translation of truth conditions of C(+ ) into first order logic. If a metric model
satisfies B(+ ), then it satisfies C(+ ), and hence it satisfies + . 
Lemma 6 (Metric Model Lemma) Let  be a finite consistent set of formulas, and
+ be an M CS which contains  and is over the same set of individual names as . If a
metric space satisfies D(+ ), then it can be extended to a metric model satisfying + .
Proof. Suppose a metric space satisfies D(+ ). We extend it to a metric model M by
interpreting every individual name a occurring in + as points(a), as corresponding set
of constants of size num(a, B(+ )) (Definition 11 and Definition 13). By Definition 13,
any formula of the form (a, a, [0, ]) is satisfied by M . For any pair of different individual names, every ,  or  formula has a witness, and all  formulas are also satisfied by
M . Therefore, M is a metric model of B(+ ). By Lemma 14, M is a metric model of + . 

5.2 Metric Space Lemma
As the process of enforcing path-consistency (Definition 8) involves the application of the
composition operator  (Definition 7), we present several lemmas in Section 5.2.1 to demonstrate the main calculation rules of  and the properties of intervals obtained from composition. In Section 5.2.2, we characterize distance constraints in D(+ ) and those appearing
in the process of enforcing path-consistency on D(+ ). Using the definitions and lemmas introduced in Section 5.2.1 and Section 5.2.2, the Metric Space Lemma is proved in
Section 5.2.3.
5.2.1 The Composition Operator
In this section, we present several lemmas to show the main calculation rules of the composition operator  and the properties of intervals obtained from composition. These lemmas
are important for understanding several proofs in later sections.
Lemmas 15-16 follow from Definition 7.
Lemma 15 Let g1 , g2 be non-negative intervals. If d3  g1  g2 , then there exist d1  g1 ,
d2  g2 such that d3  [|d1  d2 |, d1 + d2 ].
713

fiDu & Alechina

Lemma 16 (Calculation of Composition) If (m, n), (s, t), (m, ), (s, ), {l}, {r} are
non-negative non-empty intervals, H1 , H2 , H are non-negative intervals, then the following
calculation rules hold:
1. {l}  {r} = [l  r, l + r], if l  r;
2. {l}  (s, t) = (s  l, t + l), if s  l;
3. {l}  (s, t) = [0, t + l), if l  (s, t);
4. {l}  (s, t) = (l  t, t + l), if t  l;
5. {l}  (s, +) = (s  l, +), if s  l;
6. {l}  (s, +) = [0, +), if s < l;
7. (m, n)  (s, t) = (s  n, t + n), if s  n;
8. (m, n)  (s, t) = [0, t + n), if (m, n)  (s, t) 6= ;
9. (m, n)  (s, +) = (s  n, +), if s  n;
10. (m, n)  (s, +) = [0, +), if s < n;
11. (m, +)  (s, +) = [0, +);
12. H1   = ;
13. H1  H2 = H2  H1 ;
14. (H1  H2 )  H = (H1  H)  (H2  H);
S
S
15. ( k Hk )  H = k (Hk  H), where k  N>0 ;
16. (H1  H2 )  H = (H1  H)  (H2  H), if (H1  H2 ) 6= ;
17. (H1  H2 )  H = H1  (H2  H).
In Lemma 16, Rule 14 is a special case of Rule 15, where k = 2. Rule 16 states that
the composition operation is distributive over non-empty intersections of intervals. It is
necessary to require H1  H2 6= , otherwise the property may not hold. For example, if
H1 = [0, 1], H2 = [2, 3], H = [1, 2], then (H1  H2 )  H =  whilst (H1  H)  (H2  H) =
[0, 3]  [0, 5] 6= . A similar property is defined by Li, Long, Liu, Duckham, and Both
(2015) for RCC relations. The proofs for the last three calculation rules are provided in
Appendix A, whilst others are more obvious.
For an interval h of the form (l, u), [l, u), (l, u] or [l, u], we call l the greatest lower
bound of h, represented as glb(h), and u the least upper bound of h, represented as lub(h).
Below we show some interesting properties regarding the composition of intervals and their
greatest lower/least upper bounds.
Lemma 17 For any non-negative non-empty intervals g, h, the following properties hold:
714

fiQualitative Spatial Logics for Buffered Geometries

1. lub(g  h) = lub(g) + lub(h);
2. glb(g  h)  max(glb(g), glb(h)).
Proof. Follows from Lemma 16. 
A non-empty interval h is right-closed, iff h = [x, y] or h = (x, y]. h is right-open, iff
h = [x, y) or h = (x, y). h is right-infinite, iff h = [x, ) or h = (x, ). h is left-closed, iff
h = [x, y] or h = [x, y). h is left-open, iff h = (x, y] or h = (x, y).
Lemma 18 Let g1 , g2 , g3 be non-negative non-empty right-closed intervals, if g1  g2  g3 ,
then lub(g1 )  lub(g2 ) + lub(g3 ).
Proof. Suppose g1  g2  g3 . Since lub(g1 )  g1 , lub(g1 )  g2  g3 . By Lemma 15, there
exist d2  g2 , d3  g3 , such that lub(g1 )  d2 + d3 . Since d2  lub(g2 ), d3  lub(g3 ),
lub(g1 )  lub(g2 ) + lub(g3 ). 
Lemma 19 Let g1 , g2 , g3 be non-negative non-empty intervals, g1  g2  g3 . If g1 is rightinfinite, then g2 or g3 is right-infinite.
Proof. Suppose g1 is right-infinite. Since g1  g2  g3 , g2  g3 is right-infinite. By Definition 7 and Lemma 16, g2 or g3 is right-infinite. 
5.2.2 Distance Constraints in D(+ ) and DS(+ )
In this section, we characterize the distance constraints which appear in the process of
enforcing path-consistency on D(+ ) in two main steps:
Step 1 We characterize the intervals involved in D(+ ), as well as the composition of those
intervals. This step is described by Definition 14 and Lemmas 20-24.
Step 2 We introduce the notion of DS(+ ) as a set containing all distance constraints
appearing in the process of enforcing path-consistency on D(+ ), and characterize
the distance constraints in DS(+ ). This step is described by Definitions 15-17 and
Lemmas 25-31.
Definition 14 (Primitive, Composite, Definable Intervals) Let h be a non-negative
interval. h is primitive, if h is one of [0, ], (, ), [0, 2], (2, ), (2, 4], (4, ),
[0, ). h is composite, if it can be obtained as the composition of at least two primitive
intervals. h is definable, if it is primitive or composite.
Lemma 20 For any non-negative interval h, h  {0} = h.
Proof. Follows from Definition 7. 
Since Lemma 20 holds, we call {0} an identity interval.
715

fiDu & Alechina

Lemma 21 If an interval occurs in D(+ ), then it is an identity interval or a primitive
interval.
Proof. Follows from Definition 14 and Lemma 11. 
Lemma 22 If h is a definable interval, then h 6= .
Proof. Follows from Definition 14 and Definition 7. 
Lemma 23 If an interval h is definable, then the following properties hold:
1. glb(h) = n, n  {0, 1, 2, 3, 4};
2. lub(h) = + or lub(h) = m, m  N>0 .
Proof. Let us prove by induction on the structure of h.
Base case: h is primitive. By Definition 14, n  {0, 1, 2, 4}, lub(h) = + or m  {1, 2, 4}.
Inductive step: Suppose Properties 1, 2 hold for any interval ht which can be obtained as
the composition of t primitive intervals, where t  N>0 (induction hypothesis). We will
show Properties 1, 2 hold for any interval ht+1 which can be obtained as the composition of
(t + 1) primitive intervals.
For any ht+1 , there exist an ht and a primitive interval hp such that ht+1 = ht  hp . By
induction hypothesis, glb(ht ) = nt , nt  {0, 1, 2, 3, 4}; lub(ht ) = + or lub(ht ) = mt ,
mt  N>0 . From the base case, glb(hp ) = np , np  {0, 1, 2, 4}; lub(hp ) = + or lub(hp ) =
mp , mp  {1, 2, 4}. By Lemma 17, lub(ht+1 ) = lub(ht ) + lub(hp ). Thus, Property 2 holds.
By Lemma 16, if
 lub(ht ) < glb(hp ), then glb(ht+1 ) = glb(hp )  lub(ht );
 lub(hp ) < glb(ht ), then glb(ht+1 ) = glb(ht )  lub(hp );
 otherwise, glb(ht+1 ) = 0.
Since mt > 0 and mp > 0, for glb(ht+1 ) = nt+1 , nt+1 < 4. In each case, nt+1  {0, 1, 2, 3}
(Property 1 holds). 
Lemma 24 If h is an identity or definable interval, then:
1. lub(h) = 0, iff h = {0};
2. lub(h) = , iff h = [0, ];
3. glb(h) = 4, iff h = (4, ).
Proof. Follows from Lemma 17, Lemma 23 and its proof. 
Now we start to characterize the distance constraints which appear in the process of
enforcing path-consistency on D(+ ).
716

fiQualitative Spatial Logics for Buffered Geometries

Definition 15 (DS(+ )) DS(+ ) is a minimal set of distance constraints such that the
following holds:
 Any distance constraint in D(+ ) is in DS(+ );
 If distance constraints d(p, q)  h and d(q, s)  g are in DS(+ ), then d(p, s)  h  g
is in DS(+ );
 If distance constraints d(p, q)  h and d(p, q)  g are in DS(+ ), then d(p, q)  h  g
is in DS(+ ),
where p, q, s are constants in D(+ ).
In the definition above, DS(+ ) is required to be minimal, such that any interval
involved in DS(+ ) is either in D(+ ) or is obtained by applying composition or intersection
operations on intervals in D(+ ). For generality, we do not restrict p, q, s to be different
constants. For example, it is possible p = q.
Lemma 25 If a distance constraint appears in the process of enforcing path-consistency on
D(+ ), then it is in DS(+ ).
Proof. Follows from Definition 8 (path-consistency) and Definition 15. 
DS(+ ) covers all the distance constraints appearing in the process of enforcing pathconsistency on D(+ ). However, not every distance constraint in DS(+ ) necessarily
appears in the process of enforcing path-consistency on D(+ ). For example, if D(+ )
contains exactly one distance constraint d(p, p)  [0, ], then by Definition 15, d(p, p) 
[0, 2] is in DS(+ ) (so is d(p, p)  [0, n], for any n  N>0 ), but by Definition 8, d(p, p) 
[0, 2] does not appear in the process of enforcing path-consistency. It is easy to see that
DS(+ ) is an infinite set.
The concept of DS(+ ) is similar to the concept of distributive subalgebra defined by
Li et al. (2015), as the composition operation distributes over non-empty intersections of
intervals involved in DS(+ ) (Rule 16 in Lemma 16). However, in our work, the composition
operation is defined for intervals rather than relations.
Lemma 26 If a distance constraint d(p, q)  h is in DS(+ ), then h is a non-negative
interval.
Proof. If a distance constraint d(p, q)  h is in D(+ ), by Lemma 11, h is a non-negative
interval. By Definitions 5, 7 and the definition of intersection, applying composition or
intersection on non-negative intervals, we obtain non-negative intervals. By Definition 15,
h is a non-negative interval. 
Differing from the previous version (Du & Alechina, 2014b), the following definitions
and lemmas are restricted to non-empty intervals.
Recall that a non-empty interval h is right-closed, iff h = [x, y] or h = (x, y]. h is
right-open, iff h = [x, y) or h = (x, y). h is right-infinite, iff h = [x, ) or h = (x, ). h is
left-closed, iff h = [x, y] or h = [x, y). h is left-open, iff h = (x, y] or h = (x, y).
717

fiDu & Alechina

Lemma 27 If a distance constraint d(p, q)  h is in DS(+ ) and h 6= , then h is either
right-infinite or right-closed.
Proof. Let n denote the total number of times of applying composition or intersection to
obtain h, n  0. We prove by induction on n.
Base case: n = 0, then d(p, q)  h is in D(+ ). By Lemma 11, h is either right-infinite
or right-closed. Inductive step: Suppose the statement holds for any non-empty h which
can be obtained by applying composition or intersection no more than n times (induction
hypothesis). We will show it also holds for any non-empty h which can be obtained by
applying composition or intersection (n + 1) times.
 If the last step to obtain h is intersection, then by Definition 15, there exist non-empty
h1 , h2 such that h = h1  h2 . By induction hypothesis, for each hi , i  {1, 2}, hi is
either right-infinite or right-closed. By intersection rules, h is either right-infinite or
right-closed.
 If the last step to obtain h is composition, then by Definition 15, there exist nonempty h1 , h2 such that h = h1  h2 . By induction hypothesis, for each hi , i  {1, 2}, hi
is either right-infinite or right-closed. By composition rules (Lemma 16), h is either
right-infinite or right-closed.


Lemma 28 For a distance constraint d(p, q)  h in DS(+ ) and h 6= , if glb(h) 6= 0, then
h is left-open.
Proof. Let n denote the total number of times of applying composition or intersection to
obtain h, n  0. We prove by induction on n.
Base case: n = 0, then d(p, q)  h is in D(+ ). By Lemma 11, if glb(h) 6= 0, then
h is left-open. Inductive step: Suppose the statement holds for any non-empty h which
can be obtained by applying composition or intersection no more than n times (induction
hypothesis). We will show it also holds for any non-empty h which can be obtained by
applying composition or intersection (n + 1) times.
 If the last step to obtain h is intersection, then by Definition 15, there exist nonempty h1 , h2 such that h = h1  h2 . By induction hypothesis, for each hi , i  {1, 2},
if glb(hi ) 6= 0, then hi is left-open. By intersection rules, if glb(h) 6= 0, then h is
left-open.
 If the last step to obtain h is composition, then by Definition 15, there exist non-empty
h1 , h2 such that h = h1  h2 . If glb(h) 6= 0, then by composition rules (Lemma 16),
h1 h2 = . Suppose lub(h1 )  glb(h2 ), then glb(h) = glb(h2 )lub(h1 ). By Lemma 26
and glb(h) 6= 0, we have glb(h) > 0, thus glb(h2 ) > lub(h1 ). By Lemma 26, lub(h1 ) 
0, thus glb(h2 ) > 0. By induction hypothesis, h2 is left-open. By composition rules
(Lemma 16), h is left-open. Similarly, this also holds if lub(h2 )  glb(h1 ).
718

fiQualitative Spatial Logics for Buffered Geometries


For a distance constraint d(p, q)  h in DS(+ ), by Definition 15, h is obtained by
applying the composition and/or intersection operations n  0 times on intervals occurring
in D(+ ). As applying the intersection operation does not generate any new bound, the
greatest lower/least upper bound (and its openness) of h must be the same as that of an
interval in D(+ ) or the composition of intervals in D(+ ). We formalize this rationale
as the concepts of Left-Definable and Right-Definable to characterize the distance constraints in DS(+ ). Later, we will show that every distance constraint d(p, q)  h (h 6= ) in
DS(+ ) is left-definable and right-definable. Left-Definable and Right-Definable are key
concepts for proving the Path-Consistency Lemma, as they establish the correspondences
between a distance constraint in DS(+ ) and a sequence of distance constraints in D(+ ).
If a non-empty interval h is left-open, then its greatest lower bound is represented as
glb (h). If h is left-closed, then its greatest lower bound is represented as glb+ (h). If h is
right-open, then its least upper bound is represented as lub (h). If h is right-closed, then
its least upper bound is represented as lub+ (h).
Definition 16 (Left-Definable) A distance constraint d(p1 , pn )  hs (n > 1) is leftdefinable, iff hs 6=  and there exists a sequence of distance constraints d(pi , pi+1 )  hi
(0 < i < n) in D(+ ), such that for m = h1  ...  hn1 , the following holds:
1. If hs is left-open, then m is left-open and glb  (m) = glb  (hs );
2. If hs is left-closed, then m is left-closed and glb + (m) = glb + (hs );
3. hs  m.
Definition 17 (Right-Definable) A distance constraint d(p1 , pn )  hs (n > 1) is rightdefinable, iff hs 6=  and there exists a sequence of distance constraints d(pi , pi+1 )  hi
(0 < i < n) in D(+ ), such that for m = h1  ...  hn1 , the following holds:
1. If hs is right-open, then m is right-open and lub  (m) = lub  (hs );
2. If hs is right-closed, then m is right-closed and lub + (m) = lub + (hs );
3. hs  m.
It is important to distinguish the definition of left-definable/right-definable distance
constraints (Definitions 16 and 17) from Definition 14 (Definable Intervals). For example, if
distance constraints d(p1 , p2 )  {0} and d(p2 , p3 )  {0} are in D(+ ), then d(p1 , p3 )  {0} is
left-definable and right-definable, but {0} is not a definable interval. If distance constraints
d(p1 , p2 )  [0, ] and d(p2 , p3 )  (4, ) are in D(+ ), then d(p1 , p3 )  (3, 5] is leftdefinable, but (3, 5] is not a definable interval.
Lemma 29 Let h, g be non-negative intervals. If distance constraints d(p, q)  h and
d(q, s)  g are left-definable and right-definable, then d(p, s)  h  g is left-definable and
right-definable.
719

fiDu & Alechina

Proof. Since d(p, q)  h and d(q, s)  g are right-definable, then by Definition 17, h 6= ,
g 6= . By Definition 7, h  g 6= . By Definition 17, in D(+ ), there exist a sequence of
distance constraints d(p, x2 )  h1 , ..., d(xn1 , q)  hn1 for d(p, q)  h and a sequence of
distance constraints d(q, y2 )  g1 , ..., d(yt1 , s)  gt1 for d(q, s)  g respectively satisfying
the three properties. Let us take the union of the two sequences as a new one, this is,
d(p, x2 )  h1 , ..., d(xn1 , q)  hn1 , d(q, y2 )  g1 , ..., d(yt1 , s)  gt1 . By composition
rules (Lemma 16), the new sequence satisfies the properties in Definition 17 for d(p, s)  hg.
Hence, d(p, s)  h  g is right-definable.
By composition rules (Lemma 16), if h  g 6= , then glb+ (h  g) = 0. We can use the
same new sequence above. Let m1 = (h1  ...  hn1 ), m2 = (g1  ...  gt1 ). By Definition 17,
h  m1 , g  m2 . Then m1  m2 6= , therefore, glb+ (m1  m2 ) = 0. By Definition 7,
h  g  m1  m2 . By Definition 16, d(p, s)  h  g is left-definable.
If h  g = , let us suppose glb(h)  lub(g). Since d(p, q)  h is left-definable and
d(q, s)  g is right-definable, by Definitions 16 and 17 respectively, in D(+ ), there exist
a sequence of distance constraints for d(p, q)  h and a sequence of distance constraints
for d(q, s)  g, satisfying the corresponding properties. Then by composition rules (Lemma
16), the union of the two sequences satisfies the properties in Definition 16 for d(p, s)  hg.
Hence, d(p, s)  h  g is left-definable. Similarly, we can show d(p, s)  h  g is left-definable,
if glb(g)  lub(h). 
Lemma 30 Let h, g be non-negative intervals. If distance constraints d(p, q)  h and
d(p, q)  g are left-definable and right-definable, h  g 6= , then d(p, q)  h  g is leftdefinable and right-definable.
Proof. As applying intersections does not generate any new bound and h  g 6= , the
left/right bound of h  g is the same as that of h or g. If the left bound of h  g is the
same as that of h, then by Definition 16, the same sequence used for showing d(p, q)  h is
left-definable can be used to show d(p, q)  h  g is left-definable. Other cases are similar. 
Lemma 31 If a distance constraint d(p, q)  h is in DS(+ ) and h 6= , then it is leftdefinable and right-definable.
Proof. Let n denote the total number of times of applying composition or intersection to
obtain h, n  0. We prove by induction on n.
Base case: n = 0, then d(p, q)  h is in D(+ ). By Definitions 16 and 17, d(p, q)  h is
left-definable and right-definable.
Inductive step: Suppose the statement holds for any non-empty h which can be obtained
by applying composition or intersection no more than n times (induction hypothesis). We
will show it also holds for any non-empty h which can be obtained by applying composition
or intersection (n + 1) times. By Definition 15, the last operation to obtain h is either
composition or intersection. In the former case, there exist d(p, s)  g1 and d(s, q)  g2 in
DS(+ ), such that g1  g2 = h. As h 6= , by Definition 7, gi 6= , i  {1, 2}. Since g1
and g2 are obtained by applying composition or intersection no more than n times, then by
induction hypothesis, d(p, s)  g1 and d(s, q)  g2 are left-definable and right-definable. By
720

fiQualitative Spatial Logics for Buffered Geometries

Lemma 29, d(p, q)  h is left-definable and right-definable. In the latter case, there exist
d(p, q)  g1 and d(p, q)  g2 in DS(+ ), such that g1  g2 = h. As h 6= , by intersection
rules, gi 6= , i  {1, 2}. By induction hypothesis, d(p, q)  g1 and d(p, q)  g2 are leftdefinable and right-definable. By Lemma 30, d(p, q)  h is left-definable and right-definable.

For generality, we do not exclude the possibility that d(p, q)   is in DS(+ ). However,
it follows from the proof of the Path-Consistency Lemma in Section 5.3 that d(p, q)   is
not in DS(+ ). Alternatively, for a direct proof, see Lemmas 45 and 46 in Appendix C.
5.2.3 Proving the Metric Space Lemma
In the following, we show there is a metric space satisfying D(+ ), if D(+ ) is pathconsistent (Metric Space Lemma). Firstly, we show that the process of enforcing patchconsistency on D(+ ) terminates. By Lemma 13, the number of constants in D(+ ) is
finite. Let us suppose the number of constants in D(+ ) is t  N>0 .
Lemma 32 Let t  N>0 be the number of constants in D(+ ). For any non-empty
right-closed interval h referred to in the process of enforcing path-consistency on D(+ ),
lub+ (h)  4t.
Proof. If a non-empty right-closed interval h occurs in D(+ ), then by Lemma 11,
lub+ (h)  4  4t.
Otherwise, it is generated from the application of composition and/or intersection operators by Definition 8. Composition creates larger least upper bounds (Lemma 17), whilst
intersection does not. Since h is right-closed, lub+ (h) is obtained by composing right-closed
intervals only (Lemma 16). Over t constants, the longest chain involves (t  1) intervals.
lub+ (h) is maximal if we use all of these (t  1) intervals and the least upper bound of each
interval is 4. Thus, lub+ (h)  4t. 
Lemma 33 Let t  N>0 be the number of constants in D(+ ). Enforcing path-consistency
on D(+ ), a fixed point can be reached in O(t3 ).
Proof. By Definition 8, Lemmas 23 and the fact that intersection does not generate new
bounds, for any interval s appearing in the process of enforcing path-consistency on D(+ ),
the following properties hold:
1. glb(s) = n, n  {0, 1, 2, 3, 4};
2. lub(s) = + or lub(s) = m, m  N>0 .
For any interval h appearing in D(+ ), by enforcing path-consistency (Definition 8), h can
only become an h0  h. By Lemma 11, h 6= . By Lemma 27, h is either right-closed or
right-infinite, h0 is , right-closed or right-infinite.
 If h is right-closed, then h0 =  or h0 is right-closed. If h0 is right-closed, then by
Lemma 11, lub(h0 )  lub(h)  4. By Properties 1, 2, there are finitely many
possibilities for h0 .
721

fiDu & Alechina

 If h is right-infinite, then h0 is , right-closed or right-infinite.
 If h0 is right-closed, then by Lemma 32, lub(h0 )  4t. By Properties 1, 2, there
are finitely many possibilities for h0 .
 If h0 is right-infinite, then by Property 1, there are finitely many possibilities for
its greatest lower bound, thus for h0 .
Since in each case, there are finitely many possibilities for h0 , a fixed point is always reached.
Suppose the widest non-negative interval [0, ) appears in the process of enforcing
path-consistency on D(+ ). In the worst case, firstly, [0, ) is strengthened to [0, u], where
u  4t (by Lemma 32), then [0, u] is strengthened by  each time. Hence, [0, ) can be
strengthened at most (4t + 1) times. Over t constants, by Definition 13, there are O(t2 )
distance constraints in D(+ ). For any interval h appearing in D(+ ), h  [0, ), hence h
can be strengthened at most (4t + 1) times. Therefore, the total time of strengthening all
the distance constraints is O(t3 ). 
The following lemma shows how to construct a metric space from D(+ ). It is used to
prove the Metric Space Lemma.
Lemma 34 Let t  N>0 be the number of constants in D(+ ), Df (+ ) be a fixed point of
enforcing path consistency on D(+ ). If D(+ ) is path-consistent, Ds (+ ) is obtained from
Df (+ ) by replacing every right-infinite interval with {5t}, every right-closed interval h
with {lub(h)}, then Ds (+ ) is path-consistent.
Proof. Suppose D(+ ) is path-consistent. By Lemma 25, Df (+ )  DS(+ ). By Definition 8, for any interval h appearing in Df (+ ), h 6= . By Lemma 27, h is either right-infinite
or right-closed. To prove Ds (+ ) is path-consistent, we only need to show that for any three
distance ranges, {npq }, {nqs }, {nps } in Ds (+ ) over three constants p, q, s, we have
1. npq  nqs + nps ;
2. nqs  npq + nps ;
3. nps  npq + nqs .
Let hpq , hqs , hps denote the corresponding distance ranges of {npq }, {nqs }, {nps } respectively
in Df (+ ), by Definition 8, we have
 hpq  hqs  hps ;
 hqs  hpq  hps ;
 hps  hpq  hqs .
We prove Ds (+ ) is path-consistent by cases:
 If every hi (i  {pq, qs, ps}) is right-closed, then ni = lub(hi ). By Lemma 18, 1-3
hold.
722

fiQualitative Spatial Logics for Buffered Geometries

 Otherwise, not all of them are right-closed. By Lemma 19, at least two of them are
right-infinite.
 If all of them are right-infinite, then ni = 5t. Since 5t  5t + 5t, 1-3 hold.
 Otherwise, only one of them is right-closed. Let hpq be right-closed. Then,
npq = lub(hpq ), nqs = 5t, nps = 5t. By Lemma 32 and   R0 , lub(hpq ) 
4t < 5t. By Lemma 26, lub(hpq )  0. Since lub(hpq ) < 5t + 5t and
5t  5t + lub(hpq ), 1-3 hold.

Lemma 7 (Metric Space Lemma) Let  be a finite consistent set of formulas, and +
be an M CS which contains  and is over the same set of individual names as . If D(+ )
is path-consistent, then there is a metric space (, d) such that all distance constraints in
D(+ ) are satisfied.
Proof. Suppose D(+ ) is path-consistent. Let  be the set of constants in D(+ ), which is
used to interpret individual names occurring in , as shown in Definition 13. If  = , then
it is trivial. Let us assume  6= . The number of constants in  is denoted by t  N>0 . By
Lemma 33, a fixed point Df (+ ) can be reached by enforcing path-consistency on D(+ ).
Let Ds (+ ) be a set of distance constraints obtained from Df (+ ) by replacing every
right-infinite interval with {5t}, every right-closed interval h with {lub(h)}. Since every
distance constraint in Ds (+ ) is of the form d(p, q)  {r}, where r  R0 , and d(p, q)  {r}
is equivalent to d(p, q) = r, a metric (distance function) is defined over . By Definition 13
and Lemma 34, for any pair of constants x, y, if x = y, then d(x, y) = 0 holds in Ds (+ );
if x 6= y, then d(x, y)   > 0 holds in Ds (+ ). Thus, we have d(x, y) = 0 iff x = y in
Ds (+ ). By Definitions 13 and 8, for any pair of constants x, y, d(x, y) = d(y, x) holds
in Ds (+ ). By Lemma 34, Ds (+ ) is path-consistent. Thus, for any constants x, y, z,
d(x, z)  d(x, y) + d(y, z) holds in Ds (+ ). By Definition 1, the (, d) of Ds (+ ) is a
metric space such that all distance constraints in D(+ ) are satisfied. 

5.3 Path-Consistency Lemma
This section proves the Path-Consistency Lemma by contradiction, supposing that D(+ )
is not path-consistent. We examine every case where the first  interval is obtained by
enforcing path-consistency. In each case, we show that  is derivable from the corresponding
LBPT formulas in + using LBPT axioms. This contradicts the assumption that + is
consistent. Lemma 35 is used to generate all possible cases and make sure no duplicated ones
are generated. By using Lemma 35, the proof of the Path-Consistency Lemma is largely
simplified, compared to the previous version (Du & Alechina, 2014b).
Lemma 35 Let g, h be non-negative intervals. g  h =  iff (g  h)  {0} = .
Proof. If g  h 6= , then by Definition 7, 0  (g  h).
If 0  (gh), then by Lemma 15, there exist d1  g, d2  h such that 0  [|d1 d2 |, d1 +d2 ].
Thus, d1 = d2 . Therefore, g  h 6= .
723

fiDu & Alechina

Since g  h 6=  iff 0  (g  h), by contraposition we get g  h =  iff (g  h)  {0} = . 
Knowing a least upper bound or a greatest lower bound of a definable interval h, Lemmas 36-42 show all possible ways in which h can be obtained as the composition of primitive
intervals. Lemma 36 and Lemma 39 are proved below. Proofs of the other lemmas are similar and omitted.
Lemma 36 If an interval h is definable, lub(h) = 2, then h is a primitive interval [0, 2]
or h is obtained as the composition of two [0, ].
Proof. If h is primitive, then by Definition 14, h = [0, 2].
If h is composite, then by Definition 14, there exist two definable intervals g1 , g2 such that
g1  g2 = h. By Lemma 17, lub(g1 ) + lub(g2 ) = 2. By Lemma 23, lub(g1 )  , lub(g2 )  ,
thus lub(g1 ) = , lub(g2 ) = . By Lemma 24, h = [0, ]  [0, ]. 

Lemma 37 If an interval h is definable, lub(h) = 3, then h is obtained as the composition
of [0, ] and [0, 2] or as the composition of three [0, ].
Lemma 38 If an interval h is definable, lub(h) = 4, then h is a primitive interval (2, 4],
or h is obtained as the composition of two [0, 2], as the composition of two [0, ] and one
[0, 2] or as the composition of four [0, ].
Lemma 39 If an interval h is definable, glb(h) = 3, then h is obtained as the composition
of [0, ] and (4, ).
Proof. By Definition 14, h cannot be primitive.
Since h is composite, then by Definition 14, there exist two definable intervals g1 , g2 such
that g1  g2 = h. g1  g2 = , otherwise, by Lemma 16, glb(h) = 0.
Without loss of generality, let us suppose lub(g1 )  glb(g2 ). By Lemma 16, glb(g2 ) 
lub(g1 ) = 3. By Lemma 23, glb(g2 )  4, lub(g1 )  , thus glb(g2 ) = 4, lub(g1 ) = . By
Lemma 24, h is obtained as the composition of [0, ] and (4, ). 
Lemma 40 If an interval h is definable, glb(h) = 2, then h is a primitive interval (2, )
or (2, 4], or h is obtained as the composition of [0, 2] and (4, ) or as the composition
of two [0, ] and one (4, ).
Lemma 41 If an interval h is definable, glb(h) = , then h is a primitive interval (, ),
or h is obtained as the composition of [0, ] and (2, ), as the composition of [0, ] and
(2, 4], as the composition of one [0, ], one [0, 2] and one (4, ), or as the composition
of three [0, ] and one (4, ).
Lemma 42 If an interval h is definable and left-open, glb(h) = 0, then h is obtained in
exactly the following ways:
 as the composition of [0, ] and (, );
724

fiQualitative Spatial Logics for Buffered Geometries

 as the composition of [0, 2] and (2, );
 as the composition of two [0, ] and one (2, );
 as the composition of [0, 2] and (2, 4];
 as the composition of two [0, ] and one (2, 4];
 as the composition of (2, 4] and (4, );
 as the composition of two [0, 2] and one (4, );
 as the composition of two [0, ], one [0, 2] and one (4, );
 as the composition of four [0, ] and one (4, ).
In our previous work (Du et al., 2013; Du & Alechina, 2014b), we presented a slightly
different way to prove the Path-Consistency Lemma for LNF and LBPT respectively: the
first empty interval is obtained using the strengthening operator, this is, g1  (g2  g3 ) = 
and gi 6= , where i  {1, 2, 3}. gi may be {0} or a primitive interval, or it can be written as
xi  (yi  zi ), where each of xi , yi , zi may not be an identity or primitive internal also. In the
latter case, since gi = xi  (yi  zi ) 6= , xi , yi , zi are all not empty. Since the composition
operation is distributive over non-empty intersections of intervals (Rule 16 in Lemma 16),
we use Rule 16 repeatedly to rewrite g1  (g2  g3 ) until every interval is an identity or
primitive interval. The final form is h1  ...  hn = , n > 1, where hx (0 < x  n) is
{0} or a definable interval. Thus there exist two intervals hi , hj (0 < i  n, 0 < j  n,
i 6= j) such that hi  hj = . Then we look at all the different combinations such that
lub(hi )  glb(hj ). There are exactly 15 such combinations. In this paper, the proof of the
Path-Consistency Lemma is largely simplified. It shows that it is sufficient to examine 5
rather than 15 combinations.
Lemma 8 (Path-Consistency Lemma) Let  be a finite consistent set of formulas, and
+ be an M CS which contains  and is over the same set of individual names as . Then,
D(+ ) is path-consistent.
Proof. Suppose D(+ ) is not path-consistent. Then by Definitions 8, 15 and Lemma 25,
d(p, q)   is in DS(+ ), for some constants p, q. By Lemma 11, for any distance range g
occurring in D(+ ), g 6= . By Definitions 15, 7, and intersection rules, the last operation
to obtain the first  interval is intersection. By Definition 15, there exist d(p, q)  g1 and
d(p, q)  g2 in DS(+ ), g1 6= , g2 6= , and g1  g2 = . By Lemma 26, g1 , g2 are
non-negative intervals. By Lemma 35, g1  g2 =  iff (g1  g2 )  {0} = .
By Definition 13 and Definition 15, d(q, p)  g2 is in DS(+ ). Since d(p, q)  g1 is in
DS(+ ), by Definition 15, d(p, p)  (g1  g2 ) is in DS(+ ). By Definition 7, g1  g2 6= .
By Lemma 31, d(p, p)  (g1  g2 ) is left-definable and right-definable. Let h = g1  g2 .
Since d(p, p)  h is left-definable, then by Definition 16, there exists a sequence of distance
constraints d(pi , pi+1 )  hi (0 < i < n) in D(+ ), such that p = p1 = pn and for h0 =
h1  ...  hn1 , h and h0 have the same greatest lower bound (including both value and
725

fiDu & Alechina

openness) and h  h0 . By Definition 14, Lemmas 21 and 20, h0 is an identity or definable
interval. By Lemma 23, glb(h0 )  {0, , 2, 3, 4}. Therefore, (g1  g2 )  {0} =  iff one of
the following holds:
 glb(h)  {, 2, 3, 4};
 h is left-open and glb (h) = 0.
We will check whether  can be derived in every case using axioms (or derivable facts).
By Axiom 3 and Axiom 4, N EAR and F AR are both symmetric.
1. glb(h) = : we look at all the different ways where h0 is obtained from a sequence of
distance constraints d(pi , pi+1 )  hi (0 < i < n) in D(+ ) such that p = p1 = pn and
h0 = h1  ...  hn1 (see Definition 16). As every hi is {0} or a primitive interval (by
Lemma 21), Lemma 41 specifies all the different ways to obtain h0 :
(a) h0 is a primitive interval (, +): by Definition 16, d(p1 , pn )  (, +) is in
D(+ ) and n = 2. As p = p1 = pn , d(p, p)  (, +) is in D(+ ). Suppose
p  points(a) for an individual name a in . By the proof of Lemma 11, (, +)
only can come from formulas of the form (x, y, (, )), where x, y are individual names. By Definition 10, (x, y, (, )) only can come from BP T (x, y).
Since d(p, p)  (, +) is in D(+ ) and p  points(a), BP T (a, a)  + . By
Axiom 9, BP T (a, a)  .
(b) h0 is obtained as the composition of [0, ] and (2, ) or as the composition of
[0, ] and (2, 4]:
by the proof of Lemma 11 and Definition 10, BP T (a, b)  + or BP T (b, a)  + ,
N EAR(a, b)  + and N EAR(b, a)  + .
By Fact 14, BP T (x1 , x2 )  N EAR(x1 , x2 )  , {x1 , x2 } = {a, b}.
(c) h0 is obtained as the composition of one [0, ], one [0, 2] and one (4, ):
by the proof of Lemma 11 and Definition 10, BP T (a, b)  + or BP T (b, a)  + ,
N EAR(b, c)  + , N EAR(c, b)  + , F AR(c, a)  + , F AR(a, c)  + . By
Fact 16, BP T (x2 , x1 )N EAR(x2 , x3 )F AR(x3 , x1 )  , {x1 , x2 , x3 } = {a, b, c}.
(d) h0 is obtained as the composition of three [0, ] and one (4, +):
by the proof of Lemma 11 and Definition 10, we have three BP T and one
F AR over four individual names a, b, c, d. BP T refers to either BP T (x, y) or
BP T (y, x). Some cases (for example, in + , we have BP T (a, b), BP T (c, b),
BP T (d, c) and F AR(a, d)) are not valid, because different constants will be
taken from the same points(b), for an individual name b (by Definition 13). As
a consequence, in an invalid case, a sequence consisting of distance constraints
d(pi , pi+1 )  hi (0 < i < n, p = p1 = pn ) cannot exist in D(+ ). We only need
to consider all valid cases, which are listed below.
i. BP T (x1 , x2 ), BP T (x2 , x3 ), BP T (x3 , x4 ), F AR(x4 , x1 ), where
{x1 , x2 , x3 , x4 } = {a, b, c, d}. By Fact 20, BP T (x1 , x2 )  BP T (x2 , x3 ) 
BP T (x3 , x4 )  F AR(x4 , x1 )  .
ii. BP T (x2 , x1 ), BP T (x2 , x3 ), BP T (x3 , x4 ), F AR(x4 , x1 ), where
{x1 , x2 , x3 , x4 } = {a, b, c, d}. By Fact 21, BP T (x2 , x1 )  BP T (x2 , x3 ) 
BP T (x3 , x4 )  F AR(x4 , x1 )  .
726

fiQualitative Spatial Logics for Buffered Geometries

Cases 2-5 below use similar arguments. In the following proof, BP T refers to either
BP T (x, y) or BP T (y, x) (whichever makes the corresponding case valid). N EAR
and F AR are symmetric, thus the order of x, y does not matter.
2. glb(h) = 2: by Definition 16 and Lemma 21, Lemma 40 specifies all the different
ways to obtain h0 from a sequence of distance constraints d(pi , pi+1 )  hi (0 < i < n)
in D(+ ):
(a) h0 is a primitive interval (2, ) or (2, 4]:
N EAR(a, a), using Axiom 9 and Fact 14.
(b) h0 is obtained as the composition of [0, 2] and (4, +) :
one N EAR and one F AR, using Fact 15.
(c) h0 is obtained as the composition of two [0, ] and one (4, +):
two BP T and one F AR, using Facts 18 and 19.
3. glb(h) = 3: by Definition 16 and Lemma 21, Lemma 39 specifies all the ways to
obtain h0 from a sequence of distance constraints d(pi , pi+1 )  hi (0 < i < n) in
D(+ ). By Lemma 39, h0 is obtained as the composition of [0, ] and (4, +).
one BP T and one F AR, using Fact 17.
4. glb(h) = 4: by Definition 16 and Lemma 21, Lemma 24 specifies all the ways to
obtain h0 from a sequence of distance constraints d(pi , pi+1 )  hi (0 < i < n) in
D(+ ). By Lemma 24, h0 = (4, +). F AR(a, a), using Axiom 9 and Fact 17.
5. glb (h) = 0: by Definition 16 and Lemma 21, Lemma 42 specifies all the ways to
obtain h0 from a sequence of distance constraints d(pi , pi+1 )  hi (0 < i < n) in
D(+ ):
(a) h0 is obtained as the composition of [0, ] and (, ): by Definition 13, ensuring
no different constants taken from the same points(x),
BP T (x1 , x2 )  + and BP T (x1 , x2 )  + , {x1 , x2 } = {a, b}.
BP T (x1 , x2 )  BP T (x1 , x2 )  .
(b) h0 is obtained as the composition of [0, 2] and (2, ) or as the composition of
[0, 2] and (2, 4]:
one N EAR and one N EAR, using Axiom 3.
(c) h0 is obtained as the composition of two [0, ] and one (2, ) or as the composition of two [0, ] and one (2, 4]:
two BP T and one N EAR, using Axioms 10 and 11.
(d) h0 is obtained as the composition of (2, 4] and (4, ):
one F AR and one F AR, using Axiom 4.
(e) h0 is obtained as the composition of two [0, 2] and one (4, ):
two N EAR and one F AR.
This case is invalid. By Definition 16, D(+ ) contains d(pa , pb )  [0, 2], d(pb , pc ) 
[0, 2] and d(pa , pc )  (4, ), where pa  points(a), pb  points(b), pc 
points(c), for individual names a, b, c. By Definitions 10 and 13, d(pa , pb )  [0, 2]
and d(pb , pc )  [0, 2] cannot come from N EAR(a, b) and N EAR(b, c) in + (by
727

fiDu & Alechina

the proof of Lemma 11, it is clear that they cannot come from other formulas as
well), because two different constants will be taken from points(b) as witnesses
for (a, b, [0, 2]) and (b, c, [0, 2]) respectively.
(f) h0 is obtained as the composition of two [0, ], one [0, 2] and one (4, ):
two BP T , one N EAR and one F AR, using Axioms 12 and 13.
(g) h0 is obtained as the composition of four [0, ] and one (4, ):
four BP T and one F AR, using Facts 22-24.
In each valid case,  is derivable using the corresponding axioms or facts, which contradicts
the assumption that + is consistent. Therefore, D(+ ) is path-consistent. 
There is an alternative way to prove the Path-Consistency Lemma, which we believe is
longer and more complicated than the one presented in this paper, but since it may provide
additional intuitions to the reader, we sketch it in Appendix B.

6. Decidability and Complexity of LBPT
In this section, we establish the complexity of the LBPT satisfiability problem. The complexity of the LNF/LNFS satisfiability problem can be established in a similar way. The
complexity of these satisfiability problems is important, as it is related to the complexity
of the problem of finding inconsistencies, which is the basis of our approach to debugging
matches between geospatial datasets.
Definition 18 (Size of a Formula) The size of a LBPT formula s() is defined as follows:
 s(BP T (a, b)) = 3, s(N EAR(a, b)) = 3, s(F AR(a, b)) = 3;
 s() = 1 + s();
 s(  ) = 1 + s() + s(),
where a, b are individual names, ,  are formulas in L(LBP T ).
As a set of LBPT formulas S and the conjunction of all formulas in S are equi-satisfiable,
the combined size of LBPT formulas in a set S is defined as the size of the conjunction of
all formulas in S.
Next we prove Theorem 2 for LBPT: the satisfiability problem for a finite set of LBPT
formulas in a metric space is NP-complete.
Proof. NP-hardness of the LBPT satisfiability problem follows from NP-hardness of the
satisfiability problem for propositional logic, which is included in LBPT.
To prove that the LBPT satisfiability problem is in NP, we show that if a finite set of
LBPT formulas  is satisfiable, then we can guess a metric model for  and verify that this
model satisfies , both in time polynomial in the combined size of formulas in .
Suppose  is a finite set of LBPT formulas, and the number of individual names in  is
n. The completeness proof shows that, if  is satisfiable, it is satisfiable in a metric model
728

fiQualitative Spatial Logics for Buffered Geometries

M of size which is polynomially bounded by the number of individual names in . To recap
the construction of the metric model for , first we construct B(+ ), the corresponding set
of basic quantified formulas from an MCS + containing , and then construct a model for
B(+ ). By Definition 10, the number of formulas in B(+ ) is at most f = (n + 2n(n  1)).
By Definitions 11 and 13, to every individual name a in , we assign a fixed set of new
constants, points(a) = {p1a , . . . , pxa }, where x = num(a, B(+ )). Since x  f , the number of
constants in M is at most t = nf . By Lemma 34 and proofs of the Metric Space Lemma, in
such a model M , every value assigned by the distance function is of the form m, m  N0 ,
m  5t.
We guess a metric model M like this. Let s be the combined size of formulas in . Then
n < s. To every individual name a in , we assign {p1a , . . . , pxa }, where x < 2s2 . This results
in a set of constants , the size of which is < 2s3 . To every pair of constants p, q in , we
assign m to d(p, q), where m  N0 , m < 10s3 . To verify that (, d) is a metric space, by
Definition 1, it is in O(s9 ).
To verify that M satisfies , we need to verify that it satisfies the conjunction of all formulas in . For any R(a, b), where R  {BP T, N EAR, F AR}, a, b are individual names, to
verify that R(a, b) is satisfied, it takes time which is polynomial in |points(a)|  |points(b)|,
thus it is in O(s4 ). Hence, verifying that M satisfies  can be done in O(s5 ). 
In Section 3, we mentioned that  acts as a scaling factor of a metric model. This is
stated as Lemma 43 and follows from the proofs of the completeness theorem and Theorem 2.
The proof for LBPT is provided below. The proof for LNF/LNFS is similar.
Lemma 43 A finite set of LNF/LNFS/LBPT formulas is satisfiable in a metric model
where   R0 , iff it is satisfiable in a metric model when  = 1.
Proof.[for LBPT] Suppose  is a finite set of LBPT formulas, the number of individual
names in  is n and the combined size of formulas in  is s. By Definition 18, n < s.
The completeness proof shows that, if  is satisfiable, it is satisfiable in a metric model
M = (, d, I, ) constructed as shown in Section 5.1 and Section 5.2. By Definition 13,
to every individual name a in , we assign {p1a , . . . , pxa }, where x = num(a, B(+ )) < 2s2 .
This results in a set of constants , the size of which is < 2s3 . To every constant p in ,
we assign d(p, p) = 0. By Definition 13 and Lemma 34, to every pair of different constants
p, q in , we assign m to d(p, q), where m  N>0 , m < 10s3 . As M is a metric model, by
Definition 1 and the proof of the Metric Space Lemma, for any x, y, z  , we have
1. d(x, y) = 0, iff x = y;
2. d(x, y) = mxy , iff d(y, x) = mxy ;
3. if d(x, z) = mxz , d(x, y) = mxy , d(y, z) = myz , then mxz   mxy  + myz .
If M satisfies , by Definition 3, the following holds:
M |= BP T (a, b) iff pa  I (a) pb  I (b) : d (pa , pb )  [0 , ];
M |= N EAR(a, b) iff pa  I (a) pb  I (b) : d (pa , pb )  [0 , 2 ];
729

fiDu & Alechina

M |= F AR(a, b) iff pa  I (a) pb  I (b) : d (pa , pb )  (4 , );
M |=  iff M 6|= ;
M |=    iff M |=  and M |= ,
where a, b are individual names, ,  are formulas in L(LBP T ).
By setting  = 1, (, d) is still a metric space, as the following holds for any x, y, z  :
1. d(x, y) = 0 iff x = y;
2. d(x, y) = mxy , iff d(y, x) = mxy ;
3. if d(x, z) = mxz , d(x, y) = mxy , d(y, z) = myz , then mxz  mxy + myz .
By setting  = 1, the definitions of BP T , N EAR and F AR change accordingly as well.
One can easily see that M still satisfies  after replacing every  by 1.
Similar, if we have a metric model with  = 1, we can obtain a metric model with
  R0 by multiplying every distance value m by . One can easily see that M still satisfies  after multiplying all distance values in M by , and multiplying all greatest lower
bounds and least upper bounds of intervals in the truth definitions of BP T , N EAR and
F AR by . 

7. Validating Matches using Spatial Logic
The spatial logics LN F , LN F S and LBP T can be used to verify consistency of sameAs
and partOf matches between spatial objects from different geospatial datasets. If every
spatial object has a point geometry, then we apply LN F , otherwise, we apply LN F S or
LBP T . LBP T reasoning has been used together with description logic reasoning in a
geospatial data matching system MatchMaps (Du, Nguyen, Alechina, Logan, Jackson, &
Goodwin, 2015; Du, 2015). LBP T reasoning and description logic reasoning complement
each other in the sense that LBP T reasoning verifies matches regarding spatial information
whilst description logic reasoning verifies matches regarding classification information, the
unique name assumption and a stronger version of it. In the following, we describe how
LBPT is used for debugging matches.
A dedicated LBPT reasoner integrated with an assumption-based truth maintenance
system (ATMS) (de Kleer, 1986) was developed as a part of MatchMaps. It implements
LBPT axioms and the definition BEQ(a, b)  BP T (a, b)  BP T (b, a) as a set of inference
rules. For efficiency reasons, there is no one-to-one correspondence between rules and axioms. To speed up matching and avoid cycles, facts such as N EAR(a, b) are stored for only
one order of a and b, and symmetry axioms are removed. Each of the remaining axioms
involving any symmetric relation gives rise to several rules, to compensate for the removal
of symmetry. For example, the axiom
BPT (b, a)  NEAR(b, c)  BPT (c, d )  FAR(d , a)
also gives rise to a rule corresponding to the following implication:
BPT (b, a)  NEAR(c, b)  BPT (c, d )  FAR(d , a)
730

fiQualitative Spatial Logics for Buffered Geometries

(with N EAR(c, b) instead of N EAR(b, c)). However the set of rules is trivially equivalent
to the set of axioms.
Possible matches of the form sameAs(a, b) and partOf (a, b) (a is partOf b) are generated as assumptions, to be withdrawn if they are involved in a derivation of a contradiction
in description logic or in LBPT. In order to apply the LBPT reasoning, sameAs(a, b) is
replaced by BEQ(a, b), and partOf (a, b) is replaced by BP T (a, b). These substitutions do
not affect correctness of the matching results of MatchMaps, as MatchMaps adopts the definitions of sameAs and partOf such that sameAs(a, b) entails BEQ(a, b) and partOf (a, b)
entails BP T (a, b). N EAR(a, b) and F AR(a, b) facts are generated for those objects a, b
in the same dataset that are involved in some matches across the two datasets (there is
an object c in the other dataset such that BEQ(a, c), BP T (a, c) or BP T (c, a) holds, and
similarly for b).
The LBPT reasoner derives new formulas by applying inference rules to previously
derived formulas, and the ATMS maintains dependencies between derived consequences and
a set of assumptions (corresponding to possible matches). In particular, it maintains all
minimal sets of assumptions responsible for the derivation of  (false), referred to as nogoods
in ATMS terminology. Such minimal sets of assumptions responsible for a contradiction
are used to decide which matches are wrong and should be withdrawn.
In experiments, the LBPT reasoner with an ATMS was used to validate matches between
spatial objects from OSM data (building layer) and OSGB MasterMap data (Address Layer
and Topology Layer) (Du et al., 2015). The study areas are in city centres of Nottingham UK
and Southampton UK. The Nottingham data was obtained in 2012, and the Southampton
data in 2013. The numbers of spatial objects in the case studies are shown in Table 1.

Nottingham
Southampton

OSM spatial objects
281
2130

OSGB spatial objects
13204
7678

Table 1: Data used for Evaluation

The initial matches are generated by the matching method implemented in MatchMaps.
The detailed matching method is provided by Du et al. (2016). The method consists
of two main steps: matching geometries and matching spatial objects. A spatial object
in a geospatial dataset has an ID, location information (coordinates and geometry) and
meaningful labels, such as names or types, and represents an object in the real world. A
geometry here refers to a point, a line or a polygon, which is used to represent location
information in geospatial datasets.
The geometry matching requires a level of tolerance, as some difference in the geometry
representation of a spatial object is to be expected in different datasets. After discussing
with domain experts in geospatial science, we decided to apply the same level of tolerance
for the matching method and the spatial logic used in MatchMaps. In the experiments
described by Du et al. (2015), the level of tolerance for the geometry matching was set to
be 20 meters, based on the published estimate about the positional accuracy of OSM data.
The OSM positional accuracy was estimated to be about 20 meters in UK (Haklay, 2010).
In our more recent work (Du et al., 2016), we analysed how the level of tolerance affects
731

fiDu & Alechina

the precision and recall of matching results for the same geographic area in Nottingham
(the same data as shown in the first row of Table 1) using 12 different levels of tolerance
within a range of 1 to 80 meters. It shows that, for the Nottingham case, 20 meters is a
good estimate, though it is not the optimal value.
Following the first step of the matching method, we first aggregate adjacent single geometries, such as those of shops within a shopping center, then establish correspondences
between aggregated geometries using geometry matching. In the second step, we match
spatial objects located on these corresponding aggregated geometries by comparing the
similarity of names and types of spatial objects in several different cases (one-to-one, manyto-one and many-to-many). The most difficult case is when there is a match between
two aggregated geometries which contain objects {a1 , . . . , an } in one dataset and objects
{b1 , . . . , bk } in the other dataset (many-to-many matching case). When we cannot decide
the exact matches automatically using names and types of objects, we generate all matches
which are possibly correct between the objects in the two sets: for each pair ai , bj with similar labels, we generate sameAs(ai , bj ), partOf (ai , bj ), partOf (bj , ai ). We apply reasoning in
LBPT and description logic to verify consistency of these matches. The use of description
logic reasoning is described by Du (2015).

Figure 5: Examples of using LNFS and LBPT for validating matches
If a minimal set of statements involved in a contradiction contains more than one
retractable assumption, a domain expert is needed to decide the correctness of the retractable assumptions and remove the wrong one(s) to restore consistency. Location information is visualized and provided to help domain experts make such decisions. As
shown in Figure 5, a1 , b1 , c1 , d1 (dotted) are from OSGB data and a2 , b2 , c2 , d2 (solid) are
from OSM data. In the left example, by LNFS Axiom 6 (or by LBPT Axiom 12 and
BEQ(a, b)  BP T (a, b)  BP T (b, a)), a minimal set of statements for deriving an inconsistency consists of BEQ(a1 , a2 ), BEQ(b1 , b2 ), N EAR(a1 , b1 ), F AR(a2 , b2 ). It is clear that
BEQ(b1 , b2 ) is wrong, as N EAR(a1 , b1 ) and F AR(a2 , b2 ) are facts. In the right example,
BP T (d2 , d1 ) is wrong, because it contradicts BP T (c2 , c1 ), N EAR(c2 , d2 ), F AR(c1 , d1 ) by
LBPT Axiom 12. As a consequence, the sameAs and partOf matches corresponding to
BEQ(b1 , b2 ) and BP T (d2 , d1 ) respectively are also incorrect.
Table 2 shows the numbers of nogoods generated by the LBPT reasoner with an ATMS.
As mentioned earlier, nogoods are justifications for false: the minimal sets of statements
from which a contradiction is derivable. The number of interactions is the number of
times users are asked to take actions or use strategies to resolve problems (a strategy is
a heuristic which allows users to retract all similar statements at a time, for example,
732

fiQualitative Spatial Logics for Buffered Geometries

Nottingham
Southampton

nogoods
172
268

retracted BEQ/BPT
31
114

retracted sameAs/partOf
1325
488

interactions
3
7

Table 2: LBPT Verification of Matches

retracting partOf (o, x) for any x differing from an object o). As a result of LBPT reasoning
and removal of BEQ and BPT assumptions, we withdraw 1325 sameAs/partOf assumptions
for the Nottingham case and 488 sameAs/partOf assumptions for the Southampton case.
With the LBPT validation of matches, MatchMaps achieved high precision ( 90%) and
recall ( 84%) for both Nottingham and Southampton cases.
As described in our previous work (Du, Alechina, Hart, & Jackson, 2015), MatchMaps
was used by 12 experts from the University of Nottingham and Ordnance Survey of Great
Britain to match about 100 buildings and places in Southampton. A graphical user interface of MatchMaps is provided allowing users to take different types of actions to remove
wrong matches. The number of actions and the decision time of users are recorded. The
precision and recall of the matching results are compared to those obtained without using any user-involved verification. Experimental results showed that by using reasoning in
LBPT and description logic, the precision and recall of matches generated by MatchMaps
were improved on average by 9% and 8% respectively. The human effort is also reduced, in
the sense that the decision time required is much less than that of a fully manual matching
process.

8. Discussion
The spatial logics LNF, LNFS and LBPT are generally applicable to reason with spatial objects whose locations are represented at different levels of accuracy or granularity in different
datasets. Locations of spatial objects can be represented using vector data (coordinates)
or raster data (images). Sometimes, for spatial objects in different datasets, measuring
whether their locations are buffered equal directly is difficult or impossible, for example,
when locations are represented as images without knowing their coordinates. In such cases,
spatial objects may be matched by comparing shapes in images or using lexical information.
No matter how the matches between spatial objects are generated, the LNF/LNFS/LBPT
reasoning could be used to verify consistency of matches with regard to relative locations
(N EAR/F AR facts) between spatial objects in the same dataset, which are often reliable
and easy to capture.
Another potential application of these logics is in matching non-georeferenced volunteered spatial information or sketch data (Egenhofer, 1997; Kopczynski, 2006; Wallgrun,
Wolter, & Richter, 2010). Instead of being created by surveying or other mapping techniques, sketch data is often created by a person from memory or by schematizing authoritative geospatial data. A sketch map cannot provide precise metric information such as the
exact distance or size of a spatial object, but it roughly shows several kinds of qualitative
relations (e.g. nearness and directions) between spatial objects. In the work by Wallgrun
et al. (2010), qualitative spatial reasoning (based on the dipole relation algebra presented in
Moratz, Renz, & Wolter, 2000 for checking connectivity and the cardinal direction calculus
733

fiDu & Alechina

presented in Ligozat, 1998) is used for the task of matching a sketch map of a road network to a larger geo-referenced data set, for example, from OpenStreetMap. Endpoints and
junctions of roads are extracted and their relative directions are represented and checked
by spatial reasoning. The spatial logic LNF can be applied similarly to check the relative
distances between endpoints or junctions of roads. N EAR/F AR relations between these
points indicate the length of roads. For the task of matching a sketch map of polygonal
objects (e.g. buildings and places), the logic LNFS/LBPT can be applied. Suppose users
draw a sketch map of buildings and estimate the distances between some buildings as being
N EAR or F AR regarding an agreed level of tolerance . The N EAR and F AR relations
between buildings in a geo-referenced map can be calculated automatically. A mapping
between the sketch map and a geo-referenced map can be checked by reasoning in the logic
LNFS/LBPT. For example, two buildings which are specified as being F AR in the sketch
map cannot be matched to two buildings which are N EAR in the geo-referenced map.
The main limitation of the new spatial logics is that they require a level of tolerance 
and when using the logics, the value of  is the same for spatial objects of different sizes
and types (such as buildings, roads, rivers and lakes). For example, the margin of error
used for cities should be larger than that for buildings. Ideally, the value of  should vary
by the size and type of the spatial object being checked. This motivates the development
of new spatial logics to reason about the sizes and types of spatial objects, in addition to
their relative locations.
In this paper, the theorems were all proved with respect to a metric space. However,
models based on a metric space may not be realisable in a 2D Euclidean space, which is
more realistic for geospatial data. Suppose there are four points pi , where i  {1, 2, 3, 4}.
For each point pi , d(pi , pi ) = 0. For any pair of them, d(pi , pj ) = d(pj , pi ) = 1. It is clear
that there is a metric space satisfying all the distance constraints, but there is no such
2D Euclidean space. Wolter and Zakharyaschev (2003, 2005) proved that the satisfiability
problem for a finite set of M S(Q0 ) formulas in a 2D Euclidean space R2 is undecidable,
whilst its proper fragments may be decidable. We proved that the satisfiability problem
for a finite set of LNF formulas in a 2D Euclidean space is decidable in PSPACE (Du,
2015), but whether the satisfiability problem for a finite set of LNFS/LBPT formulas in a
2D Euclidean space is decidable is still unknown. It also remains open that whether the
LNF/LNFS/LBPT calculus is complete for models based on a 2D Euclidean space. If not,
a theoretical challenge is to design logics which are complete for 2D Euclidean spaces, and
hence provide more accurate debugging of matches than the logics of metric spaces.
Finally, the use of description logic and the new spatial logics may not be able to detect
all the wrong matches. For example, for spatial objects X, Y in one dataset and X 0 , Y 0 in
the other dataset, if sameAs(X, X 0 ) is correct, Y is N EAR and to the south of X, and Y 0
is N EAR and to the north of X 0 , then sameAs(Y, Y 0 ) is wrong but cannot be detected.
To deal with this, we could extend the logics with existing spatial formalisms for reasoning
about directional relations (Frank, 1991, 1996; Ligozat, 1998; Balbiani et al., 1999; Goyal
& Egenhofer, 2001; Skiadopoulos & Koubarakis, 2004).
734

fiQualitative Spatial Logics for Buffered Geometries

9. Conclusion and Future Work
We presented a series of new qualitative spatial logics LNF, LNFS and LBPT for validating
matches between spatial objects, especially in crowd-sourced geospatial data. For models
based on a metric space, a sound and complete axiomatisation is provided and corresponding
theorems are proved for each logic. The LNF, LNFS and LBPT satisfiability problems in
a metric space are all NP-complete. An LBPT reasoner with an ATMS was implemented
and used as a part of MatchMaps. Experimental results show that the LBPT reasoner
can be used to verify consistency of matches with respect to location information and
detect obvious logical errors effectively. As future work, we will investigate whether the
LNF/LNFS/LBPT calculus is complete for models based on a 2D Euclidean space and
develop new spatial logics (e.g. for reasoning about directional relations and object sizes in
addition to distances) to provide more accurate debugging of matches.

Acknowledgments
We would like to thank the anonymous reviewers who provided excellent comments that
helped us improve the paper.

Appendix A. Proofs
Lemma 9 If + is an M CS, then for any pair of individual names a, b occurring in ,
exactly one of the following cases holds in + :
1. case(a, b) = BP T (a, b)  BP T (b, a);
2. case(a, b) = BP T (a, b)  BP T (b, a);
3. case(a, b) = BP T (a, b)  BP T (b, a);
4. case(a, b) = BP T (a, b)  BP T (b, a)  N EAR(a, b);
5. case(a, b) = N EAR(a, b)  F AR(a, b);
6. case(a, b) = F AR(a, b),
where case(a, b) denotes the formula which holds between a, b in each case.
Proof. For any pair of individual names a, b occurring in + , we have:
` (B  B 1  N  F )  (B  B 1  N  F )  (B  B 1  N  F )  (B  B 1  N  F )
(B  B 1  N  F )  (B  B 1  N  F )  (B  B 1  N  F )  (B  B 1  N  F )
(B  B 1  N  F )  (B  B 1  N  F )  (B  B 1  N  F )  (B  B 1  N  F )
(BB 1 N F )(BB 1 N F )(BB 1 N F )(BB 1 N F )
where B, B 1 , N, F stand for BP T (a, b), BP T (b, a), N EAR(a, b), F AR(a, b) respectively.
From Table 3, we have
` (B  B 1 )  (B  B 1 )  (B  B 1 )  (B  B 1  N )  (N  F )  F .
735

fiDu & Alechina

B
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0

B 1
1
1
1
1
0
0
0
0
1
1
1
1
0
0
0
0

N
1
1
0
0
1
1
0
0
1
1
0
0
1
1
0
0

F
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0

Prime Implicant

B  B 1



B  B 1



B  B 1



B  B 1  N
F
N  F

Axiom/Fact used
Fact 15
Facts 14, 15, Axiom
Fact 14, Axiom 3
Fact 14, Axiom 3
Fact 15
Facts 14, 15, Axiom
Fact 14, Axiom 3
Fact 14, Axiom 3
Fact 15
Facts 14, 15, Axiom
Fact 14, Axiom 3
Fact 14, Axiom 3
Fact 15
Fact 15
Facts 14, 15, Axiom
Fact 14, Axiom 3

3

3

3

3

Table 3: truth table, 1 stands for true, 0 stands for false


Lemma 11 For any distance range g occurring in D(+ ),
g  {{0}, [0, ], (, ), [0, 2], (2, ), (2, 4], (4, ), [0, )}.
Proof. Suppose p, q are constants and d(p, q)  g is in D(+ ). Let us look at g in all
different cases:
 p = q: by Definition 13, g = {0}.
 p 6= q:
 p  points(a), q  points(a), for some individual name a:
by Definition 13, g = [0, ).
 p  points(a), q  points(b), for different individual names a, b:
by Lemma 9 and Definition 10, exactly one of following cases holds:
C1
C2
C3
C4
C5
C6

{(a, b, [0, ]), (b, a, [0, ])}  B(+ )
{(a, b, [0, ]), (b, a, (, ))}  B(+ )
{(a, b, (, )), (b, a, [0, ])}  B(+ )
{(a, b, (, )), (b, a, (, )), (a, b, [0, 2]), (b, a, [0, 2])}  B(+ )
{(a, b, (2, )), (b, a, (2, )), (a, b, [0, 4]), (b, a, [0, 4])}  B(+ )
{(a, b, (4, )), (b, a, (4, ))}  B(+ )

In C1:
 if exactly one of p, q is a witness of (a, b, [0, ]) or (b, a, [0, ]), then by
Definition 13, in the construction process, d(p, q)  [0, ] will be added to
736

fiQualitative Spatial Logics for Buffered Geometries

D(+ ), and then d(p, q)  [0, +) will be added to D(+ ). Since [0, ] 
[0, +) = [0, ], g = [0, ].
 else if p is a witness of (b, a, [0, ]) and q is a witness of (a, b, [0, ]), then
by Definition 13, in the construction process, d(p, q)  [0, ] will be added
to D(+ ), and then d(p, q)  [0, ] will be added to D(+ ) again, and then
d(p, q)  [0, +) will be added to D(+ ). Since [0, ]  [0, ]  [0, +) =
[0, ], g = [0, ].
 else, by Definition 13, g = [0, +).
In C2:
 if q is a witness of (a, b, [0, ]), then by Definition 13, in the construction
process, d(p, q)  [0, ] will be added to D(+ ), and then d(p, q)  [0, )
will be added to D(+ ). Since [0, ]  [0, ) = [0, ], g = [0, ].
 else if q is a witness of (b, a, (, )), then by Definition 13, in the construction process, d(p, q)  (, ) will be added to D(+ ), and then d(p, q) 
[0, ) will be added to D(+ ). Since (, )  [0, ) = (, ), g = (, ).
 else, by Definition 13, g = [0, +).
In C3:
 if p is a witness of (a, b, (, )), then by Definition 13, in the construction
process, d(p, q)  (, ) will be added to D(+ ), and then d(p, q)  [0, )
will be added to D(+ ). Since (, )  [0, ) = (, ), g = (, ).
 else if p is a witness of (b, a, [0, ]), then by Definition 13, in the construction
process, d(p, q)  [0, ] will be added to D(+ ), and then d(p, q)  [0, )
will be added to D(+ ). Since [0, ]  [0, ) = [0, ], g = [0, ].
 else, by Definition 13, g = [0, +).
In C4:
 if the pair p, q is a witness of (a, b, [0, 2]), then by Definition 13, in the
construction process, d(p, q)  [0, 2] will be added to D(+ ), and then
d(p, q)  [0, ) will be added to D(+ ). Since [0, 2]  [0, ) = [0, 2],
g = [0, 2].
 else if exactly one of p, q is a witness of (a, b, (, )) or (b, a, (, )),
then by Definition 13, in the construction process, d(p, q)  (, ) will be
added to D(+ ), and then d(p, q)  [0, ) will be added to D(+ ). Since
(, )  [0, ) = (, ), g = (, ).
 else if p is a witness of (a, b, (, )) and q is a witness of (b, a, (, )), then
by Definition 13, in the construction process, d(p, q)  (, ) will be added
to D(+ ), and then d(p, q)  (, ) will be added to D(+ ) again, and then
d(p, q)  [0, ) will be added to D(+ ). Since (, )  (, )  [0, ) =
(, ), g = (, ).
 else, by Definition 13, g = [0, +).
In C5:
 if the pair p, q is a witness of (a, b, [0, 4]), then by Definition 13, in the
construction process, d(p, q)  [0, 4] will be added to D(+ ), and then,
737

fiDu & Alechina

d(p, q)  (2, ) will be added to satisfy the  formulas, and then d(p, q) 
[0, ) will be added to D(+ ). Since [0, 4]  (2, )  [0, ) = (2, 4],
g = (2, 4].
 else, by Definition 13, d(p, q)  (2, ) will be added to satisfy the  formulas, then d(p, q)  [0, ) will be added to D(+ ). Since (2, )  [0, ) =
(2, ), g = (2, ).
In C6, by Definition 13, d(p, q)  (4, ) will be added, then d(p, q)  [0, )
will be added to D(+ ). Since (4, )  [0, ) = (4, ), g = (4, ).
Therefore, g  {{0}, [0, ], (, ), [0, 2], (2, ), (2, 4], (4, ), [0, )}. 
Lemma 16 (Calculation of Composition) If (m, n), (s, t), (m, ), (s, ), {l},
{r} are non-negative non-empty intervals, H1 , H2 , H are non-negative intervals, then the
following calculation rules hold:
1. {l}  {r} = [l  r, l + r], if l  r;
2. {l}  (s, t) = (s  l, t + l), if s  l;
3. {l}  (s, t) = [0, t + l), if l  (s, t);
4. {l}  (s, t) = (l  t, t + l), if t  l;
5. {l}  (s, +) = (s  l, +), if s  l;
6. {l}  (s, +) = [0, +), if s < l;
7. (m, n)  (s, t) = (s  n, t + n), if s  n;
8. (m, n)  (s, t) = [0, t + n), if (m, n)  (s, t) 6= ;
9. (m, n)  (s, +) = (s  n, +), if s  n;
10. (m, n)  (s, +) = [0, +), if s < n;
11. (m, +)  (s, +) = [0, +);
12. H1   = ;
13. H1  H2 = H2  H1 ;
14. (H1  H2 )  H = (H1  H)  (H2  H);
S
S
15. ( k Hk )  H = k (Hk  H), where k  N>0 ;
16. (H1  H2 )  H = (H1  H)  (H2  H), if (H1  H2 ) 6= ;
17. (H1  H2 )  H = H1  (H2  H).
738

fiQualitative Spatial Logics for Buffered Geometries

S
S
Proof.[for Rule 15] Suppose d  ( k Hk )  H.S By Lemma 15, there exist d1  k Hk and
d2  H such that d  {d1 }  {d2 }. Since d1  k Hk , then there exists a k  N>0 such that
d1  Hk . SinceSd1  Hk for some k, d2  H, then by Definition 7, d  Hk  H, for some k.
Therefore d  k (Hk  H).
S
Suppose S
d  k (Hk  H). Then, thereSexists a k  N>0 such that d  Hk  H.
Since Hk  k Hk , by Definition 7, d  ( k Hk )  H. 
Proof.[for Rule 16] Suppose H1  H2 6= . Then, Hi 6= , i  {1, 2}. Since H1 , H2 , H
are non-negative intervals, by the intersection rules and Definition 7, (H1  H2 )  H and
(H1 H)(H2 H) are non-negative intervals. Let L = (H1 H2 )H, R = (H1 H)(H2 H).
If H = , then by Rule 12, L = R = ; otherwise, we show L = R by cases:
 H1  H2 or H2  H1 : When H1  H2 , then Definition 7, H1  H  H2  H.
L = H2  H = R. When H2  H1 , similarly, L = H1  H = R.
 H1 6 H2 and H2 6 H1 : Without loss of generality, let us suppose glb(H1 )  glb(H2 ) 
lub(H1 )  lub(H2 ). Then, glb(H1  H2 ) = glb(H2 ), lub(H1  H2 ) = lub(H1 ).
To prove L = R, it is sufficient to show the following properties hold:
1. lub(L) = lub(R);
2. glb(L) = glb(R);
3. lub(L)  L iff lub(R)  R;
4. glb(L)  L iff glb(R)  R.
By Rules 1-14 and intersection rules, lub(L) = lub(H1  H2 ) + lub(H) = lub(H1 ) +
lub(H). lub(R) = min(lub(H1 ) + lub(H), lub(H2 ) + lub(H)) = lub(H1 ) + lub(H).
Thus, lub(L) = lub(R) (Property 1 holds).
If lub(H1 )  H1 and lub(H)  H, then by Rules 1-14 and intersection rules, lub(L)  L
and lub(R)  R; otherwise, lub(L) 6 L and lub(R) 6 R. Thus, Property 3 holds.
We prove Property 2 and Property 4 by cases:
 H  H1 =  and H  H2 = :
 lub(H)  glb(H1 ):
glb(L) = glb(H1  H2 )  lub(H) = glb(H2 )  lub(H).
glb(R) = max(glb(H1 )  lub(H), glb(H2 )  lub(H)) = glb(H2 )  lub(H).
Thus, glb(L) = glb(R) (Property 2 holds).
If glb(H2 )  H2 and lub(H)  H, then by Rules 1-14 and intersection rules,
glb(L)  L and glb(R)  R; otherwise, glb(L) 6 L and glb(R) 6 R. Thus,
Property 4 holds.
 glb(H)  lub(H2 ):
glb(L) = glb(H)  lub(H1  H2 ) = glb(H)  lub(H1 ).
glb(R) = max(glb(H)  lub(H1 ), glb(H)  lub(H2 )) = glb(H)  lub(H1 ).
Similar to the case above, it is clear that Property 2 and Property 4 hold.
 H  H1 6=  and H  H2 = : then, H  (H1  H2 ) = .
glb(L) = glb(H1  H2 )  lub(H) = glb(H2 )  lub(H).
739

fiDu & Alechina

glb(R) = max(0, glb(H2 )  lub(H)) = glb(H2 )  lub(H).
Similar to the cases above, it is clear that Property 2 and Property 4 hold.
 H  H1 =  and H  H2 6= : then, H  (H1  H2 ) = .
glb(L) = glb(H)  lub(H1  H2 ) = glb(H)  lub(H1 ).
glb(R) = max(glb(H)  lub(H1 ), 0) = glb(H)  lub(H1 ).
Similar to the cases above, it is clear that Property 2 and Property 4 hold.
 H  H1 6=  and H  H2 6= :
since H1 , H2 , H are intervals and H1  H2 6= , H  (H1  H2 ) 6= .
glb(L) = 0.
glb(R) = max(0, 0) = 0.
By Rules 1-14, glb(L)  L and glb(R)  R.
It is clear that Property 2 and Property 4 hold.
In every case, Properties 1-4 hold.
Therefore, L = R. 
Proof.[for Rule 17] Let
S L = (H1  H2 )  H, R = H1  (H2  H).
By Definition 7, LS= ( d1 H1 ,d2 H2 {d1 }  {d2 })  H.
By Rule 15, L = d1 H1 ,d2 H2 (({d1 }  {d2 })  H).
By Rule 13, ({d1 }  {d2 })  H = H
S  ({d1 }  {d2 }).
By Rule 15, H  ({d
S 1 }  {d2 }) = dH ({d}  ({d1 }  {d2 })).
By Rule 13, L =
S d1 H1 ,d2 H2 ,dH (({d1 }  {d2 })  {d}).
Similarly, R = d1 H1 ,d2 H2 ,dH ({d1 }  ({d2 }  {d})).
To prove L = R, it is sufficient to show
({d1 }  {d2 })  {d} = {d1 }  ({d2 }  {d}).
Let l = ({d1 }  {d2 })  {d}, then l = [|d1  d2 |, d1 + d2 ]  {d};
r = {d1 }  ({d2 }  {d}), then r = {d1 }  [|d2  d|, d2 + d].
We prove l = r by cases:
 d  [|d1  d2 |, d1 + d2 ]: By Definition 7, l = [0, d1 + d2 + d].
d1 + d2  d, d2 + d  d1 , d1 + d  d2 .
Thus, d1  [|d2  d|, d2 + d]. By Definition 7, r = [0, d1 + d2 + d].
 d 6 [|d1  d2 |, d1 + d2 ]:
 d > d1 + d2 : By Definition 7, l = [d  d1  d2 , d1 + d2 + d].
d1 < d  d2 = |d2  d|.
By Definition 7, r = [d  d2  d1 , d1 + d2 + d].
 d < |d1  d2 |: By Definition 7, l = [|d1  d2 |  d, d1 + d2 + d].
 d1  d2 : d < d1  d2 , this is, d1 > d2 + d.
By Definition 7, r = [d1  d2  d, d1 + d2 + d].
 d1 < d2 : d < d2  d1 , this is, d1 < d2  d.
By Definition 7, r = [d2  d  d1 , d1 + d2 + d].
In each case, l = r. Therefore, L = R. 

740

fiQualitative Spatial Logics for Buffered Geometries

Appendix B. Alternative Proof of the Path-Consistency Lemma
In this appendix, we would like to provide a sketch of an alternative proof idea of the
Path-Consistency Lemma, since it may appeal to some of the readers more than the proof
presented in Section 5.3. The alternative proof uses Lemma 44.
Lemma 44 If a distance constraint d(p, q)  h is in DS(+ ) and h =
6 , then there exist
+
d(p, q)  m1 and d(p, q)  m2 in DS( ) such that h = m1  m2 , m1 and m2 are both
identity or definable intervals.
Proof. By Lemma 31, d(p, q)  h is left-definable and right-definable. By Definition 16,
there exists a sequence of distance constraints d(pi , pi+1 )  hi (p1 = p, pn = q, 0 < i < n)
in D(+ ), such that for m1 = h1  ...  hn1 , h  m1 , h and m1 have the same greatest
lower bound (both value and openness). By Definition 15, d(p, q)  m1 is in DS(+ ). By
Lemma 21 and Definition 14, m1 is an identity or definable interval. Similarly, by Definition 17, there exists an m2 such that h  m2 , h and m2 have the same least upper bound
(both value and openness), d(p, q)  m2 is in DS(+ ), m2 is an identity or definable interval. By intersection rules, h = m1  m2 . 
Proof.[sketch of the alternative proof of the Path-Consistency Lemma] Suppose D(+ ) is
not path-consistent. Then there exist d(p, q)  g1 and d(p, q)  g2 in DS(+ ), g1 6= ,
g2 6= , and g1  g2 = . By Lemma 44, there exist d(p, q)  m1 and d(p, q)  s1 in DS(+ )
such that g1 = m1  s1 , m1 and s1 are both identity or definable intervals. Similarly, we
have g2 = m2  s2 , where m2 and s2 are both identity or definable intervals. g1  g2 = 
holds iff one of the following holds: m1  m2 = , m1  s2 = , s1  m2 = , s1  s2 = .
Without loss of generality, let us suppose m1  m2 = . By Lemma 35, m1  m2 = 
iff (m1  m2 )  {0} = . Let m = m1  m2 . Then m is an identity or definable interval.
Since d(p, q)  m1 and d(p, q)  m2 are in DS(+ ), m1 6= , m2 6= , then by Lemma 31,
d(p, q)  m1 and d(p, q)  m2 are left-definable and right-definable. Since d(p, q)  m2 , we
have d(q, p)  m2 . By Lemma 29, d(p, p)  m is left-definable and right-definable. The rest
of the proof is almost the same as the proof of the Path-Consistency Lemma (starting from
By Lemma 23, glb(h0 )  {0, , 2, 3, 4}) presented in Section 5.3. We discuss different
ways to obtain m given its greatest lower bound (the role of m is similar to h0 ) and check
whether  can be derived in every valid case. 

Appendix C. Consequences of the Path-Consistency Lemma
In this appendix, we state explicitly some implications of the Path-Consistency Lemma.
Lemma 45 Let  be a finite consistent set of formulas. If a distance constraint d(p, q)  h
is in DS(+ ), then h 6= .
Proof. Follows immediately from the proof of the Path-Consistency Lemma. 
Lemma 46 Let  be a finite consistent set of formulas. If a distance constraint d(p, p)  h
is in DS(+ ), then 0  h.
741

fiDu & Alechina

Proof. Suppose a distance constraint d(p, p)  h is in DS(+ ) and 0 6 h. By Definition 13
and Definition 15, d(p, p)  {0} is in D(+ ). By Definition 15, d(p, p)  (h  {0}) = . This
contradicts the fact that d(p, p)   is not in DS(+ ) (by Lemma 45). Therefore, 0  h. 

References
Aiello, M., Pratt-Hartmann, I., & van Benthem, J. (Eds.). (2007). Handbook of Spatial
Logics. Springer.
Allen, J. F. (1983). Maintaining Knowledge about Temporal Intervals. Communications of
the ACM, 26 (11), 832843.
Balbiani, P., Condotta, J., & del Cerro, L. F. (1999). A New Tractable Subclass of the
Rectangle Algebra. In Proceedings of the 16th International Joint Conference on
Artifical Intelligence, pp. 442447.
Bennett, B. (1996). The Application of Qualitative Spatial Reasoning to GIS. In Proceedings
of the 1st International Conference on GeoComputation, Vol. I, pp. 4447.
Bennett, B., Cohn, A. G., & Isli, A. (1997). A Logical Approach to Incorporating Qualitative Spatial Reasoning into GIS (Extended Abstract). In Proceedings of the 3rd
International Conference on Spatial Information Theory, Vol. 1329 of Lecture Notes
in Computer Science, pp. 503504. Springer.
Chen, J., Cohn, A. G., Liu, D., Wang, S., OuYang, J., & Yu, Q. (2015). A survey of
qualitative spatial representations. The Knowledge Engineering Review, 30 (1), 106
136.
Clementini, E., & Felice, P. D. (1996). An algebraic model for spatial objects with indeterminate boundaries. In Proceedings of the GISDATA specialist meeting on Geographic
Objects with Undeterminate Boundaries, pp. 155169.
Clementini, E., & Felice, P. D. (1997). Approximate Topological Relations. International
Journal of Approximate Reasoning, 16 (2), 173204.
Clementini, E., Felice, P. D., & Hernandez, D. (1997). Qualitative Representation of Positional Information. Artificial Intelligence, 95 (2), 317356.
Cohn, A. G., & Gotts, N. M. (1996a). Representing Spatial Vagueness: A Mereological Approach. In Proceedings of the 5th International Conference on Principles of Knowledge
Representation and Reasoning, pp. 230241.
Cohn, A. G., & Gotts, N. M. (1996b). The Egg-Yolk Representation of Regions with
Indeterminate Boundaries. In Proceedings of the GISDATA Specialist Meeting on
Geographical Objects with Undetermined Boundaries, pp. 171187.
Cohn, A. G., & Renz, J. (2008). Qualitative Spatial Representation and Reasoning. In
Handbook of Knowledge Representation, pp. 551596. Elsevier.
de Kleer, J. (1986). An assumption-based TMS. Artificial Intelligence, 28 (2), 127162.
Du, H. (2015). Matching Disparate Geospatial Datasets and Validating Matches using Spatial
Logic. Ph.D. thesis, School of Computer Science, University of Nottingham, UK.
742

fiQualitative Spatial Logics for Buffered Geometries

Du, H., & Alechina, N. (2014a). A Logic of Part and Whole for Buffered Geometries. In
Proceedings of the 21st European Conference on Artificial Intelligence, pp. 997998.
Du, H., & Alechina, N. (2014b). A Logic of Part and Whole for Buffered Geometries. In
Proceedings of the 7th European Starting AI Researcher Symposium, pp. 91100.
Du, H., Alechina, N., Hart, G., & Jackson, M. (2015). A Tool for Matching Crowd-sourced
and Authoritative Geospatial Data. In Proceedings of the International Conference
on Military Communications and Information Systems, pp. 18. IEEE.
Du, H., Alechina, N., Jackson, M., & Hart, G. (2016).
A Method for Matching Crowd-sourced and Authoritative Geospatial Data. Transactions in GIS.
http://dx.doi.org/10.1111/tgis.12210.
Du, H., Alechina, N., Stock, K., & Jackson, M. (2013). The Logic of NEAR and FAR. In
Proceedings of the 11th International Conference on Spatial Information Theory, Vol.
8116 of Lecture Notes in Computer Science, pp. 475494. Springer.
Du, H., Nguyen, H., Alechina, N., Logan, B., Jackson, M., & Goodwin, J. (2015). Using
Qualitative Spatial Logic for Validating Crowd-Sourced Geospatial Data. In Proceedings of the 29th AAAI Conference on Artificial Intelligence (the 27th Conference on
Innovative Applications of Artificial Intelligence), pp. 39483953.
Egenhofer, M. J. (1997). Query processing in spatial-query-by-sketch. Journal of Visual
Languages and Computing, 8 (4), 403424.
Egenhofer, M. J., & Franzosa, R. D. (1991). Point Set Topological Spatial Relations. International Journal of Geographical Information Systems, 5 (2), 161174.
Egenhofer, M. J., & Herring, J. R. (1991). Categorizing Binary Topological Relations
Between Regions, Lines, and Points in Geographic Databases. Tech. rep., University
of Maine.
Fine, K. (1975). Vagueness, truth and logic. Synthese, 30, 263300.
Frank, A. U. (1991). Qualitative Spatial Reasoning with Cardinal Directions. In Proceedings
of the 7th Austrian Conference on Artificial Intelligence, pp. 157167.
Frank, A. U. (1996). Qualitative Spatial Reasoning: Cardinal Directions as an Example.
International Journal of Geographical Information Science, 10 (3), 269290.
Goyal, R. K., & Egenhofer, M. J. (2001). Similarity of Cardinal Directions. In Jensen, C. S.,
Schneider, M., Seeger, B., & Tsotras, V. J. (Eds.), Advances in Spatial and Temporal
Databases, Vol. 2121 of Lecture Notes in Computer Science, pp. 3655. Springer.
Guesgen, H. W., & Albrecht, J. (2000). Imprecise reasoning in geographic information
systems. Fuzzy Sets and Systems, 113 (1), 121131.
Haklay, M. (2010). How good is volunteered geographical information? A comparative
study of OpenStreetMap and Ordnance Survey datasets. Environment and Planning
B: Planning and Design, 37 (4), 682703.
ISO Technical Committee 211 (2003). ISO 19107:2003 Geographic information  Spatial
schema. Tech. rep., International Organization for Standardization (TC 211).
743

fiDu & Alechina

Jackson, M., Rahemtulla, H., & Morley, J. (2010). The synergistic use of authenticated and
crowd-Sourced data for emergency response. In Proceedings of the 2nd International
Workshop on validation of GeoInformation products for crisis management, pp. 9199.
Kopczynski, M. (2006). Efficient spatial queries with sketches. In Proceedings of the ISPRS
Technical Commission II Symposium, pp. 1924.
Kutz, O. (2007). Notes on Logics of Metric Spaces. Studia Logica, 85 (1), 75104.
Kutz, O., Sturm, H., Suzuki, N., Wolter, F., & Zakharyaschev, M. (2002). Axiomatizing
Distance Logics. Journal of Applied Non-Classical Logics, 12 (3-4), 425440.
Kutz, O., Wolter, F., Sturm, H., Suzuki, N., & Zakharyaschev, M. (2003). Logics of metric
spaces. ACM Transactions on Computational Logic, 4 (2), 260294.
Lehmann, F., & Cohn, A. G. (1994). The EGG/YOLK Reliability Hierarchy: Semantic
Data Integration Using Sorts with Prototypes. In Proceedings of the 3rd International
Conference on Information and Knowledge Management, pp. 272279.
Li, S., Liu, W., & Wang, S. (2013). Qualitative constraint satisfaction problems: An extended framework with landmarks. Artificial Intelligence, 201, 3258.
Li, S., Long, Z., Liu, W., Duckham, M., & Both, A. (2015). On redundant topological
constraints. Artificial Intelligence, 225, 5176.
Ligozat, G. . (1998). Reasoning about Cardinal Directions. Journal of Visual Languages &
Computing, 9 (1), 2344.
Lutz, C., & Milicic, M. (2007). A Tableau Algorithm for Description Logics with Concrete
Domains and General TBoxes. Journal of Automated Reasoning, 38 (1-3), 227259.
Mackworth, A. K., & Freuder, E. C. (1985). The Complexity of Some Polynomial Network
Consistency Algorithms for Constraint Satisfaction Problems. Artificial Intelligence,
25 (1), 6574.
Mallenby, D. (2007). Grounding a Geographic Ontology on Geographic Data. In AAAI
Spring Symposium - Logical Formalizations of Commonsense Reasoning, pp. 101106.
Mallenby, D., & Bennett, B. (2007). Applying Spatial Reasoning to Topographical Data with
a Grounded Ontology. In Proceedings of the 2nd International Conference GeoSpatial
Semantics, No. 4853 in Lecture Notes in Computer Science, pp. 210227. Springer.
Moratz, R., Renz, J., & Wolter, D. (2000). Qualitative Spatial Reasoning about Line
Segments. In Proceedings of the 14th European Conference on Artificial Intelligence,
pp. 234238.
Moratz, R., & Wallgrun, J. O. (2012). Spatial reasoning with augmented points: Extending
cardinal directions with local distances. Journal of Spatial Information Science, 5 (1),
130.
OpenStreetMap (2012). The Free Wiki World Map. http://www.openstreetmap.org.
Ordnance Survey (2012). Ordnance Survey. http://www.ordnancesurvey.co.uk.
Pawlak, Z., Polkowski, L., & Skowron, A. (2007). Rough Set Theory. In Wiley Encyclopedia
of Computer Science and Engineering. John Wiley & Sons, Inc.
744

fiQualitative Spatial Logics for Buffered Geometries

Randell, D. A., Cui, Z., & Cohn, A. G. (1992). A Spatial Logic based on Regions and Connection. In Proceedings of the 3rd International Conference on Principles of Knowledge
Representation and Reasoning, pp. 165176.
Renz, J., & Nebel, B. (2007). Qualitative Spatial Reasoning Using Constraint Calculi. In
Aiello, M., Pratt-Hartmann, I., & van Benthem, J. (Eds.), Handbook of Spatial Logics,
pp. 161215. Springer.
Roy, A. J., & Stell, J. G. (2001). Spatial Relations between Indeterminate Regions. International Journal of Approximate Reasoning, 27 (3), 205234.
Schockaert, S., Cock, M. D., Cornelis, C., & Kerre, E. E. (2008a). Fuzzy region connection
calculus: An interpretation based on closeness. International Journal of Approximate
Reasoning, 48 (1), 332347.
Schockaert, S., Cock, M. D., Cornelis, C., & Kerre, E. E. (2008b). Fuzzy region connection calculus: Representing vague topological information. International Journal of
Approximate Reasoning, 48 (1), 314331.
Schockaert, S., Cock, M. D., & Kerre, E. E. (2009). Spatial reasoning in a fuzzy region
connection calculus. Artificial Intelligence, 173 (2), 258298.
Sirin, E., Parsia, B., Grau, B. C., Kalyanpur, A., & Katz, Y. (2007). Pellet: A practical
OWL-DL reasoner. Journal of Web Semantics, 5 (2), 5153.
Skiadopoulos, S., & Koubarakis, M. (2004). Composing cardinal direction relations. Artificial Intelligence, 152 (2), 143171.
Smith, N. J. (2008). Vagueness and Degrees of Truth. Oxford University Press.
Stocker, M., & Sirin, E. (2009). PelletSpatial: A Hybrid RCC-8 and RDF/OWL Reasoning and Query Engine. In Proceedings of the 5th International Workshop on OWL:
Experiences and Directions.
Sturm, H., Suzuki, N., Wolter, F., & Zakharyaschev, M. (2000). Semi-qualitative Reasoning
about Distances: A Preliminary Report. In Proceedings of the Logics in Artificial
Intelligence, European Workshop, JELIA, pp. 3756.
van Beek, P. (1992). Reasoning About Qualitative Temporal Information. Artificial Intelligence, 58 (1-3), 297326.
Wallgrun, J. O., Wolter, D., & Richter, K. (2010). Qualitative matching of spatial information. In Proceedings of the 18th ACM SIGSPATIAL International Symposium on
Advances in Geographic Information Systems, pp. 300309.
Wolter, F., & Zakharyaschev, M. (2003). Reasoning about Distances. In Proceedings of the
18th International Joint Conference on Artificial Intelligence, pp. 12751282.
Wolter, F., & Zakharyaschev, M. (2005). A logic for metric and topology. Journal of
Symbolic Logic, 70 (3), 795828.
Zadeh, L. A. (1975). Fuzzy logic and approximate reasoning. Synthese, 30 (3-4), 407428.
Zimmermann, K. (1995). Measuring without Measures: The Delta-Calculus. In Proceedings
of the 2nd International Conference on Spatial Information Theory, pp. 5967.

745

fi