Journal of Artificial Intelligence Research 36 (2009) 169

Submitted 04/09; published 10/09

The DL-Lite Family and Relations
Alessandro Artale
Diego Calvanese

artale@inf.unibz.it
calvanese@inf.unibz.it

KRDB Research Centre
Free University of Bozen-Bolzano
Piazza Domenicani, 3 I-39100 Bolzano, Italy

Roman Kontchakov
Michael Zakharyaschev

roman@dcs.bbk.ac.uk
michael@dcs.bbk.ac.uk

Department of Computer Science and Information Systems
Birkbeck College
Malet Street, London WC1E 7HX, U.K.

Abstract
The recently introduced series of description logics under the common moniker DLLite has attracted attention of the description logic and semantic web communities due to
the low computational complexity of inference, on the one hand, and the ability to represent
conceptual modeling formalisms, on the other. The main aim of this article is to carry out
a thorough and systematic investigation of inference in extensions of the original DL-Lite
logics along five axes: by (i) adding the Boolean connectives and (ii) number restrictions to
concept constructs, (iii) allowing role hierarchies, (iv) allowing role disjointness, symmetry,
asymmetry, reflexivity, irreflexivity and transitivity constraints, and (v) adopting or dropping the unique name assumption. We analyze the combined complexity of satisfiability
for the resulting logics, as well as the data complexity of instance checking and answering
positive existential queries. Our approach is based on embedding DL-Lite logics in suitable fragments of the one-variable first-order logic, which provides useful insights into their
properties and, in particular, computational behavior.

1. Introduction
Description Logic (cf. Baader, Calvanese, McGuinness, Nardi, & Patel-Schneider, 2003 and
references therein) is a family of knowledge representation formalisms developed over the
past three decades and, in recent years, widely used in various application areas such as:
 conceptual modeling (Bergamaschi & Sartori, 1992; Calvanese et al., 1998b, 1999;
McGuinness & Wright, 1998; Franconi & Ng, 2000; Borgida & Brachman, 2003; Berardi, Calvanese, & De Giacomo, 2005; Artale et al., 1996, 2007, 2007b),
 information and data integration (Beeri, Levy, & Rousset, 1997; Levy & Rousset,
1998; Goasdoue, Lattes, & Rousset, 2000; Calvanese et al., 1998a, 2002a, 2002b,
2008; Noy, 2004; Meyer, Lee, & Booth, 2005),
 ontology-based data access (Dolby et al., 2008; Poggi et al., 2008a; Heymans et al.,
2008),
 the Semantic Web (Heflin & Hendler, 2001; Horrocks, Patel-Schneider, & van Harmelen, 2003).
c
2009
AI Access Foundation. All rights reserved.

fiArtale, Calvanese, Kontchakov & Zakharyaschev

Description logics (DLs, for short) underlie the standard Web Ontology Language OWL,1
which is now in the process of being standardized by the W3C in its second edition, OWL 2.
The widespread use of DLs as flexible modeling languages stems from the fact that,
similarly to more traditional modeling formalisms, they structure the domain of interest into
classes (or concepts, in the DL parlance) of objects with common properties. Properties
are associated with objects by means of binary relationships (or roles) to other objects.
Constraints available in standard DLs also resemble those used in conceptual modeling
formalisms for structuring information: is-a hierarchies (i.e., inclusions) and disjointness
for concepts and roles, domain and range constraints for roles, mandatory participation in
roles, functionality and more general numeric restrictions for roles, covering within concept
hierarchies, etc. In a DL knowledge base (KB), these constraints are combined to form a
TBox asserting intensional knowledge, while an ABox collects extensional knowledge about
individual objects, such as whether an object is an instance of a concept, or two objects are
connected by a role. The standard reasoning services over a DL KB include checking its
consistency (or satisfiability), instance checking (whether a certain individual is an instance
of a concept), and logic entailment (whether a certain constraint is logically implied by
the KB). More sophisticated services are emerging that can support modular development
of ontologies by checking, for example, whether one ontology is a conservative extension
of another with respect to a certain vocabulary (see, e.g., Ghilardi, Lutz, & Wolter, 2006;
Cuenca Grau, Horrocks, Kazakov, & Sattler, 2008; Kontchakov, Wolter, & Zakharyaschev,
2008; Kontchakov, Pulina, Sattler, Schneider, Selmer, Wolter, & Zakharyaschev, 2009).
Description logics have recently been used to provide access to large amounts of data
through a high-level conceptual interface, which is of relevance to both data integration and
ontology-based data access. In this setting, the TBox constitutes the conceptual, high-level
view of the information managed by the system, and the ABox is physically stored in a
relational database and accessed using the standard relational database technology (Poggi
et al., 2008a; Calvanese et al., 2008). The fundamental inference service in this case is answering queries to the ABox with the constraints in the TBox taken into account. The kind
of queries that have most often been considered are first-order conjunctive queries, which
correspond to the commonly used Select-Project-Join SQL queries. The key properties
for such an approach to be viable in practice are (i) efficiency of query evaluation, with the
ideal target being traditional database query processing, and (ii) that query evaluation can
be done by leveraging the relational technology already used for storing the data.
With these objectives in mind, a series of description logicsthe DL-Lite familyhas
recently been proposed and investigated by Calvanese, De Giacomo, Lembo, Lenzerini,
and Rosati (2005, 2006, 2008a), and later extended by Artale, Calvanese, Kontchakov,
and Zakharyaschev (2007a), Poggi, Lembo, Calvanese, De Giacomo, Lenzerini, and Rosati
(2008a). Most logics of the family meet the requirements above and, at the same time, are
capable of representing many important types of constraints used in conceptual modeling.
In particular, inference in various DL-Lite logics can be done efficiently both in the size
of the data (data complexity) and in the overall size of the KB (combined complexity):
it was shown that KB satisfiability in these logics is polynomial for combined complexity,
while answering queries is in AC0 for data complexitywhich, roughly, means that, given a
1. http://www.w3.org/2007/OWL/

2

fiThe DL-Lite Family and Relations

conjunctive query over a KB, the query and the TBox can be rewritten (independently of the
ABox) into a union of conjunctive queries over the ABox alone. (It is to be emphasized that
the data complexity measure is very important in the application context of the DL-Lite
logics, since one can reasonably assume that the size of the data largely dominates the size
of the TBox.) Query rewriting techniques have been implemented in various systems such as
QuOnto2 (Acciarri, Calvanese, De Giacomo, Lembo, Lenzerini, Palmieri, & Rosati, 2005;
Poggi, Rodriguez, & Ruzzi, 2008b), ROWLKit (Corona, Ruzzi, & Savo, 2009), Owlgres
(Stocker & Smith, 2008) and REQUIEM (Perez-Urbina, Motik, & Horrocks, 2009). It has
also been demonstrated (Kontchakov et al., 2008) that developing, analyzing and re-using
DL-Lite ontologies (TBoxes) can be supported by efficient tools capable of checking various
types of entailment between such ontologies with respect to given vocabularies, in particular,
by minimal module extraction tools (Kontchakov et al., 2009)which do not yet exist for
richer languages.
The significance of the DL-Lite family is testified by the fact that it forms the basis
of OWL 2 QL, one of the three profiles of OWL 2.3 The OWL 2 profiles are fragments of
the full OWL 2 language that have been designed and standardized for specific application
requirements. According to (the current version of) the official W3C profiles document, the
purpose of OWL 2 QL is to be the language of choice for applications that use very large
amounts of data and where query answering is the most important reasoning task.
The common denominator of the DL-Lite logics constructed so far is as follows: (i) quantification over roles and their inverses is not qualified (in other words, in concepts of the
form R.C we must have C = >) and (ii) the TBox axioms are concept inclusions that cannot represent any kind of disjunctive information (say, that two concepts cover the whole
domain). The other DL-Lite-related dialects were designedwith the aim of capturing
more conceptual modeling constraints, but in a somewhat ad hoc mannerby extending
this core language with a number of constructs such as global functionality constraints,
role inclusions and restricted Boolean operators on concepts (see Section 4 for details).
Although some attempts have been made (Calvanese et al., 2006; Artale et al., 2007a;
Kontchakov & Zakharyaschev, 2008) to put the original DL-Lite logics into a more general
perspective and investigate their extensions with a variety of DL constructs required for
conceptual modeling, the resulting picture still remains rather fragmentary and far from
comprehensive. A systematic investigation of the DL-Lite family and relatives has become
even more urgent and challenging in view of the choice of the constructs to be included in
the specification of the OWL 2 QL profile4 (in particular, because OWL does not make the
unique name assumption, UNA, which was usually adopted in DL-Lite, and uses equalities
and inequalities between object names instead).
The main aim of this article is to fill in this gap and provide a thorough and comprehensive understanding of the interaction between various DL-Lite constructs and their impact
on the computational complexity of reasoning. To achieve this goal, we consider a spectrum
of logics, classified according to five mutually orthogonal features:
(1) the presence or absence of role inclusions;
2. http://www.dis.uniroma1.it/quonto/
3. http://www.w3.org/TR/owl2-profiles/
4. http://www.w3.org/TR/owl2-profiles/#OWL_2_QL

3

fiArtale, Calvanese, Kontchakov & Zakharyaschev

(2) the form of the allowed concept inclusions, where we consider four classes, called core,
Krom, Horn, and Bool, that exhibit different computational properties;
(3) the form of the allowed numeric constraints, ranging from none, to global functionality
constraints only, and to arbitrary number restrictions;
(4) the presence or absence of the unique name assumption (and the equalities and inequalities between object names, if this assumption is dropped); and
(5) the presence or absence of standard role constraints such as disjointness, symmetry,
asymmetry, reflexivity, irreflexivity, and transitivity.
For all the resulting cases, we investigate the combined and data complexity of KB satisfiability and instance checking, as well as the data complexity of query answering. The
obtained tight complexity results are summarized in Section 3.4 (Table 2 and Remark 3.1).
As already mentioned, the original motivation and distinguishing feature for the logics in
the DL-Lite family was their lite-ness in the sense of low computational complexity of the
reasoning tasks (query answering in AC0 for data complexity and tractable KB satisfiability
for combined complexity). In the broader perspective we take here, not all of our logics
meet this requirement, in particular, those with Krom or Bool concept inclusions.5 However,
we identify another distinguishing feature that can be regarded as the natural logic-based
characterization of the DL-Lite family: embeddability into the one-variable fragment of firstorder logic without equality and function symbols. This allows us to relate the complexity of
DL-Lite logics to the complexity of the corresponding fragments of first-order logic, and thus
to obtain a deep insight into the underlying logical properties of each DL-Lite variant. For
example, most upper complexity bounds established below follow from this embedding and
well-known results on the classical decision problem (see, e.g., Borger, Gradel, & Gurevich,
1997) and descriptive complexity (see, e.g., Immerman, 1999).
One of the most interesting findings in this article is that number restrictions, even
expressed locally, instead of global role functionality, can be added to the original DL-Lite
logics (under the UNA and without role inclusions) for free, that is, without changing
their computational complexity. The first-order approach shows that in most cases we can
also extend the DL-Lite logics with the role constraints mentioned above, again keeping the
same complexity. It also gives a framework to analyze the effect of adopting or dropping
the UNA and using (in)equalities between object names. For example, we observe that if
equality is allowed in the language of DL-Lite (which only makes sense without the UNA)
then query answering becomes LogSpace-complete for data complexity, and therefore not
first-order rewritable. It also turns out that dropping the UNA results in P-hardness of
reasoning (for both combined and data complexity) in the presence of functionality constraints (NLogSpace-hardness was shown by Calvanese et al., 2008), and in NP-hardness
if arbitrary number restrictions are allowed.
Another interesting finding is the dramatic impact of role inclusions, when combined
with number restrictions (or even functionality constraints), on the computational complexity of reasoning. As was already observed by Calvanese et al. (2006), such a combination increases data complexity of instance checking from membership in LogSpace to
5. Note, by the way, that logics with Bool concept inclusions turn out to be quite useful in conceptual
modeling and reasonably manageable computationally (Kontchakov et al., 2008).

4

fiThe DL-Lite Family and Relations

NLogSpace-hardness. We show here that the situation is actually even worse: for data
complexity, instance checking turns out to be P-complete in the case of core and Horn
logics and coNP-complete in the case of Krom and Bool logics; moreover, KB satisfiability,
which is NLogSpace-complete for combined complexity in the simplest core casei.e., efficiently tractable, when role inclusions or number restrictions are used separatelybecomes
ExpTime-completei.e., provably intractable, when they are used together.
To retain both role inclusions and functionality constraints in the language and keep
complexity within the required limits, Poggi et al. (2008a) introduced another DL-Lite
dialect, called DL-LiteA , which restricts the interaction between role inclusions and functionality constraints. Here we extend this result by showing that the DL-Lite logics with
such a limited interaction between role inclusions and number restrictions can still be embedded into the one-variable fragment of first-order logic, and so exhibit the same behavior
as their fragments with only role inclusions or only number restrictions.
The article is structured in the following way. In Section 2, we introduce the logics of the
extended DL-Lite family and illustrate their features as conceptual modeling formalisms.
In Section 3, we discuss the reasoning services and the complexity measures to be analyzed
in what follows, and give an overview of the obtained complexity results. In Section 4,
we place the introduced DL-Lite logics in the context of the original DL-Lite family, and
discuss its relationship with OWL 2. In Section 5, we study the combined complexity of
KB satisfiability and instance checking, while in Section 6, we consider the data complexity
of these problems. In Section 7, we study the data complexity of query answering. In
Section 8, we analyze the impact of dropping the UNA and adding (in)equalities between
object names on the complexity of reasoning. Section 9 concludes the article.

2. The Extended DL-Lite Family of Description Logics
Description Logic (Baader et al., 2003) is a family of logics that have been studied and
used in knowledge representation and reasoning since the 1980s. In DLs, the elements of
the domain of interest are structured into concepts (unary predicates), and their properties
are specified by means of roles (binary predicates). Complex concept and role expressions
(or simply concepts and roles) are constructed, starting from a set of concept and role
names, by applying suitable constructs, where the set of available constructs depends on
the specific description logic. Concepts and roles can then be used in a knowledge base to
assert knowledge, both at the intensional level, in a so-called TBox (T for terminological),
and at the extensional level, in a so-called ABox (A for assertional). A TBox typically
consists of a set of axioms stating the inclusion between concepts and roles. In an ABox, one
can assert membership of objects (i.e., constants) in concepts, or that a pair of objects is
connected by a role. DLs are supported by reasoning services, such as satisfiability checking
and query answering, that rely on their logic-based semantics.
2.1 Syntax and Semantics of the Logics in the DL-Lite Family
We introduce now the (extended) DL-Lite family of description logics, which was initially
proposed with the aim of capturing typical conceptual modeling formalisms, such as UML
class diagrams and ER models (see Section 2.2 for details), while maintaining good computational properties of standard DL reasoning tasks (Calvanese et al., 2005). We begin
5

fiArtale, Calvanese, Kontchakov & Zakharyaschev

by defining the logic DL-LiteHN
bool , which can be regarded as the supremum of the original
DL-Lite family (Calvanese et al., 2005, 2006, 2007b) in the lattice of description logics.
HN
DL-LiteHN
bool . The language of DL-Litebool contains object names a0 , a1 , . . . , concept names
A0 , A1 , . . . , and role names P0 , P1 , . . . . Complex roles R and concepts C of this language
are defined as follows:

Pk ,

R

::=

Pk

|

B

::=



|

Ak

|

 q R,

C

::=

B

|

C

|

C1 u C2 ,

where q is a positive integer. The concepts of the form B will be called basic.
A DL-LiteHN
bool TBox, T , is a finite set of concept and role inclusion axioms (or simply
concept and role inclusions) of the form:
C1 v C2

and

R1 v R2 ,

and an ABox, A, is a finite set of assertions of the form:
Ak (ai ),

Ak (ai ),

Pk (ai , aj )

and

Pk (ai , aj ).

Taken together, T and A constitute the DL-LiteHN
bool knowledge base K = (T , A). In the
following, we denote by role(K) the set of role names occurring in T and A, by role (K)
the set {Pk , Pk | Pk  role(K)}, and by ob(A) the set of object names in A. For a role R,
we set:
(
Pk , if R = Pk ,
inv(R) =
Pk , if R = Pk .
As usual in description logic, an interpretation, I = (I , I ), consists of a nonempty
domain I and an interpretation function I that assigns to each object name ai an element
aIi  I , to each concept name Ak a subset AIk  I of the domain, and to each role name
Pk a binary relation PkI  I  I over the domain. Unless otherwise stated, we adopt
here the unique name assumption (UNA):
aIi 6= aIj

for all

i 6= j.

(UNA)

However, we shall always indicate which of our results depend on the UNA and which do
not, and when they do depend on this assumption, we discuss also the consequences of
dropping it (see also Sections 4 and 8).
The role and concept constructs are interpreted in I in the standard way:
(Pk )I = {(y, x)  I  I | (x, y)  PkI },
I



I

( q R)

= ,

	
= x  I | ]{y  I | (x, y)  RI }  q ,

(C)I = I \ C I ,
I

(C1 u C2 )

=

C1I



(inverse role)
(the empty set)
(at least q R-successors)
(not in C)

C2I ,

(both in C1 and in C2 )

6

fiThe DL-Lite Family and Relations

where ]X denotes the cardinality of X. We will use standard abbreviations such as
C1 t C2 = (C1 u C2 ),

> = ,

R = ( 1 R),

 q R = ( q + 1 R).

Concepts of the form  q R and  q R are called number restrictions, and those of the form
R are called existential concepts.
The satisfaction relation |= is also standard:
I |= C1 v C2

iff

C1I  C2I ,

I |= R1 v R2

iff

R1I  R2I ,

I |= Ak (ai )

iff aIi  AIk ,

I |= Pk (ai , aj )

iff

(aIi , aIj )  PkI ,

I |= Ak (ai )

iff aIi 
/ AIk ,

I |= Pk (ai , aj )

iff

(aIi , aIj ) 
/ PkI .

A knowledge base K = (T , A) is said to be satisfiable (or consistent) if there is an interpretation, I, satisfying all the members of T and A. In this case we write I |= K (as well as
I |= T and I |= A) and say that I is a model of K (and of T and A).
The languages of the DL-Lite family we investigate in this article are obtained by restricting the language of DL-LiteHN
bool along three axes: (i) the Boolean operators (bool ) on
concepts, (ii) the number restrictions (N ) and (iii) the role inclusions, or hierarchies (H).
Similarly to classical logic, we adopt the following definitions. A DL-LiteHN
bool TBox T
will be called a Krom TBox 6 if its concept inclusions are restricted to:
B1 v B2 ,

B1 v B2

or

B1 v B2

(Krom)

(here and below all the Bi and B are basic concepts). T will be called a Horn TBox if its
concept inclusions are restricted to:
l
Bk v B
(Horn)
k

(by definition, the empty conjunction is >). Finally, we will call T a core TBox if its
concept inclusions are restricted to:
B1 v B2

or

B1 v B2 .

(core)

As B1 v B2 is equivalent to B1 u B2 v , core TBoxes can be regarded as sitting in the
intersection of Krom and Horn TBoxes.
Remark 2.1 We will sometimes use conjunctions
on the right-hand side of concept includ
sions in these restricted languages: C v k Bk . Clearly, this syntactic sugar does not add
any extra expressive power.
HN
HN
HN
DL-LiteHN
krom , DL-Litehorn and DL-Litecore . The fragments of DL-Litebool with Krom,
HN
HN
Horn, and core TBoxes will be denoted by DL-Litekrom , DL-Litehorn and DL-LiteHN
core , respectively. Other fragments are obtained by limiting the use of number restrictions and role
inclusions.

6. The Krom fragment of first-order logic consists of all formulas in prenex normal form whose quantifier-free
part is a conjunction of binary clauses.

7

fiArtale, Calvanese, Kontchakov & Zakharyaschev

HN
DL-LiteH
 . The fragment of DL-Lite ,   {core, krom, horn, bool}, without number
restrictions  q R, for q  2, (but with role inclusions) will be denoted by DL-LiteH
 . Note
H
that, in DL-Lite , we can still use existential concepts R (that is,  1 R).
HF
DL-LiteHF
the fragment of DL-LiteHN
in which of all number
 . Denote by DL-Lite

restrictions  q R, we have existential concepts (with q = 1) and only those with q = 2
that occur in concept inclusions of the form  2 R v . Such an inclusion is called a
global functionality constraint because it states that role R is functional (more precisely, if
I |= ( 2 R v ) and both (x, y)  RI and (x, z)  RI , then y = z).
F
DL-LiteN
 , DL-Lite and DL-Lite . If role inclusions are excluded from the language,
then for each   {core, krom, horn, bool} we obtain three fragments: DL-LiteN
 (with arbitrary number restrictions), DL-LiteF
(with
functionality
constraints
and
existential
concepts

R), and DL-Lite (without number restrictions different from R).

As we shall see later on in this article, the logics of the form DL-LiteHF
and DL-LiteHN

 ,
even for  = core, turn out to be computationally rather costly because of the interaction
between role inclusions and functionality constraints (or, more generally, number restrictions). On the other hand, for the purpose of conceptual modeling one may need both of
these constructs; cf. the example in Section 2.2. A compromise can be found by artificially
limiting the interplay between role inclusions and number restrictions in a way similar to
the logic DL-LiteA proposed by Poggi et al. (2008a).
For a TBox T , let vT denote the reflexive and transitive closure of the relation

	
(R, R0 ), (inv(R), inv(R0 )) | R v R0  T
and let R T R0 iff R vT R0 and R0 vT R. Say that R0 is a proper sub-role of R in T if
R0 vT R and R0 
6 T R.
(HN )

(HN )

DL-Lite . We now introduce the logics DL-Lite ,
  {core, krom, horn, bool},
HN
which, on the one hand, restrict the logics DL-Lite by limiting the interaction between
role inclusions and number restrictions in order to reduce complexity of reasoning, and, on
the other hand, include additional constructs, such as limited qualified existential quantifiers, role disjointness, (a)symmetry and (ir)reflexivity constraints, which increase the
expressive power of the logics but do not affect their computational properties.
(HN )
DL-Lite
TBoxes T must satisfy the conditions (A1 )(A3 ) below. (We remind
the reader that an occurrence of a concept on the right-hand (left-hand) side of a concept
inclusion is called negative if it is in the scope of an odd (even) number of negations ;
otherwise the occurrence is called positive.)
(A1 ) T may contain only positive occurrences of qualified number restrictions  q R.C,
where C is a conjunction of concepts allowed on the right-hand side of -concept
inclusions;
(A2 ) if  q R.C occurs in T , then T does not contain negative occurrences of number
restrictions  q 0 R or  q 0 inv(R) with q 0  2;
(A3 ) if R has a proper sub-role in T , then T does not contain negative occurrences of
 q R or  q inv(R) with q  2.
8

fiThe DL-Lite Family and Relations

role
role
constraints inclusions
no

no

no

yes

disj.
(a)sym.
(ir)ref.
disj.
(a)sym.
(ir)ref.
tran.
a)

number
restrictions
R
R/funct.
 qR
R
R/funct.
 qR

concept inclusions
Krom
Horn
DL-Litekrom DL-Litehorn
DL-LiteF
DL-LiteF
krom
horn
N
DL-Litekrom DL-LiteN
horn
H
DL-LiteH
DL-Lite
krom
horn
HF
DL-Litekrom DL-LiteHF
horn
HN
DL-LiteHN
DL-Lite
krom
horn

core
DL-Litecore
DL-LiteF
core
DL-LiteN
core
DL-LiteH
core
DL-LiteHF
core
DL-LiteHN
core

(HF )

Bool
DL-Litebool
DL-LiteF
bool
DL-LiteN
bool
DL-LiteH
bool
DL-LiteHF
bool
DL-LiteHN
bool

(HF )

(HF )

)
R.C/funct.a) DL-Lite(HF
DL-Litekrom DL-Litehorn DL-Litebool
core
(HN )
(HN )
(HN )
(HN )
a)
 q R.C
DL-Litecore
DL-Litekrom DL-Litehorn DL-Litebool

yes

+

)
R.C/funct.a) DL-Lite(HF
core

yes

 q R.C a)

(HF )+

DL-Litekrom

+

(HN )+

)
DL-Lite(HN
DL-Litekrom
core

(HF )+

DL-Litehorn

(HN )+

DL-Litehorn

(HF )+

DL-Litebool

(HN )+

DL-Litebool

restricted by (A1 )(A3 ).

Table 1: The extended DL-Lite family.
(HN )

(It follows that no DL-Lite
TBox can contain both, say, a functionality constraint
 2 R v  and an occurrence of  q R.C, for any q  1.)
(HN )
Additionally, DL-Lite
TBoxes can contain role constraints (or axioms) of the form:
Dis(R1 , R2 ),

Asym(Pk ),

Sym(Pk ),

Irr(Pk ),

and

Ref(Pk ).

The meaning of these new constructs is defined as usual: for an interpretation I = (I , I ),

	
 ( q R.C)I = x  I | ]{y  C I | (x, y)  RI }  q ;
 I |= Dis(R1 , R2 )
 I |= Asym(Pk )
 I |= Sym(Pk )
 I |= Irr(Pk )
 I |= Ref(Pk )

iff
iff

iff
iff
iff

R1I  R2I =  (roles R1 and R2 are disjoint);
PkI  (Pk )I =  (role Pk is asymmetric);

PkI = (Pk )I

(Pk is symmetric);

(x, x) 
/ PkI for all x  I
(x, x)  PkI for all x  I

(Pk is irreflexive);
(Pk is reflexive).

It is to be emphasized that these extra constructs are often used in conceptual modeling
(HN )
and their introduction in DL-Lite
is motivated by the OWL 2 QL proposal. (Note that
(HN )
DL-Lite
contains both DL-LiteH
and
DL-LiteN

 as its proper fragments.)
(HN )+

(HN )+

DL-Lite
.
For   {bool, horn, krom, core}, denote by DL-Lite
the extension
(HN )
of DL-Lite
with role transitivity constraints of the form Tra(Pk ), the meaning of which
is as expected:
 I |= Tra(Pk )

iff

(x, y)  PkI and (y, z)  PkI imply (x, z)  PkI , for all x, y, z  I
(Pk is transitive).
9

fiArtale, Calvanese, Kontchakov & Zakharyaschev

DL-Litebool

DL-LiteHN


@
I
@
DL-Litehorn






DL-Litekrom






@
I
@

DL-Litecore

PP
i

6
DL-LiteHF

6
DL-LiteH


DL-LiteN


(HN ) )+
DL-Lite
DL-Lite(HN


1
6
6

6
PP
i


1

DL-LiteF


6

 



iP
P
DL-Lite

)+
(HF ) DL-Lite
DL-Lite(HF



Figure 1: Language inclusions in the extended DL-Lite family.
We remind the reader of the standard restriction limiting the use of transitive roles in DLs
(see, e.g., Horrocks, Sattler, & Tobies, 2000):
 only simple roles R are allowed in concepts of the form  q R, for q  2,
where by a simple role in a given TBox T we understand a role without transitive sub-roles
(including itself). In particular, if T contains Tra(P ) then P and P  are not simple, and
so T cannot contain occurrences of concepts of the form  q P and  q P  , for q  2.
(HF )

(HF )+

(HF )

DL-Lite
and DL-Lite .
We also define languages DL-Lite
as sub-languages
(HN )
of DL-Lite ,
in which only number restrictions of the form R, R.C and functionality
constraints  2 R v  are allowedprovided, of course, that they satisfy (A1 )(A3 ); in
(HF )+
particular, R.C is not allowed if R is functional. As before, DL-Lite
are the extensions
(HF )
of DL-Lite
with role transitivity constraints (satisfying the restriction above).
Thus, the extended DL-Lite family we consider in this article consists of 40 different
logics collected in Table 1. The inclusions between these logics are shown in Figure 1.
They are obtained by taking the product of the left- and right-hand parts of the picture,
where the subscript  on the right-hand part ranges over {core, krom, horn, bool}, i.e., the
subscripts on the left-hand part, and similarly, the superscript  on the left-hand part
ranges over { , F, N , H, HF, HN , (HF), (HN ), (HF)+ , (HN )+ }, i.e., the superscripts on
the right-hand part.
The position of these logics relative to other DL-Lite logics known in the literature and
the OWL 2 QL profile will be discussed in Section 4. And starting from Section 5, we begin
a thorough investigation of the computational properties of the logics in the extended DLLite family, both with and without the UNA. But before that we illustrate the expressive
power of the DL-Lite logics by a concrete example.
2.2 DL-Lite for Conceptual Modeling
A tight correspondence between conceptual modeling formalisms, such as the ER model
and UML class diagrams, and various description logics has been pointed out in various
papers (e.g., Calvanese et al., 1998b, 1999; Borgida & Brachman, 2003; Berardi et al.,
2005). Here we give an example showing how DL-Lite logics can be used for conceptual
modeling purposes; for more details see the work by Artale et al. (2007b).
10

fiThe DL-Lite Family and Relations

1..1

Employee

1..*

empCode: Integer
salary: Integer

worksOn
boss
3..*
Project

Manager

projectName: String

1..*
1..1
{disjoint, complete}

AreaManager

manages
TopManager

1..1

Figure 2: A UML class diagram.
Let us consider the UML class diagram depicted in Figure 2 and representing (a portion
of) a company information system. According to the diagram, all managers are employees and are partitioned into area managers and top managers. This information can be
represented by means of the following concept inclusions (where in brackets we specify the
minimal DL-Lite language the inclusion belongs to):
Manager v Employee

(DL-Litecore )

AreaManager v Manager

(DL-Litecore )

TopManager v Manager

(DL-Litecore )

AreaManager v TopManager

(DL-Litecore )

Manager v AreaManager t TopManager

(DL-Litebool )

Each employee has two functional attributes, empCode and salary, with integer values.
Unlike OWL, here we do not distinguish between abstract objects and data values. Hence
we model a datatype, such as Integer , by means of a concept, and an attribute, such as
employees salary, by means of a role. Thus, salary can be represented as follows:
Employee v salary
salary



(DL-Litecore )

v Integer

(DL-Litecore )
(DL-LiteF
core )

 2 salary v 

The functional attribute empCode with values in Integer is represented in the same way.
The binary relationship worksOn has Employee as its domain and Project as its range:
worksOn v Employee
worksOn



(DL-Litecore )

v Project

(DL-Litecore )

The binary relationship boss with domain Employee and range Manager is treated analogously. Each employee works on a project and has exactly one boss, while a project must
11

fiArtale, Calvanese, Kontchakov & Zakharyaschev

involve at least three employees:
Employee v worksOn

(DL-Litecore )

Employee v boss

(DL-Litecore )
(DL-LiteF
core )

 2 boss v 
Project v  3 worksOn 

(DL-LiteN
core )

A top manager manages exactly one project and also works on that project, while a project
is managed by exactly one top manager:
manages v TopManager
manages



v Project

(DL-Litecore )

TopManager v manages
Project v manages

(DL-Litecore )
(DL-Litecore )



(DL-Litecore )

 2 manages v 

(DL-LiteF
core )

 2 manages  v 

(DL-LiteF
core )
(DL-LiteH
core )

manages v worksOn

All in all, the only languages in the extended DL-Lite family capable of representing the
(HN )
UML class diagram in Figure 2 are DL-LiteHN
bool and DL-Litebool . Note, however, that except for the covering constraint, Manager v AreaManager t TopManager , all other concept
inclusions in the DL-Lite translation of the UML class diagram belong to variants of the
(HN )
core fragments DL-LiteHN
core and DL-Litecore . It is not hard to imagine a situation where
one needs Horn concept inclusions to represent integrity constraints over UML class diagrams, for example, to express (together with the above axioms) that no chief executive
officer may work on five projects and be a manager of one of them:
CEO u ( 5 worksOn) u manages v 

(DL-LiteN
horn )

In the context of UML class diagrams, the Krom fragment DL-Litekrom (with its variants)
seems to be useless: it extends DL-Litecore with concept inclusions of the form B1 v B2
or, equivalently, > v B1 t B2 , which are rarely used in conceptual modeling. Indeed,
this would correspond to partitioning the whole domain of interest in just two parts, while
more general and useful covering constraints of the form B v B1 t    t Bk require the full
Bool language. On the other hand, the Krom fragments are important for pinpointing the
borderlines of various complexity classes over the description logics of the DL-Lite family
and their extensions; see Table 2.

3. Reasoning in DL-Lite Logics
We discuss now the reasoning problems we consider in this article, their mutual relationships, and the complexity measures we adopt. We also provide an overview of the complexity
results for DL-Lite logics obtained in this article.

12

fiThe DL-Lite Family and Relations

3.1 Reasoning Problems
We will concentrate on three fundamental and standard reasoning tasks for description
logics: satisfiability (or consistency), instance checking, and query answering.
For a DL L in the extended DL-Lite family, we define an L-concept inclusion as any
concept inclusion allowed in L. Similarly, we define the notions of L-KB and L-TBox.
Finally, define an L-concept as any concept that can occur on the right-hand side of an
L-concept inclusion or a conjunction of such concepts.
Satisfiability. The KB satisfiability problem is to check, given an L-KB K, whether there
is a model of K. Clearly, satisfiability is the minimal requirement for any ontology. As is
well known in DL (Baader et al., 2003), many other reasoning tasks for description logics
are reducible to the satisfiability problem. Consider, for example, the subsumption problem:
given an L-TBox T and an L-concept inclusion C1 v C2 , decide whether T |= C1 v C2 ,
that is, C1I  C2I , for every model I of T . To reduce this problem to (un)satisfiability, take
a fresh concept name A, a fresh object name a, and set K = (T 0 , A), where
T 0 = T  {A v C1 , A v C2 }

and A = {A(a)}.

It is easy
d to see that T |= C1 v C2 iff K is not satisfiable. For core, Krom and Horn KBs, if
C2 = k Dk , where each Dk is a (possibly negated) basic concept, checking unsatisfiability
of K amounts to checking unsatisfiability of each of the KBs Kk = (Tk , A), where Tk =
T  {A v C1 , A v Dk } (for Horn KBs, replace A v B with the equivalent A u B v ).
The concept satisfiability problemgiven an L-TBox T and an L-concept C, decide
whether C I 6=  in a model I of T is also easily reducible to KB satisfiability. Indeed,
take a fresh concept name A, a fresh object name a, and set K = (T 0 , A), where
T 0 = T  {A v C}

and A = {A(a)}.

Then C is satisfiable with respect to T iff K is satisfiable.
Instance checking. The instance checking problem is to decide, given an object name a,
an L-concept C and an L-KB K = (T , A), whether K |= C(a), that is, aI  C I , for every
model I of K. Instance checking is also reducible to (un)satisfiability: an object a is an
instance of an L-concept C in every model of K = (T , A) iff the KB K0 = (T 0 , A0 ), with
T 0 = T  {A v C}

and

A0 = A  {A(a)},

is notdsatisfiable, where A is a fresh concept name. For core, Krom and Horn KBs, if
C = k Dk , where each Dk is a (possibly negated) basic concept, we can proceed as for
subsumption: checking the unsatisfiability of K0 amounts to checking the unsatisfiability of
each KB Kk0 = (Tk0 , A0 ) with Tk0 = T  {A v Dk }.
Conversely, KB satisfiability is reducible to the complement of instance checking: K is
satisfiable iff K 6|= A(a), for a fresh concept name A and a fresh object a.
Query answering. A positive existential query q(x1 , . . . , xn ) is any first-order formula
(x1 , . . . , xn ) constructed by means of conjunction, disjunction and existential quantification starting from atoms of the from Ak (t) and Pk (t1 , t2 ), where Ak is a concept name, Pk
13

fiArtale, Calvanese, Kontchakov & Zakharyaschev

a role name, and t, t1 , t2 are terms taken from the list of variables y0 , y1 , . . . and the list of
object names a0 , a1 , . . . (i.e.,  is a positive existential formula). More precisely,
t

::=

yi

|



::=

Ak (t)

ai ,
|

Pk (t1 , t2 )

|

1  2

|

1  2

|

yi .

The free variables of  are called distinguished variables of q and the bound ones are nondistinguished variables of q. We write q(x1 , . . . , xn ) for a query with distinguished variables
x1 , . . . , xn . A conjunctive query is a positive existential query that contains no disjunction
(it is constructed from atoms by means of conjunction and existential quantification only).
Given a query q(~x) = (~x) with ~x = x1 , . . . , xn and an n-tuple ~a of object names, we
write q(~a) for the result of replacing every occurrence of xi in (~x) with the ith member of
~a. Queries containing no distinguished variables will be called ground (they are also known
as Boolean).
Let I = (I , I ) be an interpretation. An assignment a in I is a function associating
with every variable y an element a(y) of I . We will use the following notation: aI,a
= aIi
i
and y I,a = a(y). The satisfaction relation for positive existential formulas with respect to
a given assignment a is defined inductively by taking:
I |=a Ak (t)

iff

tI,a  AIk ,

I |=a Pk (t1 , t2 )

iff

I,a
I
(tI,a
1 , t2 )  Pk ,

I |=a 1  2

iff

I |=a 1 and I |=a 2 ,

I |=a 1  2

iff

I |=a 1 or I |=a 2 ,

I |=a yi 

iff

I |=b , for some assignment b in I that may differ from a on yi .

For a ground query q(~a), the satisfaction relation does not depend on the assignment a,
and so we write I |= q(~a) instead of I |=a q(~a). The answer to such a query is either yes
or no.
For a KB K = (T , A), we say that a tuple ~a of object names from A is a certain answer
to q(~x) with respect to K, and write K |= q(~a), if I |= q(~a) whenever I |= K. The query
answering problem can be formulated as follows: given an L-KB K = (T , A), a query q(~x),
and a tuple ~a of object names from A, decide whether K |= q(~a).
Note that the instance checking problem is a special case of query answering: an object
a is an instance of an L-concept C with respect to a KB K iff the answer to the query A(a)
with respect to K0 is yes, where K0 = (T 0 , A) and T 0 = T  {C v A}, with A a fresh
concept name. For Horn-concepts B1 u    u Bk , we consider the query A1 (a)      Ak (a)
with respect to K0 , where K0 = (T 0 , A) and T 0 = T  {B1 v A1 , . . . , Bk v Ak }, with
the Ai fresh concept names. Similarly, we deal with Krom-concepts D1 u    u Dk , where
each Di is a possibly negated basic concept. For core-concepts, the reduction holds just for
conjunctions of basic concepts.
3.2 Complexity Measures: Data and Combined Complexity
The computational complexity of the reasoning problems discussed above can be analyzed
with respect to different complexity measures, which depend on those parameters of the
14

fiThe DL-Lite Family and Relations

problem that are regarded to be the input (i.e., can vary) and those that are regarded to
be fixed. For satisfiability and instance checking, the parameters to consider are the size
of the TBox T and the size of the ABox A, that is the number of symbols in T and A,
denoted |T | and |A|, respectively. The size |K| of the knowledge K = (T , A) is simply given
by |T | + |A|. For query answering, one more parameter to consider would be the size of the
query. However, in our analysis we adopt the standard database assumption that the size
of queries is always bounded by some reasonable constant and, in any case, negligible with
respect to both the size of the TBox and the size of the ABox. Thus we do not count the
query as part of the input.
Hence, we consider our reasoning problems under two complexity measures. If the whole
KB K is regarded as an input, then we deal with combined complexity. If, however, only
the ABox A is counted as an input, while the TBox T (and the query) is regarded to be
fixed, then our concern is data complexity (Vardi, 1982). Combined complexity is of interest
when we are still designing and testing the ontology. On the other hand, data complexity is
preferable in all those cases where the TBox is fixed or its size (and the size of the query) is
negligible compared to the size of the ABox, which is the case, for instance, in the context
of ontology-based data access (Calvanese, De Giacomo, Lembo, Lenzerini, Poggi, & Rosati,
2007) and other data intensive applications (Decker, Erdmann, Fensel, & Studer, 1999; Noy,
2004; Lenzerini, 2002; Calvanese et al., 2008). Since the logics of the DL-Lite family were
tailored to deal with large data sets stored in relational databases, data complexity of both
instance checking and query answering is of particular interest to us.
3.3 Remarks on the Complexity Classes LogSpace and AC0
In this paper, we deal with the following complexity classes:
AC0 ( LogSpace  NLogSpace  P  NP  ExpTime.
Their definitions can be found in the standard textbooks (e.g., Garey & Johnson, 1979;
Papadimitriou, 1994; Vollmer, 1999; Kozen, 2006). Here we only remind the reader of the
two smallest classes LogSpace and AC0 .
A problem belongs to LogSpace if there is a two-tape Turing machine M such that,
starting with an input of length n written on the read-only input tape, M stops in an accepting or rejecting state having used at most log n cells of the (initially blank) read/write work
tape. A LogSpace transducer is a three-tape Turing machine that, having started with an
input of length n written on the read-only input tape, writes the result (of polynomial size)
on the write-only output tape using at most log n cells of the (initially blank) read/write
work tape. A LogSpace-reduction is a reduction computable by a LogSpace transducer;
the composition of two LogSpace transducers is also a LogSpace transducer (Kozen,
2006, Lemma 5.1).
The formal definition of the complexity class AC0 (see, e.g., Boppana & Sipser, 1990;
Vollmer, 1999 and references therein) is based on the circuit model, where functions are
represented as directed acyclic graphs built from unbounded fan-in And, Or and Not
gates (i.e., And and Or gates may have an unbounded number of incoming edges). For
this definition we assume that decision problems are encoded in the alphabet {0, 1} and
so can be regarded as Boolean functions. AC0 is the class of problems definable using
15

fiArtale, Calvanese, Kontchakov & Zakharyaschev

a family of circuits of constant depth and polynomial size, which can be generated by
a deterministic Turing machine in logarithmic time (in the size of the input); the latter
condition is called LogTime-uniformity. Intuitively, AC0 allows us to use polynomially
many processors but the run-time must be constant. A typical example of an AC0 problem
is evaluation of first-order queries over databases (or model checking of first-order sentences
over finite models), where only the database (first-order model) is regarded as the input
and the query (first-order sentence) is assumed to be fixed (Abiteboul, Hull, & Vianu, 1995;
Vollmer, 1999). On the other hand, the undirected graph reachability problem is known to
be in LogSpace (Reingold, 2008) but not in AC0 . A Boolean function f : {0, 1}n  {0, 1}
is called AC0 -reducible (or constant-depth reducible) to a function g : {0, 1}n  {0, 1} if
there is a (LogTime-uniform) family of constant-depth circuits built from And, Or, Not
and g gates that computes f . In this case we say that there is an AC0 -reduction. Note that
all the reductions considered in Section 3.1 are AC0 -reductions. Unless otherwise indicated,
in what follows we write reduction for AC0 -reduction.
3.4 Summary of Complexity Results
In this article, our aim is to investigate (i) the combined and data complexity of the satisfiability and instance checking problems and (ii) the data complexity of the query answering
problem for the logics of the extended DL-Lite family, both with and without the UNA.
(HF )+
The obtained and known results for the first 32 logics from Table 1 (the logics DL-Lite
(HN )+
and DL-Lite
are not included) are summarized in Table 2 (we remind the reader that
satisfiability and instance checking are reducible to the complements of each other and that
instance checking is a special case of query answering). In fact, all of the results in the
table follow from the lower and upper bounds marked with [] and [], respectively (by
taking into account the hierarchy of languages of the DL-Lite family): for example, the
NLogSpace membership of satisfiability in DL-LiteN
krom in Theorem 5.7 implies the same
N
F
upper bound for DL-Litekrom , DL-Litekrom , DL-Litecore , DL-LiteF
core and DL-Litecore because
.
all of them are sub-languages of DL-LiteN
krom
Remark 3.1 Two further complexity results are to be noted (they are not included in
Table 2):
(i) If equality between object names is allowed in the language of DL-Lite, which only
makes sense if the UNA is dropped, then the AC0 memberships in Table 2 are replaced by LogSpace-completeness (see Section 8, Theorem 8.3 and 8.9); inequality
constraints do not affect the complexity.
(ii) If we extend any of our languages with role transitivity constraints then the combined complexity of satisfiability remains the same, while for data complexity, instance
checking and query answering become NLogSpace-hard (see Lemma 6.3), i.e., the
membership in AC0 for data complexity is replaced by NLogSpace-completeness,
while all other complexity results remain the same.
In either case, the property of first-order rewritabilitythat is, the possibility of rewriting
a given query q and a given TBox T into a single first-order query q0 returning the certain
answers to q over (T , A) for every ABox A, which ensures that the query answering problem
is in AC0 for data complexityis lost.
16

fiThe DL-Lite Family and Relations

Complexity
Languages

UNA

Combined complexity
Satisfiability

|H]
DL-Lite[core
[ |H]
DL-Litehorn
[ |H]
DL-Litekrom
[ |H]
DL-Litebool
|N |(HF )|(HN )]
DL-Lite[F
core
[F |N |(HF )|(HN )]
DL-Litehorn
[F |N |(HF )|(HN )]
DL-Litekrom
[F |N |(HF )|(HN )]
DL-Litebool
[F |(HF )]
DL-Litecore/horn
[F |(HF )]
DL-Litekrom
[F |(HF )]
DL-Litebool
[N |(HN )]
DL-Litecore/horn
[N |(HN )]
DL-Litekrom/bool
DL-LiteHF
core/horn
DL-LiteHF
krom/bool
DL-LiteHN
core/horn
HN
DL-Litekrom/bool

yes/no

yes

no

yes/no

Data complexity
Instance checking
0

Query answering

NLogSpace  [A]

in AC

in AC0

P  [Th.8.2]  [A]

in AC0

in AC0  [C]

0

NLogSpace  [Th.8.2]

in AC

coNP  [B]

NP  [Th.8.2]  [A]

in AC0  [Th.8.3]

coNP

0

NLogSpace

in AC

in AC0

P  [Th.5.8, 5.13]

in AC0

in AC0  [Th.7.1]

NLogSpace  [Th.5.7,5.13]

in AC0

coNP

0

NP  [Th.5.6, 5.13]

in AC  [Cor.6.2]

coNP

P  [Cor.8.8]  [Th.8.7]

P  [Th.8.7]

P

P  [Cor.8.8]

P

coNP

NP

P  [Cor.8.8]

coNP

NP  [Th.8.4]

coNP  [Th.8.4]

coNP

NP  [Th.8.5]

coNP

coNP

ExpTime  [Th.5.10]

P  [Th.6.7]

P  [D]

ExpTime

coNP  [Th.6.5]

coNP

ExpTime

coNP  [Th.6.6]

coNP

ExpTime  [F]

coNP

coNP  [E]

[A] complexity of the respective fragment of propositional Boolean logic
[B] follows from the proof of the data complexity result for instance checking in ALE (Schaerf, 1993)
[C] (Calvanese et al., 2006)
[D] follows from Horn-SHIQ (Hustadt, Motik, & Sattler, 2005; Eiter, Gottlob, Ortiz, & Simkus, 2008)
[E] follows from SHIQ (Ortiz, Calvanese, & Eiter, 2006, 2008; Glimm, Horrocks, Lutz, & Sattler, 2007)
[F] follows from SHIQ (Tobies, 2001)

Table 2: Complexity of DL-Lite logics (all the complexity bounds save in AC0  are tight).

1 ||n ]
means any of DL-Lite1 , . . . , DL-Liten
DL-Lite[

(in particular, DL-Lite[ |H] is either DL-Lite or DL-LiteH
 ).

DL-Litecore/horn means DL-Litecore or DL-Litehorn (likewise for DL-Litekrom/bool ).
 [X] ( [X]) means that the upper (respectively, lower) bound follows from [X].

Detailed proofs of our results will be given in Sections 58. For the variants of logics
involving number restrictions, all upper bounds hold also under the assumption that the
numbers q in concepts of the form  q R are given in binary. (Intuitively, this follows from
the fact that in our proofs we only use those numbers that explicitly occur in the KB.) All
lower bounds remain the same for the unary coding, since in the corresponding proofs we
only use numbers not exceeding 4.
In the next section we consider the extended DL-Lite family in a more general context by
identifying its place among other DL-Lite-related logics, in particular the OWL 2 profiles.
17

fiArtale, Calvanese, Kontchakov & Zakharyaschev

4. The Landscape of DL-Lite Logics
The original family of DL-Lite logics was created with two goals in mind: to identify
description logics that, on the one hand, are capable of representing some basic features
of conceptual modeling formalisms (such as UML class diagrams and ER diagrams) and,
on the other hand, are computationally tractable, in particular, matching the AC0 data
complexity of database query answering.
As we saw in Section 2.2, to represent UML class diagrams one does not need the typical quantification constructs of the basic description logic ALC (Schmidt-Schau & Smolka,
1991), namely, universal restriction R.C and qualified existential quantification R.C: one
can always take the role filler C to be >. Indeed, domain and range restrictions for a
relationship P can be expressed by the concepts inclusions P v B1 and P  v B2 , respectively. Thus, almost all concept inclusions required for capturing UML class diagrams
are of the form B1 v B2 or B1 v B2 . These observations motivated the introduction by
Calvanese et al. (2005) of the first DL-Lite logic, which in our new nomenclature corresponds
to DL-LiteF
core . Their main results were a polynomial-time upper bound for the combined
complexity of KB satisfiability and a LogSpace upper bound for the data complexity of
conjunctive query answering (under the UNA). These results were extended by Calvanese
H
et al. (2006) to two larger languages: DL-LiteF
horn and DL-Litehorn , which were originally
called DL-Liteu,F and DL-Liteu,R , respectively. Calvanese et al. (2007b) introduced another member of the DL-Lite family (named DL-LiteR ), which extended DL-LiteH
core with
role disjointness axioms of the form Dis(R1 , R2 ). The computational behavior of the new
logic turned out to be the same as that of DL-LiteH
core . It may be worth mentioning that
DL-LiteH
covers
the
DL
fragment
of
RDFS
(Klyne
& Carroll, 2004; Hayes, 2004). Note
core
also that Calvanese et al. (2006) considered the variants of both DL-Liteu,F and DL-Liteu,R
with arbitrary n-ary relations (not only the usual binary roles) and showed that query answering in them is still in LogSpace for data complexity. We conjecture that similar results
can be obtained for the other DL-Lite logics introduced in this paper. Artale et al. (2007b)
demonstrated how n-ary relations can be represented in DL-LiteF
core by means of reification.
A further variant of DL-Lite, called DL-LiteA (A for attributes), was introduced by
Poggi et al. (2008a) with the aim of capturing as many features of conceptual modeling
formalisms as possible, while still maintaining the computational properties of the basic
variants of DL-Lite. One of the features in DL-LiteA , borrowed from conceptual modeling
formalisms and adopted also in OWL, is the distinction between (abstract) objects and data
values, and consequently, between concepts (sets of objects) and datatypes (sets of data
values), and between roles (i.e., object properties in OWL, relating objects with objects)
and attributes (i.e., data properties in OWL, relating objects with data values). However,
as far as the results in this paper are concerned, the distinction between concepts and
datatypes, and between roles and attributes has no impact on reasoning whatsoever, since
datatypes can simply be treated as special concepts that are mutually disjoint and are also
disjoint from the proper concepts. Instead, more relevant for reasoning is the possibility
to express in DL-LiteA both role inclusions and functionality, i.e., DL-LiteA includes both
F
HF
DL-LiteH
core and DL-Litecore , but not DL-Litecore .
As we have already mentioned, role inclusions and functionality constraints cannot be
combined in an unrestricted way without losing the good computational properties: in

18

fiThe DL-Lite Family and Relations

.
b
b

DL-LiteHN
krom
b

b

b

...

SHIQ
DL-LiteHN
horn
b

DL-LiteHN
bool
b

...
b

DL-Litekrom
b

b

DL-LiteHF
core
b

(HN )

b

b

b

P

b

DL-Litecore
(HF )
DL-Litecore

DL-LiteN
core

(HN )

DL-Litehorn
(HF )
DL-Litehorn
DL-LiteN
horn
+
DL-LiteA,u
b

b

b

b

b

DL-LiteHF
horn

DL-Lite+
A
DL-LiteA
DL-LiteF = DL-LiteF
DL-LiteF ,u = DL-LiteF
core
horn
H
DL-LiteR = DL-Litecore
DL-LiteR,u = DL-LiteH
horn
DL-Litecore
b

b

in AC0

DL-Litebool

Horn-SHIQ

coNP

.

b

DL-LiteHN
core

b

b

b

Figure 3: The DL-Lite family and relations.
Theorems 5.10 and 6.7, we prove that satisfiability of DL-LiteHF
core KBs is ExpTime-hard
for combined complexity, while instance checking is data-hard for P (NLogSpace-hardness
was shown by Calvanese et al., 2006). In DL-LiteA , to keep query answering in AC0 for
data complexity and satisfiability in NLogSpace for combined complexity, functional roles
(and attributes) are not allowed to be specialized, i.e., used positively on the right-hand
side of role (and attribute) inclusion axioms. So, condition (A3 ) is a slight generalization
of this restriction. DL-LiteA also allows axioms of the form B v R.C for non-functional
roles R, which is covered by conditions (A1 ) and (A2 ). Thus, DL-LiteA can be regarded
(HF )
(HN )
as a proper fragment of both DL-Litecore and DL-Litehorn . We show in Sections 5.3 and 7
that these three languages enjoy very similar computational properties under the UNA:
tractable satisfiability and query answering in AC0 .
We conclude this section with a picture in Figure 3 illustrating the landscape of DLLite-related logics by grouping them according to the data complexity of positive existential
query answering under the UNA. The original eight DL-Lite logics, called by Calvanese
et al. (2007b) the DL-Lite family, are shown in the bottom sector of the picture (the logics
+
DL-Lite+
A and DL-LiteA,u extend DL-LiteA and DL-LiteA,u with identification constraints,
(HN )

which are out of the scope of this article). Their nearest relatives are the logic DL-Litehorn
and its fragments, which are all in AC0 as well. The next layer contains the logics DL-LiteHF
core
and DL-LiteHF
,
in
which
query
answering
is
data-complete
for
P
(no
matter
whether
the
horn
UNA is adopted or not). In fact, these logics are fragments of the much more expressive DL
Horn-SHIQ, which was shown to enjoy the same data complexity of query answering by
Eiter et al. (2008). It remains to be seen whether polynomial query answering is practically
feasible; recent experiments with the DL EL (Lutz, Toman, & Wolter, 2008) indicate that
this may indeed be the case. Finally, very distant relatives of the DL-Lite family comprise

19

fiArtale, Calvanese, Kontchakov & Zakharyaschev

the upper layer of the picture, where query answering is data-complete for coNP, that is,
the same as for the very expressive DL SHIQ.
4.1 The DL-Lite Family and OWL 2
The upcoming version 2 of the Web Ontology Language OWL7 defines three profiles,8 that
is, restricted versions of the language that suit specific needs. The DL-Lite family, notably
DL-LiteH
core (or the original DL-LiteR ), is at the basis of one of these OWL 2 profiles, called
OWL 2 QL. According to http://www.w3.org/TR/owl2-profiles/, OWL 2 QL is aimed at
applications that use very large volumes of instance data, and where query answering is the
most important reasoning task. In OWL 2 QL, [. . . ] sound and complete conjunctive query
answering can be performed in LogSpace with respect to the size of the data (assertions)
[and] polynomial time algorithms can be used to implement the ontology consistency and
class expression subsumption reasoning problems. The expressive power of the profile is
necessarily quite limited, although it does include most of the main features of conceptual
models such as UML class diagrams and ER diagrams. In this section, we briefly discuss
the results obtained in this article in the context of additional constructs that are present
in OWL 2.
A very important difference between the DL-Lite family and OWL is the status of the
unique name assumption (UNA): this assumption is quite common in data management,
and hence adopted in the DL-Lite family, but not adopted in OWL. Instead, the OWL
syntax provides explicit means for stating that object names, say a and b, are supposed to
denote the same individual, a  b, or that they should be interpreted differently, a 6 b (in
OWL, these constructs are called sameAs and differentFrom).
The complexity results we obtain for logics of the form DL-LiteH
 do not depend on
whether the UNA is adopted or not (because every model of a DL-LiteH
 KB without UNA
can be untangled into a model of the same KB respecting the UNA; see Lemma 8.10).
N
However, this is not the case for the logics DL-LiteF
 and DL-Lite , where there is an obvious
interaction between the UNA and number restrictions (cf. Table 2). For example, under the
0
UNA, instance checking for DL-LiteF
core is in AC for data complexity, whereas dropping this
assumption results in a much higher complexity: in Section 8, we prove that it is P-complete.
H
The addition of the equality construct  to DL-LiteH
core and DL-Litehorn slightly changes
data complexity of query answering and instance checking, as it rises from membership in
AC0 to LogSpace-completeness; see Section 8. What is more important, however, is that
in this case we loose first-order rewritability of query answering and instance checking, and
as a result cannot use the standard database query engines in a straightforward manner.
Since the OWL 2 profiles are defined as syntactic restrictions of the language without
changing the basic semantic assumptions, it was chosen not to include in the OWL 2 QL
profile any construct that interferes with the UNA and which, in the absence of the UNA,
would cause higher complexity. That is why OWL 2 QL does not include number restrictions, not even functionality constraints. Also, keys (the mechanism of identifying objects
by means of the values of their properties) are not supported, although they are an impor7. http://www.w3.org/2007/OWL/
8. In logic, profiles would be called fragments as they are defined by placing restrictions on the OWL 2
syntax only.

20

fiThe DL-Lite Family and Relations

tant notion in conceptual modeling. Indeed, keys can be considered as a generalization of
functionality constraints (Toman & Weddell, 2005, 2008; Calvanese, De Giacomo, Lembo,
Lenzerini, & Rosati, 2007a, 2008b), since asserting a unary key, i.e., one involving only a
single role R, is equivalent to asserting the functionality of the inverse of R. Hence, in the
absence of the UNA, allowing keys would change the computational properties.
As we have already mentioned, some other standard OWL constructs, such as role disjointness, (a)symmetry and (ir)reflexivity constraints, can be added to the DL-Lite logics
without changing their computational behavior. Role transitivity constraints, Tra(R), as(HN )
serting that R must be interpreted as a transitive role, can also be added to DL-Litehorn but
this leads to the increase of the data complexity for all reasoning problems to NLogSpace,
although satisfiability remains in P for combined complexity. These results can be found
in Section 5.3.
Of other constructs of OWL 2 that so far are not supported by the DL-Lite logics we
mention nominals (i.e., singleton concepts), Boolean operators on roles, and role chains.

5. Satisfiability: Combined Complexity
DL-LiteHN
bool is clearly a sub-logic of the description logic SHIQ, the satisfiability problem
for which is known to be ExpTime-complete (Tobies, 2001).
In Section 5.1 we show, however, that the satisfiability problem for DL-LiteN
bool KBs is
1
reducible to the satisfiability problem for the one-variable fragment, QL , of first-order logic
without equality and function symbols. As satisfiability of QL1 -formulas is NP-complete
(see, e.g., Borger et al., 1997) and the logics under consideration contain full Booleans on
concepts, satisfiability of DL-LiteN
bool KBs is NP-complete as well. We shall also see that the
translations of Horn and Krom KBs into QL1 belong to the Horn and Krom fragments of
QL1 , respectively, which are known to be P- and NLogSpace-complete (see, e.g., Papadimitriou, 1994; Borger et al., 1997). In Section 5.2, we will show how to simulate the behavior of
polynomial-space-bounded alternating Turing machines by means of DL-LiteHF
core KBs. This
will give the (optimal) ExpTime lower bound for satisfiability of KBs in all the languages
of our family containing unrestricted occurrences of both functionality constraints and role
inclusions. In Section 5.3, we extend the embedding into QL1 , defined in Section 5.1, to the
(HN )
logic DL-Litebool , thereby establishing the same upper bounds as for DL-LiteN
bool and its
fragments. Finally, in Section 5.4 we investigate the impact of role transitivity constraints.
5.1 DL-LiteN
bool and its Fragments: First-Order Perspective
Our aim in this section is to construct a reduction of the satisfiability problem for DL-LiteN
bool
KBs to satisfiability of QL1 -formulas. We will do this in two steps: first we present a lengthy
yet quite natural and transparent (yet exponential) reduction  , and then we shall see from
the proof that this reduction can be substantially optimized to a linear reduction  .

Let K = (T , A) be a DL-LiteN
bool KB. Recall that role (K) denotes the set of direct and
inverse role names occurring in K and ob(A) the set of object names occurring in A. For
R  role (K), let QR
T be the set of natural numbers containing 1 and all the numbers q
for which the concept  q R occurs in T (recall that the ABox does not contain number
restrictions). Note that |QR
T |  2 if T contains a functionality constraint for R.

21

fiArtale, Calvanese, Kontchakov & Zakharyaschev

With every object name ai  ob(A) we associate the individual constant ai of QL1 and
with every concept name Ai the unary predicate Ai (x) from the signature of QL1 . For each
role R  role (K), we introduce |QR
T |-many fresh unary predicates
for q  QR
T.

Eq R(x),

The intended meaning of these predicates is as follows: for a role name Pk ,
 Eq Pk (x) and Eq Pk (x) represent the sets of points with at least q distinct Pk -successors
and at least q distinct Pk -predecessors, respectively. In particular, E1 Pk (x) and
E1 Pk (x) represent the domain and range of Pk , respectively.
Additionally, for every pair of roles Pk , Pk  role (K), we take two fresh individual constants
dpk
and
dp
k
of QL1 , which will serve as representatives of the points from the domains of Pk and
	
Pk , respectively (provided that they are not empty). Let dr(K) = dr | R  role (K) .
Furthermore, for each pair of object names ai , aj  ob(A) and each R  role (K), we take
a fresh propositional variable Rai aj of QL1 to encode the ABox assertion R(ai , aj ).9
1
By induction on the construction of a DL-LiteN
bool concept C we define the QL -formula
C :
 = ,

(Ai ) = Ai (x),

( q R) = Eq R(x),

(C) = C  (x),

(C1 u C2 ) = C1 (x)  C2 (x).

1

The DL-LiteN
bool TBox T corresponds then to the QL -sentence x T (x), where
^

T  (x) =
C1 (x)  C2 (x) .

(1)

C1 vC2 T

The ABox A is translated into the following pair of QL1 -sentences
^
^
1
A =
Ak (ai ) 
Ak (ai ),
A

2

=

^

(2)

Ak (ai )A

Ak (ai )A

Pk ai aj



^

Pk ai aj .

(3)

Pk (ai ,aj )A

Pk (ai ,aj )A

For every role R  role (K), we need two QL1 -formulas:
R (x) = E1 R(x)  inv(E1 R)(inv(dr)),
^

R (x) =
Eq0 R(x)  Eq R(x) ,

(4)
(5)

0
q,q 0 QR
T , q >q
0
00
q >q >q for no q 00 QR
T

9. In what follows, we slightly abuse notation and write R(ai , aj )  A to indicate that Pk (ai , aj )  A if
R = Pk , or Pk (aj , ai )  A if R = Pk .

22

fiThe DL-Lite Family and Relations

where (by overloading the inv operator),
(
Eq Pk , if R = Pk ,
inv(Eq R) =
Eq Pk , if R = Pk ,

and

(
dp
k,
inv(dr) =
dpk ,

if R = Pk ,
if R = Pk .

Formula (4) says that if the domain of R is not empty then its range is not empty either:
it contains the constant inv(dr), the representative of the domain of inv(R).
We also need formulas representing the relationship of the propositional variables Rai aj
with the unary predicates for the role domain and range: for a role R  role (K), let R be
the following QL1 -sentence
^

^

^

q
^


Rai ajk  Eq R(ai )

ai ob(A) qQR
aj1 ,...,ajq ob(A) k=1
T
jk 6=jk0 for k6=k0



^


Rai aj  inv(R)aj ai , (6)

ai ,aj ob(A)

where inv(R)aj ai is the propositional variable Pk aj ai if R = Pk and Pk aj ai if R = Pk .
Note that the first conjunct of (6) is the only part of the translation that relies on the UNA.
Finally, for the DL-LiteN
bool knowledge base K = (T , A), we set
i
h 1
h
^
^
i
2

A  A

R .
K = x T  (x) 
R (x)  R (x)
Rrole (K)

Rrole (K)

Thus, K is a universal sentence of QL1 .
Example 5.1 Consider, for example, the KB K = (T , A) with

	
T = A v P  , P  v A, A v  2 P, > v  1 P  , P v A
and A = {A(a), P (a, a0 )}. Then we obtain the following first-order translation:
K = x (x)  A(a)  P aa0 


P aa0  E1 P (a)  P aa  E1 P (a) 


P a0 a  E1 P (a0 )  P a0 a0  E1 P (a0 ) 


P  aa0  E1 P  (a)  P  aa  E1 P  (a) 


P  a0 a  E1 P  (a0 )  P  a0 a0  E1 P  (a0 ) 


P aa0  P aa  E2 P (a)  P a0 a  P a0 a0  E2 P (a0 ) 


P  aa0  P  aa  E2 P  (a)  P  a0 a  P  a0 a0  E2 P  (a0 ) 




P aa0  P  a0 a  P a0 a  P  aa0  P aa  P  aa  P a0 a0  P  a0 a0 .
where
(x) =

A(x)  E1 P  (x)



E1 P  (x)  A(x)  A(x)  E2 P (x) 


>  E2 P  (x)  E1 P (x)  A(x) 


E1 P (x)  E1 P  (dp )  E1 P  (x)  E1 P (dp) 


E2 P (x)  E1 P (x)  E2 P  (x)  E1 P  (x) . (7)




23

fiArtale, Calvanese, Kontchakov & Zakharyaschev

1
Theorem 5.2 A DL-LiteN
bool knowledge base K = (T , A) is satisfiable iff the QL -sentence

K is satisfiable.

Proof () If K is satisfiable then there is a model M of K whose domain consists of
all the constants occurring in K i.e., ob(A)  dr(K) (say, an Herbrand model of K ). We
denote this domain by D and the interpretations of the (unary) predicates P , propositional
variables p and constants a of QL1 in M by P M , pM and aM , respectively. Thus, for every
constant a, we have aM = a. Let D0 be the set of all constants a, a  ob(A). Without loss
of generality we may assume that D0 6= .
I
We construct an interpretation I for DL-LiteN
bool based on some domain   D0 that
will be inductively defined as the union

[

I =

where

Wm ,

W0 = D0 .

m=0

The interpretations of the object names ai in I are given by their interpretations in M,
namely, aIi = aM
i  W0 . Each set Wm+1 , for m  0, is constructed by adding to Wm some
new elements that are fresh copies of certain elements from D \ D0 . If such a new element
w0 is a copy of w  D \ D0 then we write cp(w0 ) = w, while for w  D0 we let cp(w) = w.
The set Wm \ Wm1 , for m  0, will be denoted by Vm (for convenience, let W1 = , so
that V0 = D0 ).
The interpretations AIk of concept names Ak in I are defined by taking

	
AIk = w  I | M |= Ak [cp(w)] .
(8)
The interpretation PkI of a role name Pk in I will be defined inductively as the union
PkI

=


[

Pkm ,

where

Pkm  Wm  Wm ,

m=0

along with the construction of I . First, for a role R  role (K), we define the required
R-rank r(R, d) of a point d  D by taking

r(R, d) = max {0}  { q  QR
T | M |= Eq R[d] } .
It follows from (5) that if r(R, d) = q then, for every q 0  QR
T , we have M |= Eq 0 R[d]
whenever q 0  q, and M |= Eq0 R[d] whenever q < q 0 . We also define the actual R-rank
rm (R, w) of a point w  I at step m by taking
(
]{w0  Wm | (w, w0 )  Pkm }, if R = Pk ,
rm (R, w) =
]{w0  Wm | (w0 , w)  Pkm }, if R = Pk .
For the basis of induction we set, for each role name Pk  role(K),

	
M
Pk0 = (aM
i , aj )  W0  W0 | M |= Pk ai aj .

(9)

Observe that, by (6), for all R  role (K) and w  W0 ,
r0 (R, w)  r(R, cp(w)).
24

(10)

fiThe DL-Lite Family and Relations

Suppose now that Wm and the Pkm , for m  0, have already been defined. If we had
rm (R, w) = r(R, cp(w)), for all roles R  role (K) and points w  Wm , then the interpretation I we need would be constructed. However, in general this is not the case because
there may be some defects in the sense that the actual rank of some points is smaller than
the required rank.
For a role name Pk  role(K), consider the following two sets of defects in Pkm :

	
m
w  Vm | rm (Pk , w) < r(Pk , cp(w)) ,
k =

	
m
= w  Vm | rm (Pk , w) < r(Pk , cp(w)) .
k
The purpose of, say, m
k is to identify those defective points w  Vm from which precisely
r(Pk , cp(w)) distinct Pk -arrows should start (according to M), but some arrows are still
missing (only rm (Pk , w) many arrows exist). To cure these defects, we extend Wm and
Pkm respectively to Wm+1 and Pkm+1 according to the following rules:
m
(m
k ) Let w  k , q = r(Pk , cp(w))  rm (Pk , w) and d = cp(w). We have M |= Eq 0 Pk [d]
0
for some q 0  QR
T with q  q > 0. Then, by (5), M |= E1 Pk [d] and, by (4),


M |= E1 Pk [dpk ]. In this case we take q fresh copies w10 , . . . , wq0 of dp
k (and set

0
0
cp(wi ) = dpk , for 1  i  q), add them to Wm+1 and add the pairs (w, wi ), 1  i  q,
to Pkm+1 .
m



(m
k ) Let w  k , q = r(Pk , cp(w))  rm (Pk , w) and d = cp(w). Then M |= Eq 0 Pk [d]

0
for some q 0  QR
T with q  q > 0. So, by (5), we have M |= E1 Pk [d] and, by (4),
0
0
M |= E1 Pk [dpk ]. Take q fresh copies w1 , . . . , wq of dpk (and set cp(wi0 ) = dpk , for
1  i  q), add them to Wm+1 and add the pairs (wi0 , w), 1  i  q, to Pkm+1 .

Example 5.3 Consider again the KB K and its first-order translation K from Example 5.1.
Consider also a model M of K with the domain D = {a, a0 , dp, dp }, where
AM = (E1 P )M = (E1 P  )M = (E2 P )M = D,

(E2 P  )M = ,
(P aa0 )M = (P  a0 a)M = t.

We begin the construction of the interpretation I of K by setting W0 = V0 = D0 = {a, a0 }
and P 0 = {(a, a0 )}. Then we compute the required and actual ranks r(R, w) and r0 (R, w),
for R  {P, P  } and w  V0 :
(i) r(P, a) = 2 and r0 (P, a) = 1,
(iii) r(P  , a) = 1 and r0 (P  , a) = 0,

(ii) r(P, a0 ) = 2 and r0 (P, a0 ) = 0,
(iv) r(P  , a0 ) = 1 and r0 (P  , a0 ) = 1.

At the next step, we draw a P -arrow from a to a fresh copy of dp to cure defect (i), draw
two P -arrows from a0 to two more fresh copies of dp in order to cure defects (ii), and finally
we take a fresh copy of dp and connect it to a by a P -arrow, thereby curing defect (iii).
One more step of this unraveling construction is shown in Figure 4.
Observe the following important property of the construction: for m, m0  0, w  Vm0
and R  role (K),


if m < m0 ,
0,
rm (R, w) =
(11)
q,
if m = m0 , for some q  r(R, cp(w)),


r(R, cp(w)), if m > m0 .
25

fiArtale, Calvanese, Kontchakov & Zakharyaschev

.

V0

a0
V1

a

V2

dp

dp

.
Figure 4: Unraveling model M (first three steps).
To prove this property, consider all possible cases:
 If m < m0 then the point w has not been added to Wm yet, i.e., w 
/ Wm , and so we
have rm (R, w) = 0.
 If m = m0 and m0 = 0 then rm (R, w)  r(R, cp(w)) follows from (10).
 If m = m0 and m0 > 0 then w was added at step m0 to cure a defect of some point
w0  Wm0 1 . This means that there is Pk  role(K) such that either (w0 , w)  Pkm0
(m 1)
0 1
and w0  m
or (w, w0 )  Pkm0 and w0  k 0
. Consider the former case. We
k
.
Since
fresh
witnesses
are
picked
up every time the rule (km0 1 )
have cp(w) = dp
k

is applied, rm0 (Pk , w) = 1, rm0 (Pk , w) = 0 and rm0 (R, w) = 0, for every R 6= Pk , Pk .
0
So it suffices to show that r(Pk , dp
k )  1. Indeed, as M |= Eq Pk [cp(w )] for some

R
0
q  QT , we have, by (5), M |= E1 Pk [cp(w )], and so, by (4), M |= E1 Pk [dp
k ]. By the
)

1.
The
latter
case
is
considered
analogously.
definition of r, we have r(Pk , dp
k
 If m = m0 + 1 then, for each role name Pk , all defects of w are cured at step m0 + 1
m0 
0
by applying the rules (m
). Therefore, rm0 +1 (R, w) = r(R, cp(w)).
k ) and (k
 If m > m0 + 1 then (11) follows from the observation that new arrows involving w can
only be added at step m0 + 1, that is, for all m  0 and each role name Pk  role(K),
Pkm+1 \ Pkm



Vm  Vm+1



Vm+1  Vm .

(12)

I
It follows that, for all R  role (K), q  QR
T and w   , we have:

M |= Eq R[cp(w)]

iff

w  ( q R)I .

(13)

Indeed, if M |= Eq R[cp(w)] then, by definition, r(R, cp(w))  q. Let w  Vm0 . Then,
by (11), rm (R, w) = r(R, cp(w))  q, for all m > m0 . It follows from the definition of
26

fiThe DL-Lite Family and Relations

rm (R, w) and RI that w  ( q R)I . Conversely, let w  ( q R)I and w  Vm0 . Then,
by (11), q  rm (R, w) = r(R, cp(w)), for all m > m0 . So, by the definition of r(R, cp(w))
and (5), M |= Eq R[cp(w)].
By induction on the construction of concepts C in K one can readily see that, for every
w  I , we have
M |= C  [cp(w)]
iff
w  CI .
(14)
Indeed, the basis is trivial for B =  and follows from (8) for B = Ak and from (13)
for B =  q R, while the induction step for the Booleans (C = C1 and C = C1 u C2 )
immediately follows from the induction hypothesis.
Finally, we show that for each   T  A,
M |=  

iff

I |= .

The case  = C1 v C2 follows from (14); for  = Ak (ai ) and  = Ak (ai ) from the
definition of AIk . For  = Pk (ai , aj ) and  = Pk (ai , aj ), we have (aIi , aIj )  PkI iff, by (12),
(aIi , aIj )  Pk0 iff, by (9), M |= Pk ai aj .
Thus, we have established that I |= K.
() Conversely, suppose that I |= K is an interpretation with domain I . We construct
I
a model M of K based on the same I . For every ai  ob(A), we let aM
i = ai and, for
every R  role (K), we take some d  ( 1 R)I if ( 1 R)I 6=  and an arbitrary element
I
d  I otherwise, and let drM = d. Next, for every concept name Ak , we let AM
k = Ak

M = ( q R)I . Finally, for every
and, for every role R  role (K) and q  QR
T , we set Eq R

role R  role (K) and every pair of objects ai , aj  ob(A), we define (Rai aj )M to be true
iff I |= R(ai , aj ). One can readily check that M |= K . Details are left to the reader.
q
The first-order translation K of K is obviously too lengthy to provide us with reasonably
low complexity results: |K |  |K| + (2 + qT2 )  |role(K)| + 2  |role(K)|  |ob(A)|qT . However, it
follows from the proof above that a lot of information in this translation is redundant and
can be safely omitted.
Now we define a more concise translation K of K = (T , A) into QL1 by taking:
h
^
i
1
2
K = x T  (x) 
R (x)  R (x)
 A
 A ,
Rrole (K)
1

where T  (x), R (x), R (x) and A are defined as before by means of (1), (4), (5) and (2),
respectively, and
^
^
^
2
A =
EqR,a R(a) 
(Pk (ai , aj )) ,
(15)
aob(A)

Rrole (K)
a0 ob(A) R(a,a0 )A

Pk (ai ,aj )A

where qR,a is the maximum number in QR
T such that there are qR,a many distinct ai with
R(a, ai )  A (here we use the UNA) and (Pk (ai , aj )) =  if Pk (ai , aj )  A and >
2
otherwise. Now both the size of A and the size of K are linear in the size of A and K,
respectively, no matter whether the numbers are coded in unary or in binary.
27

fiArtale, Calvanese, Kontchakov & Zakharyaschev

More importantly, the translation  can actually be done in LogSpace. Indeed, this
1
2
is trivially the case for T  (x), R (x), R (x), A and the last conjunct of A . As for
2
the first conjunct of A then, for R  role (K) and a  ob(A), the maximum qR,a in
QR
T such that there are qR,a many distinct ai with R(a, ai )  A, can be computed using
log min(max QR
T , |ob(A)|) + log |ob(A)| cells. Initially we set q = 0, and then enumerate all
object names ai in A incrementing the current q each time we find R(a, ai )  A. We stop if
q = max QR
T or we reach the end of the object name list. The resulting qR,a is the maximum
number in QR
T not exceeding q.
Example 5.4 The translation K of the KB K from Example 5.1 looks as follows:
K = x (x)  A(a)  E1 P (a)  E1 P  (a0 ),
where (x) is defined by (7).
1

Corollary 5.5 A DL-LiteN
bool KB K is satisfiable iff the QL -sentence K is satisfiable.

Proof The claim follows from the fact that K is satisfiable iff K is satisfiable. Indeed, if
M |= K then clearly M |= K . Conversely, if M |= K then one can construct a new model
M0 based on the same domain D as M by taking:
0

M
 AM
k = Ak , for all concept names Ak ;
0

 Eq RM = Eq RM , for all R  role (K) and q  QR
T;
0

 (Rai aj )M is true iff R(ai , aj )  A;
0

M
 aM
i = ai , for all ai  ob(A);
0

 drM = drM , for all R  role (K).
0

We claim that M0 |= K . Indeed, Eq RM = Eq RM , for every R  role (K) and q  QR
T . It
1
2
follows then that M0 |= x T  (x) and M0 |= x R (x). By definition, M0 |=VA , M0 |= A
q
and M0 |= x R (x). It remains to show that M0 |= R . Suppose M0 |= i=1 Raaji , that
is R(a, aji )  A, for distinct aj1 , . . . , ajq , and q  QR
T . Clearly, we have q  qR,a and
M |= Eq R(a) and thus M0 |= Eq R(a).
q
As an immediate consequence of Corollary 5.5, the facts that the translation  can be
done in LogSpace, that the satisfiability problem for QL1 -formulas is NP-complete and
that DL-Litebool contains all the Booleansand so can encode full propositional logicwe
obtain the following result:
F
Theorem 5.6 Satisfiability of DL-LiteN
bool , DL-Litebool and DL-Litebool knowledge bases is
NP-complete for combined complexity.
1

Observe now that if K is a DL-LiteN
krom KB then K is in the Krom fragment of QL .
F
Theorem 5.7 Satisfiability of DL-LiteN
 , DL-Lite and DL-Lite knowledge bases, where
  {core, krom}, is NLogSpace-complete for combined complexity.

28

fiThe DL-Lite Family and Relations

Proof As the satisfiability problem for Krom formulas with the prefix of the form x (as
in K ) is NLogSpace-complete (see, e.g., Borger et al., 1997, Exercise 8.3.7) and  is a
LogSpace reduction, satisfiability is in NLogSpace for all the logics mentioned in the
theorem. As for the lower bound, it suffices to recall that the NLogSpace-hardness for
satisfiability of propositional Krom formulas is proved by reduction of the directed graph
reachability problem using only core propositional formulas (Borger et al., 1997), and so
satisfiability in all of the above logics is NLogSpace-hard.
q
1

If K is a DL-LiteN
horn KB then K belongs to the universal Horn fragment of QL .
F
Theorem 5.8 Satisfiability of DL-LiteN
horn , DL-Litehorn and DL-Litehorn KBs is P-complete
for combined complexity.

Proof As QL1 contains no function symbols and K is universal, satisfiability of K is
LogSpace-reducible to satisfiability of a set of propositional Horn formulas, namely, the
formulas that are obtained from K by replacing x with each of the constants occurring
in K . It remains to recall that the satisfiability problem for propositional Horn formulas
is P-complete (see, e.g., Papadimitriou, 1994), which gives the required upper bound for
q
DL-LiteN
horn and lower bound for DL-Litehorn .
5.2 DL-LiteHF
core is ExpTime-hard
Unfortunately, the translation  constructed in the previous section cannot be extended
to logics of the form DL-LiteHN
with both number restrictions and role inclusions. In this

section we show that the satisfiability problem for DL-LiteHF
core KBs is ExpTime-hard, which
matches the upper bound for satisfiability of DL-LiteHN
KBs
even under binary coding of
bool
natural numbers (Tobies, 2001).
Note first that, although intersection is not allowed on the left-hand side of DL-LiteHF
core
concept inclusions, in certain cases (when the right-hand side is consistent) we can simulate
it by using role inclusions and functionality constraints. Suppose that a knowledge base K
contains a concept inclusion of the form C1 u C2 v C. Define a new KB K0 by replacing
this axiom in K with the following set of new axioms, where R1 , R2 , R3 , R12 , R23 are fresh
role names:
C1 v R1

C2 v R2 ,

(16)

R1 v R12 ,

R2 v R12 ,

(17)

 2 R12 v ,
R1

v

(18)

R3 ,

(19)

R3 v C,

(20)

R3 v R23 ,



2 R23

R2 v R23 ,

v .

(21)
(22)

Lemma 5.9 (i) If I |= K0 then I |= K, for every interpretation I.
(ii) If I |= K and C I 6=  then there is a model I 0 of K0 which has the same domain as
I and agrees with it on every symbol from K.
29

fiArtale, Calvanese, Kontchakov & Zakharyaschev

Proof (i) Suppose that I |= K0 and x  C1I  C2I . By (16), there is y with (x, y)  R1I ,
I , whence
and so y  (R1 )I , and there is z with (x, z)  R2I . By (17), {(x, y), (x, z)}  R12
y = z in view of (18). By (19), y  (R3 )I and hence there is u with (u, y)  R3I and
I and (x, y)  RI . Finally, it follows
u  (R3 )I . By (20), u  C I . By (21), (u, y)  R23
23
from (22) that u = x, and so x  C I . Thus, I |= K.
(ii) Take some point c  C I and define an extension I 0 of I to the new role names by
setting:
0

 R1I = {(x, x) | x  C1I },
0

 R2I = {(x, x) | x  C2I },
0

 R3I = {(x, x) | x  (C1 u C2 )I }  {(c, x) | x  (C1 u C2 )I },
0

0

I = RI  RI
 R12
1
2

0

and

0

0

0

I = RI  RI .
R23
2
3

It is readily seen that I 0 satisfies all the axioms (16)(22), and so I 0 |= K0 .

q

We are now in a position to prove the following:
Theorem 5.10 Satisfiability of DL-LiteHF
core KBs is ExpTime-hard for combined complexity
(with or without the UNA).
Proof We will prove this theorem in two steps. First we consider the logic DL-LiteHF
horn
and show how to encode the behavior of polynomial-space-bounded alternating Turing machines (ATMs, for short) by means of DL-LiteHF
horn KBs. As APSpace = ExpTime, where
APSpace is the class of problems recognized by polynomial-space-bounded ATMs (see, e.g.,
Kozen, 2006), this will establish ExpTime-hardness of satisfiability for DL-LiteHF
horn . Then,
using Lemma 5.9, we will show how to get rid of conjunctions on the left-hand side of the
concept inclusions involved in this encoding of ATMs and thus establish ExpTime-hardness
of DL-LiteHF
core .
Without loss of generality, we can consider only ATMs M with binary computational
trees. This means that, for every non-halting state q and every symbol a from the tape
alphabet, M has precisely two instructions of the form
(q, a) ;0M (q 0 , a0 , d0 )

and

(q, a) ;1M (q 00 , a00 , d00 ),

(23)

where d0 , d00  {, } and  (resp., ) means move the head right (resp., left) one cell.
We remind the reader that each non-halting state of M is either an and-state or an or-state.
Given such an ATM M, a polynomial function p(n) such that every run of M on every
input of length n does not use more than p(n) tape cells, and an input word ~a = a1 , . . . , an ,
we construct a DL-LiteHF
horn knowledge base KM,~a with the following properties: (i) the size
of KM,~a is polynomial in the size of M, ~a, and (ii) M accepts ~a iff KM,~a is not satisfiable.
Denote by Q the set of states and by  the tape alphabet of M.
To encode the instructions of M, we need the following roles:
 Sq , Sq0 , Sq1 , for each q  Q: informally, x  (Sq )I , for some interpretation I, means
that x represents a configuration of M with the state q, and x  (Sqk )I means that
the next state, according to the transition ;kM , is q, where k  {0, 1};
30

fiThe DL-Lite Family and Relations

 Hi , Hi0 , Hi1 , for each i  p(n): x  (Hi )I means that x represents a configuration of
M where the head scans the ith cell, and x  (Hik )I that, according to the transition
;kM , k  {0, 1}, in the next configuration the head scans the ith cell;
0 , C 1 , for each i  p(n) and each a  : x  (C  )I means that x represents
 Cia , Cia
ia
ia
k )I that, according
a configuration of M where the ith cell contains a, and x  (Cia
to ;kM , k  {0, 1}, in the next configuration the ith cell contains a.

This intended meaning can be encoded using the following concept inclusions: for every
instruction (q, a) ;kM (q 0 , a0 , ) of M and every i < p(n),

k
k
Sq u Hi u Cia
v Hi+1
u Sqk0 u Cia
0,

(24)

and for every instruction (q, a) ;kM (q 0 , a0 , ) of M and every i, 1 < i  p(n),

k
k
Sq u Hi u Cia
v Hi1
u Sqk0 u Cia
0.

(25)

To preserve the symbols on the tape that are not in the active cell, we use the following
concept inclusions, for k  {0, 1}, i, j  p(n) with j 6= i, and a  :

k
Hj u Cia
v Cia
.

(26)

To synchronize our roles, we need two more (functional) roles Tk and a number of role
inclusions to be added to the TBox: for all k  {0, 1}, i  p(n), q  Q, and a  ,
k
Cia
v Cia ,

Hik v Hi ,

Sqk v Sq ,

(27)

k
Cia
v Tk ,

Hik v Tk ,

Sqk v Tk ,

(28)

 2 Tk v .

(29)

It remains to encode the acceptance conditions for M on ~a. This can be done with the help
of the role names Yk , for k  {0, 1}, and the concept name A:
Sq v A,

q an accepting state,

Yk v Tk ,
 2 Tk
Tk u A
Sq u Yk
Sq

(31)

v ,
v

(32)

Yk ,

v A,

u Y0 u Y1 v A,

(30)

(33)
q an or-state,

(34)

q an and-state.

(35)

The TBox T of the DL-LiteHF
horn knowledge base KM,~a we are constructing consists of the
axioms (24)(35) together with the auxiliary axiom
A u D v ,

(36)

where D is a fresh concept name. The ABox A of KM,~a is comprised of the following
assertions, for some object names s and u:
Sq0 (u, s),

q0 the initial state,

H1 (u, s),
Ciai (u, s),

(37)
(38)

i  p(n), ai the ith symbol on the input tape,

(39)
(40)

D(s).
31

fiArtale, Calvanese, Kontchakov & Zakharyaschev

Clearly, KM,~a = (T , A) is a DL-LiteHF
a.
horn KB and its size is polynomial in the size of M, ~
Lemma 5.11 The ATM M accepts ~a iff the KB KM,~a is not satisfiable.
Proof () Suppose that M accepts ~a but I |= KM,~a for some interpretation I. Then we
can reconstruct the full computation tree for M on ~a by induction in the following way.
Let the root of the tree be the point sI . By (37)(39), s represents the initial configuration of M on ~a in accordance with the intended meaning of the roles Sq0 , H1 and Ciai
explained above (it does not matter if, for instance, we also have sI  (H5 )I ).
Assume now that we have already found a point x  I representing some configuration
c = b1 , . . . , bi1 , (q, bi ), bi+1 , . . . , bp(n) ,

(41)

where q is the current non-halting state and the head scans the ith cell containing bi . This
means that we have
x  (Sq )I  (Hi )I

 I
and x  (Cjb
) ,
j

for all j  p(n).

Assume also that M contains two instructions of the form (23) for (q, bi ), that is q is nonhalting. If we have (q, bi ) ;kM (q 0 , b0 , ), for k = 0 or 1, then, by (24) and (26), there are
points ys , yh and yj , for j  p(n), in I such that
(x, ys )  (Sqk0 )I ,

k
(x, yh )  (Hi+1
)I ,

k I
(x, yi )  (Cib
0) ,

k I
) ,
(x, yj )  (Cjb
j

for j 6= i.

0 , C 0 and the C 0 , j 6= i, are all sub-roles of the functional role T ,
By (28)(29), Sq00 , Hi+1
k
jbj
ib0i
and so all the points ys , yh and yj coincide; we denote this point by xk . By (27), we then
have:

(x, xk )  TkI ,

 I
 I
)  (Cib
xk  (Sq0 )I  (Hi+1
0)

 I
) ,
and xk  (Cjb
j

for j 6= i.

Similarly, if we have (q, bi ) ;kM (q 00 , b00 , ), for k = 0 or 1, then, by (25) and (26), there is
a point xk  I such that
(x, xk )  TkI ,

 I
 I
)  (Cib
xk  (Sq00 )I  (Hi1
00 )

 I
) ,
and xk  (Cjb
j

for j 6= i.

Thus, for k = 0, 1, xk is a Tk -successor of x representing the configuration ck of M after it
has executed (q, bi ) ;kM (q 00 , b00 , d) in c; in this case ck is called the k-successor of c.
According to (30), every point in the constructed computation tree for M on ~a representing a configuration with an accepting state is in AI . Suppose now, inductively, that
x represents some configuration c of the form (41), q is an or-state, xk represents the ksuccessor of c and (x, xk )  TkI , for k = 0, 1, and one of the xk , say x0 , is in AI . In
view of (33), we have x0  (Y0 )I . As T0 is functional by (32) and Y0 is a sub-role of
T0 by (31), (x, x0 )  Y0I , and so, by (34), x  AI . The case of x being an and-state is
considered analogously with the help of (35).
Since M accepts ~a, we then conclude that sI  AI , contrary to (36) and (40).
() Conversely, suppose now that M does not accept ~a. Consider the full computation
tree (, <0  <1 ) with nodes labeled with configurations of M in such a way that the root
is labeled with the initial configuration
(q0 , a1 ), a2 , . . . , an , an+1 , . . . , ap(n) ,
32

fiThe DL-Lite Family and Relations

(where the ai , for n + 1  i  p(n), are all blank), and if some node x in the tree is labeled
with a non-halting c of the form (41) and M contains two instructions of the form (23), then
x has one <0 -successor labeled with the 0-successor of c and one <1 -successor labeled with
the 1-successor of c. (It should be emphasized that (, <0  <1 ) is a tree, where different
nodes may be labeled with the same configuration.)
We use this tree to construct an interpretation I = (I , I ) as follows:
 I =   {u}, for some u 
/ ;
 sI is the root of  and uI = u;
 DI = {sI };
k )I , (x, x )  (C k )I , and (x, x )  (C k )I , for j 6= i,
 (x, xk )  (Sqk0 )I , (x, xk )  (Hi+1
k
k
jbj
ib0
iff x is labeled with c of the form (41), (q, bi ) ;kM (q 0 , b0 , ) and x <k xk , for k = 0, 1;
k )I , (x, x )  (C k )I , and (x, x )  (C k )I , for j 6= i,
 (x, xk )  (Sqk0 )I , (x, xk )  (Hi1
k
k
jbj
ib0
k
iff x is labeled with c of the form (41), (q, bi ) ;M (q 0 , b0 , ) and x <k xk , for k = 0, 1;

 (u, sI )  (Sq0 )I , (u, sI )  (H1 )I , (u, sI )  (Ciai )I , i  p(n) and over  the extensions
for the roles Sq , Hi and Cia are defined according to (27);
 TkI = <k , for k = 0, 1;
 Y0I , Y1I and AI are defined inductively:
 Induction basis: if x   is labeled with an accepting configuration, then x  AI .
 Induction step: (i) if x <k xk , for k = 0, 1, and xk  AI , then (x, xk )  YkI ; (ii) if
x is an or-state (respectively, and-state) and (x, xk )  YkI for some (respectively,
all) k  {0, 1}, then x  AI .
It follows from the given definition that I |= KM,~a . Details are left to the reader.

q

The lemma we have just proved establishes that satisfiability of DL-LiteHF
horn KBs is
ExpTime-hard. Our next aim is to show how one can eliminate the conjunctions in the
left-hand side of the TBox axioms (24)(26), (33)(35). We will do this with the help of
Lemma 5.9. Before applying it, we check first that if KM,~a is satisfiable then it is satisfiable
in an interpretation I such that I |= KM,~a and C I 6= , for every C occurring in an
axiom of the form C1 u C2 v C in K. Consider, for instance, axiom (24) and assume that
I |= KM,~a , but (Sqk0 )I = . Then, we can construct a new interpretation I 0 by adding two
0
0
new points, say x and y, to the domain of I, and setting (x, y)  (Sqk0 )I , (x, y)  (Sq0 )I ,
0
0
0
(x, y)  (Tk )I . Furthermore, if q 0 is an accepting state, we also set y  AI and (x, y)  YkI .
One can readily check that I 0 is still a model for KM,~a . The other conjuncts of (24) and
the remaining axioms are considered analogously.
After an application of Lemma 5.9 to an axiom of the form C1 uC2 v C with C2 = C20 uC200
we obtain, by (16)(22), a new KB K0 with the concept inclusion of the form C20 uC200 v R1 ,
which also requires treatment by means of the same lemma. To be able to do this, we again
33

fiArtale, Calvanese, Kontchakov & Zakharyaschev

00

have to check that K0 is satisfiable in some interpretation I 00 with (R1 )I 6= . Suppose
0
that I 0 |= K0 and (R1 )I = . Then we can construct I 00 by adding two new points, say x
0
0
I 0 , RI 0 and RI 0 . It
and y, to the domain of I 0 , adding x to C I and (x, y) to each of R1I , R12
23
3
is readily seen that I 00 |= K0 .
It is to be noted that the proof above does not depend on whether the UNA is adopted
or not.
q
As an immediate consequence we obtain:
Corollary 5.12 Satisfiability of DL-LiteHF
and DL-LiteHN
KBs with or without the UNA


is ExpTime-complete for combined complexity, where   {core, krom, horn, bool}.
5.3 Reconciling Number Restrictions and Role Inclusions
As we have seen in the previous section, the unrestricted interaction between number restrictions and role inclusions allowed in the logics of the form DL-LiteHN
results in high

combined complexity of satisfiability. In Section 6.2, we shall see that the data complexity
of instance checking and query answering also becomes unacceptably high for these logics.
A quick look at the proof of Theorem 5.10 reveals the culprit: the interplay between role
inclusions R1 v R, R2 v R and functionality constraints  2 R v , which effectively mean
that if R1 (x, y) and R2 (x, z) then y = z. In this section we study the case when such an
interplay is not allowed.
(HN )
Recall from Section 2.1 that DL-Lite
TBoxes T , for   {core, krom, horn, bool},
satisfy the following conditions:
(A1 ) T may contain only positive occurrences of qualified number restrictions  q R.C,
where C is a conjunction of concepts allowed on the right-hand side of -concept
inclusions;
(A2 ) if  q R.C occurs in T , then T does not contain negative occurrences of number
restrictions  q 0 R or  q 0 inv(R) with q 0  2;
(A3 ) if R has a proper sub-role in T , then T does not contain negative occurrences of
 q R or  q inv(R) with q  2.
(HN )

DL-Lite
TBoxes can contain role constraints such as Dis(R1 , R2 ), Asym(Pk ), Sym(Pk ),
Irr(Pk ), and Ref(Pk ).
Our main aim in this section is to prove the following theorem and develop the technical
(HN )
tools we need to investigate the data complexity of reasoning with DL-Litebool and its
sublogics later on in the paper.
(HN )

Theorem 5.13 For combined complexity, (i) satisfiability of DL-Litebool KBs is NP(HN )
complete; (ii) satisfiability of DL-Litehorn KBs is P-complete; and (iii) satisfiability of
(HN )
(HN )
DL-Litekrom and DL-Litecore KBs is NLogSpace-complete.

34

fiThe DL-Lite Family and Relations

(HN )

Let us consider first the sub-language of DL-Litebool

without qualified number restric(HN )

tions and the role constraints mentioned above; we denote it by DL-Litebool . This sub-

(HN )

language is required for purely technical reasons. In Section 7, we will also use DL-Litehorn ,
but we do not need the core or Krom fragments.
(HN )
Suppose we are given a DL-Litebool
KB K = (T , A). Let Id be a distinguished
role name. We will use it to simulate the identity relation required for encoding the role
constraints. We assume that either K does not contain Id at all or satisfies the following
conditions:
(Id1 ) Id(ai , aj )  A iff i = j, for all ai , aj  ob(A),

	
Id = {1},
(Id2 ) > v Id, Id v Id  T , and QId
T = QT
(Id3 ) Id is only allowed in role inclusions of the form Id v Id and Id v R.
In what follows, without loss of generality, we will assume that
0

0
R

(Q) QR
T  QT whenever R vT R
0

(for if this is not the case we can always add the missing numbers to QR
T , e.g., by introducing
fictitious concept inclusions of the form  v  q R0 ).
Now, in the same way as in Section 5.1, we define two translations e and e of K into
the one-variable fragment QL1 of first-order logic. The former translation, e , retains the
information about the relationships between ABox objects, and we show that every model
of Ke can again be unraveled into a model of K. We define e by taking:
h
Ke = x T  (x)  T R (x) 

^

R (x)  R (x)

i



Rrole (K)

h

1

2

A  A 

^


R 

Rrole (K)

^

Rai aj  R0 ai aj

i

,

RvR0 T
ai ,aj ob(A)

1

2

where T  (x), A , A , R (x), R (x) and R are as in (1)(6) and
^
^

T R (x) =
Eq R(x)  Eq R0 (x) .
RvR0 T or
inv(R)vinv(R0 )T

(42)

qQR
T

The following lemma is an analogue of Theorem 5.2:
(HN )

Lemma 5.14 A DL-Litebool

KB K is satisfiable iff the QL1 -sentence Ke is satisfiable.

Proof The proof basically follows the lines of the proof of Theorem 5.2 with some modifications. We present a modified unraveling construction here; the converse direction is exactly
the same as in Theorem 5.2.
In each equivalence class [Ri ] = {Rj | Ri T Rj } we select a single role (a representative
of that class) and denote it by repT (Ri ). When extending Pkm to Pkm+1 , we use the following
modified curing rules:
35

fiArtale, Calvanese, Kontchakov & Zakharyaschev



(m
k ) If Pk 6= repT (Pk ) do nothing: the defects are cured for repT (Pk ). Otherwise, let
m
w  k , q = r(Pk , cp(w))  rm (Pk , w) and d = cp(w). We have M |= Eq0 Pk [d] for
some q 0  q > 0. Then, by (5), M |= E1 Pk [d] and, by (4), M |= E1 Pk [dp
k ]. In this
0 ) = dp , for 1  i  q),
case we take q fresh copies w10 , . . . , wq0 of dp
(and
set
cp(w
i
k
k
add them to Wm+1 and

 add the pairs (w, wi0 ), 1  i  q, to each Pjm+1 with Pk vT Pj (including
Pj = Pk );
 add the pairs (wi0 , w), 1  i  q, to each Pjm+1 with Pk vT Pj ;
 if Id occurs in K, add the pairs (wi0 , wi0 ), 1  i  q, to each Pjm+1 with Id vT Pj .

m
(m
k ) This rule is the mirror image of (k ): Pk and dpk are replaced everywhere with

Pk and dpk , respectively; see the proof of Theorem 5.2.

It follows from this definition that Id never has any
in the resulting
 defects and is interpreted
	
interpretation I by the identity relation IdI = (w, w) | w  I ; the interpretations of
roles respect all the role inclusions, i.e., R1I  R2I whenever R1 vT R2 .
It remains to show that the constructed interpretation I is indeed a model of K.
First, (11) trivially holds for Id as both the required and actual ranks are equal to 1. Second, (11) holds for R such that R 6= Id and R has no proper sub-roles: the proof is exactly
the same as in Theorem 5.2, taking into account that we cure defects only for a single role in
each equivalence class and that, by (42), for all R0  [R], we have r(R0 , cp(w)) = r(R, cp(w))
and r(inv(R), cp(w)) = r(inv(R0 ), cp(w)). It follows that (13) holds for Id and any role R
without proper sub-roles. However, (13) does not necessarily hold for roles R with proper
sub-roles: as follows from the construction, the actual rank may be greater than the required
rank, in which case we only have the following:
if M |= Eq R[cp(w)]

then

w  ( q R)I .

However, this is enough for our purposes. By induction on the structure of concepts and
using (A3 ), one can show that I |= C1 v C2 whenever M |= x (C1 (x)  C2 (x)), for each
concept inclusion C1 v C2  T , and therefore, I |= T . We also have I |= A (see the proof
of Theorem 5.2) and thus I |= K.
q
Remark 5.15 It follows from the proofs of Theorem 5.2 and Lemma 5.14 that, for the
(HN )
DL-Litebool
KB K = (T , A), every model M of Ke induces a model IM of K with the
following properties:
(ABox) For all ai , aj  ob(A), we have (aIi M , aIj M )  RIM iff R(ai , aj )  CleT (A), where
CleT (A) =



	
R2 (ai , aj ) | R1 (ai , aj )  A, R1 vT R2 .

(forest) The object names a  ob(A) induce a partitioning of IM into disjoint labeled
trees Ta = (Ta , Ea , `a ) with nodes Ta , edges Ea , root aIM , and a labeling function
`a : Ea  role (K) \ {Id, Id }.
36

fiThe DL-Lite Family and Relations

(copy) There is a function cp : IM  ob(A)  dr(K) such that
 cp(aIM ) = a for a  ob(A), and
 cp(w) = dr if, for some a and w0  Ta , (w0 , w)  Ea and `a (w0 , w) = inv(R).
(iso) For each R  role (K), all labeled subtrees generated by elements w  IM with
cp(w) = dr are isomorphic.
(concept) w  B IM iff M |= B  [cp(w)], for each basic concept B in K and each w  IM .
fi
	

(role) IdIM = (w, w) fi w  IM and, for every other role name Pk ,
PkIM =



	

	
(aIi M , aIj M ) | R(ai , aj )  A, R vT Pk

(w, w) | Id vT Pk

[ 
	
(w, w0 )  Ea | `a (w, w0 ) = R, R vT Pk .
aob(A)

Such a model will be called an untangled model of K (the untangled model of K induced by
M, to be more precise).
The translation e generalizes  and thus suffers from the same exponential blowup. So
we define an optimized translation, e , which is linear in the size of K, by taking:
h
^
i
1
2
 A
 A e ,
R (x)  R (x)
Ke = x T  (x)  T R (x) 
Rrole (K)
1

where T  (x), T R (x), R (x), R (x) and A are defined by (1), (42), (4), (5) and (2),
respectively, and
^
^
^
2
e R(a)
Ae =
EqR,a

(43)
(Pk (ai , aj ))e ,
aob(A)

Rrole (K)
a0 ob(A) R(a,a0 )CleT (A)

Pk (ai ,aj )A

e
e
where qR,a
is the maximum number in QR
T such that there are qR,a many distinct ai with
R(a, ai )  CleT (A) (here we use the UNA) and (Pk (ai , aj ))e =  if Pk (ai , aj )  CleT (A)

and > otherwise; cf. (15). We note again that if QR
T = {1}, for all roles R  role (K), then
the translation does not depend on whether the UNA is adopted or not.
The following corollary is proved similarly to Corollary 5.5:
(HN )

Corollary 5.16 A DL-Litebool

KB K is satisfiable iff the QL1 -sentence Ke is satisfiable.

It should be clear that the translation e can be computed in NLogSpace (for combined
1
complexity). Indeed, this is readily seen for T  (x), T R (x), R (x), R (x), and A . In
2
order to compute Ae , we need to be able to check whether R(ai , aj )  CleT (A): this test
can be performed by a non-deterministic algorithm using logarithmic space in |role (K)|
(it is basically the same as the standard directed graph reachability problem, which is
NLogSpace-complete; see, e.g., Kozen, 2006); it can be done using N  log |role (K)| +
2 log |ob(A)| cells on the work tape, where N is a constant (in fact, N = 3 is enough: one
37

fiArtale, Calvanese, Kontchakov & Zakharyaschev

has to store R, the current role R0 and the path length for the graph reachability subroutine,
which is also bounded by log |role (K)|). Therefore, the translation e can be computed
by an NLogSpace transducer.
(HN )
Now we show how satisfiability of DL-Litebool KBs can be easily reduced to satisfiability
(HN )

(HN )

of DL-Litebool
KBs. First, we assume that DL-Litebool KBs contain no role symmetry
and asymmetry constraints because Asym(Pk ) can be equivalently replaced with Dis(Pk , Pk )
and Sym(Pk ) with Pk v Pk (it should be noted that the introduction of Pk v Pk in the
TBox does not violate (A3 )). The following lemma allows us to get rid of qualified number
restrictions as well as role disjointness, reflexivity and irreflexivity constraints:
(HN )

Lemma 5.17 For every DL-Litebool
KB K = (T , A) such that

(HN )

KB K0 = (T 0 , A0 ), one can construct a DL-Litebool

 every untangled model IM of K is a model of K0 , provided that
there are no R1 (ai , aj ), R2 (ai , aj )  CleT (A) with Dis(R1 , R2 )  T 0 ,
there is no R(ai , ai )  CleT (A) with Irr(R)  T 0 ;

(44)

 every model I 0 of K0 gives rise to a model I of K based on the same domain as I 0 and
such that I agrees with I 0 on all symbols from K0 .
(HN )

(HN )

If K0 is a DL-Litehorn KB then K is a DL-Litehorn

KB.

Proof First, for every pair R, C such that  q R.C occurs in T 0 , we introduce a fresh role
name RC . Then we replace each (positive) occurrence of  q R.C in T 0 with  q RC and
add the following concept and role inclusions to the TBox:

vC
RC

and

RC v R.

We repeat this procedure until all the occurrences of qualified number restrictions are eliminated. Denote by T 00 the resulting TBox. Observe that (A1 ) and (A2 ) ensure that T 00
satisfies (A3 ). We also notice that C occurs only on the right-hand side of those extra
axioms and thus T 00 belongs to the same fragment as T 0 . It should be clear that, since the
 q R.C occur only positively, every model of T 00 is a model of T 0 . Conversely, for every
model I 0 of T 0 , there is a model I 00 of T 00 based on the same domain such that I 00 coincides
I 00 = {(w, u)  RI 0 | u  C I 0 }, for each new role R . So,
with I 0 on all symbols in T 0 and RC
C
without loss of generality we may assume that T 0 = T 00 .
Let
0
0
0
 Tirref
 Tdisj
,
T 0 = T00  Tref
0 , T0
0
where Tref
irref and Tdisj are the sets of role reflexivity, irreflexivity and disjointness con(HN )

straints in T 0 and T00 is the remaining DL-Litebool
TBox. Let

	

	
0
T10 = > v Id, Id v Id
 Id v P | Ref(P )  Tref
,

	
A01 = Id(ai , ai ) | ai  ob(A0 ) .
(HN )

We construct K by modifying the DL-Litebool
KB K0 = (T00  T10 , A0  A01 ) in two steps:
0 , take a fresh role name S and
Step 1. For every reflexivity constraint Ref(P )  Tref
P
38

fiThe DL-Lite Family and Relations

 add a new role inclusion SP v P to the TBox;
 replace every basic concept B in T00 with B SP , which is defined inductively as follows:
 ASP = A, for each concept name A,
 ( q R)SP =  q R, for each role R 
/ {P, P  },
 ( q P )SP =  (q  1) SP and ( q P  )SP =  (q  1) SP , for q  2,
 (P )SP = > and (P  )SP = >;
 replace R(ai , aj )  A0 such that R T 0 P with SP (ai , aj ) whenever i 6= j.
Intuitively, we split the role P into its irreflexive part SP and Id. Note that if P has a
reflexive proper sub-role then, by (A3 ), there are no restrictions on the maximal number
of P -successors and P -predecessors, and therefore on SP if Ref(P )  T 0 . Let (T1 , A) be the
(HN )
resulting DL-Litebool
KB. Clearly, (T1 , A) satisfies (Id1 )(Id3 ). Observe that
CleT1 (A) role(K0 ) = CleT 0 T 0 (A0 ),
0

1

(45)

where role(K0 ) means the restriction to the role names in K0 .
Let IM be an untangled model of (T1 , A). We show that IM |= T00 . Consider a role P
with Ref(P )  T 0 . Notice that SP has no proper sub-roles in T1 and IdIM is disjoint with
SPIM . Thus, SPIM  IdIM  P IM and
(*) (B SP )IM  B IM , for B =  q R with q  2, whenever Ref(P )  T 0 , R  {P, P  } and
P has a proper sub-role in T 0 .
If P has no proper sub-roles in T 0 (i.e., no proper sub-roles in T1 different from SP and Id)
then we have SPIM  IdIM = P IM . So, for all basic concepts B in T00 not covered by (*), we
have B IM = (B SP )IM . It follows from (A3 ) that IM |= T00 .
0
0 }
Step 2. Next we take into account the set D = Tdisj
 {Dis(Pk , Id) | Irr(Pk )  Tirref
of disjointness constraints by modifying the KB (T1 , A) constructed at the previous step.
Observe that R1 v  is a logical consequence of any T {Dis(R1 , R2 )} whenever R1 vT R2 .
Let T = T1  T2 , where T2 is defined by taking
fi

	
T2 = R1 v  fi R1 vT1 R2 and either Dis(R1 , R2 )  D or Dis(R2 , R1 )  D .
By (role), for any untangled model IM of (T , A) and R1 , R2  role (K), IM |= Dis(R1 , R2 )
if there are no R1 (ai , aj ), R2 (ai , aj )  CleT1 (A), which, by (45), means that there are no
R1 (ai , aj ), R2 (ai , aj )  CleT 0 T 0 (A0 ). So, if (44) holds then every untangled model IM of
0

1

0 . As IdIM is the identity relation,
(T , A) is also a model of T1  D and thus, IM |= Tdisj
0
0
0
we have IM |= Tref  Tirref . By (45), IM |= A and as we have shown above, IM |= T00 .
Therefore, IM |= K0 .
Conversely, suppose I 0 is a model of K0 . Let I be an interpretation such that IdI
0
0
0
is the identity relation, SPI = P I \ IdI , for all P with Ref(P )  T 0 , and AI = AI ,
0
0
P I = P I and aI = aI , for all concept, role and object names A, P and a in K0 . Clearly,
I |= (T00  T10 , A0  A01 ). By the definition of the SP , I |= T1 and, since I |= D, we obtain
I |= T2 and thus I |= T . By (45), I |= A, whence I |= K.
q

39

fiArtale, Calvanese, Kontchakov & Zakharyaschev

(HN )

Now, as follows from Lemma 5.17, given a DL-Lite
KB K0 , for   {krom, horn,

(HN )
bool}, we can compute the DL-Litebool
KB K using a LogSpace transducer (which is
essentially required for checking whether R T 0 P ). We immediately obtain Theorem 5.13
from Lemma 5.14 by observing that, for each   {krom, horn, bool}, Ke belongs to the
respective first-order fragment and that condition (44) can be checked in NLogSpace
(HN )
(computing CleT (A) requires directed graph accessibility checks). The result for DL-Litecore
(HN )
follows from the corresponding result for DL-Litekrom .
5.4 Role Transitivity Constraints
(HN )+

We now consider the languages DL-Lite
,   {core, krom, horn, bool}, which extend
(HN )
DL-Lite
with role transitivity constraints of the form Tra(Pk ). We remind the reader
that a role is called simple (see, e.g., Horrocks et al., 2000) if it has no transitive sub-roles
(including itself) and that only simple roles R are allowed in concepts of the form  q R, for
q  2. In particular, if T contains Tra(P ) then P and P  are not simple, and so T cannot
contain occurrences of concepts of the form  q P and  q P  , for q  2.
(HN )+
For a DL-Lite
KB K = (T , A), define the transitive closure TraT (A) of A by
taking

	
TraT (A) = A  P (ai1 , ain ) | ai2 . . . ain1 P (ai1 , aij+1 )  A, 1  j < n, Tra(P )  T .
Clearly, TraT (A) can be computed in NLogSpace: for each pair (ai , aj ) of objects in ob(A),
we add P (ai , aj ) to TraT (A) iff there is a P -path of length < |ob(A)| between ai and aj in
A (recall that the directed graph reachability problem is NLogSpace-complete).
(HN )+

(HN )

Lemma 5.18 A DL-Lite
KB (T , A) is satisfiable iff the DL-Lite
KB (T 0 , A0 ) is
0
satisfiable, where T results from T by removing all the transitivity axioms and
A0 = CleT (TraT (CleT (A))).
Proof Indeed, if the KB (T 0 , A0 ) is satisfiable then we construct a model I for it as described
in the proofs of Lemmas 5.14 and 5.17 and then take the transitive closure of P I for every P
with Tra(P )  T (and update each RI with P vT R). As P and P  are simple, T contains
no axioms imposing upper bounds on the number of P -successors and predecessors, and so
the resulting interpretation must be a model of (T , A). The converse direction is trivial. q
We note that an analogue of Remark 5.15 also holds in this case: just replace CleT (A)
with CleT (TraT (CleT (A))) in (ABox) and take the transitive closure for each transitive subrole in (role).
Remark 5.19 It should be noted that there are two different reasons for the reduction in
Lemma 5.18 to be in NLogSpace rather than in LogSpace (as the reduction  is). First,
in order to compute CleT (A), for each pair of ai , aj , one has to find a path in the directed
graph induced by the role inclusion axioms. Second, in order to compute TraT (CleT (A)), one
has to find a path in the graph induced by the ABox A itself. So, if we are concerned with
the data complexity, CleT (A) can be computed in LogSpace (in fact, in AC0 , as we shall
40

fiThe DL-Lite Family and Relations

see in Section 6.1) because the role inclusion graph (and hence its size) does not depend on
A. The second reason, however, is more dangerous for data complexity as we shall see in
Section 6.1.
As a consequence of Lemma 5.18 and Theorem 5.13 we obtain the following:
(HN )+

Corollary 5.20 For combined complexity, (i) satisfiability of DL-Litebool
complete; (ii)
(HN )+
DL-Litekrom

(HN )+
satisfiability of DL-Litehorn KBs is P-complete;
(HN )+
and DL-Litecore
KBs is NLogSpace-complete.

KBs is NP-

and (iii) satisfiability of

Note again that if the KBs do not contain number restrictions of the form  q R, for
q  2, (as in the extensions of the DL-LiteH
 languages) then the result does not depend on
the UNA.
Remark 5.21 It should be noted that role disjointness, symmetry, asymmetry and transitivity constraints can be added to any of the logics DL-LiteHF
and DL-LiteHN

 , for
  {core, krom, horn, bool}, without changing the combined complexity of their satisfiability problems (which, by Corollary 5.12, are all ExpTime-complete). Indeed, as follows
from Theorem 10 of Glimm et al. (2007), KB satisfiability in the extension of SHIQ
with role conjunction is in ExpTime if the length of role conjunctions is bounded by
some constant (in our case, this constant is 2 because Dis(R1 , R2 ) can be encoded by
(R1 u R2 ).> v ; Asym(R) is dealt with similarly). We conjecture that role reflexivity and irreflexivity constraints do not change complexity either.

6. Instance Checking: Data Complexity
So far we have assumed the whole KB K = (T , A) to be the input for the satisfiability problem. According to the classification suggested by Vardi (1982), we have been considering
its combined complexity. Two other types of complexity for knowledge bases are:
 the schema (or TBox ) complexity, where only the TBox T is regarded to be the input,
while the ABox A is assumed to be fixed; and
 the data (or ABox ) complexity, where only the ABox A is regarded to be the input.
It is easy to see that the schema complexity of the satisfiability problem for all our logics
considered above coincides with the corresponding combined complexity. In this section,
we analyze the data complexity of satisfiability and instance checking.
(HN )

H
6.1 DL-LiteN
bool , DL-Litebool and DL-Litebool

are in AC0

In what follows, without loss of generality we assume that all role and concept names of
a given knowledge base K = (T , A) occur in its TBox and write role(T ), role (T ) and
dr(T ) instead of role(K), role (K) and dr(K), respectively; the set of concept names in T
(HN )
is denoted by con(T ). In this section we reduce satisfiability of DL-Litebool KBs to model
checking in first-order logic. To this end, we fix a signature containing two unary predicates
Ak and Ak , for each concept name Ak , and two binary predicates Pk and Pk , for each role
name Pk .
41

fiArtale, Calvanese, Kontchakov & Zakharyaschev

(HN )

Consider first the case of a DL-Litebool
KB K. We represent the ABox A of K as
a first-order model AA of the above signature. The domain of AA is ob(A) and, for all
ai , aj  ob(A) and all predicates Ak , Ak , Pk and Pk in the signature,
AA |= Ak [ai ]

iff

Ak (ai )  A,

AA |= Pk [ai , aj ]

iff

Pk (ai , aj )  A,

AA |= Ak [ai ]

iff

Ak (ai )  A,

AA |= Pk [ai , aj ]

iff

Pk (ai , aj )  A.

Now we construct a first-order sentence T in the same signature such that (i) T depends
on T but does not depend on A, and (ii) AA |= T iff Ke is satisfiable.
To simplify presentation, we denote by ext(T ) the extension of T with the following
concept inclusions:
0
0
00
  q 0 R v  q R, for all R  role (T ) and q, q 0  QR
T such that q > q and q > q > q
00
R
for no q  QT , and
0
0
  q R v  q R0 , for all q  QR
T and R v R  T or inv(R) v inv(R )  T .
V
Clearly, (ext(T )) (x) is equivalent (in first-order logic) to T  (x)T R (x) Rrole (T ) R (x);
see (1), (5) and (42).
Let Bcon(T ) be the set of basic concepts occurring in T (i.e., concepts of the form A
and  q R, for A  con(T ), R  role (T ) and q  QR
T ). To indicate which basic concepts
hold or do not hold on a domain element of a first-order model of Ke , we use functions
 : Bcon(T )  {>, }, which will be called types. Denote by Tp the set of all such types
(there are 2|Bcon(T )| of them). For a complex concept C, we define (C) by induction:
(C) = (C) and (C1 u C2 ) = (C1 )  (C2 ). The propositional variable-free formula
^

T =
(C1 )  (C2 )
C1 vC2 ext(T )

ensures that the type  is consistent with concept and role inclusions in T . It should be
emphasized that  T is built from  and > using the Boolean connectives and therefore does
not depend on a particular domain element of AA . The following formula is true if a given
1
2
element x of AA is of type  (see A and Ae ; (2) and (43), respectively):
  (x) =

^


(Ak (x)  (Ak ))  (Ak (x)  (Ak ))



Ak con(T )

^

^

Eq RT (x)  ( q R)



^



Rrole (T ) qQR
T


xy PkT (x, y)  Pk (x, y)   ,

Pk role(T )

where Eq RT (x) and RT (x, y), for R  role (T ), are abbreviations defined by
^
^

Eq RT (x) = y1 . . . yq
(yi 6= yj ) 
RT (x, yi ) ,
1i<jq

RT (x, y) =

_
Pk vT

Pk (x, y)



_
Pk vT

R

42

(46)

1iq

Pk (y, x).
R

(47)

fiThe DL-Lite Family and Relations

Clearly, we have R(ai , aj )  CleT (A) iff AA |= RT [ai , aj ] and AA |= Eq RT [a] iff a has at
least q distinct R-successors in CleT (A) (and thus in every model of K).
Without loss of generality we may assume that role (T ) = {R1 , . . . , Rk } 6= . Denote
by Tpk the set of k-tuples ~ containing a type dri  Tp for each role Ri  role (T ). We
then set
_
~
x T (x),
T
=
k
~
Tp

where
(dr1 ,...,drk )

T

(x)

=

_ 

  (x)   T

^



T
dr
i





Tp

Ri role (T )

^



(Ri ) 

Ri role (T )

_



ds (Ri )  inv(dri ) (inv(Ri )) .

Srole (T )

To explain the meaning of the subformulas of T , assume that (T , A) is satisfiable. In order
to construct a model M for Ke from the first-order model AA , we have to specify the basic
concepts that contain a given constant of Ke . In other words, we have to select a type for
each dri  dr(T ) and each a  ob(A). The formula T says that one can select a k-tuple
of types ~ = (dr1 , . . . , drk )  Tpk such that one of its disjuncts is true in AA . Such a
k-tuple fixes the witness part of the model M, consisting of the dri , and determines the
basic concepts these dri belong to. Then each disjunct of T says that (having fixed the
witness part of the model), for every a  ob(A), there is a type  (determining the basic
concepts a belongs to) such that
  is consistent with the information about a in A (cf.   (x));
  is also consistent with the concept and role inclusions of T (cf.  T );
T );
 each of dr1 , . . . , drk is consistent with the concept and role inclusions of T (cf. dr
i

 each role Ri with a nonempty domain (i.e., either  or any of ds is > on Ri ) has
a nonempty range, in particular, inv(dri ) (inv(Ri )) = >; see also R (x) as defined
by (4).
Lemma 6.1 AA |= T iff Ke is satisfiable.
~
Proof () Fix some ~ = (dr1 , . . . , drk )  Tpk such that AA |= x T (x). Then, for each
~

a  ob(A), fix some type such that the respective disjunct of T (x) holds on a in AA and
denote it by a . Define a first-order model M over the domain ob(A)  dr(T ) by taking:
 M |= B  [c] iff c (B) = >, for all c  ob(A)  dr(T ) and B  Bcon(T )
(B  is the unary predicate for B as defined on p. 22). It is easy to check that M |= Ke .
() Suppose now that Ke is satisfiable. Then there is a model M of Ke with domain
ob(A)  dr(T ). To see that AA |= T , it suffices to take the functions dri and a defined
by:
43

fiArtale, Calvanese, Kontchakov & Zakharyaschev

 dri (B) = > iff M |= B  [dri ], for dri  dr(T ) and B  Bcon(T ),
 a (B) = > iff M |= B  [a], for a  ob(A) and B  Bcon(T ).
Details are left to the reader.

q

It follows from Lemmas 6.1 and 5.17 and Corollary 5.16 that we have:
H
Corollary 6.2 The satisfiability and instance checking problems for DL-LiteN
bool , DL-Litebool
(HN )
and DL-Litebool KBs are in AC0 for data complexity.
(HN )

H
Proof DL-LiteN
bool and DL-Litebool are sub-languages of DL-Litebool , and for them the
(HN )
result immediately follows from Lemma 6.1 and Corollary 5.16. For a DL-Litebool KB
(HN )

K0 = (T 0 , A0 ), by Lemma 5.17, we construct a DL-Litebool
KB K = (T , A) such that
0
K is satisfiable iff K is satisfiable and (44) holds. The latter condition corresponds to the
following first-order sentence
^
^


T 0 =
xy R1T (x, y)  R2T (x, y)  

x PkT (x, x)   ,
Dis(R1 ,R2 )T 0

Irr(Pk )T 0

evaluated in AA . Therefore, K0 is satisfiable iff AA |= T  T 0 . Let  = T  T 0 and  0
be the result of replacing each SP (t1 , t2 ), for Ref(P )  T 0 , with P (t1 , t2 )  (t1 6= t2 ); see the
proof of Lemma 5.17. It remains to observe that AA |=  iff AA0 |=  0 .
q
As before, this result does not depend on the UNA for any member of the DL-Lite family
that has no number restrictions of the form  q R, for q  2 (in particular, for DL-LiteH
bool
and its fragments).
We also note that transitive roles cannot be included in our languages for free if we are
concerned with data complexity:
Lemma 6.3 Satisfiability and instance checking of DL-Litecore KBs extended with role transitivity constraints are NLogSpace-hard for data complexity.
Proof Suppose we are given a directed graph. Let P be a role name. Define an ABox
A by taking P (ai , aj )  A iff there is an edge (ai , aj ) in the graph. Then a node an is
reachable from a node a0 iff the DL-Litecore ABox A  {P (a0 , an )} is not satisfiable in
models with transitive P . This encoding immediately gives the claim of the lemma because
the directed graph reachability problem is NLogSpace-complete, NLogSpace is closed
under the complement (see, e.g., Kozen, 2006) and the TBox {Tra(P )} does not depend on
the input.
q
On the other hand, as the reduction of Lemma 5.18 is computable in NLogSpace, we
obtain the following:
(HN )+

Corollary 6.4 Satisfiability and instance checking of DL-Litebool
complete for data complexity.

KBs are NLogSpace-

Proof The upper bound is obtained by applying the NLogSpace reduction of Lemma 5.18
and using Corollary 6.2. The lower bound follows from Lemma 6.3.
q

44

fiThe DL-Lite Family and Relations

6.2 P- and coNP-hardness for Data Complexity
Let us now turn to the data complexity of instance checking for the DL-Lite logics with
arbitrary number restrictions and role inclusions. As follows from the results of Ortiz et al.
(2006) for SHIQ, instance checking (and in fact query answering) for DL-LiteHN
bool is in
coNP for data complexity, while the results of Hustadt et al. (2005) and Eiter et al. (2008)
for Horn-SHIQ imply a polynomial-time upper bound for DL-LiteHF
horn .
Here we show that these upper bounds are optimal in the following sense: on the one
hand, instance checking in DL-LiteHF
core is P-hard for data complexity; on the other hand,
HN
it becomes coNP-hard for both DL-LiteHF
krom and DL-Litecore (that is, if we allow negated
concept names or arbitrary number restrictionsin fact,  2 R is enough). Note that the
results of this section do not depend on whether we adopt the UNA or not.
Theorem 6.5 The instance checking (and query answering) problem for DL-LiteHF
krom KBs
is data-hard for coNP (with or without the UNA).
Proof The proof is by reduction of the unsatisfiability problem for 2+2CNF, which is
known to be coNP-complete (Schaerf, 1993). Given a 2+2CNF formula
 =

n
^

(ak,1  ak,2  ak,3  ak,4 ),

k=1

where each ak,j is one of the propositional variables a1 , . . . , am , we construct a KB (T , A )
whose TBox T does not depend on . We will use the object names f , ck , for 1  k  n,
and ai , for 1  i  m, role names S, Sf and Pj , Pj,t , Pj,f , for 1  j  4, and concept names
A and D.
Define A to be the set of the following assertions, for 1  k  n:
S(f, ck ),

P1 (ck , ak,1 ),

P2 (ck , ak,2 ),

P3 (ck , ak,3 ),

P4 (ck , ak,4 ),

and let T consist of the axioms
 2 Pj v ,
Pj,f v Pj ,

Pj,t v Pj ,

Pj,t v Pj,f ,

Pj,f


Pj,t

v A,

P1,f u P2,f u P3,t u P4,t v

Sf ,

v A,

for1  j  4,

(48)

for 1  j  4,

(49)

for 1  j  4,

(50)

for 1  j  4,

(51)
(52)



 2 S v ,

(53)

Sf v S,

(54)

Sf v D.

(55)

Note that axiom (52) does not belong to DL-LiteHF
krom because of the conjunctions in its
left-hand side. However, it can be eliminated with the help of Lemma 5.9. So let us prove
that (T , A ) |= D(f ) iff  is not satisfiable.
() Suppose that  is not satisfiable and I |= (T , A ). Define an assignment a of the
truth values t and f to propositional variables by taking a(ai ) = t iff aIi  AI . As  is false
45

fiArtale, Calvanese, Kontchakov & Zakharyaschev

under a, there is k, 1  k  n, such that a(ak,1 ) = a(ak,2 ) = f and a(ak,3 ) = a(ak,4 ) = t.
In view of (50), for each j, 1  j  4, we have cIk  (Pj,t )I  (Pj,f )I , and by (49),
cIk  (Pj )I . Therefore, by (48) and (51), cIk  (Pj,t )I if a(ak,j ) = t and cIk  (Pj,f )I if
a(ak,j ) = f, and hence, by (52), cIk  (Sf )I . Then by (53) and (54), we have f I  (Sf )I ,
from which, by (55), f I  DI . It follows that (T , A ) |= D(f ).
() Conversely, suppose that  is satisfiable. Then there is an assignment a such that
a(ak,1 ) = t or a(ak,2 ) = t or a(ak,3 ) = f or a(ak,4 ) = f, for all 1  k  n. Define I by taking

	 
	  	
  I = x i | 1  i  m  yk | 1  k  n  z ,
 aIi = xi , for 1  i  m,
cIk = yk , for 1  k  n,
f I = z,

	 
	  	
 AI = xi | a(ai ) = t  yk | 1  k  n  z ,

	 
	 
	
I = (y , aI ) | 1  k  n, a(a ) = t  (x , x ) | a(a ) = t  (z, z) ,
 Pj,t
i i
i
k k,j
k,j
	 
	

I = (y , aI ) | 1  k  n, a(a ) = f  (x , x ) | a(a ) = f ,
 Pj,f
i i
i
k,j
k k,j
I  P I , for 1  j  4,
 PjI = Pj,t
j,f

	
 SfI = (z, yk ) | a(ak,1  ak,2  ak,3  ak,4 ) = f = ,

	
 S I = (z, yk ) | 1  k  n ,

	
 DI = z | a() = f = .

It is not hard to check that I |= (T , A ) and I 6|= D(f ).

q

Theorem 6.6 The instance checking (and the query answering) problem for DL-LiteHN
core
KBs is data-hard for coNP (with or without the UNA).
Proof The proof is again by reduction of the unsatisfiability problem for 2+2CNF. The
HF
main difference from the previous one is that DL-LiteHN
core , unlike DL-Litekrom , cannot express
covering conditions like (50). It turns out, however, that we can use number restrictions
to represent constraints of this kind. Given a 2+2CNF formula , we take the same ABox
A constructed in the proof of Theorem 6.5. The ( independent) TBox T , describing the
meaning of any such representation of  in terms of A , is also defined in the same way as
in that proof, except that the axiom (50) is now replaced by the following set of axioms:
Tj,1 v Tj ,


2 Tj

v ,

Pj v Tj,1 ,

Tj,1

u


Tj,2

Tj,2 v Tj ,

v

(56)
(57)

Pj v Tj,2 ,


Tj,3
,

 2 Tj v Pj,t

Tj,3 v Tj ,

(58)
(59)

Tj,3 v Pj,f ,

(60)

where Tj , Tj,1 , Tj,2 , Tj,3 are fresh role names, for each j, 1  j  4. Note that axioms (52)
and (59) do not belong to DL-LiteHN
core because of the conjunctions in their left-hand side, but
46

fiThe DL-Lite Family and Relations

we can easily eliminate them using Lemma 5.9. So it remains to prove that (T , A ) |= D(f )
iff  is not satisfiable.
() Suppose that  is not satisfiable and I |= (T , A ). Define an assignment a of the
truth values t and f to propositional variables by taking a(ai ) = t iff aIi  AI . As  is
false under a, there is k, 1  k  n, such that a(ak,1 ) = a(ak,2 ) = f, a(ak,3 ) = a(ak,4 ) = t.
For each j, 1  j  4, we have cIk  (Pj )I ; by (58), cIk  (Tj,1 )I , (Tj,2 )I . So there
I and (cI , v )  T I . If v 6= v then cI  ( 2 T )I
are v1 , v2 such that (cIk , v1 )  Tj,1
1
2
j
j,2
k 2
k
 I
and, by (60), cIk  (Pj,t )I . Otherwise, if v1 = v2 = v, we have v  (Tj,3
) by (59),
and so by (56) and (57), cIk  (Tj,3 )I , from which, by (60), cIk  (Pj,f )I . Therefore,
cIk  (Pj,t )I  (Pj,f )I , and by (49), cIk  (Pj )I . Thus, by (48) and (51), cIk  (Pj,t )I
if a(ak,j ) = t and cIk  (Pj,f )I if a(ak,j ) = f, and hence, by (52), cIk  (Sf )I . Then
by (53) and (54), we have f I  (Sf )I , from which, by (55), f I  DI . It follows that
(T , A ) |= D(f ).
() Conversely, suppose that  is satisfiable. Then there is an assignment a such that
a(ak,1 ) = t or a(ak,2 ) = t or a(ak,3 ) = f or a(ak,4 ) = f, for all 1  k  n. Define I by taking

	 
	 
	  	
 I = xi | 1  i  m  yk | 1  k  n  uk,j,1 , uk,j,2 | 1  j  4, 1  k  n  z ,
 aIi = xi , for 1  i  m,

cIk = yk , for 1  k  n,

f I = z,

 AI = {xi | a(ai ) = t},
	

I = (y , aI ) | 1  k  n, a(a ) = t , for 1  j  4,
 Pj,t
k,j
k k,j
	

I = (y , aI ) | 1  k  n, a(a ) = f , for 1  j  4,
 Pj,f
k,j
k k,j
I  P I , for 1  j  4,
 PjI = Pj,t
j,f

	
I = (y , u
 Tj,1
k k,j,1 ) | 1  k  n , for 1  j  4,

	
I = (y , u
 Tj,2
k k,j,2 ) | 1  k  n, a(ak,j ) = t 

	
(yk , uk,j,1 ) | 1  k  n, a(ak,j ) = f , for 1  j  4,

	
I = (y , u
 Tj,3
i k,j,1 ) | 1  k  n, a(ak,j ) = f , for 1  j  4,
I  TI ,
 TjI = Tj,1
j,2

	
 SfI = (z, yk ) | a(ak,1  ak,2  ak,3  ak,4 ) = f = ,

	
 S I = (z, yk ) | 1  k  n ,

	
 DI = z | a() = f = .

It is not hard to check that I |= (T , A ) and I 6|= D(f ).

q

Our next lower bound would follow from Theorem 6, item 2 in the work of Calvanese
et al. (2006); unfortunately, the proof there is incorrect and cannot be repaired.
Theorem 6.7 The instance checking (and query answering) problem for DL-LiteHF
core KBs
is data-hard for P (with or without the UNA).
47

fiArtale, Calvanese, Kontchakov & Zakharyaschev

Proof The proof is by reduction of the entailment problem for Horn-CNF, which is known
to be P-complete (see, e.g., Borger et al., 1997, Exercise 2.2.4). Given a Horn-CNF formula
 =

n
^

(ak,1  ak,2  ak,3 )



k=1

p
^

al,0 ,

l=1

where each ak,j and each al,0 is one of the propositional variables a1 , . . . , am , we construct a
KB (T , A ) whose TBox T does not depend on . We will need the object names c1 , . . . , cn
and vk,j,i , for 1  k  n, 1  j  3, 1  i  m (for each variable, we take one object name
for each possible occurrence of this variable in each non-unit clause), role names S, St and
Pj , Pj,t , for 1  j  3, and a concept name A.
Define A to be the set containing the assertions:
S(v1,1,i , v1,2,i ), S(v1,2,i , v1,3,i ), S(v1,3,i , v2,1,i ), S(v2,1,i , v2,2,i ), S(v2,2,i , v2,3,i ), . . .
. . . , S(vn,2,i , vn,3,i ), S(vn,3,i , v1,1,i ),
Pj (vk,j,i , ck )

iff

A(v1,1,i )

al,0 = ai ,

iff

ak,j = ai ,

for 1  i  m,

for 1  i  m, 1  k  n, 1  j  3,
for 1  i  m, 1  l  p

(all objects for each variable are organized in an S-cycle and Pj (vk,j,i , ck )  A iff the
variable ai occurs in the kth non-unit clause of  in the jth position). Let T consist of the
following concept and role inclusions:
St v S,

(61)

 2 S v ,

(62)

A v St ,
St

(63)

v A,

(64)

 2 P1 v 
P1,t v P1 ,
A v P1,t ,


P1,t

u

2 P3

 2 P2 v ,

(65)

P2,t v P2 ,

(66)

A v P2,t ,

(67)

v ,

(68)

P3,t v P3 ,

(69)


P2,t

v


P3,t
,

(70)

P3,t v A.

(71)

As before, here we have an axiom, namely (70), that does not belong to DL-LiteHF
core because
of the conjunction in its left-hand side, but again it can be eliminated with the help of
Lemma 5.9. Our aim is to show that (T , A ) |= A(v1,1,i0 ) iff  |= ai0 .
() Suppose that  |= ai0 . Consider an arbitrary model I of (T , A ) and define a to be
the assignment of the truth values t and f to propositional variables such that a(ai ) = t iff
I
I
v1,1,i
 AI , for 1  i  m. By (61)(64), for each i, 1  i  m, we have either vk,j,i
 AI ,
I
I
for all k, j with 1  k  n, 1  j  3, or vk,j,i 
/ A , for all k, j with 1  k  n,
1  j  3. Now, if we have a(ak,1 ) = t and a(ak,2 ) = t, for 1  k  n then, by (65)(67),
 I
 I
 I
I
cIk  (P1,t
) , (P2,t
) . By (70), cIk  (P3,t
) and hence, by (68) and (69), vk,3,i
 (P3,t )I ,
48

fiThe DL-Lite Family and Relations

St , S
S
Pj,t , Pj
Pj

a1  a2  a3
y1

a2  a4  a5
y2

A
A

.

xk,j,i
.

zk,j,i
a1

a2

a3

a4

a5

Figure 5: The model I satisfying (T , A ), for  = (a1  a2  a3 )  (a2  a4  a5 ).
I
I
where ak,3 = ai , which means, by (71), that vk,3,i
 AI , and so v1,1,i
 AI and a(ai ) = t. It
I
follows that a() = t, and hence a(ai0 ) = t, which, by definition, means that v1,1,i
 AI .
0
So we can conclude that (T , A ) |= A(v1,1,i0 ).

() Conversely, suppose that  6|= ai0 . Then there is an assignment a with a() = t
and a(ai0 ) = f. We construct a model I of (T , A ) such that I 6|= A(v1,1,i0 ). Define I by
taking

	 
	
 I = xk,j,i , zk,j,i | 1  k  n, 1  j  3, 1  i  m  yk | 1  k  n ,
 cIk = yk , for 1  k  n,
I
= xk,j,i , for 1  k  n, 1  j  3, 1  i  m,
 vk,j,i

	
 AI = xk,j,i | 1  k  n, 1  j  3, a(ai ) = t ,
[

	
 SI =
Si , where Si = (xk,1,i , xk,2,i ), (xk,2,i , xk,3,i ), (xk,3,i , xk1,1,i ) | 1  k  n
1im

and k  1 = k + 1 if k < n, and k  1 = 1 if k = n,
[
 StI =
Si ,
1im
a(ai )=t


	
 PjI = (xk,j,i , yk ) | 1  k  n, ai = ak,j 	
(xk,j,i , zk,j,i ) | 1  k  n, ai 6= ak,j , for 1  j  2,

	
 P3I = (xk,3,i , yk ) | 1  k  n, ai = ak,3 ,

	
I = (x
 Pj,t
 k,j,i , yk ) | 1  k  n, ai = ak,j , a(a
	 i) = t 
(xk,j,i , zk,j,i ) | 1  k  n, ai 6= ak,j , for 1  j  2,

	
I = (x
 P3,t
k,3,i , yk ) | 1  k  n, ai = ak,3 , a(ai ) = t .
It is routine to check that we indeed have I |= (T , A ) and I 6|= A(v1,1,i0 ). See Figure 5 for
an example.
q

49

fiArtale, Calvanese, Kontchakov & Zakharyaschev

7. Query Answering: Data Complexity
The positive existential query answering problem is known to be data-complete for coNP
in the case of DL-LiteHN
bool : the upper bound follows from the results of Ortiz et al. (2006),
while the lower bound was established for DL-Litekrom by Calvanese et al. (2006), Schaerf
(1993). In the case of DL-LiteHF
horn , query answering is data-complete for P, as follows
from the results of Hustadt et al. (2005) and Eiter et al. (2008) for Horn-SHIQ, while for
0
DL-LiteH
horn it is in AC (Calvanese et al., 2006).
In fact, the coNP upper bound holds for the extension of DL-LiteHN
bool with role disjointness and (a)symmetry constraints (this follows from Glimm et al., 2007, Theorem 10;
cf. Remark 5.21). We conjecture that the same result holds for role (ir)reflexivity constraints.
Our main result in this section is the following:
Theorem 7.1 The positive existential query answering problem for the logics DL-LiteN
horn ,
(HN )
H
0
DL-Litehorn and DL-Litehorn is in AC for data complexity.
(HN )

Proof Suppose that we are given a consistent DL-Litehorn KB K0 = (T 0 , A0 ) (with all its
concept and role names occurring in the TBox T 0 ) and a positive existential query in prenex
(HN )
form q(~x) = ~y (~x, ~y ) in the signature of K0 . Consider the DL-Litehorn KB K = (T , A)
(HN )

provided by Lemma 5.17 (the language DL-Litehorn

is defined in Section 5.3).

Lemma 7.2 For every tuple ~a of object names in K0 , we have K0 |= q(~a) iff I |= q(~a) for
all untangled models I of K.
Proof () Suppose that K0 |= q(~a) and I is an untangled model I of K. By Lemma 5.17
and in view of consistency of K0 , which ensures that (44) holds, we then have I |= K0 and
therefore, I |= q(~a).
() Suppose I 0 |= K0 . By Lemma 5.17, there is a model I of K with the same domain as
0
I that coincides with I 0 on all symbols in K0 . As I |= q(~a), we must then have I 0 |= q(~a),
and so K0 |= q(~a) as required.
q
Next we show that, as Ke is a Horn sentence, it is enough to consider just one special
model I0 of K in the formulation of Lemma 7.2. Let M0 be the minimal Herbrand model of
(the universal Horn sentence) Ke . We remind the reader (for details consult, e.g., Apt, 1990;
Rautenberg, 2006) that M0 can be constructed by taking the intersection of all Herbrand
models for Ke , that is, of all models based on the domain that consists of constant symbols
from Ke i.e.,  = ob(A)  dr(T ); cf. Remark 5.15. We then have the following
M0 |= B  [c]

iff

Ke |= B  (c),

for B  Bcon(T ) and c  .

Let I0 be the untangled model of K induced by M0 . Denote the domain of I0 by I0 .
Property (copy) of Remark 5.15 provides us with a function cp : I0  .
There are two consequences of Lemma 5.14. First, we have
aIi 0  B I0

iff

K |= B(ai ),

for B  Bcon(T ) and ai  ob(A).

50

(72)

fiThe DL-Lite Family and Relations

Second, for every R  role (T ), if RI0 6=  then RI 6= , for all models I of K. Indeed, if
RI0 6=  then M0 |= (R) [dr]. Therefore, (T  {R v }, A) is not satisfiable, and thus
RI 6= , for all I with I |= K. Moreover, if RI0 6=  then
w  B I0

iff

K |= R v B,

for B  Bcon(T ) and w  I0 with cp(w) = dr. (73)

Lemma 7.3 If I0 |= q(~a) then I |= q(~a) for all untangled models I of K.
Proof Suppose I |= K. As q(~a) is a positive existential sentence, it is enough to construct
a homomorphism h : I0  I. We remind the reader that, by (forest), the domain I0 of
I0 is partitioned into disjoint trees Ta , for a  ob(A). Define the depth of a point w  I0
to be the length of the shortest path in the respective tree to its root. Denote by Wm the
set of points of depth  m; in particular, W0 = {aI0 | a  ob(A)}. We construct h as the
union of maps hm , m  0, where each hm is defined on Wm and has the following properties:
hm+1 (w) = hm (w), for all w  Wm , and
(am ) for every w  Wm , if w  B I0 then hm (w)  B I , for each B  Bcon(T );
(bm ) for all u, v  Wm , if (u, v)  RI0 then (hm (u), hm (v))  RI , for each R  role (T ).
For the basis of induction, we set h0 (aIi 0 ) = aIi , for ai  ob(A). Property (a0 ) follows then
from (72) and (b0 ) from (ABox) of Remark 5.15.
For the induction step, suppose that hm has already been defined for Wm , m  0. Set
hm+1 (w) = hm (w) for all w  Wm . Consider an arbitrary v  Wm+1 \ Wm . By (forest),
there is a unique u  Wm such that (u, v)  Ea , for some Ta . Let `a (u, v) = S. Then,
by (copy), cp(v) = inv(ds). By (role), u  (S)I0 and, by (am ), hm (u)  (S)I , which
means that there is w  I with (hm (u), w)  S I . Set hm+1 (v) = w. As cp(v) = inv(ds)
and (inv(S))I0 6= , it follows from (73) that if v  B I0 then w0  B I whenever we have
w0  (inv(S))I . As w  (inv(S))I , we obtain (am+1 ) for v. To show (bm+1 ), we notice
that, by (role), we have (w, v)  RI0 , for some w  Wm+1 , just in two cases: either
w  Wm+1 \ Wm , and then w = v and Id vT R, or w  Wm , and then w = u and S vT R.
In the former case, (hm+1 (v), hm+1 (v))  RI because IdI is the identity relation by (role).
In the latter case, we have (u, v)  S I0 ; hence (hm+1 (u), hm+1 (v))  S I and, as S vT R,
(hm+1 (u), hm+1 (v))  RI .
q
Assume now that, in the query q(~x) = ~y (~x, ~y ), we have ~y = y1 , . . . , yk , and  is a
quantifier-free formula. Our next lemma shows that in this case to check whether I0 |= q(~a)
it suffices to consider only the points of depth  m0 in I0 , for some m0 that does not
depend on |A|.
Lemma 7.4 Let m0 = k + |role (T )|. If I0 |= ~y (~a, ~y ) then there is an assignment a0 in
Wm0 (i.e., a0 (yi )  Wm0 for all i) such that I0 |=a0 (~a, ~y ).
Proof Suppose that I0 |=a (~a, ~y ), for some assignment a in I0 , and that there is yi ,
1  i  k, with a(yi ) 
/ Wm0 . Let Y be the minimal subset of ~y that contains yi and
every y such that either P (y 0 , y) or P (y, y 0 ) is a subformula of , for some y 0  Y and
some role name P . Let yj  Y be such that there is m > |role (T )| with a(yj )  Wm and
51

fiArtale, Calvanese, Kontchakov & Zakharyaschev

a(y) 
/ Wm1 for all y  Y (for convenience, W1 =  as before). Clearly, such an m exists:
a(yi ) 
/ Wm0 , Y has at most k variables and, by (forest), relations P I0 can connect a point
in Wn \ Wn1 only with a point in Wn+1 \ Wn2 , for n  1. Let w = a(yj ) be a point in
Ta . As w  Wm \ Wm1 , we have cp(w) = dr, for some R  role (T ). As there are at most
|role (T )| distinct labels in each labeled tree Ta and in view of (copy), for each point u
of depth > |role (T )|, there is a point u0 of depth  |role (T )| in the same Ta such that
cp(u) = cp(u0 ); by (iso), the trees generated by u and u0 are isomorphic. So, there is an
isomorphism g from the labeled tree generated by w (which contains all a(y), for y  Y )
onto the labeled tree generated by some point of depth  |role (T )| in Ta . Define a new
assignment aY by taking aY (y) = g(a(y)) if y  Y and aY (y) = a(y) otherwise. By (copy),
(concept) and (role) we then have I0 |=aY (~a, ~y ) and aY (y)  Wm0 , for each y  Y . If
aY (yj ) 
/ Wm0 for some j, we repeat the described construction. After at most k iterations
we shall obtain an assignment a0 required by the lemma.
q
To complete the proof of Theorem 7.1, we encode the problem K |= q(~a)? as a model
checking problem for first-order formulas. In precisely the same way as in Section 6.1, we
fix a signature that contains unary predicates A, A, for each concept name A, and binary
predicates P , P , for each role name P , and then represent the ABox A of K as a first-order
model AA with domain ob(A). Now we define a first-order formula T ,q (~x) in the above
signature such that (i) T ,q (~x) depends on T and q but not on A, and (ii) AA |= T ,q (~a)
iff I0 |= q(~a).
We begin by defining formulas B (x), for B  Bcon(T ), that describe the types of the
elements of ob(A) in the model I0 in the following sense (see also (72)):
AA |= B [ai ]

iff aIi 0  B I0 ,

for B  Bcon(T ) and ai  ob(A).

(74)

0 (x),  1 (x), . . . of formulas
These formulas are defined as the fixed-points of sequences B
B
with one free variable, where
(
A(x),
if B = A,
0
B (x) =
T
Eq R (x), if B =  q R,
_

i1
i1
i
0
B
(x) = B
(x) 
B
(x)      B
(x) , for i  1,
1
k
B1 uuBk vBext(T )

and Eq RT (x) is given by (46). (As in Section 6.1, to simplify presentation we use ext(T ) instead of T .) It should be clear that if there is some i such that, for all B  Bcon(T ),
i (x)   i+1 (x) (i.e., every  i (x) is equivalent to  i+1 (x) in first-order logic), then
B
B
B
B
i (x)   j (x) for every B  Bcon(T ) and j  i. So the minimum such i does not
B
B
N (x).
exceed N = |Bcon(T )|, and we set B (x) = B
Next we introduce sentences B,dr , for B  Bcon(T ) and dr  dr(T ), that describe the
types of elements in dr(T ) in the following sense (see also (73)):
AA |= B,dr

iff

w  B I0 , for B  Bcon(T ) and each w  I0 with cp(w) = dr.

(75)

(By (concept), this definition is correct.) These sentences are defined similarly to B (x).
Namely, for each B  Bcon(T ) and each dr  dr(T ), we inductively define a sequence
52

fiThe DL-Lite Family and Relations

0
1
B,dr
, B,dr
, . . . by taking
0
B,dr
= 0B,dr

and

i
B,dr
= iB,dr 

_


i1
i1
B






, for i  1,
,dr
B
,dr
1
k

B1 uuBk vBext(T )

where iB,dr = , for all i  0, whenever B 6= R and
0R,dr = x inv(R) (x)

and

iR,dr =

_

i1
inv(R),ds
,

for i  1.

dsdr(T )
i+1
i
It should be clear that there is i  |role (T )|N such that B,dr
 B,dr
, for all B  Bcon(T )
|role (T )|N

and dr  dr(T ). So we set B,dr = B,dr
.
Now we consider the directed graph GT = (VT , ET ), where VT is the set of all equivalence
classes [R], [R] = {R0 | R T R0 }, such that R is not empty in some model of T , and ET
is the set of all pairs ([Ri ], [Rj ]) such that
(path) T |= inv(Ri ) v  q Rj

and

either inv(Ri ) 6vT Rj or q  2,

and Rj has no proper sub-role satisfying (path). We have ([Ri ], [Rj ])  ET iff, for any
ABox A0 , whenever the minimal untangled model I0 of (T , A0 ) contains a copy w of inv(dri0 ),
for Ri0  [Ri ], then w is connected to a copy of inv(drj0 ), for Rj0  [Rj ], by all relations S
with Rj vT S.
Recall now that we are given a query q(~x) = ~y (~x, ~y ), where  is a quantifier-free
positive formula and ~y = y1 , . . . , yk . Let T ,m0 be the set of all paths in the graph GT of
length  m0 . More precisely,
 	 
	
T ,m0 =   ([R1 ], [R2 ], . . . , [Rn ]) | 1  n  m0 , ([Rj ], [Rj+1 ])  ET , for 1  j < n .
R

For ,  0  T ,m0 and a role R  role (T ), we write    0 if one of the following three
conditions is satisfied: (i)  =  0 and Id vT R, (ii) .[S] =  0 or (iii)  =  0 .[inv(S)], for
some role S with S vT R.
Let kT ,m0 be the set of all k-tuples of the form ~ = (1 , . . . , k ), i  T ,m0 . Intuitively,
when evaluating the query ~y (~x, ~y ) over I0 , each bound, or non-distinguished, variable yi
is mapped to a point w in Wm0 . However, the first-order model AA does not contain the
points from Wm0 \ W0 , and to represent them, we use the following trick. By (forest),
every point w in Wm0 is uniquely determined by the pair (a, ), where aI0 is the root of the
tree Ta containing w, and  is the sequence of labels `a (u, v) on the path from aI0 to w.
It follows from the unraveling procedure and (path) that   T ,m0 . So, in the formula
T ,q we are about to define we assume that the yi range over W0 and represent the first
component of the pairs (a, ), whereas the second component is encoded in the ith member
of ~ (these yi should not be confused with the yi in the original query q, which range over
all of Wm0 ). In order to treat arbitrary terms t occurring in (~x, ~y ) in a uniform way, we
set t~ = , if t = a  ob(A) or t = xi , and t~ = i , if t = yi (the distinguished variables xi
and the object names a are mapped to W0 and do not require the second component of the
pairs).
Given an assignment a0 in Wm0 we denote by split(a0 ) the pair (a, ~ ), where a is an
assignment in AA and ~ = (1 , . . . , k )  kT ,m0 are such that
53

fiArtale, Calvanese, Kontchakov & Zakharyaschev

 for each distinguished variable xi , a(xi ) = a with aI0 = a0 (xi );
 for each bound variable yi , a(yi ) = a and i = ([R1 ], . . . , [Rn ]), n  m0 , with aI0
being the root of the tree containing a0 (yi ) and R1 , . . . , Rn being the sequence of
labels `a (u, v) on the path from aI0 to a0 (yi ).
Not every pair (a, ~ ), however, corresponds to an assignment in Wm0 because some paths
in ~ may not exist in our I0 : GT represents possible paths in all models for the fixed
TBox T and varying ABox. As follows from the unraveling procedure, a point in Wm0 \ W0
corresponds to a  ob(A) and  = ([R], . . . )  T ,m0 iff a does not have enough R-witnesses
0
R
in A, i.e., iff AA |= q
 ) with
R [a]  q R [a], for some q  QT . Thus, for every (a, ~
~ = (1 , . . . , k ), there is an assignment a0 in Wm0 with split(a0 ) = (a, ~ ) iff AA |=a ~ (~y ),
where
^
_

0
q
 (1 ,...,k ) (y1 , . . . , yk ) =
Ri (yi )  q Ri (yi )
R

1ik
i 6=

qQT i

and each Ri , for 1  i  k with i 6= , is such that i = ([Ri ], . . . ).
We define now, for every ~  kT ,m0 , concept name A and role name R,
(
A (t),
if t~ = ,
A~ (t) =
A,inv(ds) , if t~ =  0 .[S], for some  0  T ,m0 ,
 T
~

~


R (t1 , t2 ), if t1 = t2 = ,
R
R~ (t1 , t2 ) =
(t1 = t2 ),
if t~1  t~2 and either t~1 6=  or t~2 6= ,


,
otherwise,
where RT (y1 , y2 ) is given by (47). We claim that, for every assignment a0 in Wm0 and
(a, ) = split(a0 ),
I0 |=a0 A(t)

iff

AA |=a A~ (t),

I0 |=a0 R(t1 , t2 )

iff

AA |=a R~ (t1 , t2 ),

for all concept names A and terms t,
for all roles R and terms t1 , t2 .

(76)
(77)

For A(a), A(xi ) or A(yi ) with i =  the claim follows from (74). For A(yi ) with i =  0 .[S],
by (copy), we have cp(a(yi )) = inv(dr), for some R  [S]; the claim then follows from (75).
For R(yi1 , yi2 ) with i1 = i2 = , the claim follows from (ABox). Let us consider the case
of R(yi1 , yi2 ) with i2 6= : we have a0 (yi2 ) 
/ W0 and thus, by (role), I0 |=a0 R(yi1 , yi2 ) iff
 a0 (yi1 ), a0 (yi2 ) are in the same tree Ta , for a  ob(A), i.e., AA |=a (yi1 = yi2 ),
 and either (a0 (yi1 ), a0 (yi2 ))  Ea and then `a (a0 (yi1 ), a0 (yi2 )) = S for some S vT R,
or (a0 (yi2 ), a0 (yi1 ))  Ea and then `a (a0 (yi2 ), a0 (yi1 )) = S for some inv(S) vT R, or
R

a0 (yi1 ) = a0 (yi2 ) and then Id vT R, i.e., i1  i2 .
Other cases are similar and left to the reader.
Finally, let ~ (~x, ~y ) be the result of attaching the superscript ~ to each atom of  and

_ 
T ,q (~x) = ~y
~ (~x, ~y )  ~ (~y ) .
~
 kT ,m

0

54

fiThe DL-Lite Family and Relations

As follows from (76)(77), for every assignment a0 in Wm0 , we have I0 |=a0 (~x, ~y ) iff
AA |=a ~ (~x, ~y ) for (a, ) = split(a0 ). For the converse direction notice that, if AA |=a ~ (~y )
then there is an assignment a0 in Wm0 with split(a0 ) = (a, ~ ).
Clearly, AA |= T ,q (~a) iff I0 |= q(~a), for every tuple ~a. We also note that, for every
pair of tuples ~a and ~b of object names in ob(A), ~ (~a, ~b) is a positive existential sentence
with inequalities, and so is domain-independent.10 It is also easily seen that, for each ~b,
~ (~b) is domain-independent. It follows from the minimality of I0 that T ,q (~a) is domainindependent, for each tuple ~a of object names in ob(A).

Finally, note that the resulting query contains  |role (T )|k(k+|role (T )|) disjuncts. q

8. DL-Lite without the Unique Name Assumption
In this section, unless otherwise stated, we assume that the interpretations do not respect
the UNA, that is, we may have aIi = aIj for distinct object names ai and aj . The consequence
relation |=noUNA refers to the class of such interpretations.
Description logics without the UNA are usually extended with additional equality and
inequality constraints of the form:
ai  aj

and

ai 6 aj ,

where ai , aj are object names. Their semantics is quite obvious: we have I |= ai  aj iff
aIi = aIj , and I |= ai 6 aj iff aIi 6= aIj . The equality and inequality constraints are supposed
to belong to the ABox part of a knowledge base. It is to be noted, however, that reasoning
with equalities is LogSpace-reducible to reasoning without them:
Lemma 8.1 For every KB K = (T , A), one can construct in LogSpace in the size of
A a KB K0 = (T , A0 ) without equality constraints such that I |= K iff I |= K0 , for every
interpretation I.
Proof Let G = (V, E) be the undirected graph with

	
V = ob(A),
E = (ai , aj ) | ai  aj  A or aj  ai  A
and [ai ] the set of all vertices of G that are reachable from ai . Define A0 by removing all the
equality constraints from A and replacing every ai with aj  [ai ] with minimal j. Note that
this minimal j can be computed in LogSpace: just enumerate the object names aj with
respect to the order of their indexes j and check whether the current aj is reachable from
ai in G. It remains to recall that reachability in undirected graphs is SLogSpace-complete
and that SLogSpace = LogSpace (Reingold, 2008).
q
As we mentioned in Section 5.3, the logics of the form DL-LiteH
 do not feel whether
we adopt the UNA or not. With this observation and Lemmas 5.17, 5.18 and 8.1 at hand,
we obtain the following result as a consequence of Theorem 5.13:
10. A query q(~
x) is said to be domain-independent in case AA |=a q(~
x) iff A |=a q(~
x), for each A such that
the domain of A contains ob(A), the active domain of AA , and AA = AAA and P A = P AA , for all concept
and role names A and P .

55

fiArtale, Calvanese, Kontchakov & Zakharyaschev

Theorem 8.2 With or without the UNA, for combined complexity, (i) satisfiability of
H
DL-LiteH
bool KBs is NP-complete; (ii) satisfiability of DL-Litehorn KBs is P-complete; and
H
(iii) satisfiability of DL-LiteH
krom and DL-Litecore KBs is NLogSpace-complete. These results hold even if the KBs contain role disjointness, (a)symmetry, (ir )reflexivity and transitivity constraints, equalities and inequalities.
On the other hand, from Corollary 6.2 and Lemmas 5.17, 5.18 and 8.1 we can derive
the following:
Theorem 8.3 Without the UNA, satisfiability and instance checking for DL-LiteH
bool KBs
0
0
are in AC for data complexity. These problems are also in AC if the KBs contain role
disjointness, (a)symmetry and (ir )reflexivity constraints and inequalities. However, they
are LogSpace-complete if the KBs may contain equalities, and NLogSpace-complete if
role transitivity constraints are allowed.
We also note that our complexity results (Corollary 5.12, Theorems 6.5, 6.6 and 6.7) for
the logics DL-LiteHF
and DL-LiteHN
do not depend on the UNA.


In this section, we analyze the combined and data complexity of reasoning in the logics
(HF )
(HN )
of the form DL-Lite
and DL-Lite
(as well as their fragments) without the UNA.
The obtained and known results are summarized in Table 2 on page 17.
(HN )

8.1 DL-Lite

: Arbitrary Number Restrictions

The following theorem shows that the interaction between number restrictions and the
possibility of identifying objects in the ABox results in a higher complexity.
Theorem 8.4 Without the UNA, satisfiability of DL-LiteN
core KBs (even without equality
and inequality constraints) is NP-hard for both combined and data complexity.
Proof The proof is by reduction of the following variant of the 3SAT problemcalled monotone one-in-three 3SAT which is known to be NP-complete (Garey & Johnson, 1979):
given a positive 3CNF formula
 =

n
^


ak,1  ak,2  ak,3 ,

k=1

where each ak,j is one of the propositional variables a1 , . . . , am , decide whether there is an
assignment for the variables aj such that exactly one variable is true in each of the clauses
k
in . To encode this problem in the language of DL-LiteN
core , we need object names ai , for
1  k  n, 1  i  m, and ck and tk , for 1  k  n, role names S and P , and concept
names A1 , A2 , A3 . Let A be the ABox containing the following assertions:
S(a1i , a2i ), . . . , S(ain1 , ani ), S(ani , a1i ),

for 1  i  m,

S(t1 , t2 ), . . . , S(tn1 , tn ), S(tn , t1 ),
P (ck , tk ),

for 1  k  n,

P (ck , akk,j ), Aj (akk,j ),

for 1  k  n, 1  j  3,

56

fiThe DL-Lite Family and Relations

and let T be the TBox with the following axioms:
A1 v A2 ,

A2 v A3 ,

A3 v A1 ,

 2 S v ,

 4 P v .

Clearly, (T , A ) is a DL-LiteN
core KB and T does not depend on  (so that we cover both
combined and data complexity). We claim that the answer to the monotone one-in-three
3SAT problem is positive iff (T , A ) is satisfiable without the UNA.
() Suppose I |= (T , A ). Define an assignment a of the truth values f and t to
propositional variables by taking a(ai ) = t iff (a1i )I = (t1 )I . Our aim is to show that
a(ak,j ) = t for exactly one j  {1, 2, 3}, for each k, 1  k  n. For all j  {1, 2, 3},
we have (cIk , (akk,j )I )  P I . Moreover, (akk,i )I 6= (akk,j )I for i 6= j. As cIk  ( 3 P )I and
(cIk , (tk )I )  P I , we then must have (akk,j )I = (tk )I for some unique j  {1, 2, 3}. It follows
from functionality of S that, for each 1  k  n, we have (a1k,j )I = (t1 )I for exactly one
j  {1, 2, 3}.
() Let a be an assignment satisfying the monotone one-in-three 3SAT problem. Take
some ai0 with a(ai0 ) = t (clearly, such an i0 exists, for otherwise a() = f) and construct
an interpretation I = (I , I ) by taking:

	 
	
 I = yk , z k | 1  k  n  xki | a(ai ) = f, 1  i  m, 1  k  n ,
 cIk = yk and (tk )I = z k , for 1  k  n,
(
xki , if a(ai ) = f,
 (aki )I =
for 1  i  m, 1  k  n,
z k , if a(ai ) = t,

	
 S I = ((a1i )I , (a2i )I ), . . . , ((ain1 )I , (ani )I ), ((ani )I , (a1i )I ) | 1  i  m ,
	

 P I = (cIk , (tk )I ), (cIk , (akk,1 )I ), (cIk , (akk,2 )I ), (cIk , (akk,3 )I ) | 1  k  n .
It is readily checked that I |= (T , A ).

q

In fact, the above lower bound is optimal:
(HN )

(HN )+

Theorem 8.5 Without the UNA, satisfiability of DL-LiteN
and DL-Lite
 , DL-Lite
KBs with equality and inequality constraints is NP-complete for both combined and data
complexity and any   {core, krom, horn, bool}.
Proof The lower bound is immediate from Theorem 8.4, and the matching upper bound
(HN )+
can be proved by the following non-deterministic algorithm. Given a DL-Litebool
KB
K = (T , A), we
 guess an equivalence relation  over ob(A);

 select in each equivalence class ai / a representative, say ai , and replace every occurrence of a  ai / in A with ai ;
 fail if the equalities and inequalities are violated in the resulting ABoxi.e., if it
contains ai 6 ai or ai  aj , for i 6= j;
57

fiArtale, Calvanese, Kontchakov & Zakharyaschev

 otherwise, remove the equality and inequality constraints from the ABox and denote
the result by A0 ;
(HN )+

 use the NP satisfiability checking algorithm for DL-Litebool
KB K0 = (T , A0 ) is consistent under the UNA.

to decide whether the

Clearly, if the algorithm returns yes, then I 0 |= K0 , for some I 0 respecting the UNA, and
we can construct a model I of K (not necessarily respecting the UNA) by extending I 0 with
0
the following interpretation of object names: aI = aIi , whenever ai is the representative
of a/ (I coincides with I 0 on all other symbols). Conversely, if I |= K then we take
the equivalence relation  defined by ai  aj iff aIi = aIj . Let I 0 be constructed from
I by removing the interpretations of all object names that are not representatives of the
equivalence classes for . It follows that I 0 respects the UNA and I 0 |= K0 , so the algorithm
returns yes.
q
(HF )

8.2 DL-Lite

: Functionality Constraints
(HF )+

Let us consider now DL-Litebool
and its fragments. The following lemma shows that for
these logics reasoning without the UNA can be reduced in polynomial time in the size of
the ABox to reasoning under the UNA.
(HF )+

Lemma 8.6 For every DL-Litebool

KB K = (T , A) with equality and inequality con(HF )+

straints, one can construct in polynomial time in |A| a DL-Litebool
KB K0 = (T , A0 ) such
that A0 contains no equalities and inequalities and K is satisfiable without the UNA iff K0
is satisfiable under the UNA.
Proof In what follows by identifying aj with ak in A we mean replacing each occurrence
of ak in A with aj . We construct A0 by first identifying aj with ak , for each aj  ak  A,
and removing the equality from A, and then exhaustively applying the following procedure
to A:
 if  2 R v   T and R(ai , aj ), R(ai , ak )  CleT (A), for distinct aj and ak , then
identify aj with ak (recall that a functional R cannot have transitive sub-roles and
thus CleT (A) is enough).
If the resulting ABox contains ai 6 ai , for some ai , then, clearly, K is not satisfiable, so
we add A(ai ) and A(ai ) to the ABox, for some concept name A. Finally, we remove
all inequalities from the ABox and denote the result by A0 . It should be clear that A0 is
computed from A in polynomial time and that, without the UNA, K is satisfiable iff K0 is
satisfiable. So it suffices to show that K0 is satisfiable without the UNA iff it is satisfiable
under the UNA. The implication () is trivial.
() Observe that the above procedure ensures that
e
qR,a
 1,

for each R with  2 S v   T , R vT S and a  ob(A0 )
(HN )

(see page 37 for definitions). Let K00 be the DL-Litebool
KB provided by Lemma 5.17 for
K0 . It follows from the above property and the proofs of Lemma 5.14 and Corollary 5.16
58

fiThe DL-Lite Family and Relations

that if K00 is satisfiable without the UNA then (K00 )e is satisfied in a first-order model
with some constants interpreted by the same domain element. As (K00 )e is a universal
first-order sentence containing no equality, it is satisfiable in a first-order model such that
all constants are interpreted by distinct elements. It follows from the proofs of Lemma 5.14
and Corollary 5.16 that this first-order model can be unraveled into a model J for K00
respecting the UNA. By Lemma 5.17, J is a model of K0 .
q
The reduction above cannot be done better than in P, as shown by the next theorem:
Theorem 8.7 Without the UNA, satisfiability of DL-LiteF
core KBs (even without equality
and inequality constraints) is P-hard for both combined and data complexity.
Proof The proof is by reduction of the entailment problem for Horn-CNF (as in the proof
of Theorem 6.7). Let
 =

n
^

ak,1  ak,2  ak,3



p
^



al,0

l=1

k=1

be a Horn-CNF formula, where each ak,j and each al,0 is one of the propositional variables
a1 , . . . , am and ak,1 , ak,2 , ak,3 are all distinct, for each k, 1  k  n. To encode the Pk
complete problem  |= ai ? in the language of DL-LiteF
core we need object names t, ai , for
1  k  n, 1  i  m, and fk and gk , for 1  k  n, and role names P , Q, S and T . The
ABox A contains the following assertions
S(a1i , a2i ), . . . , S(an1
, ani ), S(ani , a1i ),
i

for 1  i  m,

P (akk,1 , fk ), P (akk,2 , gk ), Q(gk , akk,3 ), Q(fk , akk,1 ),
T (t, a1l,0 ),

for 1  k  n,

for 1  l  p,

and the TBox T asserts that all of the roles are functional:
 2 P v ,

 2 Q v ,

 2S v 

and

 2 T v .

Clearly, K = (T , A) is a DL-LiteF
core KB and T does not depend on . We claim that
 |= aj iff (T , A  {T (t, a1j )}) is not satisfiable without the UNA. To show this, it suffices
to prove that  |= aj iff K |=noUNA T (t, a1j ).
() Suppose  |= aj . Then we can derive aj from  using the following inference rules:
  |= al,0 for each l, 1  l  p;
 if  |= ak,1 and  |= ak,2 , for some k, 1  k  n, then  |= ak,3 .
We show that K |=noUNA T (t, a1j ) by induction on the length of the derivation of aj from .
The basis of induction is trivial. So assume that aj = ak,3 ,  |= ak,1 ,  |= ak,2 , for some k,
1  k  n, and that K |=noUNA T (t, a1k,1 )  T (t, a1k,2 ). Suppose also that I |= K. Since T
0
0
is functional, we have (a1k,1 )I = (a1k,2 )I . Since S is functional, (akk,1 )I = (akk,2 )I , for all k 0 ,
1  k 0  n, and in particular, for k 0 = k. Then, since P is functional, fkI = gkI , from which,
0
0
by functionality of Q, (akk,3 )I = (akk,1 )I . Finally, since S is functional, (akk,3 )I = (akk,1 )I ,
59

fiArtale, Calvanese, Kontchakov & Zakharyaschev

for all k 0 , 1  k 0  n, and in particular, for k 0 = 1. Thus, I |= T (t, a1j ) and therefore
K |=noUNA T (t, a1j ).
() Suppose that  6|= aj . Then there is an assignment a such that a() = t and
a(aj ) = f. Construct an interpretation I by taking

	 
	  	
 I = xki | a(ai ) = f, 1  k  n, 1  i  m  z k , uk , vk | 1  k  n  w ,
(
xki , if a(ai ) = f,
 (aki )I =
for 1  k  n and 1  i  m,
z k , if a(ai ) = t,

	
 tI = w, T I = (w, z 1 ) ,

	
 S I = ((a1i )I , (a2i )I ), . . . , ((an1
)I , (ani )I ), ((ani )I , (a1i )I ) | 1  i  m ,
i
(
vk , if a(ak,2 ) = f,
 fkI = uk and gkI =
for 1  k  n,
uk , if a(ak,2 ) = t,
	

 P I = ((akk,1 )I , fkI ), ((akk,2 )I , gkI ) | 1  k  n ,
	

 QI = (gkI , (akk,3 )I ), (fkI , (akk,1 )I ) | 1  k  n .
It is readily checked that I |= K and I 6|= T (t, a1j ), and so K 6|=noUNA T (t, a1j ).

q

The above result strengthens the NLogSpace lower bound for instance checking in
DL-LiteF
core proved by Calvanese et al. (2008).
(HF )

(HF )+

Corollary 8.8 Without the UNA, satisfiability of DL-LiteF
and DL-Lite
 , DL-Lite
KBs,   {core, krom, horn}, with equalities and inequalities is P-complete for both combined and data complexity.
(HF )
(HF )+
Without the UNA, satisfiability of DL-LiteF
KBs with
bool , DL-Litebool and DL-Litebool
equalities and inequalities is NP-complete for combined complexity and P-complete for data
complexity.

Proof The upper bounds follow from Lemma 8.6 and the corresponding upper bounds for
the UNA case. The NP lower bound for combined complexity is obvious and the polynomial
lower bounds follow from Theorem 8.7.
q
8.3 Query Answering: Data Complexity
The P and coNP upper bounds for query answering without the UNA follow from the results for Horn-SHIQ (Hustadt et al., 2005; Eiter et al., 2008) and SHIQ (Ortiz et al., 2006,
2008; Glimm et al., 2007), respectively (see the discussion at the beginning of Section 7).
We present here the following result:
Theorem 8.9 Without the UNA, positive existential query answering for DL-LiteH
horn KBs
with role disjointness, (a)symmetry, (ir )reflexivity constraints and inequalities is in AC0
for data complexity. This problem is LogSpace-complete if, additionally, equalities are
allowed in the KBs.
60

fiThe DL-Lite Family and Relations

Proof The proof follows the lines of the proof of Theorem 7.1 and uses the observation
that models without the UNA give no more answers than their untangled counterparts.
More precisely, let KB K0 = (T 0 , A0 ) be as above. Suppose that it is consistent. Let q(~x)
be a positive existential query in the signature of K0 . Given K0 , Lemma 5.17 provides
us with a KB K. It is easy to see that K is a DL-LiteH
horn KB extended with inequality
constraints. The following is an analogue of Lemma 7.2, which also allows us to get rid of
those inequalities:
Lemma 8.10 For every tuple ~a of object names in K0 , we have K0 |=noUNA q(~a) iff I |= q(~a)
for all untangled models I of K (respecting the UNA).
Proof () Suppose that K0 |=noUNA q(~a) and I is an untangled model of K. As I respects
the UNA, by Lemma 5.17 and in view of satisfiability of K0 , which ensures that (44) holds,
we then have I |= K0 and therefore, I |= q(~a).
() Suppose I 0 |= K0 . We construct an interpretation J 0 respecting the UNA as follows.
0
0
0
0
Let J be the disjoint union of I and ob(A). Define a function h : J  I by taking
0
0
h(a) = aI , for each a  ob(A), and h(w) = w, for each w  I , and let


0
0
0	
0
0	
aJ = a,
AJ = u | h(u)  AI
and
P J = (u, v) | (h(x), h(v))  P I ,
for each object, concept and role name a, A, P . Clearly, J 0 respects the UNA and J 0 |= K0 .
It also follows that h is a homomorphism.
By Lemma 5.17, there is a model I of K with the same domain as J 0 that coincides
with J 0 on all symbols in K0 . As I |= q(~a), we must then have J 0 |= q(~a), and since h is a
homomorphism, I 0 |= q(~a). Therefore, K0 |=noUNA q(~a) as required.
q
The remaining part of the proof is exactly as in Theorem 7.1 (since now we may assume
that K is a DL-LiteH
horn KB containing no inequality constraints).
LogSpace-completeness for the case with equalities follows from Lemma 8.1.
q

9. Conclusion
In this article, we investigated the boundaries of the extended DL-Lite family of description
logics by providing a thorough and comprehensive understanding of the interaction between
various DL-Lite constructs and their impact on the computational complexity of reasoning.
We studied 40 different logics, classified according to five mutually orthogonal features:
(1) the presence or absence of role inclusion assertions, (2) the form of the allowed concept
inclusion assertions, distinguishing four main logical groups called core, Krom, Horn, and
Bool, (3) the form of the allowed numeric constraints, ranging from none, to global functionality constraints only, and to arbitrary number restrictions, (4) the presence or absence
of the unique name assumption (and equalities and inequalities between object names, if
this assumption is dropped), and (5) the presence or absence of standard role constraints
such as role disjointness, role symmetry, asymmetry, reflexivity, irreflexivity and transitivity. For all of the resulting logics, we studied the combined and data complexity of KB
satisfiability and instance checking, as well as the data complexity of answering positive
existential queries.
61

fiArtale, Calvanese, Kontchakov & Zakharyaschev

query answering
= instance checking

coNP
query answering

.
Legend
satisfiability
combined complexity

with/without UNA
role inclusions

F

N

ExpTime
NP
P
NLogSpace

no UNA
no role inclusions

F

UNA
no role inclusions

coNP
P
in AC0

oo
l

N

instance checking
data complexity

B

ro
m
K

co

H

or
n

.

re

F

N

Figure 6: Complexity of basic DL-Lite logics.
The obtained tight complexity results are illustrated in Figure 6, where the combined
complexity of satisfiability is represented by the height of vertical dashed lines, while the
data complexity of instance checking by the size and color of the circle on top of these lines
(recall that satisfiability and instance checking are reducible to the complement of each
other). The data complexity of query answering for the core and Horn logics, shown on
the left-hand side of the separating vertical plane, coincides with the data complexity of
instance checking; for the Krom and Bool logics, shown on the right-hand side of the plane,
query answering is always data-complete for coNP. The upper layer shows the complexity
of logics with role inclusions, in which case it does not depend on whether we adopt the
UNA or not. The middle and the lower layers deal with the logics without role inclusions
when the UNA is dropped or adopted, respectively. In each of these layers, the twelve
languages are arranged in the 4  3 grid: one axis shows the type of concepts inclusions
allowed (Horn, core, Krom, Bool), while the other the type of number restrictions (none,
global functionality F or arbitrary N ). Some observations are in order:
 Under the UNA but without role inclusions, number restrictions do not increase the
complexity of reasoning, which depends only on the form of concept inclusions allowed.
 On the other hand, without any form of number restrictions, the logics can have role
inclusions and are insensitive to the UNA; again, the complexity is determined by the
shape of concept inclusions only.
 In either of the above cases, instance checking is in AC0 for data complexity, which
means that the problems are first-order rewritable.

62

fiThe DL-Lite Family and Relations

 Without UNA adopted and without either disjunctions or role inclusions, functionality
leads to P-completeness of instance checking for data complexity, which suggests its
reducibility to Datalog.
 For data complexity, there is no difference between the core and Horn logics, and
between the Krom and Bool ones, which means that the core and Krom logics can be
extended with conjunctions on the left-hand side of concept inclusions for free.
(HF )

(HN )

Finally, for the logics DL-Lite
and DL-Lite
with both (qualified) number restrictions and role inclusions, whose interaction is restricted by conditions (A1 )(A3 ), the
complexity of reasoning always coincides with the complexity of the fragments DL-LiteF

and, respectively, DL-LiteN
 without role inclusions, no matter whether we adopt the UNA
or not.
Role disjointness, symmetry and asymmetry constraints can be added to any of the
(HN )
(HF )
languages without changing their complexity. In fact, the DL-Lite
and DL-Lite
logics contain all of the above types of constraints together with role reflexivity and irreflexivity. We conjecture that (ir)reflexivity constraints can be added to all other logics without
affecting their complexity. However, if we extend any DL-Lite logic with role transitivity
constraints, then the combined complexity of satisfiability remains the same, while instance
checking and query answering become data-hard for NLogSpace. And the addition of
equality between object nameswhich only makes sense if the UNA is droppedleads to
an increase from membership in AC0 to LogSpace-completeness for data complexity; all
other results remain unchanged.
The list of DL constructs considered in this paper is far from being complete. For
example, it would be of interest to analyze the impact of nominals, role chains and Boolean
operators on roles on the computational behavior of the DL-Lite logics. Another interesting
and practically important problem is to investigate in depth the interaction between various
constructs with the aim of pushing restrictions like (A1 )(A3 ) as far as possible.
One of the main ideas behind the DL-Lite logics was to provide efficient access to large
amounts of data through a high-level conceptual interface. This is supposed to be achieved
by representing the high-level view of the information managed by the system as a DL-Lite
TBox T , the data stored in a relational database as an ABox A, and then rewriting positive existential queries to the knowledge base (T , A) as standard first-order queries to the
database represented by A. Such an approach is believed to be viable because, for a number
of DL-Lite logics, the query answering problem is in AC0 for data complexity; cf. Theorems 7.1, 8.9 and Figure 6. The first-order rewriting technique has been implemented in
various system, notably in QuOnto (Acciarri et al., 2005; Poggi et al., 2008b), which can
query, relying on ontology-to-relational mappings, data stored in any standard relational
database management system, and in Owlgres (Stocker & Smith, 2008), which can access
an ABox stored in a Postgres database (though, to the best of our knowledge, the latter
implementation is incomplete for conjunctive query answering). It is to be noted, however,
that the size of the rewritten query can be substantially larger than the size of the original
query, which can cause problems even for a very efficient database query engine.
For a positive existential query q and TBox T , there are two major sources of high
complexity of the first-order formula T ,q in the proof of Theorem 7.1: (i) the formulas
B (x) computing whether an ABox object is an instance of a concept B (and the formulas
63

fiArtale, Calvanese, Kontchakov & Zakharyaschev

R,dr computing whether objects with outgoing R-arrows are instances of B), and (ii) the
(HN )
disjunction over the paths ~ in the graph GT . In the case of DL-Litecore , the size of
(HN )
B (x) is linear in |T |, while for DL-Litehorn it can become exponential (however, various
optimizations are possible). The size of the disjunction in (ii) is exponential in the number
of non-distinguished variables in q. One way of removing source (i) would be to extend
the given database (ABox) A by precomputing the Horn closure of the ABox with respect
to the TBox and storing the resulting data in a supplementary database. This approach
is advocated by Lutz et al. (2008) for querying databases via the description logic EL. It
could also be promising for the Horn fragments of expressive description logics such as
SHIQ (Hustadt et al., 2005; Hustadt, Motik, & Sattler, 2007)containing DL-LiteHF
horn as
a sub-languagefor which the data complexity of instance checking (Hustadt et al., 2005,
2007) and conjunctive query answering is polynomial (Eiter et al., 2008). The disadvantage
of using a supplementary database is the necessity to update it every time the ABox is
changed. It would be interesting to investigate this alternative approach for DL-Lite logics
and compare it with the approach described above. Another important problem is to
characterize those queries for which the disjunction in (ii) can be represented by a formula
of polynomial size.
As the unique name assumption is replaced in OWL by the constructs sameAs and
differentFrom (i.e.,  and 6), a challenging problem is to investigate possible ways of
dealing with equality (inequality does not require any special treatment as shown in the
proof of Lemma 8.10). Although reasoning with equality is LogSpace-reducible to reasoning without it (cf. Lemma 8.1), we lose the property of first-order rewritability, and
computing equivalence classes under  may be too costly for real-world applications.
DL-Lite logics are among those few examples of DLs for which usually very complex
non-standard reasoning problemssuch as checking whether one ontology is a conservative
extension of another one with respect to a given signature  (Kontchakov et al., 2008),
computing minimal modules of ontologies with respect to  (Kontchakov et al., 2009) or
uniform interpolants (Wang, Wang, Topor, & Pan, 2008)can be supported by practical
reasoning tools. However, only first steps have been made in this direction, and more
research is needed in order to include these reasoning problems and tools into the standard
OWL toolkit. It would be also interesting to investigate the unification problem for DL-Lite
logics (Baader & Narendran, 2001).
Finally, there exist certain parallels between the Horn logics of the DL-Lite family, EL,
Horn-SHIQ and the first-order language of tuple and equality generating dependencies,
TGDs and EGDs, used in the theory of databases (see, e.g., Gottlob & Nash, 2008). Further
investigations of the relationships between these logics may lead to a deeper understanding
of the role description logics can play in the database framework.
Acknowledgments
This research has been partially supported by FET project TONES (Thinking ONtologiES), funded within the EU 6th Framework Programme under contract FP6-7603, and
by the large-scale integrating project (IP) OntoRule (ONTOlogies meet Business RULEs
ONtologiES), funded by the EC under ICT Call 3 FP7-ICT-2008-3, contract number FP7231875. We thank the referees for their constructive criticism, comments, and suggestions.

64

fiThe DL-Lite Family and Relations

References
Abiteboul, S., Hull, R., & Vianu, V. (1995). Foundations of Databases. Addison-Wesley.
Acciarri, A., Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., Palmieri, M., &
Rosati, R. (2005). QuOnto: Querying ontologies. In Proc. of the 20th Nat. Conf.
on Artificial Intelligence (AAAI 2005), pp. 16701671.
Apt, K. (1990). Logic programming. In van Leeuwen, J. (Ed.), Handbook of Theoretical
Computer Science, Volume B: Formal Models and Sematics, pp. 493574. Elsevier
and MIT Press.
Artale, A., Calvanese, D., Kontchakov, R., & Zakharyaschev, M. (2007a). DL-Lite in the
light of first-order logic. In Proc. of the 22nd Nat. Conf. on Artificial Intelligence
(AAAI 2007), pp. 361366.
Artale, A., Calvanese, D., Kontchakov, R., Ryzhikov, V., & Zakharyaschev, M. (2007b).
Reasoning over extended ER models. In Proc. of the 26th Int. Conf. on Conceptual
Modeling (ER 2007), Vol. 4801 of Lecture Notes in Computer Science, pp. 277292.
Springer.
Artale, A., Cesarini, F., & Soda, G. (1996). Describing database objects in a concept
language environment. IEEE Trans. on Knowledge and Data Engineering, 8 (2), 345
351.
Artale, A., Parent, C., & Spaccapietra, S. (2007). Evolving objects in temporal information
systems. Ann. of Mathematics and Artificial Intelligence, 50, 538.
Baader, F., & Narendran, P. (2001). Unification of concepts terms in description logics. J.
of Symbolic Computation, 31 (3), 277305.
Baader, F., Calvanese, D., McGuinness, D., Nardi, D., & Patel-Schneider, P. F. (Eds.).
(2003). The Description Logic Handbook: Theory, Implementation and Applications.
Cambridge University Press. (2nd edition, 2007).
Beeri, C., Levy, A. Y., & Rousset, M.-C. (1997). Rewriting queries using views in description
logics. In Proc. of the 16th ACM SIGACT SIGMOD SIGART Symp. on Principles
of Database Systems (PODS97), pp. 99108.
Berardi, D., Calvanese, D., & De Giacomo, G. (2005). Reasoning on UML class diagrams.
Artificial Intelligence, 168 (12), 70118.
Bergamaschi, S., & Sartori, C. (1992). On taxonomic reasoning in conceptual design. ACM
Trans. on Database Systems, 17 (3), 385422.
Boppana, R., & Sipser, M. (1990). The complexity of finite functions. In van Leeuwen, J.
(Ed.), Handbook of Theoretical Computer Science, Volume A: Algorithms and Complexity, pp. 757804. Elsevier and MIT Press.
Borger, E., Gradel, E., & Gurevich, Y. (1997). The Classical Decision Problem. Perspectives
in Mathematical Logic. Springer.
Borgida, A., & Brachman, R. J. (2003). Conceptual modeling with description logics. In
Baader et al. (Baader et al., 2003), chap. 10, pp. 349372.

65

fiArtale, Calvanese, Kontchakov & Zakharyaschev

Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., Poggi, A., & Rosati, R. (2007).
Ontology-based database access. In Proc. of the 15th Ital. Conf. on Database Systems
(SEBD 2007), pp. 324331.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., Poggi, A., Rosati, R., & Ruzzi, M.
(2008). Data integration through DL-Lite A ontologies. In Schewe, K.-D., & Thalheim,
B. (Eds.), Revised Selected Papers of the 3rd Int. Workshop on Semantics in Data and
Knowledge Bases (SDKB 2008), Vol. 4925 of Lecture Notes in Computer Science, pp.
2647. Springer.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2005). DL-Lite:
Tractable description logics for ontologies. In Proc. of the 20th Nat. Conf. on Artificial
Intelligence (AAAI 2005), pp. 602607.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2006). Data
complexity of query answering in description logics. In Proc. of the 10th Int. Conf. on
the Principles of Knowledge Representation and Reasoning (KR 2006), pp. 260270.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2007a). Can OWL
model football leagues?. In Proc. of the 3rd Int. Workshop on OWL: Experiences and
Directions (OWLED 2007), Vol. 258 of CEUR Workshop Proceedings.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2007b). Tractable
reasoning and efficient query answering in description logics: The DL-Lite family. J.
of Automated Reasoning, 39 (3), 385429.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2008a). Inconsistency tolerance in P2P data integration: An epistemic logic approach. Information
Systems, 33 (4), 360384.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2008b). Path-based
identification constraints in description logics. In Proc. of the 11th Int. Conf. on the
Principles of Knowledge Representation and Reasoning (KR 2008), pp. 231241.
Calvanese, D., De Giacomo, G., & Lenzerini, M. (2002a). Description logics for information
integration. In Kakas, A., & Sadri, F. (Eds.), Computational Logic: Logic Programming and Beyond, Essays in Honour of Robert A. Kowalski, Vol. 2408 of Lecture Notes
in Computer Science, pp. 4160. Springer.
Calvanese, D., De Giacomo, G., & Lenzerini, M. (2002b). A framework for ontology integration. In Cruz, I., Decker, S., Euzenat, J., & McGuinness, D. (Eds.), The Emerging
Semantic Web  Selected Papers from the First Semantic Web Working Symposium,
pp. 201214. IOS Press.
Calvanese, D., De Giacomo, G., Lenzerini, M., Nardi, D., & Rosati, R. (1998a). Description
logic framework for information integration. In Proc. of the 6th Int. Conf. on the
Principles of Knowledge Representation and Reasoning (KR98), pp. 213.
Calvanese, D., Lenzerini, M., & Nardi, D. (1998b). Description logics for conceptual data
modeling. In Chomicki, J., & Saake, G. (Eds.), Logics for Databases and Information
Systems, pp. 229264. Kluwer Academic Publishers.
Calvanese, D., Lenzerini, M., & Nardi, D. (1999). Unifying class-based representation formalisms. J. of Artificial Intelligence Research, 11, 199240.
66

fiThe DL-Lite Family and Relations

Corona, C., Ruzzi, M., & Savo, D. F. (2009). Filling the gap between OWL 2 QL and
QuOnto: ROWLKit. In Proc. of the 22nd Int. Workshop on Description Logics
(DL 2009), Vol. 477 of CEUR Workshop Proceedings.
Cuenca Grau, B., Horrocks, I., Kazakov, Y., & Sattler, U. (2008). Modular reuse of ontologies: Theory and practice. J. of Artificial Intelligence Research, 31, 273318.
Decker, S., Erdmann, M., Fensel, D., & Studer, R. (1999). Ontobroker: Ontology based
access to distributed and semi-structured information. In Meersman, R., Tari, Z.,
& Stevens, S. (Eds.), Database Semantic: Semantic Issues in Multimedia Systems,
chap. 20, pp. 351370. Kluwer Academic Publishers.
Dolby, J., Fokoue, A., Kalyanpur, A., Ma, L., Schonberg, E., Srinivas, K., & Sun, X. (2008).
Scalable grounded conjunctive query evaluation over large and expressive knowledge
bases. In Proc. of the 7th Int. Semantic Web Conf. (ISWC 2008), Vol. 5318 of Lecture
Notes in Computer Science, pp. 403418. Springer.
Eiter, T., Gottlob, G., Ortiz, M., & Simkus, M. (2008). Query answering in the description logic Horn-SHIQ. In Proc. of the 11th Eur. Conference on Logics in Artificial
Intelligence (JELIA 2008), pp. 166179.
Franconi, E., & Ng, G. (2000). The i.com tool for intelligent conceptual modeling. In Proc. of
the 7th Int. Workshop on Knowledge Representation meets Databases (KRDB 2000),
Vol. 29 of CEUR Workshop Proceedings, pp. 4553.
Garey, M., & Johnson, D. (1979). Computers and Intractability: A Guide to the Theory of
NP-Completeness. W. H. Freeman.
Ghilardi, S., Lutz, C., & Wolter, F. (2006). Did I damage my ontology? A case for conservative extensions in description logics. In Doherty, P., Mylopoulos, J., & Welty,
C. (Eds.), Proc. of the 10th Int. Conf. on the Principles of Knowledge Representation
and Reasoning (KR 2006), pp. 187197.
Glimm, B., Horrocks, I., Lutz, C., & Sattler, U. (2007). Conjunctive query answering for the
description logic SHIQ. In Proc. of the 20th Int. Joint Conf. on Artificial Intelligence
(IJCAI 2007), pp. 399404.
Goasdoue, F., Lattes, V., & Rousset, M.-C. (2000). The use of CARIN language and
algorithms for information integration: The Picsel system. Int. J. of Cooperative
Information Systems, 9 (4), 383401.
Gottlob, G., & Nash, A. (2008). Efficient core computation in data exchange. J. of the
ACM, 55 (2), 149.
Hayes, P. (2004). RDF semantics. W3C Recommendation. http://www.w3.org/TR/
rdf-mt/.
Heflin, J., & Hendler, J. (2001). A portrait of the Semantic Web in action. IEEE Intelligent
Systems, 16 (2), 5459.
Heymans, S., Ma, L., Anicic, D., Ma, Z., Steinmetz, N., Pan, Y., Mei, J., Fokoue, A.,
Kalyanpur, A., Kershenbaum, A., Schonberg, E., Srinivas, K., Feier, C., Hench, G.,
Wetzstein, B., & Keller, U. (2008). Ontology reasoning with large data repositories.
In Hepp, M., De Leenheer, P., de Moor, A., & Sure, Y. (Eds.), Ontology Management,
67

fiArtale, Calvanese, Kontchakov & Zakharyaschev

Semantic Web, Semantic Web Services, and Business Applications, Vol. 7 of Semantic
Web And Beyond Computing for Human Experience, pp. 89128. Springer.
Horrocks, I., Patel-Schneider, P. F., & van Harmelen, F. (2003). From SHIQ and RDF to
OWL: The making of a web ontology language. J. of Web Semantics, 1 (1), 726.
Horrocks, I., Sattler, U., & Tobies, S. (2000). Practical reasoning for very expressive description logics. J. of the Interest Group in Pure and Applied Logic, 8 (3), 239264.
Hustadt, U., Motik, B., & Sattler, U. (2007). Reasoning in description logics by a reduction
to disjunctive Datalog. J. of Automated Reasoning, 39 (3), 351384.
Hustadt, U., Motik, B., & Sattler, U. (2005). Data complexity of reasoning in very expressive
description logics. In Proc. of the 19th Int. Joint Conf. on Artificial Intelligence
(IJCAI 2005), pp. 466471.
Immerman, N. (1999). Descriptive Complexity. Springer.
Klyne, G., & Carroll, J. J. (2004). Resource description framework (RDF): Concepts and
abstract syntax. W3C Recommendation. http://www.w3.org/TR/rdf-concepts/.
Kontchakov, R., Pulina, L., Sattler, U., Schneider, T., Selmer, P., Wolter, F., & Zakharyaschev, M. (2009). Minimal module extraction from DL-Lite ontologies using
QBF solvers. In Proc. of the 21st Int. Joint Conf. on Artificial Intelligence (IJCAI 2009), pp. 836840.
Kontchakov, R., Wolter, F., & Zakharyaschev, M. (2008). Can you tell the difference
between DL-Lite ontologies?. In Proc. of the 11th Int. Conf. on the Principles of
Knowledge Representation and Reasoning (KR 2008), pp. 285295.
Kontchakov, R., & Zakharyaschev, M. (2008). DL-Lite and role inclusions. In Domingue, J.,
& Anutariya, C. (Eds.), Proc. of the 3rd Asian Semantic Web Conf. (ASWC 2008),
Vol. 5367 of Lecture Notes in Computer Science, pp. 1630. Springer.
Kozen, D. (2006). Theory of Computation. Springer.
Lenzerini, M. (2002). Data integration: A theoretical perspective. In Proc. of the 21st ACM
SIGACT SIGMOD SIGART Symp. on Principles of Database Systems (PODS 2002),
pp. 233246.
Levy, A. Y., & Rousset, M.-C. (1998). Combining Horn rules and description logics in
CARIN. Artificial Intelligence, 104 (12), 165209.
Lutz, C., Toman, D., & Wolter, F. (2008). Conjunctive query answering in EL using a
database system. In Proc. of the 5th Int. Workshop on OWL: Experiences and Directions (OWLED 2008).
McGuinness, D., & Wright, J. R. (1998). Conceptual modelling for configuration: A description logic-based approach. Artificial Intelligence for Engineering Design, Analysis, and
Manufacturing. Special Issue on Configuration, 12, 333344.
Meyer, T., Lee, K., & Booth, R. (2005). Knowledge integration for description logics. In
Proc. of the 20th Nat. Conf. on Artificial Intelligence (AAAI 2005), pp. 645650.
Noy, N. F. (2004). Semantic integration: A survey of ontology-based approaches. SIGMOD
Record, 33 (4), 6570.
68

fiThe DL-Lite Family and Relations

Ortiz, M., Calvanese, D., & Eiter, T. (2006). Characterizing data complexity for conjunctive
query answering in expressive description logics. In Proc. of the 21st Nat. Conf. on
Artificial Intelligence (AAAI 2006), pp. 275280.
Ortiz, M., Calvanese, D., & Eiter, T. (2008). Data complexity of query answering in expressive description logics via tableaux. J. of Automated Reasoning, 41 (1), 6198.
Papadimitriou, C. (1994). Computational Complexity. Addison-Wesley.
Perez-Urbina, H., Motik, B., & Horrocks, I. (2009). A comparison of query rewriting
techniques for DL-Lite. In Proc. of the 22nd Int. Workshop on Description Logics
(DL 2009), Vol. 477 of CEUR Workshop Proceedings.
Poggi, A., Lembo, D., Calvanese, D., De Giacomo, G., Lenzerini, M., & Rosati, R. (2008a).
Linking data to ontologies. J. on Data Semantics, X, 133173.
Poggi, A., Rodriguez, M., & Ruzzi, M. (2008b). Ontology-based database access with
DIG-Mastro and the OBDA Plugin for Protege. In Clark, K., & Patel-Schneider,
P. F. (Eds.), Proc. of the 4th Int. Workshop on OWL: Experiences and Directions
(OWLED 2008 DC).
Rautenberg, W. (2006). A Concise Introduction to Mathematical Logic. Springer.
Reingold, O. (2008). Undirected connectivity in log-space. J. of the ACM, 55 (4).
Schaerf, A. (1993). On the complexity of the instance checking problem in concept languages
with existential quantification. J. of Intelligent Information Systems, 2, 265278.
Schmidt-Schau, M., & Smolka, G. (1991). Attributive concept descriptions with complements. Artificial Intelligence, 48 (1), 126.
Stocker, M., & Smith, M. (2008). Owlgres: A scalable OWL reasoner. In Proc. of the 5th
Int. Workshop on OWL: Experiences and Directions (OWLED 2008).
Tobies, S. (2001). Complexity results and practical algorithms for logics in Knowledge Representation. Ph.D. thesis, LuFG Theoretical Computer Science, RWTH-Aachen, Germany.
Toman, D., & Weddell, G. E. (2005). On the interaction between inverse features and pathfunctional dependencies in description logics. In Proc. of the 19th Int. Joint Conf. on
Artificial Intelligence (IJCAI 2005), pp. 603608.
Toman, D., & Weddell, G. E. (2008). On keys and functional dependencies as first-class
citizens in description logics. J. of Automated Reasoning, 40 (23), 117132.
Vardi, M. (1982). The complexity of relational query languages (extended abstract). In
Proc. of the 14th ACM SIGACT Symp. on Theory of Computing (STOC82), pp.
137146.
Vollmer, H. (1999). Introduction to Circuit Complexity: A Uniform Approach. Springer.
Wang, Z., Wang, K., Topor, R. W., & Pan, J. Z. (2008). Forgetting concepts in DL-Lite.
In Bechhofer, S., Hauswirth, M., Hoffmann, J., & Koubarakis, M. (Eds.), Proc. of the
5th Eur. Semantic Web Conf. (ESWC 2008), Vol. 5021 of Lecture Notes in Computer
Science, pp. 245257. Springer.

69

fi