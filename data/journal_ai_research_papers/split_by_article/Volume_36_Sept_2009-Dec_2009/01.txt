Journal of Artificial Intelligence Research 36 (2009) 71

Submitted 12/08; published 10/09

Prime Implicates and Prime Implicants:
From Propositional to Modal Logic
Meghyn Bienvenu

meghyn@informatik.uni-bremen.de

Department of Mathematics and Computer Science
University of Bremen, Germany

Abstract
Prime implicates and prime implicants have proven relevant to a number of areas of
artificial intelligence, most notably abductive reasoning and knowledge compilation. The
purpose of this paper is to examine how these notions might be appropriately extended from
propositional logic to the modal logic K. We begin the paper by considering a number of
potential definitions of clauses and terms for K. The different definitions are evaluated with
respect to a set of syntactic, semantic, and complexity-theoretic properties characteristic of
the propositional definition. We then compare the definitions with respect to the properties
of the notions of prime implicates and prime implicants that they induce. While there is
no definition that perfectly generalizes the propositional notions, we show that there does
exist one definition which satisfies many of the desirable properties of the propositional
case. In the second half of the paper, we consider the computational properties of the
selected definition. To this end, we provide sound and complete algorithms for generating
and recognizing prime implicates, and we show the prime implicate recognition task to be
Pspace-complete. We also prove upper and lower bounds on the size and number of prime
implicates. While the paper focuses on the logic K, all of our results hold equally well for
multi-modal K and for concept expressions in the description logic ALC.

1. Introduction
Prime implicates and prime implicants are important notions in artificial intelligence. They
have given rise to a significant body of work in automated reasoning and have been applied
to a number of different sub-areas in AI. Traditionally, these concepts have been studied
in the context of propositional logic, but they have also been considered for many-valued
(Ramesh & Murray, 1994) and first-order logic (Marquis, 1991a, 1991b). Not much is
known, however, about prime implicates and prime implicants in other logics. In particular,
no definition of prime implicate or prime implicant has ever been proposed for a modal or
description logic, nor has it been shown that no reasonable definition can be provided.
Given the increasing interest in modal and description logics as knowledge representation
languages, one naturally wonders whether these notions can be suitably generalized to these
more expressive logics.
We recall that in propositional logic the prime implicates of a formula are defined to be
its logically strongest clausal consequences. The restriction to clauses is made in order to
reduce redundant elements from a formulas set of consequences: there is no use in keeping
around the consequence a  b when one already has the consequences a and b. The decision
to consider only the logically strongest clausal consequences is motivated by a desire to
eliminate irrelevant weaker consequences: if we already have the consequence a, there is
c
2009
AI Access Foundation. All rights reserved.

fiBienvenu

no point in retaining the consequences a  b or a  b. Prime implicates thus provide a
complete yet compact representation of the set of logical consequences of a formula. What
is particularly nice about this representation is that it makes many computational tasks
simpler: satisfiability, tautology, entailment, and equivalence queries and the conditioning
and forgetting transformations are all tractable for formulae represented by their prime
implicates (Darwiche & Marquis, 2002). This is why prime implicates are considered an
interesting target language for knowledge compilation (Cadoli & Donini, 1997; Darwiche
& Marquis, 2002). Prime implicates have also proved relevant to other sub-areas of AI,
like distributed reasoning (Adjiman, Chatalic, Goasdoue, Rousset, & Simon, 2006), belief
revision (Bittencourt, 2007; Pagnucco, 2006), non-monotonic reasoning (cf. Przymusinski,
1989), and characterizations of relevance (Lakemeyer, 1995; Lang, Liberatore, & Marquis,
2003).
The dual notion to prime implicates is prime implicants, which are defined to be the
logically weakest terms (= conjunctions of literals) which imply a given formula. The main
application domain for prime implicants is in abduction and diagnosis. We recall that in
abduction, one is given a background theory and an observation, and the objective is to
find an explanation for the observation. In logical terms, an explanation is a formula which
logically entails the observation when taken together with the background theory. As the
set of explanations for an abduction problem can be very large, an important question
is how to select a representative subset of explanations. One very common approach is
to use prime implicants: the relevant explanations for an observation o with respect to a
background theory t are taken to be the prime implicants of t  o (de Kleer, Mackworth,
& Reiter, 1992; Eiter & Makino, 2002).
For many applications in AI, the expressive power of propositional logic proves insufficient. First-order logic provides a much greater level of expressivity, but at the price of
undecidability. Modal and description logics offer an interesting trade-off between expressivity and complexity, as they are generally more expressive than propositional logic yet
are better-behaved computationally than first-order logic. This explains the growing trend
towards using such languages for knowledge representation.
A prototypical description logic is ALC, which extends propositional logic with restricted
forms of universal and existential quantification. An example expression in ALC is
F emale  hasChild.F emale  hasChild.(Doctor  P rof essor)  hasP et.Dog
which describes the set of individuals who are female, have at least one daughter and one
pet dog, and are such that all of their children are either doctors or professors. The above
concept expression can be represented equally well in the modal logic K2 by the formula:
F emale  31 F emale  21 (Doctor  P rof essor)  32 Dog
Schild (1991) proved a general result which showed that the description logic ALC with n
binary relations is in fact a notational variant of the multi-modal logic Kn . This means that
results concerning Kn can be transferred to ALC, and vice-versa.
In this paper, we investigate the notions of prime implicates and prime implicants for
the modal logic K = K1 , but actually all of our results hold for formulae in Kn , and hence
also for concept expressions in ALC. The decision to present our results in terms of K
72

fiPrime Implicates and Prime Implicants in Modal Logic

rather than in terms of Kn or ALC was motivated solely by a desire to simplify notation
and increase the readability of the proofs.
The question of how the notions of prime implicates and prime implicants can be suitably
defined for the logic K is clearly of interest from a theoretical point of view. We argue,
however, that this question is also practically relevant. To support this claim, we briefly
discuss two application areas in which the study of prime implicates and prime implicants
in K might prove useful.
The first domain of application we will consider is abductive reasoning in K. As noted
above, one of the key foundational issues in abductive reasoning is the selection of an
interesting subset of explanations. This issue is especially crucial for logics like K which
allow for an infinite number of non-equivalent formulae, since this means that the number of
non-equivalent explanations for an abduction problem is not just large but in fact infinite,
making it simply impossible to enumerate the entire set of explanations. As prime implicants
are a widely-accepted means of characterizing relevant explanations in propositional logic,
a reasonable starting point for research into abductive reasoning in the logic K is the study
of different possible definitions of prime implicant in K and their properties.
The investigation of prime implicates in K is also relevant to the development of knowledge compilation procedures for K. We recall that knowledge compilation (cf. Darwiche
& Marquis, 2002) is a general technique for coping with the intractability of reasoning
which consists in an off-line phase in which a knowledge base is rewritten as an equivalent
knowledge base which allows for tractable reasoning, followed by an online phase in which
reasoning is performed on the compiled knowledge base. The idea is that the initial cost
of compiling the knowledge base will be offset by computational savings on later queries.
Currently, most work on knowledge compilation is restricted to propositional logic, even
though this technique could prove highly relevant for modal and description logics, which
generally suffer from an even higher computational complexity than propositional logic. As
prime implicates are one of the better-known mechanisms for compiling formulae in propositional logic, it certainly makes sense to investigate whether this approach to knowledge
compilation can be fruitfully extended to logics like K.
Our paper is organized as follows. After some preliminaries, we consider how to appropriately generalize the notions of clauses and terms to K. As there is no obvious definition,
we enumerate a list of syntactic, semantic, and complexity-theoretic properties of the propositional definitions, which we then use to compare the different candidate definitions. We
next consider the different definitions in light of the notions of prime implicate and prime
implicant they induce. Once again, we list some basic properties from the propositional
case that we would like to satisfy, and we see how the different definitions measure up.
In the second half of the paper, we investigate the computational properties of the most
satisfactory definition of prime implicates. We consider the problems of prime implicate
generation and recognition, and we provide sound and complete algorithms for both tasks.
We also study the complexity of the prime implicate recognition problem, showing it to be
Pspace-complete and thus of the same complexity as satisfiability and deduction in K. We
conclude the paper with a discussion of the relevance of our results to the two application
areas cited above and some directions for future research. In order to enhance the readability of the paper, proofs have been omitted from the body of the text. Full proofs can be
found in the appendix.
73

fiBienvenu

2. Preliminary Definitions and Notation
We briefly recall the basics of the modal logic K (refer to Blackburn, de Rijke, & Venema,
2001; Blackburn, van Benthem, & Wolter, 2006, for good introductions to modal logic).
Formulae in K are built up from a set of propositional variables V, the standard logical
connectives (, , and ), and the modal operators 2 and 3. We will call a formula of
the form 2 (resp. 3) a 2-formula (resp. 3-formula). Where convenient we will use
   as an abbreviation for   . We adopt the shorthand 2k  (resp. 3k ) to refer to
the formula consisting of  preceded by k copies of 2 (resp. 3), with the convention that
20  = 30  = . We will use var() to refer to the set of propositional variables appearing
in a formula . The modal depth of a formula , written (), is defined as the maximal
number of nested modal operators appearing in , e.g. (3(a  2a)  a) = 2. We define the
length of a formula , written ||, to be the number of occurrences of propositional variables,
logical connectives, and modal operators in . For example, we would have |(a  b)| = 4
and |3(a  b)  2a| = 8.
Negation normal form (NNF) is defined just as in propositional logic: a formula is said
to be in NNF if negation only appears directly before propositional variables. Every formula
 in K can be transformed into an equivalent formula in NNF using the recursive procedure
Nnf defined as follows:
Nnf (l)=l (for propositional literals l)
Nnf (1  2 )=Nnf (1 )Nnf (2 )
Nnf ((1  2 ))=Nnf (1 )Nnf (2 )
Nnf (1  2 )=Nnf (1 )Nnf (2 )
Nnf ((1  2 ))=Nnf (1 )Nnf (2 )

Nnf (2)=2Nnf ()
Nnf (2)=3Nnf ()
Nnf (3)=3Nnf ()
Nnf (3)=2Nnf ()
Nnf ()=Nnf ()

For example, applying Nnf to the formula 2(a  3(b  c)) results in the formula 3(a 
2(b c)) which is in NNF. The transformation Nnf takes linear time, and yields a formula
which is no more than double the size of the original formula and has the same modal depth
and propositional variables as the original.
A model for K is a tuple M = hW, R, vi, where W is a non-empty set of possible worlds,
R  W  W is a binary relation over worlds, and v : W  V  {true, f alse} is a valuation
of the propositional variables at each world. Models can be understood as labelled directed
graphs, in which the vertices correspond to the elements of W, the directed edges represent
the binary relation R, and the vertices are labeled by propositional valuations which specify
the propositional variables which are true in the corresponding possible world.
Satisfaction of a formula  in a model M at the world w (written M, w |= ) is defined
inductively as follows:
 M, w |= a if and only if v(w, a) = true
 M, w |=  if and only if M, w 6|= 
 M, w |=    if and only if M, w |=  and M, w |= 
 M, w |=    if and only if M, w |=  or M, w |= 
 M, w |= 2 if and only if M, w |=  for all w such that wRw
74

fiPrime Implicates and Prime Implicants in Modal Logic

 M, w |= 3 if and only if M, w |=  for some w such that wRw
If we think of models as labeled directed graphs, then determining the satisfaction of a
formula 2 at vertex w consists in evaluating  at all of the vertices which can be reached
from w via an edge; 2 is satisfied at w just in the case that  holds in each of these
successor vertices. Similarly, in order to decide whether a formula 3 holds at a vertex w,
we consider each of the successors of w in the graph and check whether at least one of these
vertices satisfies .
A formula  is said to be a tautology, written |= , if M, w |=  for every model M and
world w. A formula  is satisfiable if there is some model M and some world w such that
M, w |= . If there is no M and w for which M, w |= , then  is called unsatisfiable, and
we write  |= .
Ladner (1977) showed that satisfiability and unsatisfiability in K are Pspace-complete.
For Pspace membership, Ladner exhibited a polynomial space tableaux-style algorithm for
deciding satisfiability of K formulae. Pspace-hardness was proven by means of a reduction
from QBF validity (the canonical Pspace-complete problem).
In modal logic, the notion of logical consequence (or entailment) can be defined in one
of two ways:
 a formula  is a global consequence of  if whenever M, w |=  for every world w of
a model M, then M, w |=  for every world w of M
 a formula  is a local consequence of  if M, w |=  implies M, w |=  for every model
M and world w
In this paper, we will only consider the notion of local consequence, and we will take  |= 
to mean that  is a local consequence of . When  |= , we will say that  entails .
Two formulae  and  will be called equivalent, written   , if both  |=  and  |= .
A formula  is said to be logically stronger than  if  |=  and  6|= .
We now highlight some basic properties of logical consequence and equivalence in K
which will play an important role in the proofs of our results.
Theorem 1. Let , 1 , ..., m , , 1 , ..., n be formulae in K, and let  be a propositional
formula. Then
1.  |=   |=        |= 
2.  |=   3 |= 3  2 |= 2
3.  31 ...3m 21 ...2n |=   ( |=  or i 1 ...n |=  for some i)
4. |=   31  ...  3m  21  ...  2n  (|=  or |= 1  ...  m  i for some i)
5. 2 |= 21  ...  2n   |= i for some i
6. 31  ...  3m  21  ...  2n
 31  ...  3m  2(1  1  ...  m )  ...  2(n  1  ...  m )
75

fiBienvenu

Statement 1 of Theorem 1 shows how the three reasoning tasks of entailment, unsatisfiability, and tautology-testing can be rephrased in terms of one another. Statement 2 tells us
how entailment between two 2- or 3-formulae can be reduced to entailment between those
formulae with the first modality removed. Statements 3 and 4 define the conditions under
which a conjunction (resp. disjunction) of propositional literals and 2- and 3-formulae
is unsatisfiable (resp. a tautology). Statement 5 gives us the conditions under which a
2-formula implies a disjunction of 2-formulae. Statement 6 demonstrates the interaction
between 2- and 3-formulae in a disjunction.
Theorem 2. Let  be a disjunction of propositional literals and 2- and 3-formulae. Then
each of the following statements holds:
1. If  |=  for some non-tautological propositional clause , then every disjunct of  is
either a propositional literal or an unsatisfiable 3-formula
2. If  |= 31  ...  3n , then every disjunct of  is a 3-formula
3. If  |= 21  ...  2n and 6|= 21  ...  2n , then every disjunct of  is either a
2-formula or an unsatisfiable 3-formula
Theorem 3. Let  =   31  ...  3m  21  ...  2n and  =    31  ...  3p 
21  ...  2q be formulae in K. If  and   are both propositional and 6|=  , then

  |=   and
1  ...  m |= 1  ...  p and
 |=  

for every i there is some j such that i |= 1  ...  p  j
Theorems 2 and 3 concern entailment relations between formulae which are disjunctions
of propositional literals and 2- and 3-formulae. Theorem 2 tells us what kinds of formulae
of this type can entail a propositional clause, a disjunction of 3-formulae, or a disjunction
of 2-formulae, while Theorem 3 outlines the conditions under which two formulae of this
type can be related to each other by the entailment relation. We illustrate Theorem 3 on a
small example.
Example 4. Consider the formula  = b  3(a  3c)  3(d  2a)  2(c  d). Then
according to Theorem 3, we have:
  |= b  d  3(a  d)  2c, since b |= b  d and (a  3c)  (d  2a) |= a  d and
c  d |= c  (a  d)
  6|= a  3c, since b 6|= a
  6|= a  b  3(a  c), since (a  3c)  (d  2a) 6|= a  c
  6|= b  3(a  2a)  2c, since c  d 6|= c  (a  2a)
76

fiPrime Implicates and Prime Implicants in Modal Logic

3. Literals, Clauses, and Terms in K
As we have seen in the introduction, the notions of prime implicates and implicants are
straightforwardly defined using the notions of clauses and terms. Thus, if we aim to provide
suitable definitions of prime implicates and implicants for the logic K, we first need to decide
upon a suitable definition of clauses and terms in K. Unfortunately, whereas clauses and
terms are standard notions in both propositional and first-order logic1 , there is no generally
accepted definition of clauses and terms in K. Indeed, several quite different notions of
clauses and terms have been proposed in the literature for different purposes.
Instead of blindly picking a definition and hoping that it is appropriate, we prefer to
list a number of characteristics of literals, clauses, and terms in propositional logic, giving
us a principled means of comparing different candidate definitions. Each of the properties
below describes something of what it is to be a literal, clause, or term in propositional logic.
Although our list cannot be considered exhaustive, we do believe that it covers the principal
syntactic, semantic, and complexity-theoretic properties of the propositional definition.
P1 Literals, clauses, and terms are in negation normal form.
P2 Clauses do not contain , terms do not contain , and literals contain neither  nor .
P3 Clauses (resp. terms) are disjunctions (resp. conjunctions) of literals.
P4 The negation of a literal is equivalent to another literal. Negations of clauses (resp.
terms) are equivalent to terms (resp. clauses).
P5 Every formula is equivalent to a finite conjunction of clauses. Likewise, every formula
is equivalent to a finite disjunction of terms.
P6 The task of deciding whether a given formula is a literal, term, or clause can be accomplished in polynomial-time.
P7 The task of deciding whether a clause (resp. term) entails another clause (resp. term)
can be accomplished in polynomial-time.
One may wonder whether there exist definitions of literals, clauses, and terms for K
satisfying all of these properties. Unfortunately, we can show this to be impossible.
Theorem 5. Any definition of literals, clause, and terms for K that satisfies properties P1
and P2 cannot satisfy P5.
The proof of Theorem 5 only makes use of the fact that  does not distribute over 3
and  does not distribute over 2, which means that our impossibility result holds equally
well for most standard modal and description logics.
We will now consider a variety of possible definitions and evaluate them with respect
to the above criteria. The first definition that we will consider is that proposed by Cialdea
1. One might wonder why we do not simply translate our formulae in K into first-order formulae and then
put them into clausal form. The reason is simple: we are looking to define clauses and terms within the
language of K, and the clauses we obtain on passing by first-order logic are generally not expressible in K.
Moreover, if we were to define clauses in K as those first-order clauses which are representable in K, we
would obtain a set of clauses containing no 3 modalities, thereby losing much of the expressivity of K.

77

fiBienvenu

Mayer and Pirri (1995) in a paper on abductive reasoning in modal logic. They define terms
to be the formulae which can be constructed from the propositional literals using only , 2,
and 3. Modal clauses and literals are not used in the paper but can be defined analogously,
yielding the following definition2 :
D1

L ::= a | a | 2L | 3L
C ::= a | a | 2C | 3C | C  C
T ::= a | a | 2T | 3T | T  T

It is easy to see by inspection that this definition satisfies properties P1-P2, P4, and P6.
Property P3 is not satisfied, however, since there are clauses that are not disjunctions of
literals  take for instance 2(a  b). From Theorem 5 and the fact that both P1 and P2 are
satisfied, we can conclude that property P5 cannot hold. At first glance, it may seem that
entailment between clauses or terms could be accomplished in polynomial time, but this is
not the case. In fact, we can show this problem to be NP-complete. The proof relies on the
very strong resemblance between terms of D1 and concept expressions in the description
logic ALE (for which both unsatisfiability and deduction are known to be NP-complete).
By using a slightly different definition, we can gain P3:
D2

L ::= a | a | 2L | 3L
C ::= L | C  C
T ::= L | T  T

It can be easily verified that definition D2 satisfies properties P1-P4 and P6. As definition
D1 does not satisfy P5, and definition D2 is even less expressive, it follows that D2 does not
satisfy P5 either. This reduced expressiveness does not however improve its computational
complexity: property P7 is still not satisfied as we can show that entailment between
clauses or terms is NP-complete using the same reduction as was used for definition D1.
The fact that even an extremely inexpressive definition like D2 does not allow for polynomial
entailment between clauses and terms suggests that property P7 cannot be satisfied by any
reasonable definition of clauses and terms for K.
Let us now consider some more expressive options. We begin with the following definition
of clauses that was proposed by Enjalbert and Farinas del Cerro (1989) for the purpose of
modal resolution:
D3
C ::= a | a | 2C | 3ConjC | C  C
ConjC ::= C | ConjC  ConjC
This definition of clauses can be extended to a definition of terms and literals which satisfies
P3 or P4, but there is no extension which satisfies both properties. Let us first consider
one of the possible extensions which satisfies P4 and a maximal subset of P1-P7:
D3a

L ::= a | a | 2L | 3L
C ::= a | a | 2C | 3ConjC | C  C
ConjC ::= C | ConjC  ConjC
T ::= a | a | 2DisjT | 3T | T  T
DisjT ::= T | DisjT  DisjT

2. Note that here and in what follows, we let a range over propositional variables and L, C, and T range
over the sets of literals, clauses, and terms, respectively.

78

fiPrime Implicates and Prime Implicants in Modal Logic

This definition satisfies P1 and P4-P6 (satisfaction of P5 was shown in Enjalbert & Farinas
del Cerro, 1989). It does not satisfy P3 as there are clauses that are not disjunctions of
literals  take for example 2(a  b). Given that definition D3a is strictly more expressive
than definitions D1 and D2, it follows that entailment between clauses or terms must be
NP-hard, which means that D3a does not satisfy P7. In fact, we can show that entailment
between clauses or terms of definition D3a is Pspace-complete. To do so, we modify the
polynomial translation of QBF into K used to prove Pspace-hardness of K so that the
translated formula is a conjunction of clauses with respect to D3a. We then notice that
a formula  is unsatisfiable if and only if 3 entails 3(a  a). We thus reduce QBF
validity to entailment between clauses, making this task Pspace-hard, and hence (being a
subproblem of entailment in K) Pspace-complete. This same idea is used to show Pspacecompleteness for definitions D3b and D5 below.
If instead we extend D3 so as to enforce property P3, we obtain the following definition:
L ::= a | a | 2C | 3ConjC
C ::= a | a | 2C | 3ConjC | C  C
ConjC ::= C | ConjC  ConjC
T ::= L | T  T
This definition satisfies all of the properties except P2, P4, and P7. Property P4 fails to
hold because the negation of the literal 3(a  b) is not equivalent to any literal. The proof
that P5 holds is constructive: we use standard logical equivalences to rewrite formulae as
equivalent conjunctions of clauses and disjunctions of terms (this is also what we do for
definitions D4 and D5 below).
We now consider two rather simple definitions that satisfy properties P3, P4, and P5.
The first definition, which is inspired by the notion of modal atom proposed by Giunchiglia
and Sebastiani (1996), defines literals as the set of formulae in NNF that cannot be decomposed propositionally.
D3b

L ::= a | a | 2F | 3F
C ::= L | C  C
T ::= L | T  T
F ::= a | a | F  F | F  F | 2F | 3F
D4 satisfies all of the properties except P2 and P7. For P7, we note that an arbitrary formula  in NNF is unsatisfiable (a Pspace-complete problem) if and only if 3 |= 3(a  a).
Definition D4 is very liberal, imposing no structure on the formulae behind modal operators. If we define literals to be the formulae in NNF that cannot be decomposed modally
(instead of propositionally), we obtain a much stricter definition which satisfies exactly the
same properties as D4.
D4

D5

L ::= a | a | 2C | 3T
C ::= L | C  C
T ::= L | T  T

A summary of our analysis of the different definitions with respect to properties P1-P7
is provided in the following table.
Theorem 6. The results in Figure 1 hold.
79

fiBienvenu

P1
P2
P3
P4
P5
P6
P7

D1
D2
yes
yes
yes
yes
no
yes
yes
yes
no
no
yes
yes
no (unless P=NP)

D3a D3b D4 D5
yes
yes
yes yes
no
no
no
no
no
yes
yes yes
yes
no
yes yes
yes
yes
yes yes
yes
yes
yes yes
no (unless P=Pspace)

Figure 1: Properties of the different definitions of literals, clauses, and terms.

Clearly deciding between different candidate definitions is more complicated than counting up the number of properties that the definitions satisfy, the simple reason being that
some properties are more important than others. Take for instance property P5 which
requires clauses and terms to be expressive enough to represent all of the formulae in K. If
we just use the standard propositional definition of clauses and terms (thereby disregarding
the modal operators), then we find that it satisfies every property except P5, and hence
more properties than any of the definitions considered in this section, and yet we would be
hard-pressed to find someone who considers the propositional definition an appropriate definition for K. This demonstrates that expressiveness is a particularly important property,
so important in fact that we should be willing to sacrifice properties P2 and P7 to keep it.
Among the definitions that satisfy P5, we prefer definitions D4 and D5 to definitions D3a
and D3b, as the latter definitions have less in common with the propositional definition
and present no advantages over D4 and D5.
Of course, when it comes down to it, the choice of a definition must depend on the
particular application in mind. There may very well be circumstances in which a less
expressive or less elegant definition may prove to be the most suitable. In this paper we
are using clauses and terms to define prime implicates and prime implicants, so for us the
most important criteria for choosing a definition will be the quality of the notions of prime
implicates and prime implicants that the definition induces.

4. Prime Implicates/Implicants in K
Once a definition of clauses and terms has been fixed, we can define prime implicates and
prime implicants in exactly the same manner as in propositional logic:
Definition 7. A clause  is an implicate of a formula  if and only if  |= .  is a prime
implicate of  if and only if:
1.  is an implicate of 
2. If  is an implicate of  such that  |= , then  |= 
Definition 8. A term  is an implicant of the formula  if and only if  |= .  is a prime
implicant of  if and only if:
1.  is an implicant of 
80

fiPrime Implicates and Prime Implicants in Modal Logic

2. If  is an implicant of  such that  |=  , then  |= 
Of course, the notion of prime implicate (resp. implicant) that we get will be determined by the definition of clause (resp. term) that we have chosen. We will compare different definitions using the following well-known properties of prime implicates/implicants
in propositional logic:
Finiteness The number of prime implicates (resp. prime implicants) of a formula is finite
modulo logical equivalence.
Covering Every implicate of a formula is entailed by some prime implicate of the formula.
Conversely, every implicant of a formula entails some prime implicant of the formula.
Equivalence A model M is a model of  if and only if M is a model of all the prime
implicates of  if and only if M is a model of some prime implicant of 3 .
Implicant-Implicate Duality Every prime implicant of a formula is equivalent to the
negation of some prime implicate of the negated formula. Conversely, every prime
implicate of a formula is equivalent to the negation of a prime implicant of the negated
formula.
Distribution If  is a prime implicate of 1  ...  n , then there exist prime implicates
1 , ..., n of 1 , ..., n such that   1  ...  n . Likewise, if  is a prime implicant
of 1  ...  n , then there exist prime implicants 1 , ..., n of 1 , ..., n such that
  1  ...  n
Finiteness ensures that the prime implicates/implicants of a formula can be finitely
represented, while Covering means the prime implicates provide a complete representation
of the formulas implicates. Equivalence guarantees that no information is lost in replacing a formula by its prime implicates/implicants, whereas Implicant-Implicate Duality
allows us to transfer results and algorithms for prime implicates to prime implicants, and
vice-versa. Finally, Distribution relates the prime implicates/implicants of a formula to
the prime implicates/implicants of its sub-formulae. This property will play a key role in
the prime implicate generation algorithm presented in the next section.
We can show that definition D4 satisfies all five properties. For Finiteness and Covering, we first demonstrate that every implicate  of a formula  is entailed by some implicate
 of  with var( )  var() and having depth at most () + 1 (and similarly for implicants). As there are only finitely many non-equivalent formulae on a finite language and
with bounded depth, it follows that there are only finitely many prime implicates/implicants
of a given formula, and that there can be no infinite chains of increasingly stronger implicates (or increasingly weaker implicants). Equivalence follows directly from Covering
and the property P5 of the previous section: we use P5 to rewrite  as a conjunction
of clauses, each of which is implied by some prime implicate of  because of Covering.
The property Implicant-Implicate Duality is an immediate consequence of the duality
3. The property Equivalence is more commonly taken to mean that a formula is equivalent to the conjunction of its prime implicates and the disjunction of its prime implicants. We have chosen a model-theoretic
formulation in order to allow for the possibility that the set of prime implicates/implicants is infinite.

81

fiBienvenu

between clauses and terms (P4). Distribution can be shown using Covering plus the
fact that a disjunction of clauses is a clause and a conjunction of terms is a term (P3).
Theorem 9. The notions of prime implicates and prime implicants induced by definition
D4 satisfy Finiteness, Covering, Equivalence, Implicant-Implicate Duality, and
Distribution.
We remark by way of contrast that in first-order logic the notion of prime implicate induced by the standard definition of clauses has been shown to falsify Finiteness, Covering,
and Equivalence (Marquis, 1991a, 1991b).
We now show that definition D4 is the only one of our definitions to satisfy all five
properties. For definitions D1 and D2, we show that Equivalence does not hold. This
is a fairly straightforward consequence of the fact that these definitions do not satisfy
property P5.
Theorem 10. The notions of prime implicates and prime implicants induced by definitions
D1 and D2 do not satisfy Equivalence.
For the notions of prime implicates induced by definitions D3a, D3b, and D5, we show
in the appendix that the clause 2 3k a  3(a  b  2k a) is a prime implicate of 2(a  b)
for every k  14 . We thereby demonstrate not only that these definitions admit formulae
with infinitely many distinct prime implicates but also that they allow seemingly irrelevant
clauses to be counted as prime implicates. This gives us strong grounds for dismissing these
definitions as much of the utility of prime implicates in applications comes from their ability
to eliminate such irrelevant consequences.
Theorem 11. The notions of prime implicates and prime implicants induced by D3a, D3b,
and D5 falsify Finiteness.
While the comparison in the last section suggested that D5 was at least as suitable as
D4 as a definition of clauses and terms, the results of this section rule out D5 as a suitable
definition for prime implicates and prime implicants. In the remainder of the paper, we will
concentrate our attention on the notions of prime implicates and prime implicants induced
by definition D4, as these have been shown to be the most satisfactory generalizations of
the propositional case.

5. Prime Implicate Generation and Recognition
In this section, we investigate the computational aspects of modal prime implicates. As we
will be primarily focusing on the notion of prime implicate induced by definition D4, for
the remainder of the paper we will use the words clause, term, and prime implicate
to mean clause, term, and prime implicate with respect to definition D4, except where
explicitly stated otherwise.
We remark that, without loss of generality, we can restrict our attention to prime implicates since by Implicant-Implicate Duality (Theorem 9) any algorithm for generating
or recognizing prime implicates can be easily adapted into an algorithm for generating or
recognizing prime implicants.
4. For D4, the only prime implicate of 2(a  b) is itself.

82

fiPrime Implicates and Prime Implicants in Modal Logic

Function Dnf -4()
Input: a formula 
Output: a set of D4-terms
Return the set of terms output by Iter-Dnf-4({Nnf ()}).
Function Iter-Dnf -4(S)
Input: a set S of formulae in NNF
Output: a set of D4-terms, which are output one-by-one
If S = {  }  S  , then do Iter-Dnf -4(S   {}  {})
Else if S = {  }  S  , then do Iter-Dnf -4(S   {}), then do Iter-Dnf -4(S   {})
V
Else output S  if it is consistent (and nothing otherwise)
Figure 2: Helper functions Dnf -4 and Iter-Dnf -4.

5.1 Generating Prime Implicates
We start by considering the problem of generating the set of prime implicates of a given
formula. This task is important if we want to produce abductive explanations, or if we want
to compile a formula into its set of prime implicates.
For our generation algorithm, we will require a means of transforming the input formula
into an equivalent disjunction of simpler formulae. To this end, we introduce in Figure 2
the helper function Dnf -4() which returns a set of satisfiable terms with respect to D4
whose disjunction is equivalent to . The function Dnf -4 is defined in terms of another
function Iter-Dnf -4 which takes an input a set S of formulae in NNF and returns in an
iterative fashion a set of satisfiable terms whose disjunction is equivalent to S. The following
lemmas highlight some important properties of these functions.
Lemma 12. Iter-Dnf-4 terminates and requires only polynomial space in the size of its
input.
Lemma 13. The output of Dnf-4 on input  is a set of satisfiable terms with respect to
D4 whose disjunction is equivalent to .
Lemma 14. There are at most 2|| terms in Dnf-4(). Each of the terms has length at
most 2||, depth at most (), and contains only those propositional variables appearing in
var().
We present in Figure 3 the algorithm GenPI which computes the set of prime implicates
of a given formula. Our algorithm works as follows: in Step 1, we check whether  is
unsatisfiable, outputting a contradictory clause if this is the case. For satisfiable , we
set T equal to a set of satisfiable terms whose disjunction is equivalent to . Because of
Distribution, we know that every prime implicate of  is equivalent to some disjunction
of prime implicates of the terms in T . In Step 2, we set (T ) equal to the propositional
83

fiBienvenu

Function GenPI()
Input: a formula 
Output: a set of clauses
(1) If  is unsatisfiable, return {3(a  a)}. Otherwise, set T = Dnf -4().
(2) For each T  T : let LT be the set of propositional literals in T and let DT
be the set of formulae  such that 3 is in T . If there are no literals of the
form 2 in T , then set (T ) = LT  {3 |   DT }. Otherwise, set (T ) =
LT  {2T }  {3(  T ) |   DT }
where T is the conjunction
of formulae  such that 2 is in T .
W
(3) Set Candidates = { T T T | T  (T )}.
(4) For each j  Candidates: remove j from Candidates if k |= j for some
k  Candidates with k < j, or if both j |= k and j 6|= k for k > j.
(5) Return Candidates.
Figure 3: Algorithm for prime implicate generation.

literals in T (LT ) plus the strongest 2-literal implied by T (2T ) plus the strongest 3literals implied by T ({3(  T ) |   DT }). It is not too hard to see that every prime
implicate of T must be equivalent to one of the elements in (T ). This means that in
Step 3 we are guaranteed that every prime implicate of the input formula is equivalent to
some candidate prime implicate in Candidates. During the comparison phase in Step 4,
non-prime candidates are eliminated, and exactly one prime implicate of each equivalence
class will be retained.
We illustrate the behavior of GenPI on an example:
Example 15. We run GenPI on input  = a  ((3(b  c)  3b)  (3b  3(c  d)  2e  2f )).
Step 1: As  is satisfiable, we call the function Dnf -4 on , and it returns the two terms
T1 = a  3(b  c)  3b and T2 = a  3b  3(c  d)  2e  2f .
Step 2: We have LT1 = {a}, DT1 = {b  c, b}, and there are no 2-literals in T1 , so we
get (T1 ) = {a, 3(b  c), 3b}. For T2 , we have LT2 = {a}, DT2 = {b, c  d}, and
T2 = e  f , giving us (T2 ) = {a, 2(e  f ), 3(b  e  f ), 3((c  d)  e  f )}.
Step 3: The set Candidates will contain all the different possible disjunctions of elements
in (T1 ) with elements in (T2 ), of which there are 12: aa, a2(ef ), a3(bef ),
a  3((c  d)  e  f ), 3(b  c)  a, 3(b  c)  2(e  f ), 3(b  c)  3(b  e  f ),
3(bc)3((cd)ef ), 3ba, 3b2(ef ), 3b3(bef ), and 3b3((cd)ef ).
Step 4: We will remove from Candidates the clauses a  2(e  f ), a  3(b  e  f ),
a  3((c  d)  e  f ), 3(b  c)  a, and 3b  a since they are strictly weaker than
a  a. We will also eliminate the clauses 3b  2(e  f ), 3b  3(b  e  f ), and
84

fiPrime Implicates and Prime Implicants in Modal Logic

3b  3((c  d)  e  f ) since they are weaker than the clauses 3(b  c)  2(e  f ),
3(b  c)  3(b  e  f ), 3(b  c)  3((c  d)  e  f ).
Step 5: GenPI will return the four remaining clauses in Candidates, which are a  a,
3(b  c)  2(e  f ), 3(b  c)  3(b  e  f ), and 3(b  c)  3((c  d)  e  f ).
Our algorithm can be shown to be a sound and complete procedure for generating prime
implicates.
Theorem 16. The algorithm GenPI always terminates and outputs exactly the set of
prime implicates of the input formula.
By examining the prime implicates produced by the algorithm, we can place an upper
bound on the length of a formulas prime implicates.
Theorem 17. The length of the smallest clausal representation of a prime implicate of a
formula is at most single exponential in the length of the formula.
This upper bound is optimal as we can find formulae with exponentially large prime
implicates. This situation contrasts with propositional logic, where the length of prime
implicates is linearly bounded by the number of propositional variables in the formula.
Theorem 18. The length of the smallest clausal representation of a prime implicate of a
formula can be exponential in the length of the formula.
It is interesting to note that the formula used in the proof of Theorem 18 has a depth
of 1, which means that we cannot avoid this worst-case spatial complexity by restricting
our attention to formulae of shallow depth. Nor can we escape this exponential worst-case
spatial complexity by dropping down to one of the less expressive notions of prime implicates
examined in the previous section, as the following theorem attests.
Theorem 19. If prime implicates are defined using either D1 or D2, then the length of
the smallest clausal representation of a prime implicate of a formula can be exponential in
the length of the formula.
An examination of the set of candidate prime implicates constructed by our algorithm
allows us to place a bound on the maximal number of non-equivalent prime implicates a
formula can possess.
Theorem 20. The number of non-equivalent prime implicates of a formula is at most
double exponential in the length of the formula.
This bound can also be shown to be optimal. This situation contrasts with propositional
logic, where there can be at most single exponentially many non-equivalent prime implicates
of a given formula.
Theorem 21. The number of non-equivalent prime implicates of a formula may be double
exponential in the length of the formula.
Again, this worst-case result is robust in that it can be improved neither by restricting the depth of formulae, nor by using less expressive notions of prime implicate, as the
following theorem demonstrates.
85

fiBienvenu

Theorem 22. If prime implicates are defined using either D1 or D2, then the number of
non-equivalent prime implicates of a formula may be double exponential in the length of the
formula.
Theorems 19 and 22 together suggest that definitions D1 or D2 do not yield especially interesting approximate notions of prime implicate, as they induce a significant loss
of expressivity without any improvement in the size or number of prime implicates in the
worst-case.
Our generation algorithm GenPI corresponds to the simplest possible implementation
of the distribution property, and it is quite clear that it does not represent a practicable
way for producing prime implicates. One major source of inefficiency is the large number
of clauses that are generated, so if we want to design a more efficient algorithm, we need
to find ways to generate fewer candidate clauses. There are a couple of different techniques
that could be used. One very simple method which could yield a smaller number of clauses
is to eliminate from (T ) those elements which are not prime implicates of T , thereby
decreasing the cardinalities of the (T ) and hence of Candidates. To do this, we simply
test whether T is a tautology (and remove it if it is) and then compare the 3-literals in
(T ), discarding any weaker elements. If we apply this technique to Example 15, we would
remove 3b from (T1 ), thereby reducing the cardinality of Candidates from 12 to 8.
More substantial savings could be achieved by using a technique developed in the framework of propositional logic (cf. Marquis, 2000) which consists in calculating the prime implicates of T1 , then the prime implicates of T1  T2 , then those of T1  T2  T3 , and so on until
we get the prime implicates of the full disjunction of terms. By interleaving comparison
and construction, we can eliminate early on a partial clause that cannot give rise to prime
implicates instead of producing all of the extensions of the partial clause and then deleting
them one by one during the comparison phase. In our example, there were only two terms,
but imagine that there was a third term T3 . Then by applying this technique, we would
first produce the 4 prime implicates of T1  T2 and then we would compare the 4|(T3 )|
candidate clauses of T1  T2  T3 . Compare this with the current algorithm which generates
and then compares 12|(T3 )| candidate clauses.
Given that the number of elements in Candidates can be double exponential in the
length of the input, cutting down on the size of the input to GenPI could yield significant
savings. One obvious idea would be to break conjunctions of formulae into their conjuncts,
and then calculate the prime implicates of each of the conjuncts. Unfortunately, however,
we cannot apply this method to every formula as the prime implicates of the conjuncts are
not necessarily prime implicates of the full conjunction. One solution which was proposed
in the context of approximation of description logic concepts (cf. Brandt & Turhan, 2002)
is to identify simple syntactic conditions that guarantee that we will get the same result
if we break the formula into its conjuncts. For instance, one possible condition is that the
conjuncts do not share any propositional variables. The formula  in our example satisfies
this condition since the variables in a and ((3(b  c)  3b)  (3b  3(c  d)  2e  2f )) are
disjoint. By generating the prime implicates of the conjuncts separately, we can directly
identify the prime implicate a, and we only have 6 candidate clauses of ((3(b  c)  3b) 
(3b  3(c  d)  2e  2f )) to compare. If we also remove weaker elements from the (Ti ) as
86

fiPrime Implicates and Prime Implicants in Modal Logic

suggested above, we get only 3 candidate clauses for ((3(bc)3b)(3b3(cd)2e2f )),
all of which are prime implicates of .
Another important source of inefficiency in our algorithm is the comparison phase in
which we compare all candidate clauses one-by-one in order to identify the strongest ones.
The problem with this is of course that in the worst-case there can be a double exponential
number of candidate clauses, simply because there may be double exponentially many
distinct prime implicates, and each prime implicate must be equivalent to some candidate
clause. Keeping all of these double exponentially many clauses in memory will generally
not be feasible. Fortunately, however, it is not necessary to keep all of the candidate clauses
in memory at once since we can generate them on demand from the sets (T ). Indeed, as
we demonstrate in the appendix, by implementing our algorithm in a more clever fashion,
we obtain an algorithm which outputs the prime implicates iteratively while requiring only
single-exponential space (the output of the algorithm could of course be double exponentially
large because of Theorem 21).
Theorem 23. There exists an algorithm which runs in single-exponential space in the size
of the input and incrementally outputs, without duplicates, the set of prime implicates of
the input formula.
Although our modified algorithm has a much better spatial complexity than the original,
it still does not yield a practicable means for generating prime implicates. The reason is that
we still need to compare each of the candidate clauses against all the other candidate clauses
in order to decide whether a candidate is a prime implicate or not. Given that the set of
candidate clauses may be double exponential in number, this means that our algorithm may
need to perform double exponentially many entailment tests before producing even a single
prime implicate. A much more promising approach would be to test directly whether or not
a candidate clause is a prime implicate without considering all of the other candidate clauses.
In order to implement such an approach, we must of course come up with a procedure for
determining whether or not a given clause is a prime implicate. This will be our objective
in the following section.
5.2 Recognizing Prime Implicates
The focus of this section is the problem of recognizing prime implicates, that is, the problem
of deciding whether a clause  is a prime implicate of a formula . As has been discussed
in the previous subsection, this problem is of central importance, as any algorithm for
generating prime implicates must contain (implicitly or explicitly) some mechanism for
ensuring that the generated clauses are indeed prime implicates.
In propositional logic, prime implicate recognition is BH2 -complete (Marquis, 2000),
being as hard as both satisfiability and deduction. In K, satisfiability and unsatisfiability are
both Pspace-complete, so we cannot hope to find a prime implicate recognition algorithm
with a complexity of less than Pspace.
Theorem 24. Prime implicate recognition is Pspace-hard.
In order to obtain a first upper bound, we can exploit Theorem 17 which tells us that
there exists a polynomial function f such that every prime implicate of a formula  is
87

fiBienvenu

equivalent to some clauses of length at most 2f (||) . This leads to a simple procedure for
determining if a clause  is a prime implicate of a formula . We simply check for every
clause  of length at most 2f (||) whether  is an implicate of  which implies  but is not
implied by . If this is the case, then  is not a prime implicate (we have found a logically
stronger implicate of ), otherwise, there exists no stronger implicate, so  is a prime
implicate. It is not too hard to see that this algorithm can be carried out in exponential
space, which gives us an Expspace upper bound.
Of course, the problem with this naive approach is that it does not at all take into
account the structure of , so we end up comparing a huge amount of irrelevant clauses,
which is exactly what we were hoping to avoid. The algorithm that we propose later in this
section avoids this problem by exploiting the information in the input formula and clause
in order to cut down on the number of clauses to test. The key to our algorithm is the
following theorem which shows how the general problem of prime implicate recognition can
be reduced to the more specialized tasks of prime implicate recognition for propositional
formulae, 2-formulae, and 3-formulae. To simplify the presentation of the theorem, we
let () refer to the set of prime implicates of , and we use the notation  \ {l1 , ..., ln }
to refer to the clause obtained by removing each of the literals li from . For example
(a  b  3c) \ {a, 3c} refers to the clause b.
Theorem 25. Let  be a formula of K, and let  = 1  ... k  31  ... 3n  21  ...
2m (j propositional literals) be a non-tautologous clause such that (a) i  i 1 ...n
for all i, and (b) there is no literal l in  such that    \ {l}. Then   () if and only
if the following conditions hold:
1. 1  ...  k  (  ( \ {1 , ..., k }))
2. 2(i  1  ...  n )  (  ( \ {2i })) for every i
3. 3(1  ...  n )  (  ( \ {31 , ..., 3n }))
We remark that the restriction to clauses for which i  i  1  ...  m for all i
and for which  6  \ {l} for all l is required. If we drop the first requirement, then there
are some non-prime implicates that satisfy all three conditions, and if we drop the second,
there are prime implicates which fail to satisfy one of the conditions5 . These restrictions are
without loss of generality however since every clause can be transformed into an equivalent
clause satisfying them. For the first condition, we replace each 2i by 2(i  1  ...  m ),
thereby transforming a clause 1  ... k  31  ...3m  21  ... 2n into the equivalent
1  ...  k  31  ...3m  2(1  1  ...  m )  ...  2(n  1  ...  m ). Then to make
the clause satisfy the second condition, we simply remove from  those literals for which
   \ {l} until no such literal remains.
Theorem 25 shows how prime implicate recognition can be split into three more specialized sub-tasks, but it does not tell us how to carry out these tasks. Thus, in order to turn
5. For the first restriction, consider the formula  = 3(abc)2a and the clause  = 3(ab)2(ab).
It can be easily shown that  is an implicate of , but  is not a prime implicate of  since there exist
stronger implicates (e.g.  itself). Nonetheless, it can be verified that both 2(a  b  (a  b)) 
(  ( \ {2(a  b)})) and 3(a  b)  (  ( \ {3(a  b)})). For the second restriction, consider the
formula 2a and the clause 2a2(ab). We have 2(ab) 6 (2a(2a)) even though 2a2(ab)  2a
is a prime implicate of 2a.

88

fiPrime Implicates and Prime Implicants in Modal Logic

this theorem into an algorithm for prime implicate recognition, we need to figure out how
to test whether a propositional clause, a 2-formula, or a 3-formula is a prime implicate of
a formula.
Determining whether a propositional clause is a prime implicate of a formula in K is
conceptually no more difficult than determining whether a propositional clause is a prime
implicate of a propositional formula. We first ensure that the clause is an implicate of the
formula and then make sure that all literals appearing in the clause are necessary.
Theorem 26. Let  be a formula of K, and let  be a non-tautologous propositional clause
such that  |=  and such that there is no literal l in  such that    \ {l}. Then   ()
if and only if  6|=  \ {l} for all l in .
We now move on to the problem of deciding whether a clause of the form 2 is a prime
implicate of a formula . We remark that if 2 is implied by , then it must also be implied
by each of the terms Ti Dnf -4(). But if Ti |= 2, then by Theorem 1, it must be the
case that the conjunction of the 2-literals in Ti implies 2. This means that the formula
21  ...  2n (where i is the conjunction of the formulae  such that 2 is in Ti ) is an
implicate of  which implies 2, and moreover it is the strongest such implicate. It follows
then that 2 is a prime implicate of  just in the case that 2 |= 21  ...  2n , which
is true if and only if  |= i for some i (by Theorem 1). Thus, by comparing the formula 
with the formulae i associated with the terms of , we can decide whether or not 2 is a
prime implicate of .
Theorem 27. Let  be a formula of K, and let  = 2 be a non-tautologous clause such
that  |= . Then   () if and only if there exists some term T Dnf-4() such that
 |= T , where T is the conjunction of formulae  such that 2 is in T .
Finally let us turn to the problem of deciding whether a clause 3 is a prime implicate
of a formula . Now we know by Covering that if 3 is an implicate of , then there must
be some prime implicate  of  which implies 3. It follows from Theorem 2 that  must
be
W a disjunction of 3-literals, and from Theorem 16 that  is equivalent to a disjunction
T Dnf -4() 3dT where 3dT is an element of (T ) for every T (refer back to Figure 3 for
the definition of (TW
)). According to Definition 7, 3 is aWprime implicate of  just in
the case that 3 |= T Dnf -4() 3dT , or equivalently  |= T Dnf -4() dT . Thus, 3 is
not a prime implicate of W
 just in the case that there isWa choice of 3dT  (T ) for each
6|= T Dnf -4() dT .
T  Dnf -4() such that T Dnf -4() dT |=  and W
Testing directly whether  entails some formula T Dnf -4() dT could take exponential
space in the worst case since there may be exponentially many terms in Dnf -4(). Luckily,
W however, we can get around this problem by exploiting the structure of the formula
T Dnf -4() dT . We remark that because of the way (T ) is defined the formula dT must
be a conjunction of formulae  such that 2 or 3 appears in Nnf () outside the scope of
modal operators  we will use X W
to denote the set of formulae  satisfying this condition. We
show in the appendix
that  6|= T Dnf -4() dT implies the existence of a subset S  X such
W
that (a)  6|= S  and (b) every dT has at least W
one conjunct from the set S. Conversely,
the existence of such a subset of X implies  6|= T Dnf -4() dT . This observation is the
basis for the algorithm Test3PI given in Figure 4. The basic idea behind the algorithm is
to try out each of the different subsets of X in order to see whether some subset satisfies the
89

fiBienvenu

Function Test3PI(3, )
Input: a clause 3 and a formula  such that  |= 3
Output: yes or no
(1) If  |= , return yes if  |=  and no otherwise.
(2) Set X equal to the set of formulae  such that 2 or 3 appears in Nnf () outside
the scope of modal operators.
(3) For each W
S  X , test whether the following two conditions hold:
(a)  6|= S 
(b) for each Ti  Dnf -4(), there exists conjuncts 3i , 2i,1 , ..., 2i,k(i) of Ti
such that:
(i) {i , i,1 , ..., i,k(i) }  S 6= 
(ii) 3(i  i,1  ...  i,k(i) ) |= 3
Return no if some S satisfies these conditions, and yes otherwise.
Figure 4: Algorithm for identifying prime implicates of the form 3.

aforementioned conditions. If we find a suitable subset, this proves that 3 is not a prime
implicate, and if no such subset exists, then we can be sure there is no stronger implicate
than 3. The algorithm can be shown to run in polynomial space since there can be at
most || elements in X , and we can consider the terms in Dnf -4() one at a time.
Theorem 28. Let  be a formula, and let 3 be an implicate of . Then the algorithm
Test3PI returns yes on input (3, ) if and only if 3 is a prime implicate of .
Theorem 29. The algorithm Test3PI runs in polynomial space.
We now illustrate the algorithm Test3PI with two examples.
Example 30. We use Test3PI to test whether the clause  = 3(ab) is a prime implicate
of  = a  (2(b  c)  2(e  f ))  3(a  b).
Step 1: As  is satisfiable, we pass directly to Step 2.
Step 2: We set X equal to the set of formulae  such that 2 or 3 appears in Nnf ()
outside the scope of modal operators. In our case, we set X = {b  c, e  f, a  b}
since  =Nnf () and b  c, e  f , and a  b are the only formulae satisfying the
requirements.
Step 3: We examine each of the different subsets of X to determine whether they satisfy
conditions (a) and (b). In particular, we consider the subset S = {b  c, e  f }. We
remark that this subset satisfies condition (a) since a  b 6|= (b  c)  (e  f ). In order
to check condition (b), we first call the function Dnf -4 on  which returns the two
terms T1 = a  2(b  c)  3(a  b) and T2 = a  2(e  f )  3(a  b). We notice that
the conjuncts 3(a  b) and 2(b  c) of T1 satisfy conditions (i) and (ii) since b  c  S
and 3(a  b  (b  c)) |= . We then notice that the conjuncts 3(a  b) and 2(e  f ) of
T2 also satisfy conditions (i) and (ii) since e  f  S and 3(a  b  (e  f )) |= . That
90

fiPrime Implicates and Prime Implicants in Modal Logic

Function TestPI(, )
Input: a clause  and a formula 
Output: yes or no
(1) If  6|= , return no.
(2) If  |= , then return yes if  |=  and no if not.
If |= , then return yes if |=  and no otherwise.
(3) For each li in  = l1  ...  ln , test if  \ {li }  , and if so, remove li from .
Let D = {31 , ..., 3m } be the set of 3-literals in . If D is non-empty, replace
each disjunct 2 of  by the literal 2(  1  ...  m ).
(4) Let P be the set of propositional literals which are disjuncts of . For each
l  P, check whether  |=  \ {l}, and return no if so.
(5) Let B be the set of 2-formulae appearing as disjuncts in . Check for each 2
in B whether there is some T in Dnf -4(  ( \ {2})) for which the formula
2(  1  ...  k ) implies the conjunction of 2-literals in T , and return no
if not.
W
(6) If D is empty, return yes, otherwise return Test3PI(3( m
i=1 i ),   ( \ D)).
Figure 5: Algorithm for identifying prime implicates.

means that we have found a subset S of X which satisfies conditions (a) and (b), so
the algorithm returns no. This is the correct output since 3(a  b  ((b  c)  (e  f )))
is an implicate of  which is strictly stronger than .
Example 31. We use Test3PI to test whether the clause  = 3(a  b  c) is a prime
implicate of  = a  (2(b  c)  2(e  f ))  3(a  b)  2(e  f  (a  b  c)).
Step 1: We proceed directly to Step 2 since  is satisfiable.
Step 2: We set X = {b  c, e  f, a  b, e  f  (a  b  c))} since Nnf ()=a  (2(b 
c)  2(e  f ))  3(a  b)  3(e  f  (a  b  c)).
Step 3: We check whether there is some subset of X satisfying conditions (a) and (b). We
claim that there is no such subset. To see why, notice that a  2(b  c)  3(a  b) 
3(e  f  (a  b  c)) is the only term in Dnf -4(). Moreover, there is only one
set of conjuncts of this term which implies 3(a  b  c), namely {3(a  b), 2(b  c)}.
But that means that S must contain either a  b or b  c in order to satisfy condition
(b)(i). As a  b  c implies both a  b and b  c, we are guaranteed that a  b  c
will imply the disjunction of elements in S, thereby falsifying condition (a). It follows
that there is no subset of X satisfying the necessary conditions, so Test3PI returns
yes, which is the desired result.
In Figure 5, we present our algorithm for testing whether a clause  is a prime implicate
of a formula . The first two steps of the algorithm treat the limit cases where  is not
an implicate or where one or both of  and  is a tautology or contradiction. In Step 3,
91

fiBienvenu

we apply equivalence-preserving transformations to  to make it satisfy the requirements
of Theorem 25. Then in Steps 4, 5, and 6 we use the procedures from Theorems 26, 27,
and 28 to test whether the three conditions in Theorem 25 are verified. If the three tests
succeed, then by Theorem 25, the clause is a prime implicate, so we return yes. If some
test fails, we return no as the clause has been shown not to be a prime implicate.
Theorem 32. The algorithm TestPI always terminates, and it returns yes on input (,
) if and only if  is a prime implicate of .
We demonstrate the use of TestPI on an example.
Example 33. We use TestPI to test if the clauses 1 = b, 2 = 2b  2(e  f ), 3 = a  3c,
4 = 3(a  b), and 5 = 3(a  b  c)  3(a  b  c  f )  2(e  f ) are prime implicates of
 = a  (2(b  c)  2(e  f ))  3(a  b).
1 : We output no in Step 1 since  6|= 1 .
2 : We skip Steps 1 and 2 since  |= 2 and neither  |=  nor |= 2 . In Step 3, we
make no changes to 2 since it contains no redundant literals nor any 3-literals. We
skip Step 4 since 2 has no propositional disjuncts. In Step 5, we return no since
Dnf -4(  (2 \ {2b})) = {a  2(b  c)  3(a  b)  3(e  f )} and 2b 6|= 2(b  c).
3 : We proceed directly to Step 3 since  |= 3 ,  6|= , and 6|= 3 . No modifications
are made to 3 in Step 3 as it does not contain any redundant literals or 2-literals.
In Step 4, we test whether or not  |= 3 \ {a}. As  6|= 3c, we proceed on to Step
5, and then directly on to Step 6 since 3 contains no 2-literals. In Step 6, we call
Test3PI(3c,   (3 \ {3c})), which outputs no since   (3 \ {3c}) |=  and
c 6|= .
4 : Steps 1-5 are all inapplicable, so we skip directly to Step 6. In this step, we call
Test3PI with as input the clause 3(a b) and the formula  (4 \{3(a b)}) = .
We have already seen in Example 30 above that Test3PI returns no on this input,
which means that TestPI also returns no.
5 : We proceed directly to Step 3, where we delete the redundant literal 3(a  b  c  f )
and then modify the literal 2(ef ). At the end of this step, we have 5 = 3(abc)
2((ef )(abc)). Step 4 is not applicable since there are no propositional disjuncts
in 5 . In Step 5, we continue since Dnf -4(  (5 \ {2((e  f  (a  b  c))})) =
{a2(ef )3(ab)2(abc)}, and 2(((ef (abc))(abc)) |=
2(e  f )  2(a  b  c). In Step 6, we return yes since we call Test3PI on input
(3(a  b  c),   (5 \ {3(a  b  c)})), and we have previously shown in Example
31 that Test3PI returns yes on this input.
We show in the appendix that the algorithm TestPI runs in polynomial space. As we
have already shown that TestPI decides prime implicate recognition, it follows that this
problem is in Pspace:
Theorem 34. Prime implicate recognition is in Pspace.
92

fiPrime Implicates and Prime Implicants in Modal Logic

By putting together Theorems 24 and 34, we obtain a tight complexity bound for the
prime implicate recognition task.
Corollary 35. Prime implicate recognition is Pspace-complete.

6. Conclusion and Future Work
The first contribution of this work is a detailed comparison of several different possible
definitions of clauses, terms, prime implicates, and prime implicants for the modal logic K.
The results of this investigation were largely positive: although we have shown that no
perfect definition exists, we did exhibit a very simple definition (D4) which satisfies most of
the desirable properties of the propositional case. The second contribution of our work is a
thorough investigation of the computational aspects of the selected definition D4. To this
end, we presented a sound and complete algorithm for generating prime implicates, as well
as a number of optimizations to improve the efficiency of the algorithm. An examination of
the structure of the prime implicates generated by our algorithm allowed us to place upper
bounds on the length of prime implicates and on the number of prime implicates a formula
can possess. We showed these bounds to be optimal by exhibiting matching lower bounds,
and we further proved that the lower bounds hold even for some much less expressive notions of prime implicates. Finally, we constructed a polynomial-space algorithm for deciding
prime implicate recognition, thereby showing this problem to be Pspace-complete, which is
the lowest complexity that could reasonably be expected. Although the focus of the paper
was on the logic K, all of our results can be easily lifted to multi-modal K and to concept
expressions in the well-known description logic ALC.
As was mentioned in the introduction, one of the main applications of prime implicants
in propositional logic is to the area of abductive reasoning, where prime implicants play
the role of abductive explanations. The results of our paper can be directly applied to the
problem of abduction in K: our notion of prime implicants can be used as a definition of
abductive explanations in K, and our prime implicate generation algorithm provides a means
of producing all of the abductive explanations to a given abduction problem. Moreover,
because the notion of term underlying our definition of abductive explanations is more
expressive than that used by Cialdea Mayer and Pirri (1995), we are able to find explanations
which are overlooked by their method. For instance, if we look for an explanation of the
observation c given the background information 2(a  b)  c, we obtain 2(a  b), whereas
their framework yields 2a and 2b. This is an argument in favor of our approach since
generally in abduction one is looking to find the weakest conditions guaranteeing the truth
of the observation given the background information.
Also of interest are our results on the size and number of prime implicates, as these
yield corresponding lower bounds on the size and number of abductive explanations. In
particular, our results imply that the abductive explanations of Cialdea Mayer and Pirri
(1995) can have exponential size and be double exponentially many in number in the worst
case, and thus behave no better in these respects than the notion of abductive explanation
induced by our preferred definition D4. Moreover, the fact that these lower bounds hold
even in the case of the extremely inexpressive notion of abductive explanations induced
by definition D2 suggests that these high worst-case complexity results really cannot be
93

fiBienvenu

avoided. In light of these intractability results, an interesting question for future research
would be to study the problem of generating a single prime implicate, since in some applications it may prove sufficient to produce a single minimal explanation for an observation.
Another interesting subject for future work which is relevant from the point of view of abduction is the investigation of the notion of prime implicate over a fixed vocabulary. The
development of generation algorithms for this more refined notion of prime implicate would
allow one to generate only those abductive explanations which are built up from a given set
of propositional variables.
The second domain of application which was mentioned in the introduction was the
area of knowledge compilation. In propositional logic, one well-known target language for
knowledge compilation is prime implicate normal form, in which a formula is represented
as the conjunction of its prime implicates. A natural idea would be to use our selected
definition of prime implicate to define in an analogous manner a notion of prime implicate
normal form for K formulae. Unfortunately, the normal form we obtain satisfies few of the
nice properties of the propositional case. For instance, we find that entailment between two
formulae in prime implicate normal form is no easier than between arbitrary K formulae.
To see why, consider any pair of formulae  and  in negation normal form. The formulae
3 and 3 are their own prime implicates and hence are in prime implicate normal form
according to the naive definition. As  |=  just in the case that 3 |= 3, we can reduce
entailment between arbitrary K formulae in NNF to entailment between formulae in prime
implicate normal form. As the former problem is known to be Pspace-complete, it follows
that the latter is Pspace-complete as well.
At first sight, this appears to be quite a disappointing result as one would hope that the
computational difficulty of representing a formula by its prime implicates would be offset
by some good computational properties of the resulting formula. As it turns out, however,
the problem lies not in our definition of prime implicates but rather in the naive way of
defining prime implicate normal form. Indeed, in a continuation of the present work (Bienvenu, 2008), we proposed a more sophisticated definition of prime implicate normal form,
in which we specify which of the many different clausal representations of a prime implicate
should be used. This normal form was shown to enjoy a number of desirable properties
which make it interesting from the viewpoint of knowledge compilation. Most notably, it
was proven that entailment between formulae in K in our prime implicate normal form can
be carried out in polynomial time using a simple structural comparison algorithm which is
reminiscent of the structural subsumption algorithms used in subpropositional description
logics. It should be noted that the proof of this and other results by Bienvenu (2008) make
ample use of the material presented in the current paper.
In this work, we studied prime implicates with respect to the local consequence relation,
so a natural direction for future work would be the investigation of prime implicates with respect to the global consequence relation. This question is particularly interesting given that
global consequence is the type of consequence used in description logic ontologies. Unfortunately, our preliminary investigations suggest that defining and generating prime implicates
with respect to the global consequence relation will likely prove more difficult than for the
local consequence relation. For one thing, if we use a definition of clause which is reasonably
94

fiPrime Implicates and Prime Implicants in Modal Logic

expressive, then the notion of prime implicate we obtain does not satisfy Covering since
we can construct infinite sequences of stronger and stronger implicates. Take for instance
the formula (a  b)  (b  3b) which implies (using the global consequence relation)
each of the increasingly stronger clauses in the infinite sequence a  3b, a  3(b  3b),
a  3(b  3(b  3b)), ... This is a familiar situation for description logic practitioners since
these infinite sequences are responsible for the non-existence of most specific concepts in
many common DLs (cf. Kusters & Molitor, 2002) and the lack of uniform interpolation for
ALC TBoxes (Ghilardi, Lutz, & Wolter, 2006). A standard solution to this problem is to
simply place a bound on the depth of formulae to be considered, effectively blocking these
problematic infinite sequences. This will not allow us to regain Covering, but it will give
us a weaker version of this property, which should be sufficient for most applications. The
development of generation algorithms for the global consequence relation may also prove
challenging, since it is unclear at this point whether we will be able to draw inspiration from
pre-existing methods. Despite these potential difficulties, we feel that this subject is worth
exploring since it could contribute to the development of more flexible ways of accessing
and structuring information in description logic ontologies.
Finally, another natural direction for future research would be to extend our investigation of prime implicates and prime implicants to other popular modal and description logics.
Particularly of interest are modal logics of knowledge and belief and expressive description
logics used for the semantic web. We are confident that the experience gained from our
investigation of prime implicates and prime implicants in K will prove a valuable asset in
the exploration of other modal and description logics.

Acknowledgments
This paper corrects and significantly extends an earlier conference publication (Bienvenu,
2007). This paper was written while the author was a PhD student working at IRIT,
Universite Paul Sabatier, France. The author would like to thank her thesis supervisors
Andreas Herzig, Jerome Lang, and Jerome Mengin, as well as the anonymous reviewers for
very helpful feedback.

Appendix A. Proofs
Theorem 1 Let , 1 , ..., m , , 1 , ..., n be formulae in K, and let  be a propositional
formula. Then
1.  |=   |=        |= 
2.  |=   3 |= 3  2 |= 2
3.  31 ...3m 21 ...2n |=   ( |=  or i 1 ...n |=  for some i)
4. |=   31  ...  3m  21  ...  2n  (|=  or |= 1  ...  m  i for some i)
5. 2 |= 21  ...  2n   |= i for some i
95

fiBienvenu

6. 31  ...  3m  21  ...  2n
 31  ...  3m  2(1  1  ...  m )  ...  2(n  1  ...  m )
Proof. The first statement is a well-known property of local consequence, but we prove it
here for completeness:
 |=  






M, w |=  implies M, w |=  for all M, w
M, w 6|=  or M, w |=  for all M, w
M, w |=  or M, w |=  for all M, w
|=   
M, w 6|=    for all M, w
   |= 

For the second statement, if  6|= , then there is some M, w such that M, w |=   .
Create a new model M from M by adding a new world w and placing a single arc from
w to w. Then M , w |= 3  2, which means that 3  2 is satisfiable and hence
3 6|= 3 (since 2  3). For the other direction, suppose 3 6|= 3. Then there
exists M, w such that M, w |= 3  3  3  2. But this means that there is some
w for which   , hence  6|= . To complete the proof, we use the following chain of
equivalences: 2 |= 2  2 |= 2  3 |= 3   |=    |= .
For 3, suppose that   31  ...  3m  21  ...  2n 6|= . Then there exist M, w
such that M, w |=   31  ...3m  21  ...  2n . As M, w |= , we cannot have
 |= , nor can we have i  1  ...  n |=  since for each i there is some w such
that M, w |= i  1  ...  n . Now for the other direction suppose that  and all of the
i  1  ...  n are satisfiable. Then there is some propositional model w of , and for
each i, we can find Mi , wi such that Mi , wi |= i  1  ...  n . Now we construct a new
Kripke structure which contains the models Mi and the world w and in which there are arcs
going from w to each of the wi . It is not hard to see that in this new model Mnew we have
Mnew , w |=   31  ...3m  21  ...2n , so   31  ...3m  21  ...  2n 6|= .
Statement 4 follows easily from the third statement. We simply notice that   31 
...  3m  21  ...  2n is a tautology just in the case that its negation   31 
...  3n  21  ...  2m is unsatisfiable.
For 5, we use statements 1 and 4 to get the following chain of equivalences:
2 |= 21  ...  2n
 |= 3  21  ...  2n
 |=   i for some i
  |= i for some i
The first implication of the equivalence in 6 is immediate since 31  ...  3m |=
31  ...  3m and 2i |= 2(i  1  ...  m ) for all i. For the other direction, we remark
that by using statements 1 and 3, we get the following equivalences:
2(i  1  ...  m ) |= 2i  31  ...  3m
 2(i  1  ...  m )  (2i  31  ...  3m ) |= 
 2(i  1  ...  m )  3i  21  ...  2m |= 
 (i  1  ...  m )  i  1  ...  m |= 
96

fiPrime Implicates and Prime Implicants in Modal Logic

As (i  1  ...  m )  i  1  ...  m is clearly unsatisfiable, it follows that
2(i  1  ...  m ) |= 2i  31  ...  3m for every i and hence that 31  ...  3m 
2(1  1  ...  m )  ...  2(n  1  ...  m ) |= 31  ...  3m  21  ...  2n ,
completing the proof.
Theorem 2 Let  be a disjunction of propositional literals and 2- and 3-formulae. Then
each of the following statements holds:
1. If  |=  for some non-tautological propositional clause , then every disjunct of  is
either a propositional literal or an unsatisfiable 3-formula
2. If  |= 31  ...  3n , then every disjunct of  is a 3-formula
3. If  |= 21  ...  2n and 6|= 21  ...  2n , then every disjunct of  is either a
2-formula or an unsatisfiable 3-formula
Proof. For (1), let  be a non-tautologous propositional clause such that  |= , and suppose
for a contradiction that  contains a disjunct 2 or a disjunct 3 where  6|= . In the
first case, we have 2 |= , and hence |= 3  . It follows from Theorem 1 that
|= , contradicting our assumption that  is not a tautology. In the second case, we have
3 |= , and thus |= 2  . By Theorem 1, either |=  or |= . In both cases, we
reach a contradiction since we have assumed that  6|=  and 6|= . It follows then that 
cannot have any 2-formulae or satisfiable 3-formulae as disjuncts.
The proofs of (2) and (3) proceed similarly.
Theorem 3 Let  =   31  ...  3m  21  ...  2n and  =    31  ...  3p 
21  ...  2q be formulae in K. If  are   are both propositional and 6|=  , then

  |=   and

1  ...  m |= 1  ...  p and
 |=  

for every i there is some j such that i |= 1  ...  p  j
Proof. Since we have 6|=  , we know that 6|=   and 6|= 1  ...  p  i for all i. Using this
information together with Theorem 1, we get the following equivalences:
 |=  


31  ...  3m |=  



2i |=  



|=      31  ...  3p  21  ...  2m
|=    
 |=  
3(1  ...  m ) |= 
|=    31  ...  3p  2(1  ...  m )  21  ...  2q
|= 1  ...  p  (1  ...  m )
1  ...  m |= 1  ...  p
|=    3(1  ...  p  i )  21  ...  2q
there is some j such that |= 1  ...  p  i  j
there is some j such that i |= 1  ...  p  j

To complete the proof, we use the fact  |=  if and only if  |=  , 31  ...  3m |=  ,
and 2i |=  for every i.
97

fiBienvenu

Theorem 5 Any definition of literals, clause, and terms for K that satisfies properties P1
and P2 cannot satisfy P5.
Proof. We remark that the set of clauses (resp. terms) with respect to definition D1 is
precisely the set of formulae in NNF which do not contain  (resp. ), i.e. D1 is the most
expressive definition satisfying both P1 and P2. Thus, to show the result, it suffices to
show that D1 does not satisfy P5.
Suppose for a contradiction that D1 does satisfy P5. Then there must exist clauses 1 , ..., n
such that 3(a  b)  1  ...  n . Each of the clauses i is a disjunction li,1  ....  li,pi . By
distributing  over , we obtain the following:
n
^

_

3(a  b) 

li,ji

(j1 ,...,jn){1,...,p1 }...{1,...,pn} i=1

from which we can infer that for each (j1 , ..., jn )  {1, ..., p1 }  ...  {1, ..., pn } we have
n
^

li,ji |= 3(a  b)

i=1

Vn

Consider some (j1 , ..., jn ) such that i=1 li,ji is consistent (there must be at least one such
tuple, otherwise we would have 3(a  b)  ). The formulae li,ji are eitherVpropositional
literals or formulae of the form 2 or 3 for some clause . It follows that ni=1 li,ji must
have the following form:
1  ...  k  31  ...  3m  21  ...  2n
where 1 , ..., k are propositional
literals and 1 , ...,
V m , 1 , ..., n are clauses with respect
V
to D1. As we know that ni=1 li,ji |= 3(a  b) and ni=1 li,ji 6|= , by Theorem 1, there must
be some 3q such that
3q  21  ...  2n |= 3(a  b)
We now show that 3q 6|= 3(a  b) (and hence that 6|= 1  ...  n ). Suppose for a
contradiction that this is not the case. Then we must have q |= a and q |= b. But by
Theorem 1, every disjunct of q (which we recall is a D1-clause) must either be unsatisfiable
or equal to both a and b. As the latter
V is impossible, it follows that q |= , which is a
contradiction since we assumed that ni=1 li,ji is satisfiable. It follows then that in order to
get 3q  21  ...  2n |= 3(a  b), there must be some r which is not a tautology.
Now let us consider the formula
_
=
2j1 ,...,jn
{(j1 ,...,jn)|

Vn

i=1 li,ji 6}

V
where 2j1 ,...,jn is a non-tautological 2-formula appearing in ni=1 li,ji (we have just shown
that such a formula must exist). Clearly it must be the case that
n
^

_

(j1 ,...,jn){1,...,p1 }...{1,...,pn} i=1

98

li,ji |= 

fiPrime Implicates and Prime Implicants in Modal Logic

from which we get:
3(a  b) |= 
But according to Theorem 2, a satisfiable 3-formula cannot imply a disjunction of 2formulae unless that disjunction is a tautology, so we must have |=  . However, this is
impossible since it would imply (Theorem 1) that there is some j1 ,...,jn which is a tautology,
contradicting our earlier assumption to the contrary. We can thus conclude that there is
no set of clauses 1 , ..., n with respect to D1 such that 3(a  b)  1  ...  n , and hence
that any definition which satisfies P1 and P2 cannot satisfy P5.
In order to prove Theorem 6, we will make use of the following lemmas:
Lemma 6.1 Definition D5 satisfies P5.
Proof. We demonstrate that any formula in K in NNF is equivalent to a conjunction of
clauses with respect to definition D5. The restriction to formulae in NNF is without loss
of generality as every formula is equivalent to a formula in NNF. The proof proceeds by
induction on the structural complexity of formulae. The base case is propositional literals,
which are already conjunctions of clauses since every propositional literal is a clause with
respect to D5. We now suppose that the statement holds for formulae 1 and 2 and show
that it holds for more complex formulae.
We first consider  = 1  2 . By assumption, we can find clauses i and j such
that 1  1  ...  n and 2  1  ...  m . Thus,  is equivalent to the formula
1  ...  n  1  ...  m , which is a conjunction of clauses with respect to D5.
Next we consider  = 1  2 . By the induction hypothesis, we have 1  1  ...  n
and 2  1  ...  m for some clauses i and j . Thus,   (1  ...  n )  (1  ...  m ),
which can be written equivalently as   (i,j){1,...,n}{1,...,m}(i  j ). Since the union of
two clauses produces another clause, all of the i  j are clauses, completing the proof.
We now consider the case where  = 21 . By assumption, 1  1  ...  n , where each
i is a clause. So   2(1 ...n ). But we also know that 2(1 ...n )  21 ...2n .
It follows that  is equivalent to 21  ...  2n , which is a conjunction of clauses since the
2i are all clauses.
Finally, we consider  = 31 . Using the induction hypothesis, we have   3(1 
...  n ) for clauses i . But since the i are clauses, each i is a disjunction of literals
li,1  ...  li,pi . After distributing  over  and  over 3, we find that  is equivalent to the
formula
_
3(l1,j1  l2,j2  ...  ln,jn )
(j1 ,...,jn){1,...,p1 }...{1,...,pn}

which is a clause with respect to D5.
The proof that every formula is equivalent to a disjunction of terms with respect to D5
proceeds analogously.
Lemma 6.2 Every clause (resp. term) with respect to D5 is a clause (resp. term) with
respect to definitions D3a, D3b, and D4.
Proof. We will show by induction on the structural complexity of formulae that:
99

fiBienvenu

1. every clause C with respect to D5 is a clause with respect to definitions D3a, D3b,
and D4 and a disjunction of terms with respect to D3a
2. every term T with respect to D5 is a term with respect to definitions D3a, D3b, and
D4 and a conjunction of clauses with respect to D3a and D3b
We require this stronger formulation of the statement to prove some of the sub-cases.
The base case for our induction is propositional literals, which are both clauses and
terms with respect to D5. It is easy to see that (1) and (2) are verified since propositional
literals are both clauses and terms with respect to definitions D3a, D3b, and D4 (and
hence they are also disjunctions of terms with respect to D3a and conjunctions of clauses
with respect to D3a and D3b).
For the induction step, we will show that the above statements hold for arbitrary clauses
or terms with respect to D5 under the assumption that the statments hold for all of their
proper sub-clauses and sub-terms.
We begin with clauses. Let C be a D5-clause such that all proper sub-clauses and subterms of C satisfy (1) and (2). Now since C is a clause with respect to D5, it can either
be a propositional literal or a formula of the form C1  C2 for clauses C1 and C2 , 2C1 for
some clause C1 , or 3T1 for some term T1 . The case where C is a propositional literal has
already been treated in the base case. Let us thus consider the case where C = C1  C2 .
The first part of (1) holds since by the induction hypothesis both C1 and C2 are clauses
with respect to definitions D3a, D3b, and D4, and for all three definitions the disjunction
of two clauses is a clause. The second half of (1) is also verified since both C1 and C2 are
disjunctions of terms with respect to D3a, and thus so is their disjunction C1  C2 . We
next consider the case where C = 2C1 for some clause C1 with respect to D5. The first
part of (1) follows easily as we know that C1 must also be a clause with respect to D3a,
D3b, and D4, and for all of these definitions putting a 2 before a clause yields another
clause. The second part of (1) holds as well since C1 is a disjunction of terms with respect
to D3a and thus 2C1 is a term with respect to this same definition. We now suppose that
C = 3T1 for some term T1 with respect to D5. For definitions D3a and D3b, we know
from the induction hypothesis that T1 is a conjunction of clauses with respect to D3a and
D3b and hence that 3T1 is a clause with respect to these definitions. For D4, the result
obviously holds since we are allowed to put any formula in NNF behind 3. The second part
of (1) holds since by the induction hypothesis T1 is a term with respect to D3a and hence
3T1 is also a term with respect to this definition.
We next consider terms. Let T be a D5-term such that all proper sub-clauses and subterms of T satisfy (1) and (2). Then T must be either a propositional literal or a formula of
the form T1  T2 for terms T1 and T2 , 2C1 for some clause C1 , or 3T1 for some term T1 . If
T = T1  T2 , the first half of (2) holds since we know T1 and T2 to be terms with respect to
D3a, D3b, and D4, and conjunctions of terms are also terms for all three definitions. The
second half is also verified since both T1 and T2 are assumed to be conjunctions of clauses
with respect to D3a and D3b, which means that T is also a conjunction of clauses with
respect to these definitions. Next suppose that T = 2C1 . For definitions D3b and D4, it is
easy to see that T is a literal and hence a term. For D3a, the induction hypothesis tells us
that C1 is a disjunction of terms, from which we can deduce that 2C1 is a term. Moreover,
since C1 is known to be a clause with respect to D3a and D3b, then 2C1 must also be a
100

fiPrime Implicates and Prime Implicants in Modal Logic

clause with respect to these definitions, so T is a conjunction of clauses with respect to both
D3a and D3b. Finally, we treat the case where T = 3T1 . For D3a, we use the fact that
T1 is a term with respect to D3a, which means that 3T1 must also be a term. For D3b,
we use the supposition that T1 is a conjunction of clauses with respect to D3b, from which
we get that 3T1 is a literal and hence a term. The first part of (2) clearly also holds for D4
since any formula behind 3 yields a literal and thus a term. The second half of (2) follows
from the fact that by the induction hypothesis T1 is a conjunction of clauses with respect
to D3a and D3b, so 3T1 is a clause (and hence a conjunction of clauses) with respect to
these definitions.

U ,S = 1,1  ...  1,m  
where the i,j are defined inductively as follows

3i+1,j , if either i  n, ui  Sj , or i > n and uin  Sj
i,j =
2i+1,j , if either i  n, ui 6 Sj , or i > n and uin 6 Sj
for i  {1, ..., 2n} and 2n+1,j = , and  = 2...2
| {z } .
2n

Figure 6: The formula U ,S which codes an instance U = {u1 , ..., un }, S = {S1 , ..., Sm } of
the exact cover problem.

Lemma 6.3 Entailment between terms or clauses is NP-complete for both definitions D1
and D2.
Proof. In the proofs of both NP-membership and NP-hardness, we will exploit the relationship between terms with respect to definitions D1 and D2 and concept expressions in
the description logic ALE (cf. Baader, McGuiness, Nardi, & Patel-Schneider, 2003). We
recall that concept expressions in this logic are constructed as follows (we use a modal logic
syntax and assume a single modal operator in order to facilitate comparison between the
formalisms):
 ::=  |  | a | a |    | 2 | 3
The semantics of the symbols  and  is as one would expect: M, w |=  and M, w 6|=  for
every model M and world w. The semantics of atomic literals, conjunctions, and universal
and existential modalities is exactly the same as for K.
It is not hard to see that every term with respect to D1 or D2 is a concept expression in
ALE. As entailment between ALE expressions is decidable in nondeterministic polynomial
time (cf. Donini, Lenzerini, Nardi, Hollunder, Nutt, & Marchetti Spaccamela, 1992), it
follows that deciding entailment between terms with respect to either D1 or D2 can also
be accomplished in nondeterministic polynomial time, i.e. these problems belong to NP.
It remains to be shown that these problems are NP-hard. To prove this, we show how
the polynomial-time reduction of Donini (2003) (adapted from the original NP-hardness
proof by Donini et al., 1992) of the NP-complete exact cover (XC) problem (Garey &
101

fiBienvenu

Johnson, 1979) to unsatisfiability in ALE can be modified so as to give a polynomial-time
reduction from XC to entailment between terms with respect to D1 or D2.
The exact cover problem is the following: given a set U = {u1 , ..., un } and a set S =
{S1 , ..., Sm } of subsets of U, determine whether there exists
Sqan exact cover, that is, a subset
{Si1 , ..., Siq } of S such that Sih  Sik =  for h 6= k and k=1 Sik = U. Donini has proven
(2003) that U, S has an exact cover if and only if the formula U ,S pictured in Figure 6 is
unsatisfiable. Notice that U ,S is not a term with respect to either D1 and D2 as it uses
the symbols  and . We would like to find a similar formula which is a term with respect
to our definitions and which is satisfiable if and only if U ,S is. Consider the formula
U ,S = 1,1  ...  1,m   
where i,j and   are defined exactly like i,j and  except that we replace  by a and
 by a. It is easy to verify that U ,S is indeed a term with respect to both D1 and
D2. Moreover, it is not too hard to see that 1,1  ...  1,m |= 32n  if and only if
1,1  ...  1,m |= 32n a and hence that U ,S and U ,S are equisatisfiable. As U, S has an
exact cover if and only if U ,S is unsatisfiable, and U ,S is unsatisfiable just in the case that
U ,S is, it follows that U, S has an exact cover if and only if U ,S is unsatisfiable. Moreover,
U ,S can be produced in linear time from U ,S , so we have a polynomial-time reduction
from XC to unsatisfiability of terms in D1 or D2. But a formula is unsatisfiable just in
the case that it entails the term a  a. So, XC can be polynomially-reduced to entailment
between terms with respect to either D1 or D2, making these problems NP-hard and hence
NP-complete.
In order to show the NP-completeness of clausal entailment, we remark that for both
definitions D1 and D2, the function Nnf transforms negations of clauses into terms and
negations of terms into clauses. This means that we can test whether a clause  entails a
clause  by testing whether the term Nnf ( ) entails the term Nnf (). Likewise, we
can test whether a term  entails another term  by testing whether the clause Nnf ( )
entails the clause Nnf (). As the NNF transformation is polynomial, it follows that
entailment between clauses is exactly as difficult as entailment between terms, so clausal
entailment is NP-complete.
Lemma 6.4 For definition D5, entailment between clauses or terms is Pspace-complete.
Proof. Membership in Pspace is immediate since entailment between arbitrary formulae
in K can be decided in polynomial space. To prove Pspace-hardness, we adapt an existing
proof of Pspace-hardness of K.
Figure 7 presents an encoding of a QBF  = Q1 p1 ...Qm pm  in a K-formula f () that
is used in section 6.7 of (Blackburn et al., 2001) to demonstrate the Pspace-hardness of
K. The formula f () has the property that it is satisfiable just in the case that  is a
QBF-validity. As the formula f () can be generated in polynomial-time from , and the
QBF-validity problem is known to be Pspace-hard, it follows that satisfiability of formulae
in K is Pspace-hard as well.
In Figure 8, we show a modified encoding. We claim the following:
(1) f () and f  () are logically equivalent
102

fiPrime Implicates and Prime Implicants in Modal Logic

(i) q0
Vm
(ii) i=0 ((qi  j6=i qj )  2(qi  j6=i qj )  ...  2m (qi  j6=i qj ))
Vm
(iiia) i=0 ((qi  3qi+1 )  2(qi  3qi+1 )  ...  2m (qi  3qi+1 ))
V
(iiib) {i|Qi =} 2i (qi  (3(qi+1  pi+1 )  3(qi+1  pi+1 )))
V
Vm1 j
(iv) m1
i=1 ( j=i 2 ((pi  2pi )  (pi  2pi )))

(v) 2m (qm  )

Figure 7: The formula f () is the conjunction of the above formulae.
(i) q0
Vm V
(ii) i=0 ( j6=i ((qi  qj )  2(qi  qj )  ...  2m (qi  qj )))
Vm
(iiia) i=0 ((qi  3qi+1 )  2(qi  3qi+1 )  ...  2m (qi  3qi+1 ))
V
(iiib) {i|Qi =} 2i (qi  3(qi+1  pi+1 ))  2i (qi  3(qi+1  pi+1 ))
Vm1 Vm1
(iv) i=1 ( j=i (2j (pi  2pi )  2j (pi  2pi )))

(v) 2m (qm  1 )  ....  2m (qm  l )

Figure 8: The formula f  () is the conjunction of the above formulae, where the formulae
i in (v) are propositional clauses such that   1  ...  l .

(2) if  is in CNF, then f  () is a conjunction of clauses with respect to D5
(3) if  is in CNF, then f  () can be generated in polynomial time from f ()
To show (1), it suffices to show that (i)(i), (ii)(ii), (iiia)(iiia), (iiib)(iiib), (iv)(iv),
and (v)(v). The first equivalence is immediate since (i) and (i) are identical. (ii)(ii)
follows from the fact that 2k (qi  j6=i qj )  j6=i 2k (qi  qj ). (iiia)(iiia) holds
since (iiia) is just (iiia) with qi  3qi+1 replaced with qi  3qi+1 . We have (iiib)(iiib)
since 2i (qi  (3(qi+1  pi+1 )  3(qi+1  pi+1 )))  2i (qi  3(qi+1  pi+1 ))  2i (qi 
3(qi+1  pi+1 )). The equivalence (iv)(iv) holds as 2j ((pi  2pi )  (pi  2pi )) 
2j (pi  2pi )  2j (pi  2pi ). Finally, we have (v)(v) since   1  ...  l . Thus, f ()
and f  () are logically equivalent.
To prove (2), we show that each of the component formulae in f  () is a conjunction
of clauses with respect to D5, provided that  is in CNF. Clearly this is the case for (i)
as (i) is a propositional literal. The formula (ii) is also a conjunction of clauses with
respect to D5 since it is a conjunction formulae of the form 2k (qi  qj ). Similarly,
(iiia), (iiib), and (iv) are all conjunctions of clauses since the formulae 2k (qi  3qi+1 ),
2i (qi  3(qi+1  pi+1 )), 2i (qi  3(qi+1  pi+1 )), 2k (pi  2pi ), and 2k (pi  2pi ) are
all clauses with respect to D5. The formula (v) must also be a conjunction of clauses since
the i are assumed to be propositional clauses, making each 2m (qm  i ) a clause with
respect to D5, and (v) a conjunction of clauses with respect to D5.
103

fiBienvenu

For (3), it is clear that we can transform (i), (iiia), (iiib), and (iv) into (i), (iiia), (iiib),
and (iv) in polynomial time as the transformations involve only simple syntactic operations
and the resulting formulae are at most twice as large. The transformation from (ii) to (ii)
is very slightly more involved, but it is not too hard to see the resulting formula is at most
m times as large as the original (and m can be no greater than the length of f ()). The
only step which could potentially result in an exponential blow-up is the transformation
from (v) to (v), as we put  into CNF. But under the assumption that  is already in CNF,
the transformation can be executed in polynomial time and space, as all we have to do is
separate  into its conjuncts and rewrite the (qm  i ) as (qm  i ).
Now let  = Q1 p1 ...Qm pm  be a QBF such that  = 1  ...  l for some propositional
clauses i . Let f  () be the formula as defined in Figure 8. By (2) above, we know that
f  () = 1  ...  p for some clauses i with respect to D5. Now consider the following
formula
 = 3(21  ...  2p  32(a  a))
We can show that f  () is satisfiable if and only if  is satisfiable as follows:
 is unsatisfiable
 21  ...  2p  32(a  a) is unsatisfiable
 1  ...  p  2(a  a) is unsatisfiable
 1  ...  p is unsatisfiable
 f  () is unsatisfiable
But we also know from (1) above that f  ()  f (), and from (Blackburn et al., 2001)
that f () is satisfiable just in the case that  is a QBF validity. It is also easy to see
that  is satisfiable if and only if  does not entail the contradiction 3(a  a). Putting
this altogether, we find that  is valid just in the case that  does not entail 3(a  a).
As  and 3(a  a) are both clauses and terms with respect to D5, we have shown that
the QBF-validity problem for QBF with propositional formulae in CNF can be reduced to
the problems of entailment of clauses or terms with respect to D5. Moreover, this is a
polynomial time reduction since it follows from (3) that the transformation from  to 
can be accomplished in polynomial time. This suffices to show Pspace-hardness, since it is
well-known that QBF-validity remains Pspace-hard even when we restrict the propositional
part  to be a formula in CNF (cf. Papadimitriou, 1994).
Theorem 6 The results in Figure 1 hold.
Proof. The satisfaction or dissatisfaction of properties P1 and P2 can be immediately
determined by inspection of the definitions, as can the satisfaction of P3 by definitions D2,
D3b, D4, and D5. Counterexamples to P3 for definitions D1 and D3a were provided in
body of the paper: the formula 2(a  b) is a clause but not a disjunction of literals with
respect to both definitions.
In order to show that definition D3b does not satisfy P4, we remark that the negation
of the literal 3(a  b) is equivalent to 2(a  b) which cannot be expressed as a literal
in D3b. For each of the other definitions, it can be shown (by a straightforward inductive
proof) that Nnf (L) is a literal whenever L is a literal, that Nnf (C) is a term whenever
104

fiPrime Implicates and Prime Implicants in Modal Logic

C is a clause, and that Nnf (T ) is a clause whenever T is a term. This is enough to prove
that these definitions satisfy P4 since Nnf () is equivalent to .
Since we know that definitions D1 and D2 satisfy both properties P1 and P2, it follows
by Theorem 5 that these definitions do not satisfy P5. We have seen in Lemma 6.1 that
definition D5 does satisfy P5, i.e. that every formula is equivalent to some conjunction of
clauses with respect to D5 and some disjunction of terms with respect to D5. As every
clause (resp. term) of D5 is also a clause (resp. term) with respect to definitions D3a, D3b,
and D4 (by Lemma 6.2), it follows that every formula is equivalent to some conjunction of
clauses and some disjunction of terms with respect to these definitions, which means they
all satisfy P5.
It is easy to see that property P6 is satisfied by all of the definitions since all of our
definitions are context-free grammars, and it is well-known that deciding membership for
context-free grammars can be accomplished in polynomial time (cf. Younger, 1967).
From Lemma 6.3, we know that deciding entailment between clauses or terms with
respect to either D1 or D2 is NP-complete (and hence not in P, unless P=NP). Entailment
between clauses/terms is Pspace-complete for D5 (Lemma 6.4). As every clause (resp.
term) of D5 is also a clause (resp. term) with respect to definitions D3a, D3b, and D4
(from Lemma 6.2), it follows that entailment between clauses or terms is Pspace-hard for
these definitions. Membership in Pspace is immediate since entailment between arbitary
K formulae is in Pspace.
We prove Theorem 9 in several steps:
Lemma 9.1 The notions of prime implicates and prime implicants induced by D4 satisfy
Implicant-Implicate Duality.
Proof. Suppose for a contradiction that we have a prime implicant  of some formula 
which is not equivalent to the negation of a prime implicate of . Let  be a clause which
is equivalent to  (there must exist such a clause because of property P4, cf. Theorem
6). The clause  is an implicate of  since  |=  and   . As we have assumed that
 is not a prime implicate, there must be some implicate  of  such that  |=  and
 6|=  . But then let  be a term equivalent to  (here again we use P4). Now  must
be an implicant of  since  |=  . Moreover,  is strictly weaker than  since  |= 
and  6|=  and    and    . But this means that  cannot be a prime implicant,
contradicting our earlier assumption. Hence, we can conclude that every prime implicant
of a formula  is equivalent to the negation of some prime implicate of . The proof that
every prime implicate of a formula  is equivalent to the negation of a prime implicant of
 proceeds analogously.
Lemma 9.2 If clauses and terms are defined according to definition D4, then every implicate  of a formula  is entailed by some implicate  of  with var( )  var() and
with depth at most () + 1, and every implicant  of  entails an implicant  of  with
var( )  var() and depth at most () + 1.
Proof. We intend to show that the following statement holds: for any formula  and any
implicate  of , there exists a clause  such that  |=  |=  and var( )  var() and
105

fiBienvenu

()  () + 1. So let  be an arbitrary formula, and let  be some implicate of . If 
is a tautology, then we can set  = a  a (where a  var()). If   , then we can set
 = 3(a  a) (where a  var()), as this clause verifies all of the necessary conditions.
Now we consider the case where neither  nor  is a tautology or a falsehood, and we
show how to construct the clause  . The first thing we do is use Dnf-4 to rewrite  as
a disjunction of satisfiable terms Ti with respect to D4 such that the Ti contain only the
variables appearing in  and have depth at most ():
 = T1  ...  Tz
As  |= , it must be the case that Ti |=  for every Ti . Our aim is to find a clause i for
each of the terms Ti such that Ti |= i |=  and var(i )  var(Ti ) and (i )  (Ti ). So
consider some Ti . Since Ti is a term, it has the form 1  ...  k  31  ...  3m  21 
...  2n , where 1 , ..., k are propositional literals. As  is a clause, it must be of the form
1  ...  p  31  ...  3q  21  ...  2r , where 1 , ..., p are propositional literals. As
Ti |= , it must be the case that the formula
1  ...  k  31  ...  3m  21  ...  2n 
1  ...  p  21  ...  2q  31  ...  3r
is unsatisfiable. By Theorem 1, one of the following must hold:
(a) there exists u and v such that u  v
(b) there exists u such that u  1  ...  n  1  ...  q |= 
(c) there exists u such that u  1  ...  n  1  ...  q |= 
Now if (a) holds, we can set i = u since Ti |= u |= , (u ) = 0  (Ti ), and var(u ) 
var(Ti ). If it is (b) that holds, then it must be the case that
u  1  ...  n |= 1  ...  q
and hence that
3(u  1  ...  n ) |= 31  ...  3q |= 
We can set i = 3(u  1  ...  n ), since Ti |= 3(u  1  ...  n ) |= , (3(u  1 
...  n ))  (Ti ), and var(3(u  1  ...  n ))  var(Ti ). Finally, if (c) holds, then it
must be the case that
1  ...  n |= 1  ...  q  u
and hence that
2(1  ...  n ) |= 31  ...  3q  2u |= 
So we can set i = 2(1  ...  n ), as Ti |= 2(1  ...  n ) |= , (2(1  ...  n ))  (Ti ),
and var(2(1  ...  n ))  var(Ti ). Thus, we have shown that for every Ti , there is some
i such that Ti |= i |=  and var(i )  var(Ti ) and (i )  (Ti ). But then 1  ...  z is
a clause implied by every Ti , and hence by , and such that var(i )  i var(Ti )  var()
and (i )  maxi (Ti )  ().
Now let  be an implicant of , and let  be the formula Nnf (). We know that
the NNF transformation is equivalence-preserving, hence   , and it is straightforward
106

fiPrime Implicates and Prime Implicants in Modal Logic

to show that  must be a clause with respect to D4. But then  is an implicate of ,
so there must be some clause  with var( )  var() = var() and depth at most
() + 1 = () + 1 such that  |=  |= . Let  be Nnf ( ). It can be easily verified
that  is a term. Moreover, by properties of the NNF transformation, we have    ,
var( ) = var( ) = var( ), and ( ) = ( ) = ( ). But then  is a term such that
var( )  var(), ( )  () + 1, and  |=  |= .
Lemma 9.3 The notions of prime implicates and prime implicants induced by D4 satisfy
Finiteness.
Proof. Consider an arbitrary formula . From Lemma 9.2, we know that for each prime
implicate  of , there must be an implicate  of  containing only those propositional
atoms appearing in  and such that ( )  () + 1 and  |= . But since  is a prime
implicate, we must also have  |=  and hence    . Thus, every prime implicate of
 is equivalent to some clause built from the finite set of propositional symbols in  and
having depth at most () + 1. As there are only finitely many non-equivalent formulae
on a finite alphabet and with fixed depth, it follows that there can be only finitely many
distinct prime implicates. By Lemma 9.1, every prime implicant of  is equivalent to the
negation of some prime implicate of . It follows then that every formula can only have
finitely many distinct prime implicants.
Lemma 9.4 The notions of prime implicates and prime implicants induced by D4 satisfy
Covering.
Proof. Let  be an arbitrary formula. From Lemma 9.2, we know that every implicate of
 is entailed by some implicate of  whose propositional variables are contained in var()
and whose depth is at most () + 1. Now consider the following set
 = { |  |= ,  is a clause, var()  var(), ()  () + 1}
and define another set  from  as follows:
 = {   | 6    .   |=  and  6|=   }
In other words,  is the set of all of the logically strongest implicates of  having depth at
most () + 1 and built from the propositional letters in . We claim the following:
(1) every    is a prime implicate of 
(2) for every implicate  of , there is some    such that  |= 
We begin by proving (1). Suppose that (1) does not hold, that is, that there is some   
which is not a prime implicate of . Since  is by definition an implicate of , it follows that
there must be some implicate  of  such that  |=  and  6|= . But by Lemma 9.2, there
is some implicate  of  such that ( )  () + 1, var( )  var(), and  |= . But
that means that  is an element of  which implies but is not implied by , contradicting
the assumption that  is in . We can thus conclude that every element of  must be a
prime implicate of .
107

fiBienvenu

For (2): let  be some implicate of . Then by Lemma 9.2, there exists some clause
   such that  |= . If   , we are done. Otherwise, there must exist some   
such that  |=  and  6|= . If   , we are done, otherwise, we find another stronger
member of . But as  has finitely many elements modulo equivalence, after a finite number
of steps, we will find some element which is in  and which implies . Since we have just
seen that all members of  are prime implicates of , it follows that every implicate of  is
implied by some prime implicate of .
For the second part of Covering, let  be an implicant of , and let  be a clause
equivalent to  (there must be one because D4 satisfies P4). Now since  |= , we must
also have  |= . According to what we have just shown, there must be some prime
implicate  of  such that  |=  |= . By Lemma 9.1,  must be equivalent to the
negation of some prime implicant  of . But since    and  |=  and   , it
follows that  |= , completing the proof.
Lemma 9.5 The notions of prime implicates and prime implicants induced by D4 satisfy
Equivalence.
Proof. Let  be some formula in K, and suppose that M is a model of every prime implicate
of . As D4 is known to satisfy property P5 (by Theorem 6), we can find a conjunction of
clauses which is equivalent to . By Covering (Lemma 9.3), each of these clauses is implied
by some prime implicate of , so M must be a model of each of these clauses. It follows
that M is a model of . For the other direction, we simply note that by the definition of
prime implicates if M is a model of , then it must also be a model of every prime implicate
of . We have thus shown that M is a model of  if and only if it is a model of every prime
implicate of . Using a similar argument, we can show that M is a model of  if and only
if it is a model of some prime implicant of .
Lemma 9.6 The notions of prime implicates and prime implicants induced by D4 satisfy
Distribution.
Proof. Let  be a prime implicate of 1  ...  n . Now for each i , we must have i |= .
From Covering, we know that there must exist some prime implicate i for each i such
that i |= . This means that the formula 1  ...  n (which is a clause because it is a
disjunction of clauses) entails . But since  is a prime implicate, it must also be the case
that  |= 1  ...  n , and hence   1  ...  n . The proof for prime implicants is entirely
similar.
Theorem 9 The notions of prime implicates and prime implicants induced by definition
D4 satisfy Finiteness, Covering, Equivalence, Implicant-Implicate Duality, and
Distribution.
Proof. Follows directly from Lemmas 9.1-9.6.
Theorem 10 The notions of prime implicates and prime implicants induced by definitions
D1 and D2 do not satisfy Equivalence.
108

fiPrime Implicates and Prime Implicants in Modal Logic

Proof. The proof is the same for both definitions. Suppose that Equivalence holds. Then
for every formula , the set  of prime implicates of  is equivalent to . But this means
that the set   {} is inconsistent, and hence by compactness of K (cf. Blackburn et al.,
2001, p. 86) that there is some finite subset S    {} which is inconsistent. If  6 ,
then we know that the set S must contain  because the set of prime implicates of 
cannot be inconsistent. But then the conjunction of elements in S \ {} is a conjunction
of clauses which is equivalent to . It follows that every formula  is equivalent to some
conjunction of clauses. As we have shown earlier in the proof of Theorem 5 that there are
formulae which are not equivalent to a conjunction of clauses with respect to D1 or D2, it
follows that Equivalence cannot hold for these definitions.
Theorem 11 The notions of prime implicates and prime implicants induced by definitions
D3a, D3b, and D5 do not satisfy Finiteness.
Proof. Suppose that clauses are defined with respect to definition D3a, D3b, or D5 (the
proof is the same for all three definitions). Consider the formula  = 2(a  b). It follows
from Theorem 3 that  implies k = 2(3k a)  3(a  b  2k a) for every k  1. As the
formulae k are clauses (with respect to D3a, D3b, and D5), the k are all implicates
of . To complete the proof, we show that every k is a prime implicate of . Since the k
are mutually non-equivalent (because 2p a 6|= 2q a whenever p 6= q), it follows that  has
infinitely many prime implicates modulo equivalence.
Consider some k and some implicate  = 31  ...  3m  21  ...  2n of  that
implies it (by Theorem 2 there cannot be any propositional literals in ). Using Theorem 3
and the fact that  |=  |= k , we get the following:
(a) a  b |= i  i  ...  m for some i
(b) i |= (3k a)  (a  b  2k a) for every i
(c) 1  ...  m |= a  b  2k a
Let i be such that a  b |= i  i  ...  m . We remark that i must be satisfiable since
otherwise we can combine (a) and (c) to get a  b |= a  b  2k a. Now by (b), we know that
i |= (3k a)  (a  b  2k a) and hence that i  (2k a)  (a  b  3ka) is inconsistent. It
follows that both i  (2k a)  a and i  (2k a)  b are inconsistent. Using Theorem 1,
we find that either i |= 3k a or i |= a  b. As i is a satisfiable clause with respect to
definitions D3a, D3b, and D5, it cannot imply a  b, so we must have i |= 3k a. By
putting (a) and (c) together, we find that
a  b  i |= 1  ...  m |= a  b  2k a
It follows that i |= 2k a, i.e. 3k a |= i . We thus have i  3k a and 1  ...  m 
a  b  2k a. As 3k a |= i and a  b  2k a |= 1  ...  m , by Theorem 3 we get
2(3k a)  3(a  b  2k a) |= 2i  3i  ...  3m |=  and hence k  . We have thus
shown that any implicate of  which implies k must be equivalent to k . This means that
each k is a prime implicate of , completing the proof.
109

fiBienvenu

Lemmas 12, 13, and 14 follow easily from known properties of the disjunctive normal
form transformation in propositional logic (cf. Bienvenu, 2009, ch. 2).
In the proof of Theorem 16, we will make use of the following lemmas:
Lemma 16.1 The algorithm GenPI always terminates.
Proof. We know from Lemma 12 that the algorithm Dnf -4 always terminates and returns
a finite set of formulae. This means that there are only finitely many terms T to consider.
For each T , the set (T ) contains only finitely many elements (this is immediate given
the definition of (T )), which means that the set Candidates also has finite cardinality.
In the final step, we compare at most once each pair of elements in Candidates. As the
comparison always terminates, and there are only finitely many pairs to check, it follows
that the algorithm GenPI terminates.
Lemma 16.2 The algorithm GenPI outputs exactly the set of prime implicates of the input
formula.
Proof. We first prove that every prime implicate of a satisfiable term T is equivalent to
some element in (T ). Let T = 1  ...  k  31  ...  3m  21  ...  2n be some
satisfiable term, and let  = 1  ...  p  31  ...  3q  21  ...  2r be one of its
prime implicates. We restrict our attention to the interesting case in which both T and 
are non-tautologous. As T |= , it must be the case that
1  ...  k  31  ...  3m  21  ...  2n 
1  ...  p  21  ...  2q  31  ...  3r
is unsatisfiable. By Theorem 1, one of the following must hold:
(a) there exists u and v such that u  v
(b) there exists u such that u  1  ...  n |= 1  ...  q
(c) there exists u such that 1  ...  n |= u  1  ...  q
If (a) holds, then u |= , so  must be equivalent to u or else we would have found a
stronger implicate, contradicting our assumption that  is a prime implicate of T . But then
the result holds since u is in (T ). If (b) holds, then the formula 3(u  1  ...  n )
is an implicate of T which implies , so   3(u  1  ...  n ). We are done since
3(u  1  ...  r ) is a member of (T ). Finally we consider the case where (c) holds. In
this case, 2(1  ...  n ) is an implicate of T which implies , and so is equivalent to  (as
 is a prime implicate). But then we have the desired result since 2(1  ...  n ) is one
of the elements in (T ). Thus we can conclude that every prime implicate of a term T is
equivalent to some element in (T ). By Lemma 13, the elements in Dnf -4() are terms,
and their disjunction is equivalent to . As D4 satisfies Distribution, it follows that every
prime implicate of the input  is equivalent to some element in Candidates. This means
that if an element i in Candidates is not a prime implicate of , then there is some prime
implicate  of  that implies but is not implied by i , and hence some j  Candidates
such that j |= i and i 6|= j . Thus, during the comparison phase, this clause will be
removed from Candidates. Now suppose that the clause  is a prime implicate of . Then
110

fiPrime Implicates and Prime Implicants in Modal Logic

we know that there must be some i  Candidates such that i  , and moreover, we
can choose i so that there is no j with j < i such that j |= i . When in the final step we
compare i with all the clauses j with j 6= i, we will never find that j |= i for j < i, nor
that j |= i 6|= j for some j > i, otherwise  would not be a prime implicate. It follows
then that i remains in the set Candidates which is returned by the algorithm. We have
thus shown that the set of formulae output by GenPI on input  is precisely the set of
prime implicates of .
Theorem 16 The algorithm GenPI always terminates and outputs exactly the set of prime
implicates of the input formula.
Proof. Follows directly from Lemmas 16.1 and 16.2.
Theorem 17 The length of the smallest clausal representation of a prime implicate of a
formula is at most single exponential in the length of the formula.
Proof. Prime implicates generated by GenPI can have at most 2|| disjuncts as there are
at most 2|| terms in Dnf -4() by Lemma 14. Moreover, each disjunct has length at most
2|| (also by Lemma 14). This gives us a total of 2||  2|| symbols, to which we must
add the at most 2||  1 disjunction symbols connecting the disjuncts. We thus find that
the length of the smallest representation of a prime implicate of a formula  is at most
2||  2|| + (2||  1).
Theorem 18 The length of the smallest clausal representation of a prime implicate of a
formula can be exponential in the length of the formula.
Proof. Consider the formula
=

n
^

(2ai,1  2ai,2 )

i=1

and the clause
=

_

(j1 ,...,jn

2(a1,j1  a2,j2  ...  an,jn )

){1,2}n

where ak,l 6= am,p whenever k 6= m or l 6= p. It is not difficult to see that  and  are
equivalent, which means that  must be a prime implicate of . All that remains to be
shown is that any clause equivalent to  must have length at least ||. This yields the result
since  clearly has size exponential in n, whereas the length of  is only linear in n.
Let  be a shortest clause which is equivalent to . As  is equivalent to , it follows
from Theorem 2 that  is a disjunction of 2-literals and of inconsistent 3-literals. But
since  is assumed to be a shortest representation of , it cannot contain any inconsistent
3-literals or any redundant 2-literals, since we could remove them to find an equivalent
shorter clause. So  must be of the form 21  ...  2m , where l 6|= k whenever l 6= k.
Now since  |= , every disjunct 2p must also imply . As  is a disjunction of 2-literals,
it follows from Theorem 3 that every disjunct 2p of  implies some disjunct 2q of . But
that means that every 2p must have length at least 2n + 1, since each p is a satisfiable
formula which implies a conjunction of n distinct propositional variables. We also know
that every disjunct 2q of  implies some disjunct 2p of  since  |=  . We now wish
111

fiBienvenu

to show that no two disjuncts of  imply the same disjunct of  . Suppose that this is not
the case, that is, that there are distinct disjuncts 21 and 22 of  and some disjunct 2p
of  such that 21 |= 2p and 22 |= 2p . Now since 21 and 22 are distinct disjuncts,
there must be some i such that 21 |= ai,1 and 22 |= ai,2 or 21 |= ai,2 and 22 |= ai,1 .
We know that 2p |= 2q for some q , and that every q implies either ai1 or ai2 , so either
2p |= 2ai1 or 2p |= 2ai2 . But we know that the 2q each imply either 2ai,1 or 2ai,2
but not both, so one of 21 and 22 must not imply 2p . This contradicts our earlier
assumption that 21 |= 2p and 22 |= 2p , so each disjunct of  must imply a distinct
disjunct of  . We have thus demonstrated that  contains just as many disjuncts as .
As we have already shown that the disjuncts of  are no shorter than the disjuncts of , it
follows that | |  ||, and hence | | = ||. We conclude that every clause equivalent to 
has length at least ||, completing the proof.
For Theorem 19, we will prove that the following clause
_
=
2q1 ...qn c
(q1 ,...,qn){3,2}n

is a prime implicate (with respect to both D1 and D2) of the formula


=

( 23(b0  b1 )  22(b0  b1 ) ) 

n
^

( 2i 3bi  2i 2bi )

i=2



n1
^

2i+1 ( (bi1  bi )  2bi )  2n+1 ( (bn1  bn )  c )

i=1

and moreover that there is no shorter way to represent .
The proof of Theorem 19 makes use of the following lemmas.
Lemma 19.1 Let l1  ...  lm be a D1-clause which implies q1 ...qn a, where qi  {2, 3} and
a is a propositional variable. Then l1  ...  lm  q1 ...qn a.
Proof. In the proof, we will make use of the fact that every D1-clause is satisfiable. This
is very straightforwardly shown by structural induction. The base case is propositional
literals, which are clearly satisfiable. For the induction step, we consider a D1-clause 
such that all its proper sub-clauses are satisfiable. There are three possibilities: either 
is of the form 2  or 3  where  is a satisfiable D1-clause, or a disjunction 1  2 of
satisfiable D1-clauses 1 and 2 . In all three cases, we find that  must also be satisfiable.
The proof of the lemma is by induction on n. When n = 0, we have just l1  ...  lm |= a.
According to Theorem 2, every disjunct of l1  ...  lm must be either a or some unsatisfiable
formula. But we have shown in the previous paragraph that every D1-clause is satisfiable,
so l1  ...  lm  a.
Now suppose the result holds whenever n  k, and suppose that we have l1  ...  lm |=
q1 ...qk+1 a. For every li , we must have li |= q1 ...qk+1 a, and hence |= li  q1 ...qk+1 a. Using
Theorem 1, we arrive at the following four possibilities:
112

fiPrime Implicates and Prime Implicants in Modal Logic

(a) |= q1 ...qk+1 a
(b) li  
(c) q1 = 3 and li  3li and li |= q2 ...qk+1 a
(d) q1 = 2 and li  2li and li |= q2 ...qk+1 a
We can eliminate case (a) since 6|= q1 ...qk+1 a for every string of modalities q1 ...qk+1 . We can
also eliminate (b) since all of the li must be satisfiable as they are D1-clauses. We remark
that if (c) holds, then according to the induction hypothesis, li  3q2 ...qk+1 a. Similarly, if
(d) holds, then li  2q2 ...qk+1 a. It follows then that each li is equivalent to q1 ...qk+1 a, and
so l1  ...  lm  q1 ...qk+1 a.
V
n , and let T = 2q (b  b )  ( n
k
Lemma
19.2
Fix
(q
,
...,
q
)

{2,
3}
1
n
1
0
1
k=2 2 qk bk ) 
Vn1 k+1
( (bk1  bk )  2bk )  2n+1 ( (bn1  bn )  c ). Then T |= 2r1 ...rn c if and
k=1 2
only if rk = qk for all 1  k  n.
Proof. We begin by showing that for all 1  i  n  1 the formula
bi1  bi  (

n
^

n1
^

2ki1 qk bk )  (

k=i+1

2ki ((bk1  bk )  2 bk ) )  2ni ((bn1  bn )  c)

k=i

entails the formula ri+1 ...rn c just in the case that qi+1 ...qn = ri+1 ...rn .
The proof is by induction on i. The base case is i = n  1. We have
bn2  bn1  qn bn  ((bn2  bn1 )  2bn1 )  2((bn1  bn )  c) |= rn c

(1)

if and only if
bn2  bn1  qn bn  2bn1  2((bn1  bn )  c) |= rn c
if and only if (Theorem 1) either
qn = 3 and rn = 2 and bn1  ((bn1  bn )  c) |= c
or
qn = rn and bn1  bn  ((bn1  bn )  c) |= c
As bn1  ((bn1  bn )  c) 6|= c, we cannot have the first alternative. It follows then that
if Equation (1) holds, then the second alternative must hold, in which case we get qn = rn ,
as desired. For the other direction, we simply note that bn1  bn  ((bn1  bn )  c) |= c
is a valid entailment, which means qn = rn implies Equation (1).
Next let us suppose that the above statement holds for all 1 < j  i  n  1, and let us
prove the statement holds when i = j  1. Then
bj2  bj1  (

n
^

kj

2

qk bk )  (

k=j

n1
^

2kj+1 (bk1  bk  2bk ) )

k=j1

 2nj+1 ((bn1  bn )  c)

|= rj ...rn c
113

(2)

fiBienvenu

if and only if one of the following holds:
(a) qj = 3 and rj = 2 and
bj1  (

n
^

n1
^

2kj1 qk bk )  (

k=j+1

2kj ((bk1  bk )  2bk ) )  2nj ((bn1  bn )  c)

k=j

|= rj+1 ...rn c

(b) qj = rj and
bj1  bj  (

n
^

n1
^

2kj1 qk bk )  (

k=j+1

2kj ((bk1  bk )  2bk ))  2nj ((bn1  bn )  c)

k=j

|= rj+1 ...rn c

We will first show that the entailment in (a) does not hold. Consider the model M =
hW, R, vi defined as follows:
 W = {wj , ..., wn }
 R = {(wj , wj+1 ), ..., (wn1 , wn )}
 v(c, w) = f alse for all w  W
 for w 6= wj : v(bk , w) = true if and only if w = wk
 v(bk , wj ) = true if and only if k = j  1
Notice that since each world (excepting wn ) has exactly one successor, the 2- and 3quantifiers have the same behaviour (except at wn ). It can easily be verified that M, wj
satisfies the left-hand side of the aboveV
entailment for any tuple qj+1 ...qn : we have M, wj |=
bj1 by definition, we have M, wj |= nk=j+1 2kj1 qk bk because M, wk |= bk for k 6= j,
Vn1 kj
we have M, wj |= k=j
2 ((bk1  bk )  2bk ) ) since M, wj 6|= bj and M, wk 6|= bk1 for
k 6= j, and finally we have M, wj |= 2nj ((bn1  bn )  c) since wn 6|= bn1 . However, the
right-hand side rj+1 ...rn c is not satisfied at wj : the only world accessible from wj in n  j
steps is wn which does not satisfy c.
We have just shown that case (a) cannot hold, which means that Equation (2) holds if
and only if (b) does. But if we apply the induction hypothesis to the entailment in (b), we
find that it holds just in the case that qj+1 ...qn = rj+1 ...rn . It follows then that Equation (2)
if and only if qj ...qn = rj ...rn , as desired. This completes our proof of the above statement.
We now proceed to the proof of the lemma. By Theorem 1,
2q1 (b0  b1 )  (

n
^

n1
^

2k qk bk )  (

k=2

2k+1 ( (bk1  bk )  2bk )  2n+1 ( (bn1  bn )  c )

k=1

|= 2r1 ...rn c

holds just in the case that
q1 (b0  b1 )  (

n
^

k=2

2k1 qk bk ) 

n1
^

2k ( (bk1  bk )  2bk )  2n ( (bn1  bn )  c )

k=1

|= r1 ...rn c
114

fiPrime Implicates and Prime Implicants in Modal Logic

which in turn holds if and only if one of the following statements holds:
(i) q1 = 3 and r1 = 2 and
(

n
^

n1
^

2k2 qk bk )  (

k=2

2k1 ((bk1  bk )  2bk ) )  2n1 ((bn1  bn )  c) |= r2 ...rn c

k=1

(ii) q1 = r1 and
b0  b1  (

n
^

k=2

n1
^

2k2 qk bk )  (

2k1 ((bk1  bk )  2bk ) )  2n1 ((bn1  bn )  c)

k=1

|= r2 ...rn c

We remark that if we set j = 1 in (a) above, then the left-hand side of the entailment in (i)
is logically weaker than that in (a), and the right-hand side matches that in (a). As we have
already shown that the entailment in (a) does not hold, it follows that the entailment in
(i) cannot hold either. Thus, we find that the desired entailment relation in the statement
of the lemma holds if and only if (ii) does. This completes the proof since we have already
shown in the induction above that the entailment in (ii) holds if and only if q2 ...qn = r2 ...rn ,
i.e. (ii) is true just in the case that q1 ...qn = r1 = rn .
Lemma 19.3 There is no D1-clause equivalent to  and with strictly smaller size than .
Proof. Let  be a D1-clause which is equivalent to . Suppose furthermore that  is a
shortest such clause. As  is non-tautologous and contains only 2-literals as disjuncts, it
follows that every disjunct of  must be either unsatisfiable or a 2-literal (cf. Theorem 2).
But D1-clauses are always satisfiable (cf. proof of Lemma 19.1), so  must contain only
2-literals.
Since  |= , every disjunct 2l of  must imply some disjunct 2q1 ...qn c of . Also,
every disjunct 2l of  must be implied by some disjunct 2q1 ...qn c of , since otherwise we
could remove 2l from  while preserving the equivalence between  and  .
It follows then that each disjunct of  is implied by some disjunct of  and implies
some disjunct of . But since the disjuncts of  do not imply each other (because of Lemma
19.1), it follows that each disjunct of  is equivalent to some disjunct of , and moreover
that every disjunct of  is equivalent to some disjunct of  .
This completes the proof since it is clear that the disjuncts 2q1 ...qn c of  cannot be
more compactly represented.
Our proof works equally well for D2, since every D2-clause is also a D1-clause.
Theorem 19 If prime implicates are defined using either D1 or D2, then the length of
the smallest clausal representation of a prime implicate of a formula can be exponential in
the length of the formula.
Proof. We begin with definition D1. Let  and  be as defined on page 112. We begin by
distributing  over  in order to transform  into an equivalent disjunction of D4-terms:
_

Tq1 ,...,qn
(q1 ,...,qn){2,3}n

115

fiBienvenu

where Tq1 ,...,qn is equal to
2q1 (b0  b1 )  (

n
^

2 i q i bi ) 

n1
^

2i+1 ( (bi1  bi )  2bi )  2n+1 ( (bn1  bn )  c )

i=1

i=2

By Lemma 19.2, Tq1 ,...,qn |= 2q1 ...qn c, and hence Tq1 ,...,qn |= . We thus have  |= .
We now show that there is no stronger clause with respect to D1 which is implied by
. Let  be a D1-clause such that  |=  |= . As  is a non-tautologous disjunction of
2-literals, we know from Lemma 2 that every disjunct of  must be of the form 2l where
l is a D1-clause such that l |= r1 ...rn c for some quantifier string r1 ...rn . But according to
Lemma 19.1, if l |= r1 ...rn c, then l is equivalent to r1 ...rn c. It follows that  is equivalent
to a clause having only disjuncts of the forms 2r1 ...rn c.
As  |=  , it must be the case that each of the terms Tq1 ,...,qn implies  , or equivalently
Tq1 ,...,qn   |= . As we have shown above that the disjuncts of  are all 2-literals, it
follows from Theorem 1 that each term implies some disjunct of  . Moreover, we know
from the preceding paragraph that each of the disjuncts of  is equivalent to some formula
of the form 2r1 ...rn c. By Lemma 19.2, the only formula of this type which is implied by
Tq1 ,...,qn is the formula 2q1 ...qn c. This means that for every tuple of quantifiers (q1 , ..., qn ),
there is a disjunct of  which is equivalent to 2q1 ...qn c. It follows that every disjunct of
 is equivalent to some disjunct of  , giving us  |=  . We can thus conclude that  is a
prime implicate of .
This completes the proof, since we have already shown in Lemma 19.3 that there is no
shorter D1-clause which is equivalent to  than  itself.
The above proof also works for definition D2 since every D2-clause is also a D1-clause.
In particular this means that any D2-clause which is a prime implicate with respect to D1
is also a prime implicate with respect to D2, and that any D2-clause which is shortest
among all equivalent D1-clauses is also shortest among D2-clauses.
Theorem 20 The number of non-equivalent prime implicates of a formula is at most double
exponential in the length of the formula.
Proof. We know from Theorem 16 that every prime implicateWof  is equivalent to some
clause returned by GenPI. Every such clause is of the form T Dnf -4() T where T 
(T ). As there can be at most 2|| terms in Dnf -4() by Lemma 14, these clauses can have
no more than 2|| disjuncts. Moreover, there are at most 2|| choices for each disjunct T
since the cardinality of (T ) is bounded above by the size of T , which we know from Lemma
||
1.3 to be no more than 2||. It follows then that there are at most (2||)2 clauses returned
||
by GenPI, hence at most (2||)2 non-equivalent prime implicates of .
Theorem 21 The number of non-equivalent prime implicates of a formula may be double
exponential in the length of the formula.
Proof. Let n be some natural number, and let a11 , a12 , ..., an1 , an2 , b11 , b12 , b12 , ..., bn1 ,
bn2 be 4n distinct propositional variables. Consider the formula  defined as
n
^

((3ai1  2bi1 )  (3ai2  2bi2 ))

i=1

116

fiPrime Implicates and Prime Implicants in Modal Logic

It is not hard to see that there will be 2n terms in Dnf -4(), corresponding to the 2n ways
of deciding for each i  {1, ..., n} whether to take the first or second disjunct. Each term
T  Dnf -4() will be of the form
n
^

(3ai f (i,T )  2bi f (i,T ) )

i=1

where f (i, T )  {1, 2} for all i. For each T , denote by D(T ) the set of formulae {3(a f (i,T ) 
b1 f (1,T )  ...  bn f (n,T ) )) | 1  i  n}. Now consider the set of clauses C defined as
{

_

dT | dT  D(T )}

T Dnf -4()
n

Notice that there are n2 clauses in C since each clause corresponds to a choice of one of
the n elements in D(T ) for each of the 2n terms T in Dnf -4(). This number is double
exponential in || since the length of  is linear in n. In order to complete the proof, we
show that (i) all of the clauses in C are prime implicates of  and (ii) that the clauses in C
are mutually non-equivalent.
We begin by showing that 1 6|= 2 for every pair of distinct elements 1 and 2 in C.
This immediately gives us (ii) and will prove useful in the proof of (i). Let 1 and 2 be
distinct clauses in C. As 1 and 2 are distinct, there must be some term T  Dnf -4()
for which 1 and 2 choose different elements from D(T ). Let d1 be the element from
D(T ) appearing as a disjunct in 1 , let d2 be the element in D(T ) which is a disjunct in
2 , and let aj,k be the a-literal which appears in d2 (and hence not in d1 ). Consider the
formula  = 2(aj,k  b1,k1  ...  bn,kn ), where the tuple (k1 , ..., kn ) is just like the tuple
associated with T except that the 1s and 2s are inversed. Clearly d1   is consistent,
since the variables in  do not appear in d1 . But  is inconsistent with every disjunct in
2 , since by construction every disjunct in 2 contains a literal whose negation appears in
. It follows that 2 |=  but 1 6|= , and hence 1 6|= 2 .
We now prove (i). Let  be a clause in C, and let  be a prime implicate of  which
implies . By Theorem 16, we know that  must be equivalent to one of the clauses output
by GenPI, and more specifically to a clause output by GenPI which is a disjunction of
3-literals (because of Theorem 2). We remark that the set C is composed of exactly those
candidate clauses which are disjunctions of 3-literals, so  must be equivalent to some
clause in C. But we have just shown that the only element in C which implies  is  itself.
It follows that   , which means that  is a prime implicate of .
Theorem 22 If prime implicates are defined using either D1 or D2, then the number of
non-equivalent prime implicates of a formula may be double exponential in the length of the
formula.
Proof. Let  and  be as defined on page 112. Set  equal to the formula obtained from 
by replacing c in the last conjunct of  by c  d. Set  equal to the set of clauses that can
be obtained from  by replacing zero or more occurrences of c by d. For example, if n = 1,
n
then  = {23c  22c, 23d  22c, 23c  22d, 23d  22d}. There are 22 elements in
 since we choose for each of the 2n disjuncts of  whether to change c into d. We intend
117

fiBienvenu

to show that the clauses in  are all pairwise non-equivalent prime implicates of  . The
proof that every element in  is indeed a prime implicate of  (with respect to both D1
and D2) proceeds quite similarly to the proof that  is a prime implicate of  (see proof
of Theorem 19), so we will not repeat it here. Instead we will show that all of the elements
in  are pairwise non-equivalent. To do so, we consider any two distinct elements  and 
of . Since  and  are distinct, there must be some string of quantifiers q1 ...qn such that
 has a disjunct 2q1 ...qn  (  {c, d}) which is not a disjunct of . Now if  |= , then we
would have 2q1 ...qn  |= , and hence 2q1 ...qn  |= 2r1 ...rn  for some disjunct r1 ...rn  of .
But by using Lemma 19.1, we see that this can only happen if r1 ...rn = q1 ...qn and  =  ,
i.e. if 2q1 ...qn is a disjunct of . This is a contradiction, so we must have  6|= . It follows
that the elements of  are pairwise non-equivalent, and hence that  possesses a double
exponential number of prime implicates.
Theorem 23 There exists an algorithm which runs in single-exponential space in the size
of the input and incrementally outputs, without duplicates, the set of prime implicates of
the input formula.
Proof. Let the sets T and Candidates and the function  be defined as in Figure 3.
We assume that T is ordered: T = {T1 , ..., Tn }. For each Ti  T , we let max i denote
the number of elements in (Ti ), and we assume an ordering on the elements of (Ti ):
(Ti ) = {i,1 , ..., i,max i }. Notice that the tuples in {1, .., max 1 }  ...  {1, ..., max n } can be
ordered using the standard lexicographic ordering <lex : (a1 , ..., an ) <lex (b1 , ..., bn ) if and
only if there is some 1  j  n such that aj < bj and ak  bk for all 1  k  j  1. Now
set maxindex = ni=1 maxi , and let f : {1, .., max 1 }  ...  {1, ..., max n }  {1, ..., maxindex }
be the bijection defined as follows: f (a1 , ..., an ) = m if and only if (a1 , ..., an ) is the m-th
tuple in the lexicographic ordering of {1, .., max 1 }  ...  {1, ..., max n }. We will denote by
m the unique clause of form 1,a1  ...  n,an such that f (a1 , ..., an ) = m. We remark
that given an index m  {1, ..., maxindex } and the sets (T1 ), ..., (Tn ), it is possible to
generate in polynomial space (in the size of the sets (T1 ), ..., (Tn )) the clause m . We
make use of this fact in our modified version of algorithm GenPI, which is defined as follows:
Function IterGenPI()
(1) Same as in GenPI.
(2) Same as in GenPI.
(3) For i = 1 to maxindex : if j 6|= i for all j < i and either j 6|= i or i |= j
for every i < j  maxindex , then output i .
The proofs of termination, correctness, and completeness of IterGenPI are very similar to corresponding results for GenPI (Theorem 16), so we will omit the details. We
will instead focus on the spatial complexity of IterGenPI. The first step of IterGenPI
clearly runs in single-exponential space in ||, since deciding the satisfiability of  takes
only polynomial space in ||, and generating the elements in Dnf -4() takes at most
single-exponential space in || (refer to Lemma 14). Step 2 also uses no more than singleexponential space in ||, since each of the sets (T ) associated with a term Ti  T has
polynomial size in Ti . Finally, for Step 3, we use the above observation that the generation of a given i from its index i can be done in polynomial space in the size of the sets
118

fiPrime Implicates and Prime Implicants in Modal Logic

(T1 ), ..., (Tn ), and hence in single-exponential space in ||. This is sufficient since for
the comparisons in Step 3, we only need to keep two candidate clauses in memory at any
one time, and deciding whether one candidate clause entails another can be accomplished
in single-exponential space (since both clauses have single-exponential size in ||).
Theorem 24 Prime implicate recognition is Pspace-hard.
Proof. The reduction is simple: a formula  is unsatisfiable if and only if 3(a  a) is a
prime implicate of . This suffices as the problem of checking the unsatisfiability of formulae
in K is known to be Pspace-complete.
We will need the following two lemmas for Theorem 25:
Lemma 25.1 Let  be a formula from K, and let  = 1  ...  k  31  ...  3m 
21  ...  2n (j propositional literals) be a non-tautologous clause. Suppose furthermore
that there is no literal l in  such that    \ {l}. If   (), then 1  ...  k 
(  ( \ {1 , ..., k })) and 3(1  ...  n )  (  ( \ {31 , ..., 3m })) and for every
i, 2(i  1  ...  m )  (  ( \ {2i })).
Proof. We will prove the contrapositive: if 1  ...  k 6 (  ( \ {1 , ..., k })) or
3(1  ...  n ) 6 (  ( \ {31 , ..., 3m })) or there is some i for which 2(i  1 
...  m ) 6 (  ( \ {2i })), then  6 (). We will only consider the case where
 |=  because if  6|=  then we immediately get  6 ().
Let us first suppose that 1 ...k 6 ((\{1 , ..., k })). Since  |= , we must also
have (\{1 , ..., k }) |= 1 ...k , so 1 ...k is an implicate of (\{1 , ..., k }).
As 1  ...  k is known not to be a prime implicate of   ( \ {1 , ..., k }), it follows that
there must be some clause  such that   ( \ {1 , ..., k }) |=  |= 1  ...  k 6|=  . Now
consider the clause  =   31  ...  3m  21  ...  2n . We know that  |=  since
  ( \ {1 , ..., k }) |=  , and that  |=  because  |= 1  ...  k . We also have  6|= 
since  must be equivalent to a propositional clause (by Theorem 2) and the propositional
part of  (namely 1  ...  k ) does not imply  . It follows then that  |=  |=  6|=  ,
so  6 ().
Next suppose that 3(1  ...  n ) 6 (  ( \ {31 , ..., 3m })). Now 3(1  ...  n )
must be an implicate of   ( \ {31 , ..., 3m }) since we have assumed that  |= .
As 3(1  ...  n ) is not a prime implicate of   ( \ {31 , ..., 3m }), it follows that
there is some  such that   ( \ {31 , ..., 3m }) |=  |= 3(1  ...  n ) 6|=  . Let
 = 1 ...k  21 ...2n . Because of Theorem 2, we know that  is a disjunction
of 3-literals, so according to Theorem 3 we must have  6|=  since 3(1  ...  n ) 6|=  .
We also know that  |=  since   ( \ {31 , ..., 3m }) |=  and that  |=  since
 |= 3(1  ...  n ). That means that  |=  |=  6|=  , so  6 ().
Finally consider the case where there is some i for which 2(i  1  ...  m ) 6
(  ( \ {2i })). We know that  |=  and hence that   ( \ {2i }) |= 2i .
Moreover, since ( \ {2i }) |= 3j for all j, we have   ( \ {2i }) |= 2(i 
1  ...  m ). Thus, if 2(i  1  ...  m ) 6 (  ( \ {2i })), it must mean
that there is some  such that   ( \ {2i }) |=  |= 2(i  1  ...  m ) 6|=  .
By assumption,  is not a tautology, so 2(i  1  ...  m ) cannot be a tautology
119

fiBienvenu

either. As  |= 2(i  1  ...  m ) and 2(i  1  ...  m ) is not a tautology,
it follows from Theorem 2 that  is equivalent to some formula 21  ...  2p . Let
 = 1  ...  k  31  ...  3m  21  ...  2i1  (21  ...  2p )  2i+1  ...  2n .
As   ( \ {2i }) |= 21  ...  2p , it must be the case that  |=  . Also, we know
that there can be no j such that i |= j  1  ...  m because otherwise we would have
i  1  ...  m |= j and hence 2(i  1  ...  m ) |= 21  ...  2p . Similarly,
there can be no k 6= i such that 2i |= 2(k  1  ...  m ) because this would mean
that    \ {2i }, contradicting our assumption that there are no superfluous disjuncts
in . It follows then by Theorem 3 that  6|=  . Thus,  |=  |=  6|=  , which means
 6 ().
Lemma 25.2 Let  be a formula of K, and let  = 1 ...k 31 ...3m 21 ...2n
(j propositional literals) be a non-tautologous clause. Suppose furthermore that there is no
literal l in  such that    \ {l}. Then if  6 (), either 1  ...  k 6 (  ( \
{1 , ..., k })) or 3(1  ...  m ) 6 (  (1  ...  k  2(1  1  ...  m )  ...  2(n 
1  ...  m ))) or 2(i  1  ...  m ) 6 (  ( \ {2i })) for some i.
Proof. We will only consider the case where  |=  because if  6|=  then we immediately
get the result. Suppose then that  6 () and  |= . By Definition 7, there must be some
 = 1  ...o  31  ...  3p  21  ...  2q such that  |=  |=  6|=  . Since  6|=  ,
by Proposition 3 we know that either 1  ...  k 6|= 1  ...  o or 1  ...  m 6|= 1  ...  p
or there is some i for which i 6|= j  1  ...  p for all j.
We begin with the case where 1  ...  k 6|= 1  ...  o . As  |= , by Theorem 3,
1 ...p |= 1 ...m and for every i there is some j such that i |= 1 ...m j . It
follows then (also by Theorem 3) that  |=  |= 1 ...o 31 ...3m 21 ...2n ,
and hence that (\{1 , ..., k }) |= 1 ...o . As 1 ...o |= 1 ...k 6|= 1 ...o ,
we have found an implicate of   ( \ {1 , ..., k }) which is stronger than 1  ...  k , so
1  ...  k 6 (  ( \ {1 , ..., k })).
Next suppose that 1 ...m 6|= 1 ...p . As  |= , it follows from Theorem 3 that

1 ...o |= 1 ...k and that for every i there is some j such that i |= 1 ...m j .
We thereby obtain  |=  |= 1  ...  k  31  ...  3p  2(1  1  ...  m )  ... 
2(n  1  ...  m ). From this, we can infer that   (1  ...  k  2(1  1  ... 
m )  ...  2(n  1  ...  m )) |= 31  ...  3p |= 31  ...  3m 6|= 31  ...  3p .
As 31  ...  3m  3(1  ...  m ), it follows that 3(1  ...  m ) 6 (  (1  ... 
k  2(1  1  ...  m )  ...  2(n  1  ...  m ))).
Finally suppose that i 6|= j  1  ...  p for all j and furthermore that 1  ...  m |=

1  ...  p (we have already shown the result holds when 1  ...  m 6|= 1  ... 
p ). Now 2(i  1  ...  m ) is an implicate of   ( \ {2i })) so to show that
2(i  1  ...  m ) is not a prime implicate of   ( \ {2i })), we must find some
stronger implicate. Consider the set S = {s  {1, ..., q} : s |= i  1  ...  m and s 6|=
k 1 ...m for k 6= i}. We note that there must be at least one element in S as we have
assumed  6|=  \ {2i }. Now since 1  ...  o |= 1  ...  k , 1  ...  p |= 1  ...  m, for
...  m , and s |= s for s  S, we
every s 6 S there is some r 6= i such that sW|= r  1 W

get  |=  W
|= 1 ...k 31 ...3m ( j6=i 2j )( W
sS 2s ). It follows that (\

{2i }) |= sS 2(s 1 ...m ), which means that sS 2(s 1 ...m ) is an
120

fiPrime Implicates and Prime Implicants in Modal Logic

W
implicate of (\{2i }). Moreover, sS 2(s 1 ...m ) |= 2(i 1 ...m )
since by construction s |= i  1  ...  m for every s  S.
W
It remains to be shown that 2(i  1  ...  m ) 6|= sS 2(s  1  ...  m ).
Suppose
for a contradiction that the contrary holds. Then 2(i  1  ...  m ) |=
W

sS 2(s  1  ...  m ), so by Theorem 1, there must be some s  S for which
i  1  ...  m |= s  1  ...  m . But then i |= s  1  ...  m , and thus
i |= s  1  ...  p since we have assumed 1  ...  m |= 1  ...  p . This contradicts
our earlier assumption that W
i 6|= j  1  ...  p for all j. Thus, we have shown that
2(i  1  ...  m ) 6|= sS 2(s  1  ...  m ), so 2(i  1  ...  m ) 6
(  ( \ {2i })).
Theorem 25 Let  be a formula of K, and let  = 1 ...k 31 ...3n 21 ...2m
(j propositional literals) be a non-tautologous clause such that (a) i  i  1  ...  n
for all i, and (b) there is no literal l in  such that    \ {l}. Then   () if and only
if the following conditions hold:
1. 1  ...  k  (  ( \ {1 , ..., k }))
2. 2(i  1  ...  n )  (  ( \ {2i })) for every i
3. 3(1  ...  n )  (  ( \ {31 , ..., 3n }))
Proof. The forward direction was shown in Lemma 25.1. The other direction follows from
Lemma 25.2 together with the hypothesis that i  i  1  ...  n for all i (which
ensures that   (1  ...  k  2(1  1  ...  m )  ...  2(n  1  ...  m )) 
  ( \ {31 , ..., 3n })).
Theorem 26 Let  be a formula of K, and let  be a non-tautologous propositional clause
such that  |=  and such that there is no literal l in  such that    \ {l}. Then   ()
if and only if  6|=  \ {l} for all l in .
Proof. Consider a formula  and a non-tautologous propositional clause  such that  |= 
and such that there is no literal l in  such that    \ {l}. Suppose that  |=  \ {l}
for some l in . As we know that  6  \ {l}, it follows that  \ {l} is an implicate of
 which is strictly stronger than , so  is not a prime implicate of . For the other
direction, suppose that  6 (). Then it must be the case that there is some clause 
such that  |=  |=  6|= . Since  |= , it follows from Theorem 2 that each literal in 
is a propositional literal of  or is inconsistent. If all of the literals in  are inconsistent,
then both  and  must be inconsistent, so clearly  |=  \ {l} for every l in . Otherwise,
 is equivalent to a propositional clause, and more specifically to a propositional clause
containing only those literals appearing in  (since  |= ). As  is strictly stronger than ,
there must be some literal l in  which does not appear in . But that means  |=  \ {l}
and so  |=  \ {l}, completing the proof.
Theorem 27 Let  be a formula of K, and let  = 2 be a non-tautologous clause such
that  |= . Then   () if and only if there exists some term T Dnf-4() such that
 |= T , where T is the conjunction of formulae  such that 2 is in T .
121

fiBienvenu

Proof. Let  be some formula, and let  = 2 be a non-tautologous clause such that  |= .
For the first direction, suppose that there is no term T Dnf -4() such that  |= T , where
T is the conjunction of formulae  such that 2 is in T . There are two cases: either there
are no terms in Dnf -4() because  is unsatisfiable, or there are terms but none satisfy the
condition. In the first case, 2 is not a prime implicate of , since any contradictory
clause
W
(e.g. 3(a  a)) is stronger. In the second case, consider the clause  = T 2T , where
T is the conjunction of formulae  such that 2 is in T . Now for every T we must
W have
2T |= 2, otherwise we would have T 6|= 2, and hence
W  6|= 2. Moreover,  |= T 2T
since T |= 2T for every T . But by Theorem 1, 2 6|= T 2T since  6|= T for all T . So
we have  |=  |=  6|=  , which means that  is not a prime implicate of .
For the other direction, suppose that 2 is not a prime implicate of  and that  6|= .
Then
must have T |= 2 for all T Dnf -4(),
W Dnf -4() is non-empty. As  |= 2, we W
so T 2T also implies 2. We now show
. We let
W that T 2T is a primeWimplicate of W
 be some implicate of  which implies T 2T . Now since  |= T 2T and T 2T is
non-tautologous, it follows from Theorem 2 that   21  ...  2n for some formulae i .
As  |= , we must have T |= 21  ...  2n for all T W
Dnf -4(). But that can only
Wbe the
case if 2T |= 21  ...  2n for all T , which W
means T 2T |= 21  ...  2n . As T 2T
implies every implicate W
of  that implies it, T 2T must be a prime implicate of . But
this means that 2 6|= T 2T , since we have assumed that 2 is not a prime implicate
of . It follows from Theorem 1 that  6|= T for all T Dnf -4().
In order to show Theorem 28 we will need the following lemmas:
Lemma 28.1 If 3 is an implicate of  which is not a prime implicate, the algorithm
Test3PI returns no on input (3, ).
Proof. Suppose that 3 is not a prime implicate of . If  is unsatisfiable, then  must
be satisfiable, so we will return no in the first step. If  is satisfiable, then since we have
assumed that 3 is an implicate of , there must be some clause  such that  |=  |= 3
but 3 6|= . As  |= 3, it follows from Theorem 2 that  is equivalent to a disjunction
of 3-formulae, and hence to some clause 3  .
We know from Lemma 13 that  is equivalent to the disjunction of terms in Dnf -4().
It must thus be the case that Ti |= 3  for all Ti  Dnf -4(). Since each Ti is a satisfiable
conjunction of propositional literals and 2- and 3-formulae, it follows that there exists a set
{3i , 2i,1 , ..., 2i,k(i) } of conjuncts of Ti such that 3(i i,1 ...i,k(i) ) |= 3  , otherwise
Ti would fail to imply 3  . Moreover, all of the elements of {3i , 2i,1 , ..., 2i,k(i) } must
appear in the NNF of  outside modal operators, so the formulae i , i,1 , ..., i,k(i) must all
be elements of the set X . It is immediate that both
3

_
(i  i,1  ...  i,k(i) ) |= 3  |= 3
i

and
3 6|= 3

_

(i  i,1  ...  i,k(i) )

i

122

(3)

fiPrime Implicates and Prime Implicants in Modal Logic

W
The latter implies that the formula 3  (3 i (i  i,1  ...  i,k(i) )) must be consistent,
which means that
_
^
  ( (i  i,1  ...  i,k(i) ))    (i  i,1  ...  i,k(i) )
i

i

must be consistent as well. But then itVmust be the case that we can select for each i some
i  {i , i,1 , ..., i,k(i) } such that   i i is consistent. Let S be the set of i . The set
S satisfies the condition of the algorithm since:
 SX
  6|=

W

S

 (because we know  

V

i

i to be consistent)

 for each Ti  Dnf -4(), the conjuncts 3i , 2i,1 , ..., 2i,k(i) of Ti are such that:
 {i , i,1 , ..., i,k(i) }  S 6=  (since S contains i  {i , i,1 , ..., i,k(i) })
 3(i  i,1  ...  i,k(i) ) |= 3 (follows from (3) above)
Since there exists a set S  X satisfying these conditions, the algorithm returns no.
Lemma 28.2 If the algorithm Test3PI returns no on input (3, ), then 3 is not a
prime implicate of .
Proof. Suppose Test3PI returns no on input (3, ). If this happens during the first
step, it must be the case that  is unsatisfiable and 3 is unsatisfiable, in which case 3 is
not a prime implicate of . The other possibility is that the algorithm returns no in Step 3,
which means W
there must be some S  X satisfying:
(a)  6|= S 
(b) for each Ti  Dnf -4(), there exist conjuncts 3i , 2i,1 , ..., 2i,k(i) of Ti
such that:
(i) {i , i,1 , ..., i,k(i) }  S 6= 
(ii) 3(i  i,1  ...  i,k(i) ) |= 3
W
Let  be the clause i 3(i  i,1 W
 ...  i,k(i)
W ). We remark that for each Ti , we have Ti |=
3(i i,1 ...i,k(i) ), and hence
T
|=
i
i
i 3(i i,1 ...i,k(i) ).
W
W From the definition of
Dnf -4(), we also have   i Ti . It immediately follows that  |= i 3(i i,1 ...i,k(i) )
and hence W
 |= . From 2 (b) (ii), we have that 3(i  i,1  ...  i,k(i) ) |= 3 for every i,
and hence i 3(i  i,1  ...  i,k(i)) |= 3 which yields  |= 3. From 2 (b) (i), we have
that {i , i,1 , ..., i,k(i) }  S 6=  and hence that for every
i there is some   S W
such that
W
i  i,1  ... i,k(i)W|= . From this we can infer that i 3(i  i,1  ... i,k(i) ) |= W
S 3,
and hence  |= 3 S . But we know from 2 (a) and Theorem 1 that 3 6|= 3 S .
It follows then that 3 6|= . Putting all this together, we see that there exists a clause 
such that  |=  |= 3 but 3 6|= , and hence that 3 is not a prime implicate of .
Theorem 28 Let  be a formula, and let 3 be an implicate of . Then the algorithm
Test3PI returns yes on input (3, ) if and only if 3 is a prime implicate of .
123

fiBienvenu

Proof. It is clear that Test3PI terminates since unsatisfiability testing and the NNF transformation always terminate, and there are only finitely many S and Ti . Lemmas 28.1 and
28.2 show us that the algorithm always gives the correct response.
Theorem 29 The algorithm Test3PI runs in polynomial space.
Proof. We remark that the sum of the lengths of the elements in X is bounded by the
length of the formula Nnf(), and hence by Lemma 14 the sum of theW lengths of the
elements of a particular S  X cannot exceed 2||. Testing whether  6|= S  can thus
be accomplished in polynomial V
space in the length of  and  as it involves testing the
satisfiability of the formula   S  whose length is clearly polynomial in  and .
Now let us turn to Step 3 (b). We notice that it is not necessary to keep all of the Ti in
memory at once, since we can generate the terms Ti one at a time using only polynomial
space by Lemma 12. By Lemma 14, the length of any Ti in Dnf -4() can be at most 2||.
It follows that checking whether {i , i,1 , ..., i,k(i) }  S 6= , or whether 3(i  i,1  ... 
i,k(i) ) |= 3 can both be accomplished in polynomial space in the length of  and . We
conclude that the algorithm Test3PI runs in polynomial space.
In order to show Theorem 32, we use the following lemmas:
Lemma 32.1 If  is a clause that is not a prime implicate of , then TestPI outputs no
on this input.
Proof. Let us begin by considering a formula  which is a clause but that is not a prime
implicate of . There are two possible reasons for this: either  is not an implicate of , or
it is an implicate but there exists some stronger implicate. In the first case, TestPI returns
no in Step 1, as desired. We will now focus on the case where  is an implicate but not a
prime implicate. We begin by treating the limit cases where one or both of  and  is a
tautology or contradiction. Given that we know  to be a non-prime implicate of , there
are only two possible scenarios: either 6|=  and |= , or  |=  and  6|= . In both cases,
the algorithm returns no in Step 2.
If  is an implicate of , and neither  nor  is a tautology or contradiction, then the
algorithm will continue on to Step 3. In this step, any redundant literals will be deleted
from , and if  contains 3-literals, we add an extra disjunct to the 2-literals so that 
satisfies the syntactic requirements of Theorem 25. Let 1  ...k  31  ...  3m  21 
...  2n be the clause  at the end of Step 3 once all modifications have been made. As
the transformations in Step 3 are equivalence-preserving (Theorem 1), the modified  is
equivalent to the original, so  is still a non-tautologous non-prime implicate of . This
means  and  now satisfy all of the conditions of Theorem 25. It follows then that one of
the following holds:
(a) 1  ...  k 6 (  ( \ {1 , ..., k })
(b) 2(i  1  ...  n ) 6 (  ( \ {2i })) for some i
(c) 3(1  ...  n ) 6 (  ( \ {31 , ..., 3n }))
124

fiPrime Implicates and Prime Implicants in Modal Logic

Suppose that (a) holds. Now 1  ...  k is a non-tautologous propositional clause implied
by   ( \ {1 , ..., k }) which contains no redundant literals. This means that   ( \
{1 , ..., k }) and 1 ...k satisfy the conditions of Theorem 26. According to this theorem,
as 1  ...  k 6 (  ( \ {1 , ..., k }), then there must be some j such that   ( \
{1 , ..., k }) |= 1  ...  j1  j+1  ...  k . This means that  |=  \ {j }, so the algorithm
returns no in Step 4.
Suppose next that (b) holds, and let i be such that 2(i  1  ...  n ) 6 ( 
( \ {2i })). By Theorem 27, this means that there is no T Dnf -4() such that
2(i  1  ...  n ) entails the conjunction of 2-formulae conjuncts of T . It follows that
the algorithm returns no in Step 5.
Finally consider the case
Then in Step 6,
Wm where neither (a) nor (b) holds but (c)Wdoes.
m
we will call Test3PI(3( i=1 i ),   ( \ {31 , ..., 3m })). As 3( i=1 i ) is not a prime
implicate of (\{31 , ..., 3m })) and we have shown Test3PI to be correct (Theorem
28), Test3PI will return no, so TestPI will return no as well. As we have covered each of
the possible cases, we can conclude that if  is a clause that is not a prime implicate of ,
then TestPI outputs no.
Lemma 32.2 If TestPI outputs no with input (, ) and  is a clause, then  is not a
prime implicate of .
Proof. There are 5 different ways for TestPI to return no (these occur in Steps 1, 2, 4, 5,
and 6). Let us consider each of these in turn. The first way that the algorithm can return
no is in Step 1 if we find that  6|= . This is correct since  cannot be a prime implicate if
it is not a consequence of . In Step 2, we return no if  is unsatisfiable but  is not, or if
 is a tautology but  is not. This is also correct since in both cases  cannot be a prime
implicate since there exist stronger implicates (any contradictory clause if   , and any
non-tautologous implicate of  if   ). In Step 3, we may modify , but the resulting
formula is equivalent to the original, and so it is a prime implicate just in the case that the
original clause was. Let 1  ...k  31  ...  3m  21  ...  2n be the clause at the end
of Step 3. Now in Step 4, we return no if we find some propositional literal l in  for which
 |= \{l}. Now since in Step 3, we have removed redundant literals from , we can be sure
that  \ {l} is strictly stronger than . So we have  |=  \ {l} |=  and  6|=  \ {l}, which
means that  is not a prime implicate of . We now consider Step 5 of TestPI. In this step,
we return no if for some disjunct 2i there is no term T in Dnf -4((\{2i })) for which
2(i  1  ...  m ) entails the conjunction of 2-literals in T . According to Theorem 27,
this means that 2(i  1  ...  m ) is not a prime implicate of   ( \ {2i }), which
means that  is not a prime implicate
W of  by Theorem 25. . In this step, we return no
if Test3PI returns no on input (3( ki=1 i ),   ( \ {31 , ..., 3m })). By Theorem 28,
W
we know that this happens just in the case that 3( ki=1 i ) is not a prime implicate of
  ( \ {31 , ..., 3m }). It follows from Theorem 25 that  is not a prime implicate
of .
Theorem 32 The algorithm TestPI always terminates, and it returns yes on input (,
) if and only if  is a prime implicate of .
125

fiBienvenu

Proof. The algorithm TestPI clearly terminates because Steps 1 to 5 involve a finite number
of syntactic operations on  and a finite number of entailment checks. Moreover, the call
to Test3PI in Step 6 is known to terminate (Theorem 28). Correctness and completeness
have already been shown in Lemmas 32.1 and 32.2.
We make use of the following lemma in the proof of Theorem 34:
Lemma 34.1 The algorithm TestPI provided in Figure 5 runs in polynomial space in the
length of the input.
Proof. It is clear that steps 1 through 5 can be carried out in polynomial space in the length
of the input, since they simply involve testing the satisfiability of formulae whose lengths are
polynomial in ||+||. Step 6 can also
W be carried out in polynomial space since by Theorem
29 deciding whether the formula 3(W m
i=1 i ) is a prime implicate of   ( \ {1 , ..., m }))
takes only polynomial space in |3( m
i=1 i )| + |  ( \ {31 , ..., 3m }))|, and hence in
|| + ||. We can thus conclude that the algorithm TestPI runs in polynomial space in the
length of the input.
Theorem 34 Prime implicate recognition is in Pspace.
Proof. We have show in Theorem 32 that TestPI always terminates and returns yes whenever the clause is a prime implicate and no otherwise. This means that TestPI is a decision
procedure for prime implicate recognition. Since the algorithm has been shown to run in
polynomial space (Lemma 34.1), we can conclude that prime implicate recognition is in
Pspace.
Corollary 35 Prime implicate recognition is Pspace-complete.
Proof. Follows directly from Theorems 24 and 34.

References
Adjiman, P., Chatalic, P., Goasdoue, F., Rousset, M.-C., & Simon, L. (2006). Distributed
reasoning in a peer-to-peer setting: Application to the semantic web. Journal of
Artificial Intelligence Research, 25, 269314.
Baader, F., McGuiness, D. L., Nardi, D., & Patel-Schneider, P. (Eds.). (2003). The Description Logic Handbook. Cambridge University Press.
Bienvenu, M. (2007). Prime implicates and prime implicants in modal logic. In Proceedings
of the Twenty-Second Conference on Artificial Intelligence (AAAI07), pp. 397384.
Bienvenu, M. (2008). Prime implicate normal form for ALC concepts. In Proceedings of the
Twenty-Third Conference on Artificial Intelligence (AAAI08), pp. 412417.
Bienvenu, M. (2009). Consequence Finding in Modal Logic. Ph.D. thesis, Universite de
Toulouse.
Bittencourt, G. (2007). Combining syntax and semantics through prime form representation. Journal of Logic and Computation, 18 (1), 1333.
126

fiPrime Implicates and Prime Implicants in Modal Logic

Blackburn, P., de Rijke, M., & Venema, Y. (2001). Modal logic. Cambridge University
Press.
Blackburn, P., van Benthem, J., & Wolter, F. (Eds.). (2006). Handbook of Modal Logic.
Elsevier.
Brandt, S., & Turhan, A. (2002). An approach for optimized approximation. In Proceedings
of the KI-2002 Workshop on Applications of Description Logics (KIDLWS01).
Cadoli, M., & Donini, F. M. (1997). A survey on knowledge compilation. AI Communications, 10 (3-4), 137150.
Cialdea Mayer, M., & Pirri, F. (1995). Propositional abduction in modal logic. Logic
Journal of the IGPL, 3 (6), 907919.
Darwiche, A., & Marquis, P. (2002). A knowledge compilation map. Journal of Artificial
Intelligence Research, 17, 229264.
de Kleer, J., Mackworth, A. K., & Reiter, R. (1992). Characterizing diagnoses and systems.
Artificial Intelligence, 56, 197222.
Donini, F. M. (2003). The Description Logic Handbook, chap. Complexity of Reasoning.
Cambridge University Press.
Donini, F. M., Lenzerini, M., Nardi, D., Hollunder, B., Nutt, W., & Marchetti Spaccamela,
A. (1992). The complexity of existential qualification in concept languages. Artificial
Intelligence, 53, 309327.
Eiter, T., & Makino, K. (2002). On computing all abductive explanations. In Proceedings of
the Eighteenth National Conference on Artificial Intelligence (AAAI02), pp. 6267.
Enjalbert, P., & Farinas del Cerro, L. (1989). Modal resolution in clausal form. Theoretical
Computer Science, 65 (1), 133.
Garey, M. R., & Johnson, D. S. (1979). Computers and intractability. A guide to the theory
of NP-completeness. W. H. Freeman.
Ghilardi, S., Lutz, C., & Wolter, F. (2006). Did I damage my ontology? A case for conservative extensions in description logics. In Proceedings of the Tenth International
Conference on Principles of Knowledge Representation and Reasoning (KR06), pp.
187197.
Giunchiglia, F., & Sebastiani, R. (1996). A SAT-based decision procedure for ALC. In
Proceedings of the Fifth International Conference on Principles of Knowledge Representation and Reasoning (KR96), pp. 304314.
Kusters, R., & Molitor, R. (2002). Approximating most specific concepts in logics with
existential restrictions. AI Communications, 15 (1), 4759.
Ladner, R. (1977). The computational complexity of provability in systems of modal propositional logic. SIAM Journal of Computing, 6 (3), 467480.
Lakemeyer, G. (1995). A logical account of relevance. In Proceedings of the Fourteenth
International Joint Conference on Artificial Intelligence (IJCAI95), pp. 853861.
127

fiBienvenu

Lang, J., Liberatore, P., & Marquis, P. (2003). Propositional independence: Formulavariable independence and forgetting. Journal of Artificial Intelligence Research, 18,
391443.
Marquis, P. (1991a). Contribution a letude des methodes de construction dhypotheses en
intelligence artificielle. In french, Universite de Nancy I.
Marquis, P. (1991b). Extending abduction from propositional to first-order logic. In Proceedings of Fundamentals of Artificial Intelligence Research Workshop, pp. 141155.
Marquis, P. (2000). Handbook on Defeasible Reasoning and Uncertainty Management Systems, Vol. 5, chap. Consequence Finding Algorithms, pp. 41145. Kluwer.
Pagnucco, M. (2006). Knowledge compilation for belief change. In Proceedings of the
Nineteenth Australian Conference on Artificial Intelligence (AI06), pp. 9099.
Papadimitriou, C. (1994). Computational Complexity. Addison Welsey.
Przymusinski, T. (1989). An algorithm to compute circumscription. Artificial Intelligence,
38 (1), 4973.
Ramesh, A., & Murray, N. (1994). Computing prime implicants/implicates for regular logics.
In Proceedings of the Twenty-Fourth IEEE International Symposium on MultipleValued Logic, pp. 115123.
Schild, K. (1991). A correspondence theory for terminological logics: Preliminary report.
In Proceedings of the Twelth International Joint Conference on Artificial Intelligence
(IJCAI91), pp. 466471.
Younger, D. H. (1967). Recognition and parsing of context-free languages in time n3 .
Information and Control, 10 (2), 189208.

128

fi